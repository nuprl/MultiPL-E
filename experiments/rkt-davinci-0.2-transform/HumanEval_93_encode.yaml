name: HumanEval_93_encode
language: rkt
prompt: "#lang racket\n\n;; Write a function that takes a message, and encodes in\
  \ such a \n;; way that it swaps case of all letters, replaces all vowels in \n;;\
  \ the message with the letter that appears 2 places ahead of that \n;; vowel in\
  \ the english alphabet. \n;; Assume only letters. \n;; Examples:\n;; >>> (encode\
  \ \"test\")\n;; \"TGST\"\n;; >>> (encode \"This is a message\")\n;; \"tHKS KS C\
  \ MGSSCGG\"\n(define (encode message)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encode))\n\
  \    (check-equal? (candidate \"TEST\") \"tgst\")\n    (check-equal? (candidate\
  \ \"Mudasir\") \"mWDCSKR\")\n    (check-equal? (candidate \"YES\") \"ygs\")\n  \
  \  (check-equal? (candidate \"This is a message\") \"tHKS KS C MGSSCGG\")\n    (check-equal?\
  \ (candidate \"I DoNt KnOw WhAt tO WrItE\") \"k dQnT kNqW wHcT Tq wRkTg\")\n))\n\
  \n(test-humaneval)"
completions: ["  (map (lambda (c)\n         (if (char-alphabetic? c)\n           \
    \  (let ([c (char-upcase c)])\n               (if (or (char=? c #\\A) (char=?\
    \ c #\\E) (char=? c #\\I) (char=? c #\\O) (char=? c #\\U))\n                 \
    \  (char-downcase (char+ c 2))\n                   (char-downcase c)))\n     \
    \        c))\n       message))\n", "  (string-upcase message))\n", "  (define\
    \ (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n     \
    \   (char-downcase c)))\n  (define (encode-char c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c\
    \ #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n  \
    \    [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else (swap-case\
    \ c)]))\n  (string-map encode-char message))\n", "  (map (lambda (c)\n       \
    \  (cond\n           [(char-alphabetic? c)\n            (let ([c (char-upcase\
    \ c)])\n              (cond\n                [(or (char=? c #\\A) (char=? c #\\\
    E) (char=? c #\\I) (char=? c #\\O) (char=? c #\\U))\n                 (char-downcase\
    \ (char-next (char-next c)))]\n                [else\n                 (char-downcase\
    \ (char-next c))]))]\n           [else\n            c]))\n       (string->list\
    \ message)))\n", "  (map (lambda (c)\n         (cond\n           [(char-alphabetic?\
    \ c)\n            (let* ([c (char-upcase c)]\n                   [c (if (member\
    \ c '(#\\A #\\E #\\I #\\O #\\U))\n                          (char-downcase c)\n\
    \                          c)])\n              (if (char-alphabetic? c)\n    \
    \              (let* ([c (char-upcase c)]\n                         [c (if (member\
    \ c '(#\\A #\\E #\\I #\\O #\\U))\n                                (char-downcase\
    \ c)\n                                c)])\n                    (if (char-alphabetic?\
    \ c)\n                        (let* ([c (char-upcase c)]\n                   \
    \            [c (if (member c '(#\\A #\\E #\\I #\\O #\\U))\n                 \
    \                     (char-downcase c)\n                                    \
    \  c)])\n                          (if (char-alphabetic? c)\n                \
    \              (let* ([c (char-upcase c)]\n                                  \
    \   [c (if (member c '(#\\A #\\E #\\I #\\O #\\U))\n                          \
    \                  (char-downcase c)\n                                       \
    \     c)])\n                                (if (char-alphabetic? c)\n       \
    \                             (let* ([c (char-upcase c)]\n                   \
    \                        [c (if (member c '(#\\A #\\E #\\I #\\O #\\U))\n     \
    \                                             (char-downcase c)\n            \
    \                                      c)])\n                                \
    \      (if (char-alphabetic? c)\n                                          (let*\
    \ ([c (char-upcase c)]\n                                                 [c (if\
    \ (member c '(#\\A #\\E #\\I #\\O #\\U))\n                                   \
    \                     (char-downcase c)\n                                    \
    \                    c)])\n                                            (if (char-alphabetic?\
    \ c)\n                                                (let* ([c (char-upcase c)]\n\
    \                                                       [c (if (member c '(#\\\
    A #\\E #\\I #\\O #\\U))\n                                                    \
    \          (char-downcase c)\n                                                ",
  "  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (if (char-vowel?\
    \ c)\n            (char-upcase (char-next (char-next (char-downcase c))))\n  \
    \          (char-upcase (char-downcase c)))\n        c))\n  (string-map encode-char\
    \ message))\n", "  (string-map (lambda (c)\n                (cond\n          \
    \        [(char-alphabetic? c)\n                   (let* ([c (char-upcase c)]\n\
    \                          [c (+ c 2)])\n                     (if (> c 90)\n \
    \                        (- c 26)\n                         c))]\n           \
    \       [else c]))\n              message))\n", "  (define (encode-char c)\n \
    \   (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n    \
    \       (char-upcase c)\n           (char-downcase c))]\n      [(char=? c #\\\
    a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=?\
    \ c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (next-vowel\
    \ c)\n    (cond ((char=? c #\\a) #\\c)\n          ((char=? c #\\e) #\\g)\n   \
    \       ((char=? c #\\i) #\\k)\n          ((char=? c #\\o) #\\q)\n          ((char=?\
    \ c #\\u) #\\w)\n          (else c)))\n  (define (encode-char c)\n    (next-vowel\
    \ (swap-case c)))\n  (string-map encode-char message))\n", "  (map (lambda (c)\n\
    \         (cond\n           [(char-alphabetic? c)\n            (if (char-lower-case?\
    \ c)\n                (char-upcase c)\n                (char-downcase c))]\n \
    \          [(char=? c #\\a) #\\c]\n           [(char=? c #\\e) #\\g]\n       \
    \    [(char=? c #\\i) #\\k]\n           [(char=? c #\\o) #\\q]\n           [(char=?\
    \ c #\\u) #\\w]\n           [else c]))\n       (string->list message)))\n", " \
    \ (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (let*\
    \ ([c (char-upcase c)]\n              [c-code (char-&gt;integer c)]\n        \
    \      [c-code (+ c-code 2)])\n         (if (&gt; c-code 90)\n             (integer-&gt;char\
    \ (+ c-code -26))\n             (integer-&gt;char c-code)))]\n      [else c]))\n\
    \  (map encode-char message))\n</code>\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n        (list-ref (list\
    \ #\\c #\\d #\\f #\\g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\\
    v #\\w #\\x #\\y #\\z)\n                  (+ 2 (string-index \"aeiou\" c)))\n\
    \        c))\n  (string-join\n   (map (lambda (c) (encode-char (swap-case c)))\n\
    \        (string->list message))\n   \"\"))\n", "  (define (swap-case c)\n   \
    \ (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase c)))\n\
    \  (define (encode-char c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=?\
    \ c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n\
    \      [(char=? c #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c\
    \ #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n  \
    \    [(char=? c #\\U) #\\W]\n      [else c]))\n  (string-map (lambda (c) (encode-char\
    \ (swap-case c))) message))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (if (char-vowel? c)\n        (char-next (char-next c))\n        c))\n\
    \  (define (encode-string s)\n    (if (empty? s)\n        \"\"\n        (string-append\
    \ (string (encode-char (car s)))\n                       (encode-string (cdr s)))))\n\
    \  (string-join (map (lambda (c) (string (swap-case c)))\n                   \
    \ (string-split message))\n               \"\"))\n", "  (define (encode-char c)\n\
    \    (cond\n      [(char-alphabetic? c)\n       (define (is-vowel? c)\n      \
    \   (or (char=? c #\\a)\n             (char=? c #\\e)\n             (char=? c\
    \ #\\i)\n             (char=? c #\\o)\n             (char=? c #\\u)))\n      \
    \ (define (shift-char c)\n         (define (shift-char-helper c n)\n         \
    \  (if (= n 0)\n               c\n               (shift-char-helper (char+ c 1)\
    \ (- n 1))))\n         (shift-char-helper c 2))\n       (if (is-vowel? c)\n  \
    \         (shift-char c)\n           (char-upcase c))]\n      [else c]))\n  (define\
    \ (encode-helper message)\n    (if (empty? message)\n        '()\n        (cons\
    \ (encode-char (first message))\n              (encode-helper (rest message)))))\n\
    \  (list->string (encode-helper (string->list message))))\n", "  (define (swap-case\
    \ c)\n    (if (char-alphabetic? c)\n        (if (char-upper-case? c)\n       \
    \     (char-downcase c)\n            (char-upcase c))\n        c))\n  (define\
    \ (encode-char c)\n    (if (char-alphabetic? c)\n        (if (char-vowel? c)\n\
    \            (let ((vowels (string-&gt;list \"aeiouAEIOU\")))\n              (list-ref\
    \ vowels (+ 2 (list-index (char-downcase c) vowels))))\n            c)\n     \
    \   c))\n  (string-join (map encode-char (map swap-case (string-&gt;list message)))\
    \ \"\"))\n</code>\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-upper-case? c)\n           (char-downcase c)\n        \
    \   (char-upcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c\
    \ #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n  \
    \    [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else (swap-case\
    \ c)]))\n  (string-map encode-char message))\n", "  (define (swap-case c)\n  \
    \  (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase c)))\n\
    \  (define (encode-char c)\n    (if (or (char=? c #\\a) (char=? c #\\e) (char=?\
    \ c #\\i) (char=? c #\\o) (char=? c #\\u))\n        (swap-case (char-upcase c))\n\
    \        (swap-case c)))\n  (define (encode-message message)\n    (if (empty?\
    \ message)\n        \"\"\n        (string-append (string (encode-char (car message)))\
    \ (encode-message (cdr message)))))\n  (encode-message message))\n", "  (define\
    \ (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n     \
    \   (char-downcase c)))\n  (define (encode-char c)\n    (cond [(char=? c #\\a)\
    \ #\\c]\n          [(char=? c #\\e) #\\g]\n          [(char=? c #\\i) #\\k]\n\
    \          [(char=? c #\\o) #\\q]\n          [(char=? c #\\u) #\\w]\n        \
    \  [(char=? c #\\A) #\\C]\n          [(char=? c #\\E) #\\G]\n          [(char=?\
    \ c #\\I) #\\K]\n          [(char=? c #\\O) #\\Q]\n          [(char=? c #\\U)\
    \ #\\W]\n          [else (swap-case c)]))\n  (string-map encode-char message))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
