name: HumanEval_93_encode
language: rkt
prompt: "#lang racket\n\n;; Write a function that takes a message, and encodes in\
  \ such a \n;; way that it swaps case of all letters, replaces all vowels in \n;;\
  \ the message with the letter that appears 2 places ahead of that \n;; vowel in\
  \ the english alphabet. \n;; Assume only letters. \n;; Examples:\n;; >>> (encode\
  \ \"test\")\n;; \"TGST\"\n;; >>> (encode \"This is a message\")\n;; \"tHKS KS C\
  \ MGSSCGG\"\n(define (encode message)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encode))\n\
  \    (check-equal? (candidate \"TEST\") \"tgst\")\n    (check-equal? (candidate\
  \ \"Mudasir\") \"mWDCSKR\")\n    (check-equal? (candidate \"YES\") \"ygs\")\n  \
  \  (check-equal? (candidate \"This is a message\") \"tHKS KS C MGSSCGG\")\n    (check-equal?\
  \ (candidate \"I DoNt KnOw WhAt tO WrItE\") \"k dQnT kNqW wHcT Tq wRkTg\")\n))\n\
  \n(test-humaneval)"
completions: ["  (map (lambda (c)\n         (if (char-alphabetic? c)\n           \
    \  (let ([c (char-upcase c)])\n               (if (or (char=? c #\\A) (char=?\
    \ c #\\E) (char=? c #\\I) (char=? c #\\O) (char=? c #\\U))\n                 \
    \  (char-downcase (char+ c 2))\n                   (char-downcase c)))\n     \
    \        c))\n       message))\n", "  (string-upcase message))\n", "  (define\
    \ (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n     \
    \   (char-downcase c)))\n  (define (encode-char c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c\
    \ #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n  \
    \    [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else (swap-case\
    \ c)]))\n  (string-map encode-char message))\n", "  (map (lambda (c)\n       \
    \  (cond\n           [(char-alphabetic? c)\n            (let ([c (char-upcase\
    \ c)])\n              (cond\n                [(or (char=? c #\\A) (char=? c #\\\
    E) (char=? c #\\I) (char=? c #\\O) (char=? c #\\U))\n                 (char-downcase\
    \ (char-next (char-next c)))]\n                [else\n                 (char-downcase\
    \ (char-next c))]))]\n           [else\n            c]))\n       (string->list\
    \ message)))\n", "  (map (lambda (c)\n         (cond\n           [(char-alphabetic?\
    \ c)\n            (let* ([c (char-upcase c)]\n                   [c (if (member\
    \ c '(#\\A #\\E #\\I #\\O #\\U))\n                          (char-downcase c)\n\
    \                          c)])\n              (if (char-alphabetic? c)\n    \
    \              (let* ([c (char-upcase c)]\n                         [c (if (member\
    \ c '(#\\A #\\E #\\I #\\O #\\U))\n                                (char-downcase\
    \ c)\n                                c)])\n                    (if (char-alphabetic?\
    \ c)\n                        (let* ([c (char-upcase c)]\n                   \
    \            [c (if (member c '(#\\A #\\E #\\I #\\O #\\U))\n                 \
    \                     (char-downcase c)\n                                    \
    \  c)])\n                          (if (char-alphabetic? c)\n                \
    \              (let* ([c (char-upcase c)]\n                                  \
    \   [c (if (member c '(#\\A #\\E #\\I #\\O #\\U))\n                          \
    \                  (char-downcase c)\n                                       \
    \     c)])\n                                (if (char-alphabetic? c)\n       \
    \                             (let* ([c (char-upcase c)]\n                   \
    \                        [c (if (member c '(#\\A #\\E #\\I #\\O #\\U))\n     \
    \                                             (char-downcase c)\n            \
    \                                      c)])\n                                \
    \      (if (char-alphabetic? c)\n                                          (let*\
    \ ([c (char-upcase c)]\n                                                 [c (if\
    \ (member c '(#\\A #\\E #\\I #\\O #\\U))\n                                   \
    \                     (char-downcase c)\n                                    \
    \                    c)])\n                                            (if (char-alphabetic?\
    \ c)\n                                                (let* ([c (char-upcase c)]\n\
    \                                                       [c (if (member c '(#\\\
    A #\\E #\\I #\\O #\\U))\n                                                    \
    \          (char-downcase c)\n                                                ",
  "  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (if (char-vowel?\
    \ c)\n            (char-upcase (char-next (char-next (char-downcase c))))\n  \
    \          (char-upcase (char-downcase c)))\n        c))\n  (string-map encode-char\
    \ message))\n", "  (string-map (lambda (c)\n                (cond\n          \
    \        [(char-alphabetic? c)\n                   (let* ([c (char-upcase c)]\n\
    \                          [c (+ c 2)])\n                     (if (> c 90)\n \
    \                        (- c 26)\n                         c))]\n           \
    \       [else c]))\n              message))\n", "  (define (encode-char c)\n \
    \   (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n    \
    \       (char-upcase c)\n           (char-downcase c))]\n      [(char=? c #\\\
    a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=?\
    \ c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (next-vowel\
    \ c)\n    (cond ((char=? c #\\a) #\\c)\n          ((char=? c #\\e) #\\g)\n   \
    \       ((char=? c #\\i) #\\k)\n          ((char=? c #\\o) #\\q)\n          ((char=?\
    \ c #\\u) #\\w)\n          (else c)))\n  (define (encode-char c)\n    (next-vowel\
    \ (swap-case c)))\n  (string-map encode-char message))\n", "  (map (lambda (c)\n\
    \         (cond\n           [(char-alphabetic? c)\n            (if (char-lower-case?\
    \ c)\n                (char-upcase c)\n                (char-downcase c))]\n \
    \          [(char=? c #\\a) #\\c]\n           [(char=? c #\\e) #\\g]\n       \
    \    [(char=? c #\\i) #\\k]\n           [(char=? c #\\o) #\\q]\n           [(char=?\
    \ c #\\u) #\\w]\n           [else c]))\n       (string->list message)))\n", " \
    \ (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (let*\
    \ ([c (char-upcase c)]\n              [c-code (char-&gt;integer c)]\n        \
    \      [c-code (+ c-code 2)])\n         (if (&gt; c-code 90)\n             (integer-&gt;char\
    \ (+ c-code -26))\n             (integer-&gt;char c-code)))]\n      [else c]))\n\
    \  (map encode-char message))\n</code>\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n        (list-ref (list\
    \ #\\c #\\d #\\f #\\g #\\h #\\j #\\k #\\l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\\
    v #\\w #\\x #\\y #\\z)\n                  (+ 2 (string-index \"aeiou\" c)))\n\
    \        c))\n  (string-join\n   (map (lambda (c) (encode-char (swap-case c)))\n\
    \        (string->list message))\n   \"\"))\n", "  (define (swap-case c)\n   \
    \ (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase c)))\n\
    \  (define (encode-char c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=?\
    \ c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n\
    \      [(char=? c #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c\
    \ #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n  \
    \    [(char=? c #\\U) #\\W]\n      [else c]))\n  (string-map (lambda (c) (encode-char\
    \ (swap-case c))) message))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (if (char-vowel? c)\n        (char-next (char-next c))\n        c))\n\
    \  (define (encode-string s)\n    (if (empty? s)\n        \"\"\n        (string-append\
    \ (string (encode-char (car s)))\n                       (encode-string (cdr s)))))\n\
    \  (string-join (map (lambda (c) (string (swap-case c)))\n                   \
    \ (string-split message))\n               \"\"))\n", "  (define (encode-char c)\n\
    \    (cond\n      [(char-alphabetic? c)\n       (define (is-vowel? c)\n      \
    \   (or (char=? c #\\a)\n             (char=? c #\\e)\n             (char=? c\
    \ #\\i)\n             (char=? c #\\o)\n             (char=? c #\\u)))\n      \
    \ (define (shift-char c)\n         (define (shift-char-helper c n)\n         \
    \  (if (= n 0)\n               c\n               (shift-char-helper (char+ c 1)\
    \ (- n 1))))\n         (shift-char-helper c 2))\n       (if (is-vowel? c)\n  \
    \         (shift-char c)\n           (char-upcase c))]\n      [else c]))\n  (define\
    \ (encode-helper message)\n    (if (empty? message)\n        '()\n        (cons\
    \ (encode-char (first message))\n              (encode-helper (rest message)))))\n\
    \  (list->string (encode-helper (string->list message))))\n", "  (define (swap-case\
    \ c)\n    (if (char-alphabetic? c)\n        (if (char-upper-case? c)\n       \
    \     (char-downcase c)\n            (char-upcase c))\n        c))\n  (define\
    \ (encode-char c)\n    (if (char-alphabetic? c)\n        (if (char-vowel? c)\n\
    \            (let ((vowels (string-&gt;list \"aeiouAEIOU\")))\n              (list-ref\
    \ vowels (+ 2 (list-index (char-downcase c) vowels))))\n            c)\n     \
    \   c))\n  (string-join (map encode-char (map swap-case (string-&gt;list message)))\
    \ \"\"))\n</code>\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-upper-case? c)\n           (char-downcase c)\n        \
    \   (char-upcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c\
    \ #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n  \
    \    [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else (swap-case\
    \ c)]))\n  (string-map encode-char message))\n", "  (define (swap-case c)\n  \
    \  (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase c)))\n\
    \  (define (encode-char c)\n    (if (or (char=? c #\\a) (char=? c #\\e) (char=?\
    \ c #\\i) (char=? c #\\o) (char=? c #\\u))\n        (swap-case (char-upcase c))\n\
    \        (swap-case c)))\n  (define (encode-message message)\n    (if (empty?\
    \ message)\n        \"\"\n        (string-append (string (encode-char (car message)))\
    \ (encode-message (cdr message)))))\n  (encode-message message))\n", "  (define\
    \ (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n     \
    \   (char-downcase c)))\n  (define (encode-char c)\n    (cond [(char=? c #\\a)\
    \ #\\c]\n          [(char=? c #\\e) #\\g]\n          [(char=? c #\\i) #\\k]\n\
    \          [(char=? c #\\o) #\\q]\n          [(char=? c #\\u) #\\w]\n        \
    \  [(char=? c #\\A) #\\C]\n          [(char=? c #\\E) #\\G]\n          [(char=?\
    \ c #\\I) #\\K]\n          [(char=? c #\\O) #\\Q]\n          [(char=? c #\\U)\
    \ #\\W]\n          [else (swap-case c)]))\n  (string-map encode-char message))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (next-char c)\n         (if (char=? c #\\z)\n             #\\a\n           \
    \  (char+ c 1)))\n       (define (next-next-char c)\n         (if (char=? c #\\\
    y)\n             #\\a\n             (next-char (next-char c))))\n       (define\
    \ (is-vowel? c)\n         (or (char=? c #\\a)\n             (char=? c #\\e)\n\
    \             (char=? c #\\i)\n             (char=? c #\\o)\n             (char=?\
    \ c #\\u)))\n       (cond\n         [(is-vowel? c)\n          (next-next-char\
    \ c)]\n         [else\n          (next-char c)])]\n      [else\n       c]))\n\
    \  (define (encode-string s)\n    (if (string-empty? s)\n        \"\"\n      \
    \  (string-append (encode-char (string-ref s 0))\n                       (encode-string\
    \ (substring s 1)))))\n  (encode-string message))\n", "  (define (swap-case c)\n\
    \    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (encode-char c)\n    (cond ((char=? c #\\a) #\\c)\n        \
    \  ((char=? c #\\e) #\\g)\n          ((char=? c #\\i) #\\k)\n          ((char=?\
    \ c #\\o) #\\q)\n          ((char=? c #\\u) #\\w)\n          ((char=? c #\\A)\
    \ #\\C)\n          ((char=? c #\\E) #\\G)\n          ((char=? c #\\I) #\\K)\n\
    \          ((char=? c #\\O) #\\Q)\n          ((char=? c #\\U) #\\W)\n        \
    \  (else (swap-case c))))\n  (string-map encode-char message))\n", "  (define\
    \ (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define (next-char\
    \ c)\n         (cond\n           [(char=? c #\\z) #\\a]\n           [(char=? c\
    \ #\\Z) #\\A]\n           [else (char+ c 1)]))\n       (define (next-next-char\
    \ c)\n         (cond\n           [(char=? c #\\y) #\\a]\n           [(char=? c\
    \ #\\Y) #\\A]\n           [else (next-char (next-char c))]))\n       (define (is-vowel?\
    \ c)\n         (or (char-ci=? c #\\a)\n             (char-ci=? c #\\e)\n     \
    \        (char-ci=? c #\\i)\n             (char-ci=? c #\\o)\n             (char-ci=?\
    \ c #\\u)))\n       (if (is-vowel? c)\n           (next-next-char c)\n       \
    \    (next-char c))]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (let ([message (string-upcase message)])\n    (for/fold ([result \"\"]) ([c (in-string\
    \ message)])\n      (cond\n        [(char-alphabetic? c)\n         (string-append\
    \ result (encode-char c))]\n        [else\n         (string-append result (string\
    \ c))]))))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (let ([message (string-&gt;list message)])\n    (map (lambda (x)\n         \
    \  (cond\n             [(char-alphabetic? x)\n              (if (char-lower-case?\
    \ x)\n                  (char-upcase x)\n                  (char-downcase x))]\n\
    \             [(char-vowel? x)\n              (char-&gt;integer (char-&gt;integer\
    \ x) + 2)]\n             [else x]))\n         message)))\n</code>\nI'm getting\
    \ the following error:\n<code>application: not a procedure;\n expected a procedure\
    \ that can be applied to arguments\n  given: #&lt;char-code&gt;\n  arguments...:\n\
    \   #&lt;char-code&gt;\n   #&lt;procedure:+&gt;\n   2\n</code>\nI'm not sure what\
    \ I'm doing wrong. I'm trying to convert the character to an integer, add 2 to\
    \ it, and then convert it back to a character.\n\n\nA:\n\nYou're trying to apply\
    \ <code>char-&gt;integer</code> to two arguments, but it only takes one. You need\
    \ to apply it to the character, then apply the result to <code>+</code>.\n<code>(define\
    \ (encode message)\n  (let ([message (string-&gt;list message)])\n    (map (lambda\
    \ (x)\n           (cond\n             [(char-alphabetic? x)\n              (if\
    \ (char-lower-case? x)\n                  (char-upcase x)\n                  (char-downcase\
    \ x))]\n             [(char-vowel? x)\n              (integer-&gt;char (+ 2 (char-&gt;integer\
    \ x)))]\n             [else x]))\n         message)))\n</code>\n", "  (define\
    \ (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n     \
    \   (char-downcase c)))\n  (define (vowel? c)\n    (or (char=? c #\\a)\n     \
    \   (char=? c #\\e)\n        (char=? c #\\i)\n        (char=? c #\\o)\n      \
    \  (char=? c #\\u)))\n  (define (encode-char c)\n    (if (vowel? c)\n        (swap-case\
    \ (char-upcase c))\n        (swap-case c)))\n  (string-map encode-char message))\n",
  "  (string-upcase (string-map (lambda (c)\n                               (if (char-alphabetic?\
    \ c)\n                                   (if (vowel? c)\n                    \
    \                   (next-vowel c)\n                                       (next-consonant\
    \ c))\n                                   c))\n                             message)))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case?\
    \ c)\n           (char-upcase c)\n           (char-downcase c))]\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (char-vowel? c)\n        (char-next (char-next c))\n        c))\n\
    \  (string-map encode-char (string-map swap-case message)))\n", "  (map (lambda\
    \ (c)\n         (cond\n           [(char-alphabetic? c)\n            (if (char-lower-case?\
    \ c)\n                (char-upcase c)\n                (char-downcase c))]\n \
    \          [(char=? c #\\a) #\\c]\n           [(char=? c #\\e) #\\g]\n       \
    \    [(char=? c #\\i) #\\k]\n           [(char=? c #\\o) #\\q]\n           [(char=?\
    \ c #\\u) #\\w]\n           [else c]))\n       (string->list message)))\n", " \
    \ (define (is-vowel? c)\n    (or (equal? c #\\a)\n        (equal? c #\\e)\n  \
    \      (equal? c #\\i)\n        (equal? c #\\o)\n        (equal? c #\\u)))\n \
    \ (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase\
    \ c)\n        (char-upcase c)))\n  (define (encode-char c)\n    (cond ((is-vowel?\
    \ c)\n           (swap-case (list-ref (string->list \"cdfghjklmnpqrstvwxyzab\"\
    )\n                                (char->integer c))))\n          (else (swap-case\
    \ c))))\n  (list->string (map encode-char (string->list message))))\n", "  (define\
    \ (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define (next-char\
    \ c)\n         (if (char=? c #\\z)\n             #\\a\n             (char+ c 1)))\n\
    \       (define (next-next-char c)\n         (if (char=? c #\\y)\n           \
    \  #\\a\n             (char+ c 2)))\n       (define (is-vowel? c)\n         (or\
    \ (char=? c #\\a)\n             (char=? c #\\e)\n             (char=? c #\\i)\n\
    \             (char=? c #\\o)\n             (char=? c #\\u)))\n       (if (is-vowel?\
    \ c)\n           (next-next-char c)\n           (next-char c))]\n      [else c]))\n\
    \  (define (encode-string s)\n    (if (string-empty? s)\n        \"\"\n      \
    \  (string-append (encode-string (substring s 1))\n                       (string\
    \ (encode-char (string-ref s 0))))))\n  (encode-string message))\n", "  (define\
    \ (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define (next-char\
    \ c)\n         (if (char=? c #\\z)\n             #\\a\n             (char+ c 1)))\n\
    \       (define (next-next-char c)\n         (if (char=? c #\\y)\n           \
    \  #\\a\n             (next-char (next-char c))))\n       (define (is-vowel? c)\n\
    \         (or (char=? c #\\a)\n             (char=? c #\\e)\n             (char=?\
    \ c #\\i)\n             (char=? c #\\o)\n             (char=? c #\\u)))\n    \
    \   (if (is-vowel? c)\n           (next-next-char c)\n           (next-char c))]\n\
    \      [else c]))\n  (define (encode-string s)\n    (if (string-empty? s)\n  \
    \      \"\"\n        (string-append (string (encode-char (string-ref s 0)))\n\
    \                       (encode-string (substring s 1)))))\n  (encode-string message))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (is-vowel? c)\n         (member c '(#\\a #\\e #\\i #\\o #\\u)))\n       (define\
    \ (next-vowel c)\n         (cond\n           [(eq? c #\\u) #\\a]\n           [(eq?\
    \ c #\\a) #\\e]\n           [(eq? c #\\e) #\\i]\n           [(eq? c #\\i) #\\\
    o]\n           [(eq? c #\\o) #\\u]))\n       (if (is-vowel? c)\n           (next-vowel\
    \ (next-vowel c))\n           (char-upcase c))]\n      [else c]))\n  (string-&gt;list\
    \ (string-map encode-char message)))\n</code>\n", "  (define (swap-case c)\n \
    \   (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (encode-char c)\n    (if (char-vowel? c)\n        (char-next\
    \ (char-next c))\n        c))\n  (string-map encode-char (string-map swap-case\
    \ message)))\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n    \
    \    (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char c)\n\
    \    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n     \
    \ [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u)\
    \ #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=?\
    \ c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n\
    \      [else (swap-case c)]))\n  (string-map encode-char message))\n", "  (define\
    \ (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define (next-char\
    \ c)\n         (if (char=? c #\\z)\n             #\\a\n             (char+ c 1)))\n\
    \       (define (next-next-char c)\n         (if (char=? c #\\y)\n           \
    \  #\\a\n             (next-char (next-char c))))\n       (define (is-vowel? c)\n\
    \         (or (char=? c #\\a)\n             (char=? c #\\e)\n             (char=?\
    \ c #\\i)\n             (char=? c #\\o)\n             (char=? c #\\u)))\n    \
    \   (if (is-vowel? c)\n           (next-next-char c)\n           (next-char c))]\n\
    \      [else c]))\n  (define (encode-string s)\n    (string-map encode-char s))\n\
    \  (encode-string message))\n", "  (string-upcase message))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (define (next-char c)\n \
    \        (integer->char (+ (char->integer c) 1)))\n       (define (next-next-char\
    \ c)\n         (integer->char (+ (char->integer c) 2)))\n       (define (is-vowel?\
    \ c)\n         (or (char=? c #\\a)\n             (char=? c #\\e)\n           \
    \  (char=? c #\\i)\n             (char=? c #\\o)\n             (char=? c #\\u)))\n\
    \       (define (encode-vowel c)\n         (cond\n           [(char=? c #\\u)\n\
    \            (next-char #\\a)]\n           [else\n            (next-next-char\
    \ c)]))\n       (cond\n         [(is-vowel? c)\n          (encode-vowel c)]\n\
    \         [else\n          (next-char c)])]\n      [else\n       c]))\n  (define\
    \ (encode-string s)\n    (cond\n      [(empty? s)\n       empty]\n      [else\n\
    \       (cons (encode-char (first s))\n             (encode-string (rest s)))]))\n\
    \  (encode-string message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (string-map\n   (lambda (c)\n     (cond\n       [(char-alphabetic? c)\n    \
    \    (if (char-lower-case? c)\n            (char-upcase c)\n            (char-downcase\
    \ c))]\n       [(char=? c #\\a) #\\c]\n       [(char=? c #\\e) #\\g]\n       [(char=?\
    \ c #\\i) #\\k]\n       [(char=? c #\\o) #\\q]\n       [(char=? c #\\u) #\\w]\n\
    \       [else c]))\n   message))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (encode-char c)\n    (if (char-alphabetic?\
    \ c)\n        (if (or (char-lower-case? c) (char-upper-case? c))\n           \
    \ (if (or (char=? c #\\a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=?\
    \ c #\\u))\n                (char-upcase (char+ c 2))\n                (char-upcase\
    \ (char+ c 1)))\n            c)\n        c))\n  (string-map encode-char (string-map\
    \ swap-case message)))\n", "  (map (lambda (c)\n         (cond\n           [(char-alphabetic?\
    \ c)\n            (if (char-lower-case? c)\n                (char-upcase c)\n\
    \                (char-downcase c))]\n           [(char=? c #\\a) #\\c]\n    \
    \       [(char=? c #\\e) #\\g]\n           [(char=? c #\\i) #\\k]\n          \
    \ [(char=? c #\\o) #\\q]\n           [(char=? c #\\u) #\\w]\n           [else\
    \ c]))\n       (string->list message)))\n", "  (define (encode-char c)\n    (if\
    \ (char-alphabetic? c)\n        (let* ([c (char-upcase c)]\n               [c\
    \ (if (char-vowel? c)\n                      (char-next (char-next c))\n     \
    \                 c)])\n          (if (char-lower-case? c)\n              (char-upcase\
    \ c)\n              c))\n        c))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c\
    \ #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n  \
    \    [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else (swap-case\
    \ c)]))\n  (string-map encode-char message))\n", "  (define (encode-char c)\n\
    \    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n   \
    \        (char-upcase c)\n           (char-downcase c))]\n      [(char=? c #\\\
    a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=?\
    \ c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase\
    \ c)\n        (char-upcase c)))\n  (define (encode-char c)\n    (cond ((char=?\
    \ c #\\a) #\\c)\n          ((char=? c #\\e) #\\g)\n          ((char=? c #\\i)\
    \ #\\k)\n          ((char=? c #\\o) #\\q)\n          ((char=? c #\\u) #\\w)\n\
    \          ((char=? c #\\A) #\\C)\n          ((char=? c #\\E) #\\G)\n        \
    \  ((char=? c #\\I) #\\K)\n          ((char=? c #\\O) #\\Q)\n          ((char=?\
    \ c #\\U) #\\W)\n          (else (swap-case c))))\n  (map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (if (char-vowel?\
    \ c)\n            (let ([v (char-downcase c)])\n              (if (char=? v #\\\
    u)\n                  #\\c\n                  (char+ v 2)))\n            (swap-case\
    \ c))\n        c))\n  (string-map encode-char message))\n", "  (define (swap-case\
    \ c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (next-vowel c)\n    (cond\n      [(char=? c #\\a) #\\c]\n  \
    \    [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\\
    o) #\\q]\n      [(char=? c #\\u) #\\y]\n      [else c]))\n  (define (encode-char\
    \ c)\n    (if (or (char-vowel? c) (char-vowel? (swap-case c)))\n        (next-vowel\
    \ c)\n        (swap-case c)))\n  (string-map encode-char message))\n", "  (define\
    \ (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n   \
    \     (char-upcase c)))\n  (define (encode-char c)\n    (if (char-vowel? c)\n\
    \        (encode-vowel c)\n        (swap-case c)))\n  (define (encode-vowel c)\n\
    \    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n     \
    \ [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u)\
    \ #\\y]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=?\
    \ c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\Y]\n\
    \      [else (error \"not a vowel\")]))\n  (string-map encode-char message))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (vowel? c)\n         (or (char=? c #\\a)\n             (char=? c #\\e)\n   \
    \          (char=? c #\\i)\n             (char=? c #\\o)\n             (char=?\
    \ c #\\u)))\n       (define (next-char c)\n         (if (char=? c #\\z)\n    \
    \         #\\a\n             (char+ c 1)))\n       (define (next-next-char c)\n\
    \         (if (char=? c #\\y)\n             #\\b\n             (next-char (next-char\
    \ c))))\n       (if (vowel? c)\n           (next-next-char c)\n           (next-char\
    \ c))]\n      [else c]))\n  (define (encode-string s)\n    (string-append (list\
    \ (encode-char (string-ref s 0)))\n                   (encode-string (substring\
    \ s 1))))\n  (encode-string message))\n", "  (define (encode-char c)\n    (cond\n\
    \      [(char-alphabetic? c)\n       (let ([c (char-upcase c)])\n         (cond\n\
    \           [(char=? c #\\A) #\\C]\n           [(char=? c #\\E) #\\G]\n      \
    \     [(char=? c #\\I) #\\K]\n           [(char=? c #\\O) #\\Q]\n           [(char=?\
    \ c #\\U) #\\W]\n           [else (char-upcase c)]))]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (cond ((char=? c\
    \ #\\a) #\\c)\n          ((char=? c #\\e) #\\g)\n          ((char=? c #\\i) #\\\
    k)\n          ((char=? c #\\o) #\\q)\n          ((char=? c #\\u) #\\w)\n     \
    \     ((char=? c #\\A) #\\C)\n          ((char=? c #\\E) #\\G)\n          ((char=?\
    \ c #\\I) #\\K)\n          ((char=? c #\\O) #\\Q)\n          ((char=? c #\\U)\
    \ #\\W)\n          (else c)))\n  (define (encode-string s)\n    (if (string-empty?\
    \ s)\n        \"\"\n        (string-append (encode-char (swap-case (string-ref\
    \ s 0)))\n                       (encode-string (substring s 1)))))\n  (encode-string\
    \ message))\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n     \
    \   (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char c)\n\
    \    (if (char-vowel? c)\n        (encode-vowel c)\n        (swap-case c)))\n\
    \  (define (encode-vowel c)\n    (define (next-vowel c)\n      (if (char-vowel?\
    \ c)\n          (next-vowel (char-next c))\n          c))\n    (define (next-next-vowel\
    \ c)\n      (if (char-vowel? c)\n          (next-next-vowel (char-next c))\n \
    \         c))\n    (next-next-vowel (next-vowel c)))\n  (define (char-vowel? c)\n\
    \    (or (char=? c #\\a)\n        (char=? c #\\e)\n        (char=? c #\\i)\n \
    \       (char=? c #\\o)\n        (char=? c #\\u)))\n  (string-map encode-char\
    \ message))\n", "  (define (swap-case c)\n    (if (char-upper-case? c)\n     \
    \   (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char c)\n\
    \    (if (member c '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n        (string-ref \"cdfghjklmnpqrstvwxyzab\"\
    \ (string-index \"aeiou\" c))\n        (swap-case c)))\n  (string-join (map encode-char\
    \ (string->list message))))\n", "  (map (lambda (char)\n         (if (char-alphabetic?\
    \ char)\n             (if (char-lower-case? char)\n                 (char-upcase\
    \ char)\n                 (char-downcase char))\n             char))\n       message))\n",
  "  (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n\
    \        (char-upcase c)))\n  (define (encode-char c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c\
    \ #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n  \
    \    [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else (swap-case\
    \ c)]))\n  (string-map encode-char message))\n", "  (define (encode-char c)\n\
    \    (cond\n      [(char-alphabetic? c)\n       (define (is-vowel? c)\n      \
    \   (member c '(#\\a #\\e #\\i #\\o #\\u)))\n       (define (next-vowel c)\n \
    \        (cond\n           [(char=? c #\\a) #\\c]\n           [(char=? c #\\e)\
    \ #\\g]\n           [(char=? c #\\i) #\\k]\n           [(char=? c #\\o) #\\q]\n\
    \           [(char=? c #\\u) #\\w]))\n       (if (is-vowel? c)\n           (next-vowel\
    \ c)\n           (char-upcase c))]\n      [else c]))\n  (string-map encode-char\
    \ message))\n", "  (define (swap-case c)\n    (if (char-alphabetic? c)\n     \
    \   (if (char-lower-case? c)\n            (char-upcase c)\n            (char-downcase\
    \ c))\n        c))\n  (define (shift-vowel c)\n    (if (member c '(#\\a #\\e #\\\
    i #\\o #\\u))\n        (char-upcase c)\n        c))\n  (define (encode-char c)\n\
    \    (shift-vowel (swap-case c)))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (if (char-vowel?\
    \ c)\n            (let ((vowels (string-&gt;list \"aeiou\")))\n              (list-ref\
    \ vowels (+ 2 (list-index (char-&gt;integer c) vowels))))\n            c)\n  \
    \      c))\n  (string-&gt;list (map swap-case (map encode-char (string-&gt;list\
    \ message)))))\n</code>\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (next-char c)\n         (if (char=? c #\\z)\n           \
    \  #\\a\n             (char+ c 1)))\n       (define (next-next-char c)\n     \
    \    (if (char=? c #\\y)\n             #\\a\n             (next-char (next-char\
    \ c))))\n       (define (is-vowel? c)\n         (or (char=? c #\\a)\n        \
    \     (char=? c #\\e)\n             (char=? c #\\i)\n             (char=? c #\\\
    o)\n             (char=? c #\\u)))\n       (cond\n         [(is-vowel? c)\n  \
    \        (next-next-char c)]\n         [else\n          (next-char c)])]\n   \
    \   [else\n       c]))\n  (string-map encode-char message))\n", "  (define (encode-char\
    \ c)\n    (cond [(char-alphabetic? c)\n           (if (char-lower-case? c)\n \
    \              (char-upcase c)\n               (char-downcase c))]\n         \
    \ [(char=? c #\\a) #\\c]\n          [(char=? c #\\e) #\\g]\n          [(char=?\
    \ c #\\i) #\\k]\n          [(char=? c #\\o) #\\q]\n          [(char=? c #\\u)\
    \ #\\w]\n          [else c]))\n  (string-map encode-char message))\n", "  (define\
    \ (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case?\
    \ c)\n           (char-upcase c)\n           (char-downcase c))]\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n  \
    \    [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\\
    U) #\\W]\n      [else (swap-case c)]))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-upper-case?\
    \ c)\n            (char-downcase c)\n            (char-upcase c))\n        c))\n\
    \  (define (next-vowel c)\n    (cond ((char=? c #\\a) #\\c)\n          ((char=?\
    \ c #\\e) #\\g)\n          ((char=? c #\\i) #\\k)\n          ((char=? c #\\o)\
    \ #\\q)\n          ((char=? c #\\u) #\\w)\n          (else c)))\n  (define (encode-char\
    \ c)\n    (next-vowel (swap-case c)))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-upper-case?\
    \ c)\n            (char-downcase c)\n            (char-upcase c))\n        c))\n\
    \  (define (next-vowel c)\n    (cond ((char=? c #\\a) #\\c)\n          ((char=?\
    \ c #\\e) #\\g)\n          ((char=? c #\\i) #\\k)\n          ((char=? c #\\o)\
    \ #\\q)\n          ((char=? c #\\u) #\\w)\n          (else c)))\n  (define (encode-char\
    \ c)\n    (next-vowel (swap-case c)))\n  (string-map encode-char message))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (vowel? c)\n         (member c '(#\\a #\\e #\\i #\\o #\\u)))\n       (define\
    \ (next-char c)\n         (integer->char (+ (char->integer c) 1)))\n       (define\
    \ (next-vowel c)\n         (cond\n           [(vowel? c)\n            (next-char\
    \ (next-char c))]\n           [else\n            (next-char c)]))\n       (cond\n\
    \         [(vowel? c)\n          (next-vowel c)]\n         [else\n          (next-char\
    \ c)])]\n      [else\n       c]))\n  (define (encode-string s)\n    (string-map\
    \ encode-char s))\n  (encode-string message))\n", "  (define (encode-char c)\n\
    \    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n   \
    \        (char-upcase c)\n           (char-downcase c))]\n      [(char=? c #\\\
    a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=?\
    \ c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-upper-case? c)\n           (char-downcase c)\n        \
    \   (char-upcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if\
    \ (char-lower-case? c)\n           (char-upcase c)\n           (char-downcase\
    \ c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=?\
    \ c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n\
    \      [else c]))\n  (string-map encode-char message))\n", "  (define (swap-case\
    \ c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase\
    \ c)))\n  (define (encode-char c)\n    (if (char-vowel? c)\n        (char-next\
    \ (char-next c))\n        c))\n  (string-map encode-char (string-map swap-case\
    \ message)))\n", "  (string-join\n   (map\n    (lambda (x)\n      (if (char-alphabetic?\
    \ x)\n          (if (char-lower-case? x)\n              (char-upcase x)\n    \
    \          (char-downcase x))\n          x))\n    (string-split message #\\space))\n\
    \   \" \"))\n", "  (define (encode-char c)\n    (define (is-vowel? c)\n      (or\
    \ (char=? c #\\a)\n          (char=? c #\\e)\n          (char=? c #\\i)\n    \
    \      (char=? c #\\o)\n          (char=? c #\\u)))\n    (define (swap-case c)\n\
    \      (if (char-upper-case? c)\n          (char-downcase c)\n          (char-upcase\
    \ c)))\n    (define (next-char c)\n      (if (char=? c #\\z)\n          #\\a\n\
    \          (char+ c 1)))\n    (define (next-next-char c)\n      (if (char=? c\
    \ #\\y)\n          #\\a\n          (next-char (next-char c))))\n    (if (is-vowel?\
    \ c)\n        (next-next-char c)\n        (swap-case c)))\n  (string-map encode-char\
    \ message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=?\
    \ c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n\
    \      [(char=? c #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c\
    \ #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n  \
    \    [(char=? c #\\U) #\\W]\n      [else c]))\n  (string-map (lambda (c) (encode-char\
    \ (swap-case c))) message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n  \
    \    [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\\
    U) #\\W]\n      [else (swap-case c)]))\n  (string-map encode-char message))\n",
  "  (string-upcase message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (is-vowel? c)\n         (or (char=? c #\\a)\n           \
    \  (char=? c #\\e)\n             (char=? c #\\i)\n             (char=? c #\\o)\n\
    \             (char=? c #\\u)))\n       (define (shift-char c)\n         (define\
    \ (shift-char-helper c)\n           (if (char=? c #\\z)\n               #\\a\n\
    \               (char+ c 1)))\n         (shift-char-helper (shift-char-helper\
    \ c)))\n       (if (is-vowel? c)\n           (shift-char (shift-char c))\n   \
    \        (char-upcase c))]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (if (char-vowel?\
    \ c)\n        (char-next (char-next c))\n        c))\n  (string-map swap-case\
    \ (string-map encode-char message)))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (define (is-vowel? c)\n      (member c '(#\\a #\\e #\\i #\\o #\\u)))\n\
    \    (if (is-vowel? c)\n        (let ([c (swap-case c)])\n          (char+ c 2))\n\
    \        (swap-case c)))\n  (string-map encode-char message))\n", "  (define (encode-char\
    \ c)\n    (define (is-vowel? c)\n      (or (char=? c #\\a)\n          (char=?\
    \ c #\\e)\n          (char=? c #\\i)\n          (char=? c #\\o)\n          (char=?\
    \ c #\\u)))\n    (define (swap-case c)\n      (if (char-upper-case? c)\n     \
    \     (char-downcase c)\n          (char-upcase c)))\n    (define (next-vowel\
    \ c)\n      (cond ((char=? c #\\a) #\\c)\n            ((char=? c #\\e) #\\g)\n\
    \            ((char=? c #\\i) #\\k)\n            ((char=? c #\\o) #\\q)\n    \
    \        ((char=? c #\\u) #\\w)))\n    (if (is-vowel? c)\n        (next-vowel\
    \ c)\n        (swap-case c)))\n  (string-map encode-char message))\n", "  (define\
    \ (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n\
    \            (char-upcase c)\n            (char-downcase c))\n        c))\n  (define\
    \ (encode-char c)\n    (if (char-vowel? c)\n        (char-next (char-next c))\n\
    \        c))\n  (string-map swap-case (string-map encode-char message)))\n", " \
    \ (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase\
    \ c)\n        (char-upcase c)))\n  (define (encode-char c)\n    (if (char-vowel?\
    \ c)\n        (swap-case (char-next (char-next c)))\n        (swap-case c)))\n\
    \  (define (encode-helper message)\n    (if (empty? message)\n        empty\n\
    \        (cons (encode-char (first message)) (encode-helper (rest message)))))\n\
    \  (list->string (encode-helper (string->list message))))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n\
    \           (char-upcase c)\n           (char-downcase c))]\n      [(char=? c\
    \ #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n  \
    \    [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (define (vowel? c)\n      (member c '(#\\a #\\e #\\i #\\o #\\u)))\n\
    \    (define (next-vowel c)\n      (cond\n        [(vowel? c) (next-vowel (next-char\
    \ c))]\n        [else c]))\n    (define (next-char c)\n      (integer->char (+\
    \ (char->integer c) 1)))\n    (cond\n      [(vowel? c) (next-vowel c)]\n     \
    \ [else (swap-case c)]))\n  (string-map encode-char message))\n", "  (map (lambda\
    \ (c)\n         (cond\n           [(char-alphabetic? c)\n            (if (char-lower-case?\
    \ c)\n                (char-upcase c)\n                (char-downcase c))]\n \
    \          [(char=? c #\\a) #\\c]\n           [(char=? c #\\e) #\\g]\n       \
    \    [(char=? c #\\i) #\\k]\n           [(char=? c #\\o) #\\q]\n           [(char=?\
    \ c #\\u) #\\w]\n           [else c]))\n       (string->list message)))\n", " \
    \ (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (is-vowel? c)\n         (or (char=? c #\\a)\n             (char=? c #\\e)\n\
    \             (char=? c #\\i)\n             (char=? c #\\o)\n             (char=?\
    \ c #\\u)))\n       (if (is-vowel? c)\n           (char-upcase (char-upcase c))\n\
    \           (char-downcase (char-downcase c)))]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (encode-char c)\n    (define (is-vowel?\
    \ c)\n      (member c '(#\\a #\\e #\\i #\\o #\\u)))\n    (define (next-vowel c)\n\
    \      (cond\n        [(equal? c #\\a) #\\e]\n        [(equal? c #\\e) #\\i]\n\
    \        [(equal? c #\\i) #\\o]\n        [(equal? c #\\o) #\\u]\n        [(equal?\
    \ c #\\u) #\\a]\n        [else c]))\n    (define (next-char c)\n      (integer->char\
    \ (+ (char->integer c) 1)))\n    (cond\n      [(is-vowel? c) (next-vowel c)]\n\
    \      [(char-alphabetic? c) (next-char c)]\n      [else c]))\n  (define (encode-string\
    \ s)\n    (if (empty? s)\n        empty\n        (cons (encode-char (first s))\
    \ (encode-string (rest s)))))\n  (string-&gt;list (encode-string (string-&gt;list\
    \ message))))\n</code>\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (swap-vowel\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [else c]))\n  (define (encode-char c)\n    (swap-vowel (swap-case\
    \ c)))\n  (string-map encode-char message))\n", "  (define (encode-char c)\n \
    \   (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n    \
    \       (char-upcase c)\n           (char-downcase c))]\n      [(char=? c #\\\
    a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=?\
    \ c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n        (list-ref '(#\\\
    c #\\f #\\j #\\o #\\t) (position c '(#\\a #\\e #\\i #\\o #\\u)))\n        c))\n\
    \  (map (lambda (c) (encode-char (swap-case c))) message))\n", "  (define (swap-case\
    \ c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (encode-char c)\n    (cond\n      [(char=? c #\\a) #\\c]\n \
    \     [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\\
    o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=?\
    \ c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n\
    \      [(char=? c #\\U) #\\W]\n      [else c]))\n  (string-map swap-case (string-map\
    \ encode-char message)))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (vowel? c)\n         (or (char=? c #\\a)\n             (char=?\
    \ c #\\e)\n             (char=? c #\\i)\n             (char=? c #\\o)\n      \
    \       (char=? c #\\u)))\n       (define (next-char c)\n         (if (char=?\
    \ c #\\z)\n             #\\a\n             (char+ c 1)))\n       (define (next-next-char\
    \ c)\n         (if (char=? c #\\y)\n             #\\b\n             (next-char\
    \ (next-char c))))\n       (if (vowel? c)\n           (next-next-char c)\n   \
    \        (next-char c))]\n      [else c]))\n  (define (encode-string s)\n    (string-map\
    \ encode-char s))\n  (encode-string message))\n", "  (define (encode-char c)\n\
    \    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n   \
    \        (char-upcase c)\n           (char-downcase c))]\n      [(char=? c #\\\
    a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=?\
    \ c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))\n        c))\n  (define (encode-char c)\n    (if (char-alphabetic?\
    \ c)\n        (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n            (let ([n\
    \ (char-&gt;integer c)])\n              (integer-&gt;char (+ n 2)))\n        \
    \    (swap-case c))\n        c))\n  (string-&gt;list (string-map encode-char message)))\n\
    </code>\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase\
    \ c)\n        (char-downcase c)))\n  (define (encode-char c)\n    (if (member\
    \ c '(#\\a #\\e #\\i #\\o #\\u))\n        (list-ref '(#\\c #\\f #\\j #\\o #\\\
    t) (position c '(#\\a #\\e #\\i #\\o #\\u)))\n        c))\n  (map (lambda (c)\
    \ (encode-char (swap-case c))) message))\n", "  (define (swap-case c)\n    (if\
    \ (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase c)))\n\
    \  (define (encode-char c)\n    (cond ((char=? c #\\a) #\\c)\n          ((char=?\
    \ c #\\e) #\\g)\n          ((char=? c #\\i) #\\k)\n          ((char=? c #\\o)\
    \ #\\q)\n          ((char=? c #\\u) #\\w)\n          ((char=? c #\\A) #\\C)\n\
    \          ((char=? c #\\E) #\\G)\n          ((char=? c #\\I) #\\K)\n        \
    \  ((char=? c #\\O) #\\Q)\n          ((char=? c #\\U) #\\W)\n          (else c)))\n\
    \  (define (encode-string s)\n    (if (string-empty? s)\n        \"\"\n      \
    \  (string-append (string (encode-char (string-ref s 0)))\n                  \
    \     (encode-string (substring s 1)))))\n  (encode-string (string-map swap-case\
    \ message)))\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n    \
    \    (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char c)\n\
    \    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n     \
    \ [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u)\
    \ #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=?\
    \ c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n\
    \      [else (swap-case c)]))\n  (string-map encode-char message))\n", "  (define\
    \ (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (char-upcase\
    \ c)]\n      [(char-vowel? c)\n       (char-upcase (char-next (char-next c)))]\n\
    \      [else\n       c]))\n  (string-map encode-char message))\n", "  (define\
    \ (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n     \
    \   (char-downcase c)))\n  (define (shift-vowel c)\n    (cond ((char=? c #\\a)\
    \ #\\c)\n          ((char=? c #\\e) #\\g)\n          ((char=? c #\\i) #\\k)\n\
    \          ((char=? c #\\o) #\\q)\n          ((char=? c #\\u) #\\w)\n        \
    \  (else c)))\n  (define (encode-char c)\n    (shift-vowel (swap-case c)))\n \
    \ (string-map encode-char message))\n", "  (define (encode-char c)\n    (cond\n\
    \      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n           (char-upcase\
    \ c)\n           (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=?\
    \ c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n\
    \      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (string-upcase message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (swap-case c)\n         (if (char-lower-case? c)\n      \
    \       (char-upcase c)\n             (char-downcase c)))\n       (define (next-vowel\
    \ c)\n         (define (is-vowel? c)\n           (or (char=? c #\\a)\n       \
    \        (char=? c #\\e)\n               (char=? c #\\i)\n               (char=?\
    \ c #\\o)\n               (char=? c #\\u)))\n         (define (next-char c)\n\
    \           (if (char=? c #\\z)\n               #\\a\n               (char+ c\
    \ 1)))\n         (if (is-vowel? c)\n             (next-char (next-char c))\n \
    \            c))\n       (swap-case (next-vowel c))]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n  \
    \    [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\\
    U) #\\W]\n      [else (swap-case c)]))\n  (string-map encode-char message))\n",
  "  (map (lambda (c)\n         (if (char-alphabetic? c)\n             (if (char-lower-case?\
    \ c)\n                 (char-upcase c)\n                 (char-downcase c))\n\
    \             c))\n       message))\n", "  (define (swap-case c)\n    (if (char-upcase?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (next-vowel\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [else c]))\n  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c) (swap-case c)]\n      [(char-vowel? c) (next-vowel c)]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (let ([vowels (list #\\a #\\e #\\\
    i #\\o #\\u)]\n        [alphabet (list #\\a #\\b #\\c #\\d #\\e #\\f #\\g #\\\
    h #\\i #\\j #\\k #\\l #\\m #\\n #\\o #\\p #\\q #\\r #\\s #\\t #\\u #\\v #\\w #\\\
    x #\\y #\\z)])\n    (for/list ([c (in-string message)])\n      (if (char-alphabetic?\
    \ c)\n          (if (member c vowels)\n              (list-ref alphabet (+ (index-of\
    \ c alphabet) 2))\n              (list-ref alphabet (index-of c alphabet)))\n\
    \          c))))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-upper-case? c)\n           (char-downcase c)\n        \
    \   (char-upcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (string-upcase message))\n", "  (map (lambda (c)\n         (if (char-alphabetic?\
    \ c)\n             (if (char-lower-case? c)\n                 (char-upcase c)\n\
    \                 (char-downcase c))\n             c))\n       message))\n", " \
    \ (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c\
    \ #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n  \
    \    [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else c]))\n\
    \  (string-map (lambda (c) (encode-char (swap-case c))) message))\n", "  (string-map\
    \ (lambda (c)\n                (if (char-alphabetic? c)\n                    (if\
    \ (char-lower-case? c)\n                        (char-upcase c)\n            \
    \            (char-downcase c))\n                    c))\n              message))\n",
  "  (define (swap-case c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n\
    \        (char-downcase c)))\n  (define (encode-char c)\n    (if (char-vowel?\
    \ c)\n        (char-next (char-next c))\n        c))\n  (string-map encode-char\
    \ (string-map swap-case message)))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n  \
    \    [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\\
    U) #\\W]\n      [else (swap-case c)]))\n  (string-map encode-char message))\n",
  "  (define (swap-case char)\n    (if (char-lower-case? char)\n        (char-upcase\
    \ char)\n        (char-downcase char)))\n  (define (encode-char char)\n    (if\
    \ (char-vowel? char)\n        (swap-case (char-next (char-next char)))\n     \
    \   (swap-case char)))\n  (string-map encode-char message))\n", "  (define (swap-case\
    \ c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase\
    \ c)))\n  (define (encode-char c)\n    (if (char-vowel? c)\n        (char-next\
    \ (char-next c))\n        c))\n  (string-map encode-char (string-map swap-case\
    \ message)))\n", "  (define (swap-case c)\n    (if (char-upper-case? c)\n    \
    \    (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char c)\n\
    \    (if (char-vowel? c)\n        (char-next (char-next c))\n        c))\n  (string-map\
    \ encode-char (string-map swap-case message)))\n", "  (string-upcase message))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (next-char c)\n         (integer->char (+ (char->integer c) 1)))\n       (define\
    \ (next-next-char c)\n         (integer->char (+ (char->integer c) 2)))\n    \
    \   (define (is-vowel? c)\n         (or (char=? c #\\a)\n             (char=?\
    \ c #\\e)\n             (char=? c #\\i)\n             (char=? c #\\o)\n      \
    \       (char=? c #\\u)))\n       (if (is-vowel? c)\n           (next-next-char\
    \ c)\n           (next-char c))]\n      [else c]))\n  (define (encode-string s)\n\
    \    (if (empty? s)\n        empty\n        (cons (encode-char (first s))\n  \
    \            (encode-string (rest s)))))\n  (string-&gt;list (encode-string (string-&gt;list\
    \ message))))\n</code>\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (if (char-vowel? c)\n        (char-next (char-next c))\n        c))\n\
    \  (string-map swap-case (string-map encode-char message)))\n", "  (string-upcase\
    \ message))\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n     \
    \   (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char c)\n\
    \    (if (vowel? c)\n        (encode-vowel c)\n        (swap-case c)))\n  (define\
    \ (encode-vowel c)\n    (let ([vowels (string-&gt;list \"aeiou\")])\n      (list-ref\
    \ vowels (modulo (+ (list-index c vowels) 2) 5))))\n  (string-&gt;list (string-join\
    \ (map encode-char (string-&gt;list message)))))\n</code>\n", "  (define (swap-case\
    \ c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n       \
    \     (char-upcase c)\n            (char-downcase c))\n        c))\n  (define\
    \ (encode-char c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (char-downcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case?\
    \ c)\n            (char-upcase c)\n            (", "  (define (swap-case c)\n\
    \    (if (char-upcase? c)\n        (char-downcase c)\n        (char-upcase c)))\n\
    \  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (swap-case\
    \ c)]\n      [(char=? c #\\a)\n       #\\c]\n      [(char=? c #\\e)\n       #\\\
    g]\n      [(char=? c #\\i)\n       #\\k]\n      [(char=? c #\\o)\n       #\\q]\n\
    \      [(char=? c #\\u)\n       #\\w]\n      [else\n       c]))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (vowel?\
    \ c)\n    (member c '(#\\a #\\e #\\i #\\o #\\u)))\n  (define (encode-char c)\n\
    \    (if (vowel? c)\n        (list-ref '(#\\c #\\d #\\f #\\g #\\h #\\j #\\k #\\\
    l #\\m #\\n #\\p #\\q #\\r #\\s #\\t #\\v #\\w #\\x #\\y #\\z)\n             \
    \     (modulo (+ (char->integer c) 2) 26))\n        (swap-case c)))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (vowel? c)\n        (encode-vowel c)\n        (swap-case c)))\n\
    \  (define (encode-vowel c)\n    (define (next-vowel c)\n      (if (vowel? c)\n\
    \          (next-vowel (next-char c))\n          c))\n    (define (next-char c)\n\
    \      (integer->char (+ 1 (char->integer c))))\n    (next-vowel (next-char c)))\n\
    \  (define (vowel? c)\n    (member c '(#\\a #\\e #\\i #\\o #\\u)))\n  (string-map\
    \ encode-char message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (is-vowel? c)\n         (member c '(#\\a #\\e #\\i #\\o #\\u)))\n       (define\
    \ (next-vowel c)\n         (cond\n           [(char=? c #\\u) #\\a]\n        \
    \   [(char=? c #\\o) #\\e]\n           [(char=? c #\\i) #\\o]\n           [(char=?\
    \ c #\\e) #\\i]\n           [(char=? c #\\a) #\\u]))\n       (if (is-vowel? c)\n\
    \           (next-vowel c)\n           (char-upcase c))]\n      [else c]))\n \
    \ (string-map encode-char message))\n", "  (define (encode-char c)\n    (if (char-alphabetic?\
    \ c)\n        (if (char-vowel? c)\n            (char-upcase (char-next (char-next\
    \ (char-downcase c))))\n            (char-swap-case c))\n        c))\n  (string-map\
    \ encode-char message))\n", "  (map (lambda (c)\n         (cond\n           [(char-alphabetic?\
    \ c)\n            (let ([c (char-upcase c)])\n              (cond\n          \
    \      [(char=? c #\\A) #\\C]\n                [(char=? c #\\E) #\\G]\n      \
    \          [(char=? c #\\I) #\\K]\n                [(char=? c #\\O) #\\Q]\n  \
    \              [(char=? c #\\U) #\\W]\n                [else (char-downcase c)]))]\n\
    \           [else c]))\n       (string->list message)))\n", "  (map (lambda (c)\n\
    \         (if (char-alphabetic? c)\n             (if (char-lower-case? c)\n  \
    \               (char-upcase c)\n                 (char-downcase c))\n       \
    \      c))\n       message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (char-vowel? c)\n        (encode-vowel c)\n        (swap-case c)))\n\
    \  (define (encode-vowel c)\n    (define (next-vowel c)\n      (if (char-vowel?\
    \ c)\n          (next-vowel (char+ c 1))\n          c))\n    (define (next-next-vowel\
    \ c)\n      (if (char-vowel? c)\n          (next-next-vowel (char+ c 1))\n   \
    \       c))\n    (next-next-vowel (next-vowel c)))\n  (define (char-vowel? c)\n\
    \    (or (char=? c #\\a)\n        (char=? c #\\e)\n        (char=? c #\\i)\n \
    \       (char=? c #\\o)\n        (char=? c #\\u)))\n  (string-map encode-char\
    \ message))\n", "  (map (lambda (c)\n         (if (char-alphabetic? c)\n     \
    \        (let ((c-up (char-upcase c)))\n               (if (char-vowel? c-up)\n\
    \                   (let ((c-up-code (char-code c-up)))\n                    \
    \ (char (+ c-up-code 2)))\n                   c))\n             c))\n       message))\n",
  "  (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n\
    \        (char-upcase c)))\n  (define (encode-char c)\n    (if (member c '(#\\\
    a #\\e #\\i #\\o #\\u))\n        (list-ref '(#\\c #\\f #\\j #\\o #\\t) (position\
    \ c '(#\\a #\\e #\\i #\\o #\\u)))\n        c))\n  (define (encode-message message)\n\
    \    (if (empty? message)\n        empty\n        (cons (encode-char (swap-case\
    \ (first message)))\n              (encode-message (rest message)))))\n  (list->string\
    \ (encode-message (string->list message))))\n", "  (define (encode-char c)\n \
    \   (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n    \
    \       (char-upcase c)\n           (char-downcase c))]\n      [(char=? c #\\\
    a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=?\
    \ c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map\
    \ encode-char message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (if (char-lower-case? c)\n           (char-upcase c)\n          \
    \ (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\\
    g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=?\
    \ c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n", " \
    \ (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase\
    \ c)\n        (char-upcase c)))\n  (define (swap-vowel c)\n    (cond\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (define (encode-char c)\n    (swap-vowel (swap-case c)))\n  (string-map encode-char\
    \ message))\n", "  (define (swap-case c)\n    (if (char-upper-case? c)\n     \
    \   (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char c)\n\
    \    (if (or (char=? c #\\a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=?\
    \ c #\\u))\n        (swap-case (char-upcase c))\n        (swap-case c)))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (if (char-vowel? c)\n        (char-upcase (char-next (char-next c)))\n\
    \        (swap-case c)))\n  (string-map encode-char message))\n", "  (define (swap-case\
    \ c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase\
    \ c)))\n  (define (encode-char c)\n    (if (char-vowel? c)\n        (encode-vowel\
    \ c)\n        (swap-case c)))\n  (define (encode-vowel c)\n    (define (next-vowel\
    \ c)\n      (if (char-vowel? c)\n          (next-vowel (char+ c 1))\n        \
    \  c))\n    (define (next-next-vowel c)\n      (if (char-vowel? c)\n         \
    \ (next-next-vowel (char+ c 1))\n          c))\n    (next-next-vowel (next-vowel\
    \ c)))\n  (string-map encode-char message))\n", "  (define (swap-case c)\n   \
    \ (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase c)))\n\
    \  (define (encode-char c)\n    (cond ((char=? c #\\a) #\\c)\n          ((char=?\
    \ c #\\e) #\\g)\n          ((char=? c #\\i) #\\k)\n          ((char=? c #\\o)\
    \ #\\q)\n          ((char=? c #\\u) #\\w)\n          ((char=? c #\\A) #\\C)\n\
    \          ((char=? c #\\E) #\\G)\n          ((char=? c #\\I) #\\K)\n        \
    \  ((char=? c #\\O) #\\Q)\n          ((char=? c #\\U) #\\W)\n          (else c)))\n\
    \  (define (encode-string s)\n    (if (empty? s)\n        empty\n        (cons\
    \ (encode-char (first s))\n              (encode-string (rest s)))))\n  (define\
    \ (swap-case-string s)\n    (if (empty? s)\n        empty\n        (cons (swap-case\
    \ (first s))\n              (swap-case-string (rest s)))))\n  (string-append (encode-string\
    \ (swap-case-string message))))\n", "  (define (encode-char c)\n    (cond\n  \
    \    [(char-alphabetic? c)\n       (if (char-lower-case? c)\n           (char-upcase\
    \ c)\n           (char-downcase c))]\n      [(char=? c #\\a) #\\c]\n      [(char=?\
    \ c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n\
    \      [(char=? c #\\u) #\\w]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (define\
    \ (is-vowel? c)\n         (member c '(#\\a #\\e #\\i #\\o #\\u)))\n       (define\
    \ (encode-vowel c)\n         (define (next-vowel c)\n           (cond\n      \
    \       [(equal? c #\\u) #\\a]\n             [else (next-char c)]))\n        \
    \ (next-vowel (next-vowel c)))\n       (if (is-vowel? c)\n           (encode-vowel\
    \ c)\n           (char-upcase c))]\n      [else c]))\n  (string-map encode-char\
    \ message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (next-char c)\n         (if (char=? c #\\z)\n           \
    \  #\\a\n             (char+ c 1)))\n       (define (next-next-char c)\n     \
    \    (if (char=? c #\\y)\n             #\\a\n             (next-char (next-char\
    \ c))))\n       (define (is-vowel? c)\n         (or (char=? c #\\a)\n        \
    \     (char=? c #\\e)\n             (char=? c #\\i)\n             (char=? c #\\\
    o)\n             (char=? c #\\u)))\n       (define (swap-case c)\n         (if\
    \ (char-upper-case? c)\n             (char-downcase c)\n             (char-upcase\
    \ c)))\n       (cond\n         [(is-vowel? c)\n          (next-next-char c)]\n\
    \         [else\n          (swap-case c)])]\n      [else\n       c]))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (swap-vowel\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [else c]))\n  (define (encode-char c)\n    (swap-vowel (swap-case\
    \ c)))\n  (string-map encode-char message))\n", "  (define (encode-char c)\n \
    \   (define (is-vowel? c)\n      (or (char=? c #\\a)\n          (char=? c #\\\
    e)\n          (char=? c #\\i)\n          (char=? c #\\o)\n          (char=? c\
    \ #\\u)))\n    (define (encode-vowel c)\n      (cond ((char=? c #\\a) #\\c)\n\
    \            ((char=? c #\\e) #\\g)\n            ((char=? c #\\i) #\\k)\n    \
    \        ((char=? c #\\o) #\\q)\n            ((char=? c #\\u) #\\y)))\n    (if\
    \ (is-vowel? c)\n        (encode-vowel c)\n        (char-upcase c)))\n  (map encode-char\
    \ message))\n", "  (string-map\n   (lambda (c)\n     (cond\n       [(char-alphabetic?\
    \ c)\n        (if (char-lower-case? c)\n            (char-upcase c)\n        \
    \    (char-downcase c))]\n       [(char=? c #\\a) #\\c]\n       [(char=? c #\\\
    e) #\\g]\n       [(char=? c #\\i) #\\k]\n       [(char=? c #\\o) #\\q]\n     \
    \  [(char=? c #\\u) #\\w]\n       [else c]))\n   message))\n", "  (define (swap-case\
    \ c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase\
    \ c)))\n  (define (encode-char c)\n    (if (char-vowel? c)\n        (char-next\
    \ (char-next c))\n        c))\n  (string-map (lambda (c) (encode-char (swap-case\
    \ c))) message))\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n\
    \        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n  \
    \    [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\\
    U) #\\W]\n      [else c]))\n  (define (encode-string s)\n    (if (string-empty?\
    \ s)\n        \"\"\n        (string-append (encode-char (string-ref s 0))\n  \
    \                     (encode-string (substring s 1)))))\n  (encode-string (string-map\
    \ swap-case message)))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (member c '(\"a\" \"e\" \"i\" \"o\" \"u\"))\n        (list-ref '(\"\
    c\" \"f\" \"j\" \"n\" \"r\") (index-of c '(\"a\" \"e\" \"i\" \"o\" \"u\")))\n\
    \        c))\n  (map (lambda (c) (encode-char (swap-case c))) (string->list message)))\n",
  "  (define (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case?\
    \ c)\n           (char-upcase c)\n           (char-downcase c))]\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (if (or (char=? c #\\a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\\
    o) (char=? c #\\u))\n        (swap-case (char-upcase c))\n        (swap-case c)))\n\
    \  (define (encode-string s)\n    (if (string-empty? s)\n        \"\"\n      \
    \  (string-append (string (encode-char (string-ref s 0)))\n                  \
    \     (encode-string (substring s 1)))))\n  (encode-string message))\n", "  (define\
    \ (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n   \
    \     (char-upcase c)))\n  (define (encode-char c)\n    (if (char-vowel? c)\n\
    \        (char-upcase (char-next (char-next c)))\n        (swap-case c)))\n  (string-map\
    \ encode-char message))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n\
    \      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c\
    \ #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n  \
    \    [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\\
    U) #\\W]\n      [else (swap-case c)]))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n\
    \        (char-upcase c)))\n  (define (encode-char c)\n    (if (or (char=? c #\\\
    a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=? c #\\u))\n        (swap-case\
    \ (char-upcase c))\n        (swap-case c)))\n  (define (encode-message message)\n\
    \    (if (empty? message)\n        empty\n        (cons (encode-char (first message))\
    \ (encode-message (rest message)))))\n  (encode-message message))\n", "  (define\
    \ (swap-case c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n   \
    \     (char-upcase c)))\n  (define (encode-char c)\n    (if (char-vowel? c)\n\
    \        (encode-vowel c)\n        (swap-case c)))\n  (define (encode-vowel c)\n\
    \    (define (next-vowel c)\n      (if (char-vowel? c)\n          (next-vowel\
    \ (char+ c 1))\n          c))\n    (next-vowel (next-vowel c)))\n  (string-map\
    \ encode-char message))\n", "  (string-upcase (string-replace message \"a\" \"\
    c\")\n                 (string-replace message \"e\" \"g\")\n                \
    \ (string-replace message \"i\" \"k\")\n                 (string-replace message\
    \ \"o\" \"q\")\n                 (string-replace message \"u\" \"w\")))\n", " \
    \ (define (encode-char c)\n    (cond\n      ((char-alphabetic? c)\n       (if\
    \ (char-lower-case? c)\n           (char-upcase c)\n           (char-downcase\
    \ c)))\n      ((char-vowel? c)\n       (char-next (char-next c)))\n      (else\
    \ c)))\n  (string-map encode-char message))\n", "  (define (swap-case c)\n   \
    \ (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n            (char-upcase\
    \ c)\n            (char-downcase c))\n        c))\n  (define (shift-vowel c)\n\
    \    (if (char-vowel? c)\n        (if (char-lower-case? c)\n            (if (char=?\
    \ c #\\u)\n                #\\a\n                (char+ c 2))\n            (if\
    \ (char=? c #\\U)\n                #\\A\n                (char+ c 2)))\n     \
    \   c))\n  (define (encode-char c)\n    (shift-vowel (swap-case c)))\n  (string-map\
    \ encode-char message))\n", "  (let ([vowels (list #\\a #\\e #\\i #\\o #\\u)]\n\
    \        [vowels-shifted (list #\\c #\\g #\\k #\\o #\\s)]\n        [alphabet (list->string\
    \ (range #\\a #\\z))])\n    (string-map\n     (lambda (c)\n       (if (char-alphabetic?\
    \ c)\n           (if (member c vowels)\n               (list-ref vowels-shifted\
    \ (position c vowels))\n               (list-ref alphabet (modulo (+ (position\
    \ c alphabet) 2) 26)))\n           c))\n     message)))\n", "  (define (swap-case\
    \ c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase\
    \ c)))\n  (define (encode-char c)\n    (cond\n      [(char=? c #\\a) #\\c]\n \
    \     [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\\
    o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [(char=? c #\\A) #\\C]\n      [(char=?\
    \ c #\\E) #\\G]\n      [(char=? c #\\I) #\\K]\n      [(char=? c #\\O) #\\Q]\n\
    \      [(char=? c #\\U) #\\W]\n      [else c]))\n  (define (encode-message message)\n\
    \    (if (empty? message)\n        empty\n        (cons (encode-char (swap-case\
    \ (first message)))\n              (encode-message (rest message)))))\n  (list->string\
    \ (encode-message (string->list message))))\n", "  (define (swap-case c)\n   \
    \ (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase c)))\n\
    \  (define (encode-char c)\n    (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n \
    \       (list-ref '(#\\c #\\f #\\j #\\o #\\t)\n                  (position c '(#\\\
    a #\\e #\\i #\\o #\\u)))\n        c))\n  (string-map encode-char (string-map swap-case\
    \ message)))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (let* ([alphabet (string->list \"abcdefghijklmnopqrstuvwxyz\")]\n\
    \              [c (char-downcase c)]\n              [index (string-index alphabet\
    \ c)])\n         (if (member c \"aeiou\")\n             (list-ref alphabet (+\
    \ index 2))\n             (list-ref alphabet (+ index 1))))]\n      [else c]))\n\
    \  (string-join (map encode-char (string->list message))))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n\
    \           (char-upcase c)\n           (char-downcase c))]\n      [(char=? c\
    \ #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n  \
    \    [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (if (member c '(#\\a #\\e #\\i #\\o #\\u))\n        (char-upcase (char-upcase\
    \ c 2))\n        (swap-case c)))\n  (string-map encode-char message))\n", "  (define\
    \ (encode-char c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case?\
    \ c)\n           (char-upcase c)\n           (char-downcase c))]\n      [(char=?\
    \ c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n\
    \      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-upper-case?\
    \ c)\n        (char-downcase c)\n        (char-upcase c)))\n  (define (encode-char\
    \ c)\n    (if (char-vowel? c)\n        (char-upcase (char-next (char-next c)))\n\
    \        (swap-case c)))\n  (string-map encode-char message))\n", "  (string-map\n\
    \   (lambda (c)\n     (if (char-alphabetic? c)\n         (let ([c (char-upcase\
    \ c)])\n           (if (char-vowel? c)\n               (let ([c (char-next (char-next\
    \ c))])\n                 (if (char-vowel? c)\n                     (char-next\
    \ c)\n                     c))\n               c))\n         c))\n   message))\n",
  "  (string-map (lambda (c)\n                (cond\n                  [(char-alphabetic?\
    \ c)\n                   (let* ([c (char-upcase c)]\n                        \
    \  [c (if (member c '(#\\A #\\E #\\I #\\O #\\U))\n                           \
    \      (char-upcase (char-next (char-next c)))\n                             \
    \    c)])\n                    (if (char-lower-case? c)\n                    \
    \    (char-upcase c)\n                        (char-downcase c)))]\n         \
    \         [else c]))\n              message))\n", "  (string-map (lambda (c)\n\
    \                (cond\n                  [(char-alphabetic? c)\n            \
    \       (let ([c (char-upcase c)])\n                     (cond\n             \
    \          [(char=? c #\\A) #\\C]\n                       [(char=? c #\\E) #\\\
    G]\n                       [(char=? c #\\I) #\\K]\n                       [(char=?\
    \ c #\\O) #\\Q]\n                       [(char=? c #\\U) #\\W]\n             \
    \          [else (char-upcase c)]))]\n                  [else c]))\n         \
    \     message))\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n \
    \       (char-upcase c)\n        (char-downcase c)))\n  (define (swap-vowel c)\n\
    \    (cond ((char=? c #\\a) #\\c)\n          ((char=? c #\\e) #\\g)\n        \
    \  ((char=? c #\\i) #\\k)\n          ((char=? c #\\o) #\\q)\n          ((char=?\
    \ c #\\u) #\\w)\n          (else c)))\n  (define (swap-letter c)\n    (swap-case\
    \ (swap-vowel c)))\n  (string-map swap-letter message))\n", "  (define (swap-case\
    \ c)\n    (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase\
    \ c)))\n  (define (encode-char c)\n    (if (char-vowel? c)\n        (char-next\
    \ (char-next c))\n        c))\n  (string-map encode-char (string-map swap-case\
    \ message)))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (define (next-char c)\n         (if (char=? c #\\z)\n           \
    \  #\\a\n             (char+ c 1)))\n       (define (next-next-char c)\n     \
    \    (if (char=? c #\\y)\n             #\\a\n             (next-char (next-char\
    \ c))))\n       (define (is-vowel? c)\n         (or (char=? c #\\a)\n        \
    \     (char=? c #\\e)\n             (char=? c #\\i)\n             (char=? c #\\\
    o)\n             (char=? c #\\u)))\n       (if (is-vowel? c)\n           (next-next-char\
    \ c)\n           (next-char c))]\n      [else c]))\n  (define (encode-string str)\n\
    \    (if (string-empty? str)\n        \"\"\n        (string-append\n         (string\
    \ (encode-char (string-ref str 0)))\n         (encode-string (substring str 1)))))\n\
    \  (encode-string message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (char-vowel? c)\n        (char-upcase (char-next (char-next c)))\n\
    \        (swap-case c)))\n  (string-map encode-char message))\n", "  (define (swap-case\
    \ c)\n    (cond\n      [(char-upper-case? c) (char-downcase c)]\n      [(char-lower-case?\
    \ c) (char-upcase c)]\n      [else c]))\n  (define (encode-char c)\n    (cond\n\
    \      [(char=? c #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c\
    \ #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n  \
    \    [(char=? c #\\A) #\\C]\n      [(char=? c #\\E) #\\G]\n      [(char=? c #\\\
    I) #\\K]\n      [(char=? c #\\O) #\\Q]\n      [(char=? c #\\U) #\\W]\n      [else\
    \ (swap-case c)]))\n  (string-map encode-char message))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (define (next-char c)\n \
    \        (cond\n           [(char=? c #\\z) #\\a]\n           [(char=? c #\\Z)\
    \ #\\A]\n           [else (char+ c 1)]))\n       (define (next-next-char c)\n\
    \         (cond\n           [(char=? c #\\y) #\\a]\n           [(char=? c #\\\
    Y) #\\A]\n           [else (next-char (next-char c))]))\n       (define (is-vowel?\
    \ c)\n         (member (char-downcase c) '(#\\a #\\e #\\i #\\o #\\u)))\n     \
    \  (cond\n         [(is-vowel? c)\n          (next-next-char c)]\n         [(char-lower-case?\
    \ c)\n          (char-upcase c)]\n         [(char-upper-case? c)\n          (char-downcase\
    \ c)]\n         [else c])]\n      [else c]))\n  (string-map encode-char message))\n",
  "  (define (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-upper-case?\
    \ c)\n            (char-downcase c)\n            (char-upcase c))\n        c))\n\
    \  (define (encode-char c)\n    (if (char-alphabetic? c)\n        (if (char-upper-case?\
    \ c)\n            (char-downcase c)\n            (char-upcase c))\n        c))\n\
    \  (define (encode-vowel c)\n    (if (char-alphabetic? c)\n        (if (char-upper-case?\
    \ c)\n            (char-downcase c)\n            (char-upcase c))\n        c))\n\
    \  (define (encode-letter c)\n    (if (char-alphabetic? c)\n        (if (char-upper-case?\
    \ c)\n            (char-downcase c)\n            (char-upcase c))\n        c))\n\
    \  (define (encode-letter c)\n    (if (char-alphabetic? c)\n        (if (char-upper-case?\
    \ c)\n            (char-downcase c)\n            (char-upcase c))\n        c))\n\
    \  (define (encode-letter c)\n    (if (char-alphabetic? c)\n        (if (char-upper-case?\
    \ c)\n            (char-downcase c)\n            (char-upcase c))\n        c))\n\
    \  (define (encode-letter c)\n    (if (char-alphabetic? c)\n        (if (char-upper-case?\
    \ c)\n            (char-downcase c)\n            (char-upcase c))\n        c))\n\
    \  (define (encode-letter c)\n    (if (char-alphabetic? c)\n        (if (char-upper-case?\
    \ c)\n            (char-downcase c)\n            (char-upcase c))\n        c))\n\
    \  (define (encode-letter c)\n    (if (char-alphabetic? c)\n        (if (char-upper-case?\
    \ c)\n            (char-downcase c)\n", "  (define (encode-char c)\n    (define\
    \ (is-vowel? c)\n      (or (equal? c #\\a) (equal? c #\\e) (equal? c #\\i) (equal?\
    \ c #\\o) (equal? c #\\u)))\n    (define (next-vowel c)\n      (cond ((equal?\
    \ c #\\a) #\\c)\n            ((equal? c #\\e) #\\g)\n            ((equal? c #\\\
    i) #\\k)\n            ((equal? c #\\o) #\\q)\n            ((equal? c #\\u) #\\\
    w)))\n    (cond ((is-vowel? c) (next-vowel c))\n          ((char-upcase? c) (char-downcase\
    \ c))\n          ((char-downcase? c) (char-upcase c))\n          (else c)))\n\
    \  (string-map encode-char message))\n", "  (define (encode-char c)\n    (cond\n\
    \      [(char-alphabetic? c)\n       (let ([c (char-upcase c)])\n         (cond\n\
    \           [(member c '(#\\A #\\E #\\I #\\O #\\U))\n            (char-upcase\
    \ (list-ref '(#\\C #\\F #\\J #\\P #\\U)\n                                   (char-&gt;integer\
    \ c)))]\n           [else (char-upcase c)]))]\n      [else c]))\n  (string-&gt;list\
    \ (string-map encode-char message)))\n</code>\n", "  (define (swap-case c)\n \
    \   (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase\
    \ c)))\n  (define (next-vowel c)\n    (cond ((char=? c #\\a) #\\c)\n         \
    \ ((char=? c #\\e) #\\g)\n          ((char=? c #\\i) #\\k)\n          ((char=?\
    \ c #\\o) #\\q)\n          ((char=? c #\\u) #\\w)\n          (else c)))\n  (define\
    \ (encode-char c)\n    (next-vowel (swap-case c)))\n  (define (encode-string s)\n\
    \    (string-map encode-char s))\n  (encode-string message))\n", "  (define (swap-case\
    \ c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase\
    \ c)))\n  (define (encode-char c)\n    (if (or (char=? c #\\a)\n            (char=?\
    \ c #\\e)\n            (char=? c #\\i)\n            (char=? c #\\o)\n        \
    \    (char=? c #\\u))\n        (swap-case (char-upcase c))\n        (swap-case\
    \ c)))\n  (string-map encode-char message))\n", "  (define (swap-case c)\n   \
    \ (if (char-lower-case? c)\n        (char-upcase c)\n        (char-downcase c)))\n\
    \  (define (vowel-shift c)\n    (cond\n      [(char=? c #\\a) #\\c]\n      [(char=?\
    \ c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n      [(char=? c #\\o) #\\q]\n\
    \      [(char=? c #\\u) #\\w]\n      [else c]))\n  (define (encode-char c)\n \
    \   (cond\n      [(char-alphabetic? c) (swap-case (vowel-shift c))]\n      [else\
    \ c]))\n  (string-map encode-char message))\n", "  (map (lambda (c)\n        \
    \ (if (char-alphabetic? c)\n             (if (char-lower-case? c)\n          \
    \       (char-upcase c)\n                 (char-downcase c))\n             c))\n\
    \       message))\n", "  (define (encode-char c)\n    (cond\n      [(char-alphabetic?\
    \ c)\n       (let ([c (char-upcase c)])\n         (cond\n           [(char=? c\
    \ #\\A) #\\C]\n           [(char=? c #\\E) #\\G]\n           [(char=? c #\\I)\
    \ #\\K]\n           [(char=? c #\\O) #\\Q]\n           [(char=? c #\\U) #\\W]\n\
    \           [else (char-upcase c)]))]\n      [else c]))\n  (string-map encode-char\
    \ message))\n", "  (define (encode-char c)\n    (define (is-vowel? c)\n      (or\
    \ (char=? c #\\a)\n          (char=? c #\\e)\n          (char=? c #\\i)\n    \
    \      (char=? c #\\o)\n          (char=? c #\\u)))\n    (define (next-vowel c)\n\
    \      (cond ((char=? c #\\a) #\\c)\n            ((char=? c #\\e) #\\g)\n    \
    \        ((char=? c #\\i) #\\k)\n            ((char=? c #\\o) #\\q)\n        \
    \    ((char=? c #\\u) #\\w)))\n    (cond ((is-vowel? c) (next-vowel c))\n    \
    \      ((char-downcase c) (char-upcase c))\n          ((char-upcase c) (char-downcase\
    \ c))\n          (else c)))\n  (string-map encode-char message))\n", "  (define\
    \ (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n\
    \            (char-upcase c)\n            (char-downcase c))\n        c))\n  (define\
    \ (map-vowels c)\n    (cond ((char=? c #\\a) #\\c)\n          ((char=? c #\\e)\
    \ #\\g)\n          ((char=? c #\\i) #\\k)\n          ((char=? c #\\o) #\\q)\n\
    \          ((char=? c #\\u) #\\w)\n          (else c)))\n  (string-map (lambda\
    \ (c) (map-vowels (swap-case c))) message))\n", "  (define (swap-case c)\n   \
    \ (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase c)))\n\
    \  (define (encode-char c)\n    (define (vowel? c)\n      (or (char=? c #\\a)\n\
    \          (char=? c #\\e)\n          (char=? c #\\i)\n          (char=? c #\\\
    o)\n          (char=? c #\\u)))\n    (if (vowel? c)\n        (swap-case (char-upcase\
    \ c))\n        (swap-case c)))\n  (string-map encode-char message))\n", "  (define\
    \ (swap-case c)\n    (if (char-alphabetic? c)\n        (if (char-lower-case? c)\n\
    \            (char-upcase c)\n            (char-downcase c))\n        c))\n  (define\
    \ (encode-char c)\n    (if (char-alphabetic? c)\n        (let ((vowels (string-&gt;list\
    \ \"aeiou\")))\n          (if (member c vowels)\n              (let ((index (list-index\
    \ (lambda (x) (= x c)) vowels)))\n                (if (= index 4)\n          \
    \          (list-ref vowels 0)\n                    (list-ref vowels (+ index\
    \ 2))))\n              c))\n        c))\n  (list-&gt;string (map swap-case (map\
    \ encode-char (string-&gt;list message)))))\n</code>\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (if (char-lower-case? c)\n\
    \           (char-upcase c)\n           (char-downcase c))]\n      [(char=? c\
    \ #\\a) #\\c]\n      [(char=? c #\\e) #\\g]\n      [(char=? c #\\i) #\\k]\n  \
    \    [(char=? c #\\o) #\\q]\n      [(char=? c #\\u) #\\w]\n      [else c]))\n\
    \  (string-map encode-char message))\n", "  (define (swap-case c)\n    (if (char-lower-case?\
    \ c)\n        (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char\
    \ c)\n    (if (char-vowel? c)\n        (char-next (char-next c))\n        c))\n\
    \  (string-map encode-char (string-map swap-case message)))\n", "  (define (swap-case\
    \ c)\n    (if (char-upper-case? c)\n        (char-downcase c)\n        (char-upcase\
    \ c)))\n  (define (encode-char c)\n    (if (char-vowel? c)\n        (char-next\
    \ (char-next c))\n        c))\n  (string-map encode-char (string-map swap-case\
    \ message)))\n", "  (define (swap-case c)\n    (if (char-lower-case? c)\n    \
    \    (char-upcase c)\n        (char-downcase c)))\n  (define (encode-char c)\n\
    \    (if (or (char=? c #\\a) (char=? c #\\e) (char=? c #\\i) (char=? c #\\o) (char=?\
    \ c #\\u))\n        (swap-case (char-upcase c))\n        (swap-case c)))\n  (define\
    \ (encode-message message)\n    (if (empty? message)\n        \"\"\n        (string-append\
    \ (string (encode-char (string-ref message 0))) (encode-message (substring message\
    \ 1)))))\n  (encode-message message))\n", "  (define (encode-char c)\n    (cond\n\
    \      [(char-alphabetic? c)\n       (cond\n         [(char-lower-case? c)\n \
    \         (char-upcase c)]\n         [(char-upper-case? c)\n          (char-downcase\
    \ c)])]\n      [(char-vowel? c)\n       (char-next (char-next c))]\n      [else\n\
    \       c]))\n  (string-map encode-char message))\n", "  (define (encode-char\
    \ c)\n    (cond\n      [(char-alphabetic? c)\n       (define (is-vowel? c)\n \
    \        (or (char=? c #\\a)\n             (char=? c #\\e)\n             (char=?\
    \ c #\\i)\n             (char=? c #\\o)\n             (char=? c #\\u)))\n    \
    \   (define (next-char c)\n         (if (char=? c #\\z)\n             #\\a\n \
    \            (char+ c 1)))\n       (if (is-vowel? c)\n           (next-char (next-char\
    \ c))\n           (next-char c))]\n      [else c]))\n  (string-map encode-char\
    \ message))\n", "  (define (swap-case c)\n    (if (char-alphabetic? c)\n     \
    \   (if (char-lower-case? c)\n            (char-upcase c)\n            (char-downcase\
    \ c))\n        c))\n  (define (encode-char c)\n    (if (char-alphabetic? c)\n\
    \        (if (or (char-lower-case? c) (char-upper-case? c))\n            (let\
    \ ((vowels (string-&gt;list \"aeiouAEIOU\")))\n              (if (member c vowels)\n\
    \                  (let ((index (list-index vowels c)))\n                    (list-ref\
    \ vowels (+ index 2)))\n                  (swap-case c)))\n            c)\n  \
    \      c))\n  (list-&gt;string (map encode-char (string-&gt;list message))))\n\
    </code>\n", "  (string-upcase message))\n", "  (map (lambda (c)\n         (cond\n\
    \           [(char-alphabetic? c)\n            (let ([c (char-upcase c)])\n  \
    \            (cond\n                [(or (char=? c #\\A) (char=? c #\\E) (char=?\
    \ c #\\I) (char=? c #\\O) (char=? c #\\U))\n                 (char-downcase (char-upcase\
    \ (char+ c 2)))]\n                [else\n                 (char-downcase (char-upcase\
    \ (char+ c 1)))]))]\n           [else c]))\n       (string->list message)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
