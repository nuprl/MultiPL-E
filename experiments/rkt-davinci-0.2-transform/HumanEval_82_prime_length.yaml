name: HumanEval_82_prime_length
language: rkt
prompt: "#lang racket\n\n;; Write a function that takes a string and returns True\
  \ if the string\n;; length is a prime number or False otherwise\n;; Examples\n;;\
  \ >>> (prime_length \"Hello\")\n;; #t\n;; >>> (prime_length \"abcdcba\")\n;; #t\n\
  ;; >>> (prime_length \"kittens\")\n;; #t\n;; >>> (prime_length \"orange\")\n;; #f\n\
  (define (prime_length string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prime_length))\n\
  \    (check-equal? (candidate \"Hello\") #t)\n    (check-equal? (candidate \"abcdcba\"\
  ) #t)\n    (check-equal? (candidate \"kittens\") #t)\n    (check-equal? (candidate\
  \ \"orange\") #f)\n    (check-equal? (candidate \"wow\") #t)\n    (check-equal?\
  \ (candidate \"world\") #t)\n    (check-equal? (candidate \"MadaM\") #t)\n    (check-equal?\
  \ (candidate \"Wow\") #t)\n    (check-equal? (candidate \"\") #f)\n    (check-equal?\
  \ (candidate \"HI\") #t)\n    (check-equal? (candidate \"go\") #t)\n    (check-equal?\
  \ (candidate \"gogo\") #f)\n    (check-equal? (candidate \"aaaaaaaaaaaaaaa\") #f)\n\
  \    (check-equal? (candidate \"Madam\") #t)\n    (check-equal? (candidate \"M\"\
  ) #f)\n    (check-equal? (candidate \"0\") #f)\n))\n\n(test-humaneval)"
completions: ["  (define (is_prime n)\n    (define (iter i)\n      (cond ((= i n)\
    \ #t)\n            ((= (modulo n i) 0) #f)\n            (else (iter (+ i 1)))))\n\
    \    (iter 2))\n  (is_prime (string-length string)))\n", "  (define (is-prime\
    \ n)\n    (define (divides? a b)\n      (= (remainder b a) 0))\n    (define (find-divisor\
    \ n test-divisor)\n      (cond ((> (square test-divisor) n) n)\n            ((divides?\
    \ test-divisor n) test-divisor)\n            (else (find-divisor n (+ test-divisor\
    \ 1)))))\n    (= (find-divisor n 2) n))\n  (is-prime (string-length string)))\n",
  "  (define (is_prime n)\n    (define (divides? a b)\n      (= (remainder b a) 0))\n\
    \    (define (find-divisor n test-divisor)\n      (cond ((> (square test-divisor)\
    \ n) n)\n            ((divides? test-divisor n) test-divisor)\n            (else\
    \ (find-divisor n (+ test-divisor 1)))))\n    (= (find-divisor n 2) n))\n  (is_prime\
    \ (string-length string)))\n", "  (define (prime? n)\n    (define (divisible?\
    \ a b)\n      (= (remainder a b) 0))\n    (define (find-divisor n test-divisor)\n\
    \      (cond ((> (square test-divisor) n) n)\n            ((divisible? n test-divisor)\
    \ test-divisor)\n            (else (find-divisor n (+ test-divisor 1)))))\n  \
    \  (= (find-divisor n 2) n))\n  (prime? (string-length string)))\n", "  (define\
    \ (is-prime n)\n    (define (iter i)\n      (cond ((= i n) #t)\n            ((=\
    \ (modulo n i) 0) #f)\n            (else (iter (+ i 1)))))\n    (iter 2))\n  (is-prime\
    \ (string-length string)))\n", "  (define (is-prime? n)\n    (define (iter i)\n\
    \      (cond ((= i 1) #t)\n            ((= (modulo n i) 0) #f)\n            (else\
    \ (iter (- i 1)))))\n    (iter (- n 1)))\n  (is-prime? (string-length string)))\n",
  "  (define (is_prime n)\n    (cond ((= n 1) #f)\n          ((= n 2) #t)\n      \
    \    ((even? n) #f)\n          (else\n           (let loop ((i 3))\n         \
    \    (cond ((&gt; i (sqrt n)) #t)\n                   ((= (modulo n i) 0) #f)\n\
    \                   (else (loop (+ i 2))))))))\n  (is_prime (string-length string)))\n\
    </code>\n", "  (define (is_prime n)\n    (define (divides? a b)\n      (= (remainder\
    \ b a) 0))\n    (define (find-divisor n test-divisor)\n      (cond ((> (square\
    \ test-divisor) n) n)\n            ((divides? test-divisor n) test-divisor)\n\
    \            (else (find-divisor n (+ test-divisor 1)))))\n    (= (find-divisor\
    \ n 2) n))\n  (is_prime (string-length string)))\n", "  (define (is-prime? n)\n\
    \    (define (divides? a b)\n      (= (remainder b a) 0))\n    (define (find-divisor\
    \ n test-divisor)\n      (cond ((> (square test-divisor) n) n)\n            ((divides?\
    \ test-divisor n) test-divisor)\n            (else (find-divisor n (+ test-divisor\
    \ 1)))))\n    (= (find-divisor n 2) n))\n  (is-prime? (string-length string)))\n",
  "  (define (is-prime? n)\n    (define (iter i)\n      (cond\n        [(= i 1) #t]\n\
    \        [(= (modulo n i) 0) #f]\n        [else (iter (- i 1))]))\n    (iter (-\
    \ n 1)))\n  (is-prime? (string-length string)))\n", "  (define (prime? n)\n  \
    \  (define (divisible? a b)\n      (= (remainder a b) 0))\n    (define (find-divisor\
    \ n test-divisor)\n      (cond ((> (square test-divisor) n) n)\n            ((divisible?\
    \ n test-divisor) test-divisor)\n            (else (find-divisor n (+ test-divisor\
    \ 1)))))\n    (= (find-divisor n 2) n))\n  (prime? (string-length string)))\n",
  "  (define (prime? n)\n    (define (iter i)\n      (cond ((= i n) #t)\n        \
    \    ((= (modulo n i) 0) #f)\n            (else (iter (+ i 1)))))\n    (iter 2))\n\
    \  (prime? (string-length string)))\n", "  (define (is-prime n)\n    (define (divisible?\
    \ a b)\n      (= (remainder a b) 0))\n    (define (find-divisor n test-divisor)\n\
    \      (cond ((> (square test-divisor) n) n)\n            ((divisible? n test-divisor)\
    \ test-divisor)\n            (else (find-divisor n (+ test-divisor 1)))))\n  \
    \  (= (find-divisor n 2) n))\n  (is-prime (string-length string)))\n", "  (define\
    \ (is-prime n)\n    (define (is-prime-helper n i)\n      (cond ((= i 1) #t)\n\
    \            ((= (modulo n i) 0) #f)\n            (else (is-prime-helper n (-\
    \ i 1)))))\n    (is-prime-helper n (- n 1)))\n  (is-prime (string-length string)))\n",
  "  (define (is_prime n)\n    (define (divisible? a b)\n      (= (remainder a b)\
    \ 0))\n    (define (find-divisor n test-divisor)\n      (cond ((> (square test-divisor)\
    \ n) n)\n            ((divisible? n test-divisor) test-divisor)\n            (else\
    \ (find-divisor n (+ test-divisor 1)))))\n    (= (find-divisor n 2) n))\n  (is_prime\
    \ (string-length string)))\n", "  (define (is_prime n)\n    (define (helper i)\n\
    \      (cond ((= i 1) #t)\n            ((= (modulo n i) 0) #f)\n            (else\
    \ (helper (- i 1)))))\n    (helper (- n 1)))\n  (is_prime (string-length string)))\n",
  "  (define (is_prime n)\n    (define (is_divisible? a b)\n      (= (remainder a\
    \ b) 0))\n    (define (smallest_divisor n)\n      (define (find-divisor n test-divisor)\n\
    \        (cond ((> (square test-divisor) n) n)\n              ((is_divisible?\
    \ n test-divisor) test-divisor)\n              (else (find-divisor n (+ test-divisor\
    \ 1)))))\n      (find-divisor n 2))\n    (= (smallest_divisor n) n))\n  (is_prime\
    \ (string-length string)))\n", "  (define (prime? n)\n    (define (divisible?\
    \ a b)\n      (= (remainder a b) 0))\n    (define (find-divisor n test-divisor)\n\
    \      (cond ((> (square test-divisor) n) n)\n            ((divisible? n test-divisor)\
    \ test-divisor)\n            (else (find-divisor n (+ test-divisor 1)))))\n  \
    \  (= (find-divisor n 2) n))\n  (prime? (string-length string)))\n", "  (define\
    \ (is_prime n)\n    (define (is_divisible? a b)\n      (= (remainder a b) 0))\n\
    \    (define (is_prime? n)\n      (cond\n        ((= n 1) #f)\n        ((= n 2)\
    \ #t)\n        ((is_divisible? n 2) #f)\n        (else (is_prime? (- n 1)))))\n\
    \    (is_prime? n))\n  (is_prime (string-length string)))\n", "  (define (is_prime\
    \ n)\n    (define (iter i)\n      (if (= i n)\n          #t\n          (if (=\
    \ (remainder n i) 0)\n              #f\n              (iter (+ i 1)))))\n    (iter\
    \ 2))\n  (is_prime (string-length string)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
