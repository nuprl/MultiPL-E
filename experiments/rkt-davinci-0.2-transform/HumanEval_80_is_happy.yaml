name: HumanEval_80_is_happy
language: rkt
prompt: "#lang racket\n\n;; You are given a string s.\n;; Your task is to check if\
  \ the string is happy or not.\n;; A string is happy if its length is at least 3\
  \ and every 3 consecutive letters are distinct\n;; For example:\n;; >>> (is_happy\
  \ a)\n;; #f\n;; >>> (is_happy aa)\n;; #f\n;; >>> (is_happy abcd)\n;; #t\n;; >>>\
  \ (is_happy aabb)\n;; #f\n;; >>> (is_happy adb)\n;; #t\n;; >>> (is_happy xyy)\n\
  ;; #f\n(define (is_happy s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_happy))\n\
  \    (check-equal? (candidate \"a\") #f)\n    (check-equal? (candidate \"aa\") #f)\n\
  \    (check-equal? (candidate \"abcd\") #t)\n    (check-equal? (candidate \"aabb\"\
  ) #f)\n    (check-equal? (candidate \"adb\") #t)\n    (check-equal? (candidate \"\
  xyy\") #f)\n    (check-equal? (candidate \"iopaxpoi\") #t)\n    (check-equal? (candidate\
  \ \"iopaxioi\") #f)\n))\n\n(test-humaneval)"
completions: ["  (define (is_happy-helper s)\n    (if (or (< (string-length s) 3)\n\
    \            (equal? (string-ref s 0) (string-ref s 1))\n            (equal? (string-ref\
    \ s 1) (string-ref s 2)))\n        #f\n        (is_happy-helper (substring s 1))))\n\
    \  (is_happy-helper s))\n", "  (cond\n    [(< (string-length s) 3) #f]\n    [(equal?\
    \ (substring s 0 3) (substring s 1 4)) #f]\n    [else (is_happy (substring s 1))]))\n",
  "  (if (&lt; (string-length s) 3)\n      #f\n      (let loop ([i 0])\n        (if\
    \ (= i (- (string-length s) 2))\n            #t\n            (if (string=? (substring\
    \ s i (+ i 3)) (string-append (substring s i (+ i 1)) (substring s i (+ i 1))\
    \ (substring s i (+ i 1))))\n                #f\n                (loop (+ i 1)))))))\n\
    </code>\n", "  (if (or (< (string-length s) 3)\n          (equal? (substring s\
    \ 0 3) (substring s 1 4)))\n      #f\n      #t))\n", "  (if (< (string-length\
    \ s) 3)\n      #f\n      (let ((s (string->list s)))\n        (cond\n        \
    \ ((equal? (list-ref s 0) (list-ref s 1)) #f)\n         ((equal? (list-ref s 1)\
    \ (list-ref s 2)) #f)\n         ((equal? (list-ref s 0) (list-ref s 2)) #f)\n\
    \         (else #t)))))\n", "  (if (or (< (string-length s) 3)\n          (string-contains\
    \ s #\\a #\\a)\n          (string-contains s #\\b #\\b)\n          (string-contains\
    \ s #\\c #\\c)\n          (string-contains s #\\d #\\d))\n      #f\n      #t))\n",
  "  (if (&lt; (string-length s) 3)\n      #f\n      (let* ([s (string-&gt;list s)]\n\
    \             [s (map symbol-&gt;string s)]\n             [s (string-join s)])\n\
    \        (if (string-contains? s \"aaa\")\n            #f\n            #t))))\n\
    </code>\nI am not sure if this is the most efficient way to do it.\nI am also\
    \ not sure if I should use <code>string-&gt;list</code> and <code>map</code> to\
    \ convert the string to a list of characters.\nI am also not sure if I should\
    \ use <code>string-join</code> to convert the list of characters back to a string.\n\
    I am also not sure if I should use <code>string-contains?</code> to check if the\
    \ string contains 3 consecutive letters.\nI am also not sure if I should use <code>string-length</code>\
    \ to check if the string is at least 3 characters long.\nI am also not sure if\
    \ I should use <code>let*</code> to bind the variables.\nI am also not sure if\
    \ I should use <code>if</code> to check if the string is happy or not.\nI am also\
    \ not sure if I should use <code>#f</code> and <code>#t</code> to return the result.\n\
    I am also not sure if I should use <code>&lt;</code> to check if the string is\
    \ at least 3 characters long.\nI am also not sure if I should use <code>symbol-&gt;string</code>\
    \ to convert the characters to strings.\nI am also not sure if I should use <code>string-contains?</code>\
    \ to check if the string contains 3 consecutive letters.\nI am also not sure if\
    \ I should use <code>string-length</code> to check if the string is at least 3\
    \ characters long.\nI am also not sure if I should use <code>let*</code> to bind\
    \ the variables.\nI am also not sure if I should use <code>if</code> to check\
    \ if the string is happy or not.\nI am also not sure if I should use <code>#f</code>\
    \ and <code>", "  (if (< (string-length s) 3)\n      #f\n      (let ([s (string-append\
    \ s (string-take s 3))])\n        (for/and ([i (in-range (string-length s) (-\
    \ (string-length s) 3))])\n          (not (equal? (string-take s i) (string-take\
    \ s (+ i 3))))))))\n", "  (if (&lt; (string-length s) 3)\n      #f\n      (let\
    \ loop ([i 0])\n        (if (&lt; i (- (string-length s) 2))\n            (if\
    \ (equal? (substring s i (+ i 3)) (string-append (substring s i (+ i 1)) (substring\
    \ s i (+ i 1)) (substring s i (+ i 1))))\n                #f\n               \
    \ (loop (+ i 1)))\n            #t))))\n</code>\n", "  (cond\n    [(< (string-length\
    \ s) 3) #f]\n    [(equal? (string-ref s 0) (string-ref s 1)) #f]\n    [(equal?\
    \ (string-ref s 1) (string-ref s 2)) #f]\n    [else #t]))\n", "  (define (is_happy-helper\
    \ s)\n    (cond\n      [(empty? s) #t]\n      [(empty? (rest s)) #t]\n      [(empty?\
    \ (rest (rest s))) #t]\n      [(char=? (first s) (first (rest s))) #f]\n     \
    \ [(char=? (first s) (first (rest (rest s)))) #f]\n      [(char=? (first (rest\
    \ s)) (first (rest (rest s)))) #f]\n      [else (is_happy-helper (rest s))]))\n\
    \  (and\n    (>= (string-length s) 3)\n    (is_happy-helper s)))\n", "  (cond\n\
    \    [(>= (string-length s) 3)\n     (if (equal? (string-ref s 0) (string-ref\
    \ s 1))\n         #f\n         (if (equal? (string-ref s 1) (string-ref s 2))\n\
    \             #f\n             (is_happy (substring s 1))))]\n    [else #f]))\n",
  "  (cond\n    [(< (string-length s) 3) #f]\n    [(equal? (substring s 0 3) (substring\
    \ s 1 4)) #f]\n    [else (is_happy (substring s 1))]))\n", "  (if (or (< (string-length\
    \ s) 3)\n          (string-contains s #\\a #\\a)\n          (string-contains s\
    \ #\\b #\\b)\n          (string-contains s #\\c #\\c)\n          (string-contains\
    \ s #\\d #\\d))\n      #f\n      #t))\n", "  (cond\n    [(< (string-length s)\
    \ 3) #f]\n    [(and (not (= (string-ref s 0) (string-ref s 1)))\n          (not\
    \ (= (string-ref s 0) (string-ref s 2)))\n          (not (= (string-ref s 1) (string-ref\
    \ s 2)))) #t]\n    [else #f]))\n", "  (cond\n    [(< (string-length s) 3) #f]\n\
    \    [(equal? (string-ref s 0) (string-ref s 1)) #f]\n    [(equal? (string-ref\
    \ s 1) (string-ref s 2)) #f]\n    [else #t]))\n", "  (if (&lt; (string-length\
    \ s) 3)\n      #f\n      (let ([s (string-&gt;list s)])\n        (for/and ([i\
    \ (in-range (sub1 (string-length s)) 2 -1)])\n          (not (equal? (list-ref\
    \ s i) (list-ref s (- i 1))))))))\n</code>\n", "  (cond\n    [(< (string-length\
    \ s) 3) #f]\n    [(and (equal? (string-ref s 0) (string-ref s 1))\n          (equal?\
    \ (string-ref s 1) (string-ref s 2))) #f]\n    [else (is_happy (substring s 1))]))\n",
  "  (if (string&lt;=? s 3)\n      #f\n      (let ([s (string-&gt;list s)])\n    \
    \    (for/and ([i (in-range 0 (- (length s) 2))])\n          (not (equal? (list-ref\
    \ s i) (list-ref s (+ i 1))))))))\n</code>\n", "  (cond\n    [(< (string-length\
    \ s) 3) #f]\n    [(equal? (string-ref s 0) (string-ref s 1)) #f]\n    [(equal?\
    \ (string-ref s 1) (string-ref s 2)) #f]\n    [else #t]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
