name: HumanEval_128_prod_signs
language: rkt
prompt: "#lang racket\n\n;; You are given an array arr of integers and you need to\
  \ return\n;; sum of magnitudes of integers multiplied by product of all signs\n\
  ;; of each number in the array, represented by 1, -1 or 0.\n;; Note: return None\
  \ for empty arr.\n;; Example:\n;; >>> (prod_signs (list 1 2 2 -4))\n;; 9\n;; >>>\
  \ (prod_signs (list 0 1))\n;; 0\n;; >>> (prod_signs (list ))\n;; #f\n(define (prod_signs\
  \ arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate prod_signs))\n\
  \    (check-equal? (candidate (list 1 2 2 -4)) -9)\n    (check-equal? (candidate\
  \ (list 0 1)) 0)\n    (check-equal? (candidate (list 1 1 1 2 3 -1 1)) -10)\n   \
  \ (check-equal? (candidate (list )) #f)\n    (check-equal? (candidate (list 2 4\
  \ 1 2 -1 -1 9)) 20)\n    (check-equal? (candidate (list -1 1 -1 1)) 4)\n    (check-equal?\
  \ (candidate (list -1 1 1 1)) -4)\n    (check-equal? (candidate (list -1 1 1 0))\
  \ 0)\n))\n\n(test-humaneval)"
completions: ["  (if (null? arr)\n      #f\n      (let loop ((arr arr)\n         \
    \        (prod 1)\n                 (sum 0))\n        (if (null? arr)\n      \
    \      (* prod sum)\n            (let ((x (car arr)))\n              (cond ((>\
    \ x 0)\n                     (loop (cdr arr)\n                           (* prod\
    \ 1)\n                           (+ sum x)))\n                    ((< x 0)\n \
    \                    (loop (cdr arr)\n                           (* prod -1)\n\
    \                           (+ sum (- x))))\n                    (else\n     \
    \                (loop (cdr arr)\n                           (* prod 0)\n    \
    \                       (+ sum 0)))))))))\n", "  (cond\n    [(empty? arr) #f]\n\
    \    [(empty? (rest arr)) (abs (first arr))]\n    [else (* (signum (first arr))\
    \ (prod_signs (rest arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(= (length\
    \ arr) 1) (abs (first arr))]\n    [else (* (prod_signs (rest arr)) (sign (first\
    \ arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(= (length arr) 1) (abs\
    \ (car arr))]\n    [else (* (abs (car arr)) (prod_signs (cdr arr)))]))\n", " \
    \ (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)]\n             [sign-prod (apply * signs)]\n    \
    \         [magnitudes (map abs arr)])\n        (apply + (map * magnitudes signs)))))\n",
  "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (if (empty? arr)\n      #f\n      (let ([signs (map abs arr)])\n\
    \        (apply * (map signum arr))\n        (apply + signs))))\n", "  (if (null?\
    \ arr)\n      #f\n      (let ((signs (map (lambda (x)\n                      \
    \    (if (zero? x)\n                              0\n                        \
    \      (if (< x 0)\n                                  -1\n                   \
    \               1)))\n                        arr)))\n        (let ((magnitudes\
    \ (map abs arr)))\n          (let ((product (apply * signs)))\n            (apply\
    \ + (map * magnitudes signs)))))))\n", "  (if (null? arr)\n      #f\n      (let\
    \ ([prod (apply * (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr))])\n\
    \        (apply + (map (lambda (x) (abs x)) arr))\n        (* prod (apply + (map\
    \ (lambda (x) (abs x)) arr))))))\n", "  (if (null? arr)\n      #f\n      (let\
    \ ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n      \
    \  (let ([magnitudes (map abs arr)])\n          (let ([prod (apply * signs)])\n\
    \            (apply + (map * magnitudes signs)))))))\n", "  (if (null? arr)\n\
    \      #f\n      (let ([signs (map (lambda (x)\n                          (if\
    \ (zero? x)\n                              0\n                              (if\
    \ (< x 0)\n                                  -1\n                            \
    \      1)))\n                        arr)])\n        (let ([magnitudes (map abs\
    \ arr)])\n          (apply * signs)\n          (apply + magnitudes)))))\n", " \
    \ (if (null? arr)\n      #f\n      (let loop ([arr arr] [prod 1])\n        (if\
    \ (null? arr)\n            (* (apply + (map abs arr)) prod)\n            (loop\
    \ (cdr arr) (* prod (signum (car arr))))))))\n", "  (if (null? arr)\n      #f\n\
    \      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \        (apply * (map abs arr))\n        (apply * signs))))\n", "  (if (null?\
    \ arr)\n      #f\n      (let ([prod (apply * (map (lambda (x) (if (zero? x) 0\
    \ (if (> x 0) 1 -1))) arr))])\n        (apply + (map (lambda (x) (abs x)) arr)))))\n",
  "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x)\n            \
    \              (if (zero? x)\n                              0\n              \
    \                (if (< x 0)\n                                  -1\n         \
    \                         1)))\n                        arr)])\n        (let ([magnitudes\
    \ (map abs arr)])\n          (let ([sign-prod (apply * signs)])\n            (let\
    \ ([mag-sum (apply + magnitudes)])\n              (* sign-prod mag-sum)))))))\n",
  "  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)]\n     \
    \        [prod (apply * signs)]\n             [sum (apply + magnitudes)])\n  \
    \      (* prod sum))))\n", "  (if (null? arr)\n      #f\n      (let ((signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)))\n        (apply * (map\
    \ abs arr))\n        (apply * signs))))\n", "  (if (null? arr)\n      #f\n   \
    \   (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \        (apply * (map abs arr))\n        (apply * signs))))\n", "  (cond\n  \
    \  [(empty? arr) #f]\n    [(= (length arr) 1) (abs (first arr))]\n    [else\n\
    \     (* (prod_signs (rest arr))\n        (signum (first arr))\n        (abs (first\
    \ arr)))]))\n", "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda\
    \ (x) (if (> x 0) 1 -1)) arr)])\n        (let ([magnitudes (map abs arr)])\n \
    \         (let ([prod (apply * signs)])\n            (apply + (map * magnitudes\
    \ signs)))))))\n", "  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [sign-prod (apply\
    \ * signs)]\n             [magnitudes (map abs arr)])\n        (apply + (map *\
    \ magnitudes signs)))))\n", "  (cond\n    [(empty? arr) #f]\n    [(empty? (rest\
    \ arr)) (abs (first arr))]\n    [else (* (prod_signs (rest arr)) (signum (first\
    \ arr)))]))\n", "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda\
    \ (x)\n                          (if (zero? x)\n                             \
    \ 0\n                              (if (< x 0)\n                             \
    \     -1\n                                  1)))\n                        arr)])\n\
    \        (apply * (map abs arr))\n        (apply * signs))))\n", "  (if (null?\
    \ arr)\n      #f\n      (let ((signs (map (lambda (x)\n                      \
    \    (if (zero? x)\n                              0\n                        \
    \      (if (> x 0)\n                                  1\n                    \
    \              -1)))\n                        arr)))\n        (let ((prod (apply\
    \ * signs)))\n          (let ((magnitudes (map abs arr)))\n            (apply\
    \ + (map * magnitudes signs)))))))\n", "  (cond [(empty? arr) #f]\n        [else\
    \ (let ([signs (map sign arr)])\n                (apply * signs)\n           \
    \     (apply + (map abs arr)))]))\n", "  (if (null? arr)\n      #f\n      (let\
    \ ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n      \
    \  (apply * (map abs arr))\n        (apply * signs))))\n", "  (if (null? arr)\n\
    \      #f\n      (let ((signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)))\n        (let ((magnitudes (map abs arr)))\n          (let ((prod (apply\
    \ * signs)))\n            (let ((sum (apply + magnitudes)))\n              (*\
    \ prod sum)))))))\n", "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply\
    \ + (map abs arr))))))\n", "  (if (null? arr)\n      #f\n      (let ([signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map\
    \ abs arr))\n        (apply * signs))))\n", "  (if (null? arr)\n      #f\n   \
    \   (let loop ([arr arr] [acc 1])\n        (if (null? arr)\n            (if (zero?\
    \ acc)\n                0\n                acc)\n            (loop (cdr arr) (*\
    \ acc (signum (car arr))))))))\n", "  (if (null? arr)\n      #f\n      (let ((signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)))\n        (apply\
    \ * (map abs arr)))))\n", "  (cond\n    [(empty? arr) #f]\n    [(= (length arr)\
    \ 1) (abs (car arr))]\n    [else\n     (* (abs (car arr))\n        (prod_signs\
    \ (cdr arr)))]))\n", "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n\
    \        (apply * signs))))\n", "  (cond\n    [(empty? arr) #f]\n    [(= (length\
    \ arr) 1) (abs (first arr))]\n    [else (* (abs (first arr)) (prod_signs (rest\
    \ arr)))]))\n", "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n\
    \        (apply * signs))))\n", "  (if (null? arr)\n      #f\n      (let ((magnitude\
    \ (map abs arr))\n            (sign (map (lambda (x)\n                       \
    \  (cond ((> x 0) 1)\n                               ((< x 0) -1)\n          \
    \                     (else 0)))\n                       arr)))\n        (apply\
    \ * (map * magnitude sign)))))\n", "  (if (null? arr)\n      #f\n      (let loop\
    \ ([arr arr] [prod 1])\n        (if (null? arr)\n            (* prod (apply +\
    \ (map abs arr)))\n            (loop (cdr arr) (* prod (signum (car arr))))))))\n",
  "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x)\n            \
    \              (if (zero? x)\n                              0\n              \
    \                (if (> x 0)\n                                  1\n          \
    \                        -1)))\n                        arr)])\n        (let ([prod\
    \ (apply * signs)])\n          (let ([magnitudes (map abs arr)])\n           \
    \ (apply + (map * magnitudes signs)))))))\n", "  (if (null? arr)\n      #f\n \
    \     (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \        (* (apply * signs) (apply + (map abs arr))))))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [(empty? (cdr arr)) (abs (car arr))]\n    [else (* (abs (car arr))\
    \ (prod_signs (cdr arr)))]))\n", "  (if (null? arr)\n      #f\n      (let ((signs\
    \ (map (lambda (x)\n                          (if (zero? x)\n                \
    \              0\n                              (if (> x 0)\n                \
    \                  1\n                                  -1)))\n              \
    \          arr)))\n        (let ((magnitudes (map abs arr)))\n          (let ((sign_product\
    \ (apply * signs)))\n            (let ((magnitude_sum (apply + magnitudes)))\n\
    \              (* sign_product magnitude_sum)))))))\n", "  (if (null? arr)\n \
    \     #f\n      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)]\n             [magnitudes (map abs arr)]\n             [sign-prod (apply\
    \ * signs)]\n             [mag-sum (apply + magnitudes)])\n        (* sign-prod\
    \ mag-sum))))\n", "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n\
    \        (apply * signs))))\n", "  (cond\n    [(empty? arr) #f]\n    [(= (length\
    \ arr) 1) (abs (first arr))]\n    [else (* (prod_signs (rest arr)) (sign (first\
    \ arr)))]))\n", "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (< x 0) -1 1))) arr)])\n        (apply * (map abs arr))\n\
    \        (apply * signs))))\n", "  (if (null? arr)\n      #f\n      (let ([signs\
    \ (map (lambda (x)\n                          (if (zero? x)\n                \
    \              0\n                              (if (< x 0)\n                \
    \                  -1\n                                  1)))\n              \
    \          arr)])\n        (let ([magnitudes (map abs arr)])\n          (apply\
    \ * (map * signs magnitudes))))))\n", "  (cond\n    [(empty? arr) #f]\n    [(empty?\
    \ (rest arr)) (abs (first arr))]\n    [else (* (prod_signs (rest arr)) (signum\
    \ (first arr)) (abs (first arr)))]))\n", "  (if (empty? arr)\n      #f\n     \
    \ (let ([signs (map sign arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (cond [(empty? arr) #f]\n        [else (let ([signs (map\
    \ (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n                (* (product\
    \ signs) (sum (map abs arr))))]))\n", "  (cond [(empty? arr) #f]\n        [else\n\
    \         (let ([signs (map (lambda (x) (if (zero? x) 0 (if (< x 0) -1 1))) arr)])\n\
    \           (apply * (map abs arr))\n           (apply * signs))]))\n", "  (if\
    \ (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if\
    \ (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (if (null? arr)\n      #f\n      (let ((signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)))\n        (let ((prod (apply * signs)))\n      \
    \    (let ((magnitudes (map abs arr)))\n            (apply + (map (lambda (x)\
    \ (* x prod)) magnitudes)))))))\n", "  (if (null? arr)\n      #f\n      (let ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply\
    \ * (map abs arr))\n        (apply * signs))))\n", "  (cond\n    [(empty? arr)\
    \ #f]\n    [(zero? (length arr)) 0]\n    [else\n     (let* ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n            [prod (apply * signs)]\n\
    \            [magnitudes (map abs arr)])\n       (apply + (map * magnitudes signs)))]))\n",
  "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x)\n            \
    \              (if (zero? x)\n                              0\n              \
    \                (if (> x 0)\n                                  1\n          \
    \                        -1)))\n                        arr)])\n        (apply\
    \ * (map abs arr))\n        (apply * signs))))\n", "  (cond [(empty? arr) #f]\n\
    \        [else (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n                (* (product signs) (sum (map abs arr))))]))\n", "  (if\
    \ (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if\
    \ (> x 0) 1 -1))) arr)])\n        (* (apply * signs) (apply + (map abs arr))))))\n",
  "  (if (null? arr)\n      #f\n      (let ([signs (map signum arr)])\n        (apply\
    \ * signs)\n        (apply + (map abs arr)))))\n", "  (cond\n    [(empty? arr)\
    \ #f]\n    [(= (length arr) 1) (abs (car arr))]\n    [else\n     (* (abs (car\
    \ arr))\n        (prod_signs (cdr arr)))]))\n", "  (if (null? arr)\n      #f\n\
    \      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \        (apply * (map abs arr))\n        (apply * signs))))\n", "  (cond\n  \
    \  [(empty? arr) #f]\n    [(= (length arr) 1) (abs (first arr))]\n    [else (*\
    \ (prod_signs (rest arr)) (signum (first arr)))]))\n", "  (if (null? arr)\n  \
    \    #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [(= (length arr) 1) (abs (first arr))]\n    [else\
    \ (* (prod_signs (rest arr)) (sign (first arr)))]))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [(zero? (car arr)) 0]\n    [else (* (car arr) (prod_signs (cdr\
    \ arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(= (length arr) 1) (abs\
    \ (first arr))]\n    [else (* (prod_signs (rest arr)) (abs (first arr)))]))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(= (length arr) 1) (abs (first arr))]\n  \
    \  [else (* (prod_signs (rest arr)) (signum (first arr)))]))\n", "  (cond\n  \
    \  [(empty? arr) #f]\n    [(= (length arr) 1) (abs (first arr))]\n    [else (*\
    \ (prod_signs (rest arr)) (signum (first arr)))]))\n", "  (if (null? arr)\n  \
    \    #f\n      (let ([prod (foldl * 1 (map sign arr))])\n        (if (= prod 0)\n\
    \            0\n            (* prod (foldl + 0 (map abs arr)))))))\n", "  (if\
    \ (null? arr)\n      #f\n      (let* ([signs (map (lambda (x)\n              \
    \             (if (zero? x)\n                               0\n              \
    \                 (if (positive? x)\n                                   1\n  \
    \                                 -1)))\n                         arr)]\n    \
    \         [prod (apply * signs)]\n             [magnitudes (map abs arr)])\n \
    \       (apply + (map * magnitudes signs)))))\n", "  (cond [(empty? arr) #f]\n\
    \        [else\n         (let ([signs (map (lambda (x) (if (zero? x) 0 (if (>\
    \ x 0) 1 -1))) arr)])\n           (* (apply * signs) (apply + (map abs arr))))]))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(= (length arr) 1) (abs (first arr))]\n  \
    \  [else (* (prod_signs (rest arr)) (abs (first arr)))]))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [(zero? (apply * (map sign arr))) 0]\n    [else (* (apply * (map\
    \ sign arr)) (apply + (map abs arr)))]))\n", "  (if (null? arr)\n      #f\n  \
    \    (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (positive? x) 1 -1)))\
    \ arr)]\n             [magnitudes (map abs arr)])\n        (apply * signs)\n \
    \       (apply + magnitudes))))\n", "  (cond\n    [(empty? arr) #f]\n    [(empty?\
    \ (cdr arr)) (abs (car arr))]\n    [else (* (signum (car arr)) (prod_signs (cdr\
    \ arr)))]))\n", "  (if (null? arr)\n      #f\n      (let loop ([arr arr] [prod\
    \ 1])\n        (if (null? arr)\n            (* (apply + (map abs arr)) prod)\n\
    \            (let ([sign (if (zero? (car arr))\n                            0\n\
    \                            (if (positive? (car arr))\n                     \
    \           1\n                                -1))])\n              (loop (cdr\
    \ arr) (* prod sign)))))))\n", "  (cond\n    [(empty? arr) #f]\n    [(= (length\
    \ arr) 1) (abs (first arr))]\n    [else\n     (* (prod_signs (rest arr))\n   \
    \     (abs (first arr)))]))\n", "  (if (null? arr)\n      #f\n      (let* ([signs\
    \ (map (lambda (x)\n                           (if (zero? x)\n               \
    \                0\n                               (if (< x 0)\n             \
    \                      -1\n                                   1)))\n         \
    \                arr)]\n             [magnitudes (map abs arr)])\n        (* (apply\
    \ * signs)\n           (apply + magnitudes)))))\n", "  (cond\n    [(empty? arr)\
    \ #f]\n    [(zero? (apply * (map sign arr))) 0]\n    [else (* (apply * (map sign\
    \ arr)) (apply + (map abs arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(empty?\
    \ (cdr arr)) (abs (car arr))]\n    [else (* (car arr) (prod_signs (cdr arr)))]))\n",
  "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x)\n            \
    \              (if (zero? x)\n                              0\n              \
    \                (if (< x 0)\n                                  -1\n         \
    \                         1)))\n                        arr)])\n        (apply\
    \ * (map abs arr))\n        (apply * signs))))\n", "  (if (null? arr)\n      #f\n\
    \      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \        (apply * (map abs arr))\n        (apply * signs))))\n", "  (cond\n  \
    \  [(empty? arr) #f]\n    [(= (length arr) 1) (abs (car arr))]\n    [else\n  \
    \   (* (abs (car arr))\n        (prod_signs (cdr arr)))]))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [(= (length arr) 1) (abs (car arr))]\n    [else (* (prod_signs\
    \ (cdr arr)) (signum (car arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(=\
    \ (length arr) 1) (abs (first arr))]\n    [else\n     (* (prod_signs (rest arr))\n\
    \        (if (zero? (first arr))\n            0\n            (if (negative? (first\
    \ arr)) -1 1)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(= (length arr) 1)\
    \ (abs (first arr))]\n    [else (* (prod_signs (rest arr)) (abs (first arr)))]))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(= (length arr) 1) (abs (car arr))]\n    [else\
    \ (* (prod_signs (cdr arr)) (signum (car arr)))]))\n", "  (if (null? arr)\n  \
    \    #f\n      (let* ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)]\n             [magnitudes (map abs arr)]\n             [sign-prod (apply\
    \ * signs)]\n             [mag-sum (apply + magnitudes)])\n        (* sign-prod\
    \ mag-sum))))\n", "  (cond\n    [(empty? arr) #f]\n    [(= (length arr) 1) (abs\
    \ (car arr))]\n    [else (* (prod_signs (cdr arr)) (abs (car arr)))]))\n", " \
    \ (cond\n    [(empty? arr) #f]\n    [(= (length arr) 1) (abs (first arr))]\n \
    \   [else\n     (* (prod_signs (rest arr))\n        (abs (first arr)))]))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(zero? (apply * (map sign arr))) 0]\n    [else\
    \ (* (apply * (map sign arr)) (apply + (map abs arr)))]))\n", "  (if (null? arr)\n\
    \      #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [(= (length arr) 1) (abs (car arr))]\n    [else (*\
    \ (prod_signs (cdr arr)) (abs (car arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n\
    \    [(= (length arr) 1) (abs (first arr))]\n    [else (* (prod_signs (rest arr))\
    \ (sign (first arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(zero? (product\
    \ (map sign arr))) 0]\n    [else (* (product (map sign arr)) (sum (map abs arr)))]))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(zero? (apply * (map signum arr))) 0]\n  \
    \  [else (* (apply * (map signum arr)) (apply + (map abs arr)))]))\n", "  (if\
    \ (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (< x 0) -1 1))\
    \ arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [(= (length arr) 1) (abs (car arr))]\n    [else (*\
    \ (prod_signs (cdr arr)) (signum (car arr)))]))\n", "  (cond\n    [(empty? arr)\
    \ #f]\n    [(= (length arr) 1) (abs (first arr))]\n    [else (* (prod_signs (rest\
    \ arr)) (abs (first arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(= (length\
    \ arr) 1) (abs (car arr))]\n    [else (* (prod_signs (cdr arr)) (signum (car arr)))]))\n",
  "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)])\n        (let ([magnitudes (map abs arr)])\n  \
    \        (let ([prod (apply * signs)])\n            (let ([sum (apply + magnitudes)])\n\
    \              (* prod sum)))))))\n", "  (cond\n    [(empty? arr) #f]\n    [(=\
    \ (length arr) 1) (abs (car arr))]\n    [else (* (prod_signs (cdr arr)) (sign\
    \ (car arr)))]))\n", "  (if (null? arr)\n      #f\n      (let ((signs (map (lambda\
    \ (x)\n                          (if (zero? x)\n                             \
    \ 0\n                              (if (< x 0)\n                             \
    \     -1\n                                  1)))\n                        arr)))\n\
    \        (let ((sign-prod (apply * signs)))\n          (let ((magnitudes (map\
    \ abs arr)))\n            (apply + (map * magnitudes signs)))))))\n", "  (if (null?\
    \ arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x\
    \ 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(= (length arr) 1) (abs (car arr))]\n    [else\
    \ (* (prod_signs (cdr arr)) (signum (car arr)))]))\n", "  (cond [(empty? arr)\
    \ #f]\n        [else\n         (let ([prod (apply * (map sign arr))])\n      \
    \     (if (= prod 0)\n               0\n               (* prod (apply + (map abs\
    \ arr)))))]))\n", "  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map\
    \ abs arr)]\n             [sign-prod (apply * signs)]\n             [mag-sum (apply\
    \ + magnitudes)])\n        (* sign-prod mag-sum))))\n", "  (if (null? arr)\n \
    \     #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n        (apply * signs)\n        (apply + (map abs arr)))))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [(= (length arr) 1) (abs (car arr))]\n    [else (*\
    \ (prod_signs (cdr arr)) (abs (car arr)))]))\n", "  (if (null? arr)\n      #f\n\
    \      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n\
    \        (* (apply * signs) (apply + (map abs arr))))))\n", "  (if (null? arr)\n\
    \      #f\n      (let* ([signs (map abs arr)]\n             [magnitudes (map signum\
    \ arr)]\n             [prod (apply * magnitudes)])\n        (apply + (map * signs\
    \ prod)))))\n", "  (if (null? arr)\n      #f\n      (let ((signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (< x 0) -1 1))) arr)))\n        (apply * (map abs arr))\n\
    \        (apply * signs))))\n", "  (if (null? arr)\n      #f\n      (let ((signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)))\n        (apply\
    \ * (map abs arr))\n        (apply * signs))))\n", "  (cond\n    [(empty? arr)\
    \ #f]\n    [(zero? (length arr)) 0]\n    [else\n     (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (positive? x) 1 -1))) arr)])\n       (apply * (map abs\
    \ arr))\n       (apply * signs))]))\n", "  (if (null? arr)\n      #f\n      (let*\
    \ ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n       \
    \      [magnitudes (map abs arr)]\n             [sign-product (apply * signs)]\n\
    \             [magnitude-sum (apply + magnitudes)])\n        (* sign-product magnitude-sum))))\n",
  "  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)]\n     \
    \        [sign-prod (foldl * 1 signs)]\n             [mag-sum (foldl + 0 magnitudes)])\n\
    \        (* sign-prod mag-sum))))\n", "  (if (null? arr)\n      #f\n      (let\
    \ ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n      \
    \  (apply * (map abs arr))\n        (apply * signs))))\n", "  (if (null? arr)\n\
    \      #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n", "  (if\
    \ (null? arr)\n      #f\n      (let ([signs (map (lambda (x)\n               \
    \           (if (zero? x)\n                              0\n                 \
    \             (if (> x 0)\n                                  1\n             \
    \                     -1)))\n                        arr)])\n        (let ([magnitudes\
    \ (map abs arr)])\n          (let ([sign-product (apply * signs)])\n         \
    \   (let ([magnitude-sum (apply + magnitudes)])\n              (* sign-product\
    \ magnitude-sum)))))))\n", "  (cond\n    [(empty? arr) #f]\n    [(zero? (apply\
    \ * (map sign arr))) 0]\n    [else (* (apply * (map sign arr)) (apply + (map abs\
    \ arr)))]))\n", "  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [prod (apply * signs)]\n\
    \             [mags (map abs arr)])\n        (apply + (map * mags signs)))))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(= (length arr) 1) (abs (car arr))]\n    [else\
    \ (* (prod_signs (cdr arr)) (signum (car arr)))]))\n", "  (if (null? arr)\n  \
    \    #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n", "  (if\
    \ (null? arr)\n      #f\n      (let ((signs (map (lambda (x) (if (zero? x) 0 (if\
    \ (> x 0) 1 -1))) arr)))\n        (let ((prod (apply * signs)))\n          (let\
    \ ((magnitudes (map abs arr)))\n            (apply + (map * magnitudes signs)))))))\n",
  "  (if (null? arr)\n      #f\n      (let ((signs (map (lambda (x)\n            \
    \              (if (zero? x)\n                              0\n              \
    \                (if (< x 0)\n                                  -1\n         \
    \                         1)))\n                        arr)))\n        (let ((sign-prod\
    \ (apply * signs)))\n          (let ((magnitudes (map abs arr)))\n           \
    \ (apply + (map * magnitudes signs)))))))\n", "  (if (null? arr)\n      #f\n \
    \     (let ((signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)))\n\
    \        (apply * (map abs arr))\n        (apply * signs))))\n", "  (cond\n  \
    \  [(empty? arr) #f]\n    [(= 0 (car arr)) 0]\n    [else\n     (* (car arr) (prod_signs\
    \ (cdr arr)))]))\n", "  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [sign-prod (apply\
    \ * signs)]\n             [magnitudes (map abs arr)])\n        (apply + (map *\
    \ magnitudes signs)))))\n", "  (cond\n    [(empty? arr) #f]\n    [(= (length arr)\
    \ 1) (abs (first arr))]\n    [else (* (abs (first arr)) (prod_signs (rest arr)))]))\n",
  "  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (< x 0) -1 1))) arr)]\n             [magnitudes (map abs arr)])\n    \
    \    (apply * signs)\n        (apply + magnitudes))))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [(= (length arr) 1) (abs (car arr))]\n    [else\n     (* (prod_signs\
    \ (cdr arr))\n        (if (= (car arr) 0)\n            0\n            (abs (car\
    \ arr))))]))\n", "  (cond [(empty? arr) #f]\n        [else\n         (let* ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n               \
    \ [magnitudes (map abs arr)]\n                [sign-product (apply * signs)]\n\
    \                [magnitude-sum (apply + magnitudes)])\n           (* sign-product\
    \ magnitude-sum))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(empty? (cdr arr))\
    \ (abs (car arr))]\n    [else (* (abs (car arr)) (prod_signs (cdr arr)))]))\n",
  "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)])\n        (let ([magnitudes (map abs arr)])\n  \
    \        (let ([prod (apply * signs)])\n            (apply + (map * magnitudes\
    \ signs)))))))\n", "  (cond\n    [(empty? arr) #f]\n    [(empty? (rest arr)) (abs\
    \ (first arr))]\n    [else (* (abs (first arr)) (prod_signs (rest arr)))]))\n",
  "  (if (null? arr)\n      #f\n      (let ((signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)))\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (if (null? arr)\n      #f\n      (let* ([signs (map sign\
    \ arr)]\n             [magnitudes (map abs arr)]\n             [sign-prod (apply\
    \ * signs)]\n             [mag-sum (apply + magnitudes)])\n        (* sign-prod\
    \ mag-sum))))\n", "  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map\
    \ abs arr)]\n             [prod (apply * signs)]\n             [sum (apply + magnitudes)])\n\
    \        (* prod sum))))\n", "  (if (empty? arr)\n      #f\n      (let loop ([arr\
    \ arr] [sum 0] [prod 1])\n        (if (empty? arr)\n            (* sum prod)\n\
    \            (let ([x (car arr)])\n              (loop (cdr arr) (+ sum (abs x))\
    \ (* prod (if (zero? x) 0 (if (> x 0) 1 -1)))))))))\n", "  (if (null? arr)\n \
    \     #f\n      (let ((signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)))\n        (let ((magnitudes (map abs arr)))\n          (let ((prod (apply\
    \ * signs)))\n            (apply + (map * magnitudes signs)))))))\n", "  (if (null?\
    \ arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x\
    \ 0) 1 -1))) arr)])\n        (apply * signs)\n        (apply + (map abs arr)))))\n",
  "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (if (null? arr)\n      #f\n      (let ((signs (map sign arr)))\n\
    \        (apply * signs)\n        (apply + (map abs arr)))))\n", "  (if (null?\
    \ arr)\n      #f\n      (let ((signs (map sign arr)))\n        (apply * (map abs\
    \ arr)))))\n", "  (cond\n    [(empty? arr) #f]\n    [(empty? (cdr arr)) (abs (car\
    \ arr))]\n    [else (* (signum (car arr)) (prod_signs (cdr arr)))]))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [(zero? (car arr)) 0]\n    [else\n     (* (abs (car\
    \ arr))\n        (prod_signs (cdr arr)))]))\n", "  (if (null? arr)\n      #f\n\
    \      (let ((signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)))\n\
    \        (let ((prod (apply * signs)))\n          (let ((magnitudes (map abs arr)))\n\
    \            (apply + (map (lambda (x) (* x prod)) magnitudes)))))))\n", "  (if\
    \ (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if\
    \ (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (if (null? arr)\n      #f\n      (let ([magnitudes (map abs arr)])\n        (apply\
    \ * (map signum arr))\n        (apply + magnitudes))))\n", "  (if (null? arr)\n\
    \      #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (< x 0) -1\
    \ 1))) arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n\
    \        (apply * signs))))\n", "  (cond [(null? arr) #f]\n        [(= (length\
    \ arr) 1) (abs (car arr))]\n        [else (* (prod_signs (cdr arr)) (signum (car\
    \ arr)))]))\n", "  (if (empty? arr)\n      #f\n      (let* ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map\
    \ abs arr)]\n             [sign-prod (apply * signs)]\n             [mag-sum (apply\
    \ + magnitudes)])\n        (* sign-prod mag-sum))))\n", "  (if (null? arr)\n \
    \     #f\n      (let ((signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)))\n        (apply * (map abs arr))\n        (apply * signs))))\n", "  (if\
    \ (null? arr)\n      #f\n      (let ((signs (map (lambda (x) (if (zero? x) 0 (if\
    \ (> x 0) 1 -1))) arr)))\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (if (null? arr)\n      #f\n      (let loop ((arr arr)\n                 (prod\
    \ 1)\n                 (sum 0))\n        (if (null? arr)\n            (* sum prod)\n\
    \            (loop (cdr arr)\n                  (* prod (signum (car arr)))\n\
    \                  (+ sum (abs (car arr))))))))\n", "  (if (null? arr)\n     \
    \ #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n        (if (member 0 signs)\n            0\n            (* (apply *\
    \ signs) (apply + (map abs arr)))))))\n", "  (cond\n    [(empty? arr) #f]\n  \
    \  [(zero? (apply * (map signum arr))) 0]\n    [else (* (apply * (map signum arr))\
    \ (apply + (map abs arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(= (length\
    \ arr) 1) (abs (first arr))]\n    [else\n     (* (prod_signs (rest arr))\n   \
    \     (abs (first arr)))]))\n", "  (if (null? arr)\n      #f\n      (let ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n        (let ([prod\
    \ (apply * signs)])\n          (let ([magnitudes (map abs arr)])\n           \
    \ (apply * magnitudes))))))\n", "  (cond\n    [(empty? arr) #f]\n    [(= (length\
    \ arr) 1) (abs (first arr))]\n    [else (* (prod_signs (rest arr)) (signum (first\
    \ arr)))]))\n", "  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map\
    \ abs arr)]\n             [prod (apply * signs)]\n             [sum (apply + magnitudes)])\n\
    \        (* prod sum))))\n", "  (cond\n    [(empty? arr) #f]\n    [(= (length\
    \ arr) 1) (abs (car arr))]\n    [else\n     (* (prod_signs (cdr arr))\n      \
    \  (if (= (car arr) 0)\n            0\n            (abs (car arr))))]))\n", " \
    \ (cond\n    [(empty? arr) #f]\n    [(zero? (car arr)) 0]\n    [else (* (car arr)\
    \ (prod_signs (cdr arr)))]))\n", "  (if (null? arr)\n      #f\n      (let* ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes\
    \ (map abs arr)]\n             [sign-product (apply * signs)]\n             [magnitude-sum\
    \ (apply + magnitudes)])\n        (* sign-product magnitude-sum))))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [(equal? (length arr) 1)\n     (if (zero? (car arr))\n\
    \         0\n         (abs (car arr)))]\n    [else\n     (* (prod_signs (cdr arr))\n\
    \        (if (zero? (car arr))\n            0\n            (abs (car arr))))]))\n",
  "  (if (null? arr)\n      #f\n      (let ((signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)))\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (< x 0) -1 1))) arr)])\n        (apply * (map abs arr))\n\
    \        (apply * signs))))\n", "  (if (null? arr)\n      #f\n      (let* ([signs\
    \ (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)]\n             [prod\
    \ (apply * signs)]\n             [mags (map abs arr)])\n        (apply + (map\
    \ * mags signs)))))\n", "  (cond\n    [(empty? arr) #f]\n    [(= (length arr)\
    \ 1) (abs (car arr))]\n    [else (* (prod_signs (cdr arr)) (abs (car arr)))]))\n",
  "  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)]\n     \
    \        [sign-product (apply * signs)]\n             [magnitude-sum (apply +\
    \ magnitudes)])\n        (* sign-product magnitude-sum))))\n", "  (if (null? arr)\n\
    \      #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n        (* (apply * signs) (apply + (map abs arr))))))\n", "  (if (null?\
    \ arr)\n      #f\n      (let ((signs (map (lambda (x) (if (zero? x) 0 (if (> x\
    \ 0) 1 -1))) arr)))\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (if (null? arr)\n      #f\n      (let ((signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)))\n        (let ((magnitudes (map abs arr)))\n  \
    \        (let ((sign-product (apply * signs)))\n            (let ((magnitude-sum\
    \ (apply + magnitudes)))\n              (* sign-product magnitude-sum)))))))\n",
  "  (if (null? arr)\n      #f\n      (let loop ([arr arr] [prod 1])\n        (if\
    \ (null? arr)\n            (abs prod)\n            (loop (cdr arr) (* prod (signum\
    \ (car arr))))))))\n", "  (cond\n    [(empty? arr) #f]\n    [(= 1 (length arr))\
    \ (abs (first arr))]\n    [else\n     (* (abs (first arr))\n        (prod_signs\
    \ (rest arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(zero? (car arr))\
    \ 0]\n    [else\n     (* (abs (car arr))\n        (prod_signs (cdr arr)))]))\n",
  "  (if (null? arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x)\
    \ 0 (if (> x 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply\
    \ * signs))))\n", "  (cond [(empty? arr) #f]\n        [else (let ([signs (map\
    \ sign arr)])\n                (apply * signs)\n                (apply + (map\
    \ abs arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(= (length arr) 1) (abs\
    \ (car arr))]\n    [else\n     (* (prod_signs (cdr arr))\n        (abs (car arr)))]))\n",
  "  (if (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if (positive?\
    \ x) 1 -1)) arr)]\n             [sign-prod (apply * signs)]\n             [magnitudes\
    \ (map abs arr)])\n        (apply + (map * magnitudes signs)))))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [(zero? (apply * (map sign arr))) 0]\n    [else (*\
    \ (apply * (map sign arr)) (apply + (map abs arr)))]))\n", "  (if (null? arr)\n\
    \      #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n", "  (cond\n\
    \    [(empty? arr) #f]\n    [(= (length arr) 1) (abs (first arr))]\n    [else\
    \ (* (prod_signs (rest arr)) (signum (first arr)))]))\n", "  (if (null? arr)\n\
    \      #f\n      (let ((signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)))\n        (apply * (map abs arr))\n        (apply * signs))))\n", "  (if\
    \ (null? arr)\n      #f\n      (let ((signs (map (lambda (x) (if (zero? x) 0 (if\
    \ (> x 0) 1 -1))) arr)))\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(= 1 (length arr)) (abs (first arr))]\n  \
    \  [else (* (abs (first arr)) (prod_signs (rest arr)))]))\n", "  (cond\n    [(empty?\
    \ arr) #f]\n    [(= 0 (car arr)) 0]\n    [else (* (car arr) (prod_signs (cdr arr)))]))\n",
  "  (if (null? arr)\n      #f\n      (letrec ([signs (map (lambda (x) (if (zero?\
    \ x) 0 (if (> x 0) 1 -1))) arr)]\n               [magnitudes (map abs arr)])\n\
    \        (* (apply * signs) (apply + magnitudes)))))\n", "  (if (null? arr)\n\
    \      #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)])\n        (* (apply * signs) (apply + (map abs arr))))))\n", "  (if (null?\
    \ arr)\n      #f\n      (let ([signs (map (lambda (x) (if (zero? x) 0 (if (> x\
    \ 0) 1 -1))) arr)])\n        (apply * (map abs arr))\n        (apply * signs))))\n",
  "  (cond\n    [(empty? arr) #f]\n    [(zero? (car arr)) 0]\n    [else\n     (* (car\
    \ arr) (prod_signs (cdr arr)))]))\n", "  (if (empty? arr)\n      #f\n      (let\
    \ ([signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)])\n      \
    \  (apply * (map abs arr))\n        (apply * signs))))\n", "  (if (null? arr)\n\
    \      #f\n      (let ((signs (map (lambda (x) (if (zero? x) 0 (if (> x 0) 1 -1)))\
    \ arr)))\n        (apply * (map abs arr))\n        (apply * signs))))\n", "  (if\
    \ (null? arr)\n      #f\n      (let* ([signs (map (lambda (x) (if (zero? x) 0\
    \ (if (> x 0) 1 -1))) arr)]\n             [magnitudes (map abs arr)]\n       \
    \      [sign-prod (apply * signs)]\n             [magnitude-sum (apply + magnitudes)])\n\
    \        (* sign-prod magnitude-sum))))\n", "  (cond\n    [(empty? arr) #f]\n\
    \    [(empty? (cdr arr)) (abs (car arr))]\n    [else (* (abs (car arr)) (prod_signs\
    \ (cdr arr)))]))\n", "  (cond\n    [(empty? arr) #f]\n    [(= (length arr) 1)\
    \ (abs (car arr))]\n    [else\n     (* (abs (car arr))\n        (prod_signs (cdr\
    \ arr)))]))\n", "  (if (null? arr)\n      #f\n      (let ((signs (map (lambda\
    \ (x) (if (zero? x) 0 (if (> x 0) 1 -1))) arr)))\n        (let ((magnitudes (map\
    \ abs arr)))\n          (let ((prod (apply * signs)))\n            (apply + (map\
    \ (lambda (x) (* x prod)) magnitudes)))))))\n", "  (if (null? arr)\n      #f\n\
    \      (let* ([signs (map sign arr)]\n             [magnitudes (map abs arr)]\n\
    \             [sign-prod (apply * signs)]\n             [mag-sum (apply + magnitudes)])\n\
    \        (* sign-prod mag-sum))))\n", "  (if (null? arr)\n      #f\n      (let\
    \ ([prod (apply * (map sign arr))])\n        (if (= prod 0)\n            0\n \
    \           (* prod (apply + (map abs arr)))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
