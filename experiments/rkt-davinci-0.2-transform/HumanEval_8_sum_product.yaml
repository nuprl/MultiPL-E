name: HumanEval_8_sum_product
language: rkt
prompt: "#lang racket\n\n;; For a given list of integers, return a tuple consisting\
  \ of a sum and a product of all the integers in a list.\n;; Empty sum should be\
  \ equal to 0 and empty product should be equal to 1.\n;; >>> (sum_product (list\
  \ ))\n;; (list 0 1)\n;; >>> (sum_product (list 1 2 3 4))\n;; (list 10 24)\n(define\
  \ (sum_product numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate sum_product))\n\
  \    (check-equal? (candidate (list )) (list 0 1))\n    (check-equal? (candidate\
  \ (list 1 1 1)) (list 3 1))\n    (check-equal? (candidate (list 100 0)) (list 100\
  \ 0))\n    (check-equal? (candidate (list 3 5 7)) (list 15 105))\n    (check-equal?\
  \ (candidate (list 10)) (list 10 10))\n))\n\n(test-humaneval)"
completions: ["  (define (sum_product_iter numbers sum product)\n    (if (null? numbers)\n\
    \        (list sum product)\n        (sum_product_iter (cdr numbers) (+ sum (car\
    \ numbers)) (* product (car numbers)))))\n  (sum_product_iter numbers 0 1))\n",
  "  (list (apply + numbers)\n        (apply * numbers)))\n", "  (list (apply + numbers)\n\
    \        (apply * numbers)))\n", "  (define (sum_product_iter sum product numbers)\n\
    \    (if (null? numbers)\n        (list sum product)\n        (sum_product_iter\
    \ (+ sum (car numbers)) (* product (car numbers)) (cdr numbers))))\n  (sum_product_iter\
    \ 0 1 numbers))\n", "  (list (apply + numbers)\n        (apply * numbers)))\n",
  "  (define (sum_product_iter numbers sum product)\n    (cond\n      [(empty? numbers)\
    \ (list sum product)]\n      [else (sum_product_iter (rest numbers) (+ sum (first\
    \ numbers)) (* product (first numbers)))]))\n  (sum_product_iter numbers 0 1))\n",
  "  (define (sum_product_iter numbers sum product)\n    (if (null? numbers)\n   \
    \     (list sum product)\n        (sum_product_iter (cdr numbers) (+ sum (car\
    \ numbers)) (* product (car numbers)))))\n  (sum_product_iter numbers 0 1))\n",
  "  (define (sum_product_iter numbers sum product)\n    (if (null? numbers)\n   \
    \     (list sum product)\n        (sum_product_iter (cdr numbers) (+ sum (car\
    \ numbers)) (* product (car numbers)))))\n  (sum_product_iter numbers 0 1))\n",
  "  (define (sum_product_helper numbers sum product)\n    (if (null? numbers)\n \
    \       (list sum product)\n        (sum_product_helper (cdr numbers) (+ sum (car\
    \ numbers)) (* product (car numbers)))))\n  (sum_product_helper numbers 0 1))\n",
  "  (list (apply + numbers) (apply * numbers)))\n", "  (list (apply + numbers)\n\
    \        (apply * numbers)))\n", "  (list (apply + numbers)\n        (apply *\
    \ numbers)))\n", "  (list (apply + numbers)\n        (apply * numbers)))\n", " \
    \ (define (sum_product_iter numbers sum product)\n    (if (null? numbers)\n  \
    \      (list sum product)\n        (sum_product_iter (cdr numbers) (+ sum (car\
    \ numbers)) (* product (car numbers)))))\n  (sum_product_iter numbers 0 1))\n",
  "  (list (apply + numbers) (apply * numbers)))\n", "  (let* ([sum (apply + numbers)]\n\
    \         [product (apply * numbers)])\n    (list sum product)))\n", "  (define\
    \ (sum_product_iter sum product numbers)\n    (cond [(empty? numbers) (list sum\
    \ product)]\n          [else (sum_product_iter (+ sum (first numbers)) (* product\
    \ (first numbers)) (rest numbers))]))\n  (sum_product_iter 0 1 numbers))\n", " \
    \ (list (apply + numbers)\n        (apply * numbers)))\n", "  (define (sum_product_iter\
    \ numbers sum product)\n    (if (null? numbers)\n        (list sum product)\n\
    \        (sum_product_iter (cdr numbers) (+ sum (car numbers)) (* product (car\
    \ numbers)))))\n  (sum_product_iter numbers 0 1))\n", "  (list (apply + numbers)\n\
    \        (apply * numbers)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
