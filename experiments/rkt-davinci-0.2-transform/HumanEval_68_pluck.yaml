name: HumanEval_68_pluck
language: rkt
prompt: "#lang racket\n\n;; \"Given an array representing a branch of a tree that\
  \ has non-negative integer nodes\n;; your task is to pluck one of the nodes and\
  \ return it.\n;; The plucked node should be the node with the smallest even value.\n\
  ;; If multiple nodes with the same smallest even value are found return the node\
  \ that has smallest index.\n;; The plucked node should be returned in a list, [\
  \ smalest_value, its index ],\n;; If there are no even values or the given array\
  \ is empty, return [].\n;; Example 1:\n;; >>> (pluck (list 4 2 3))\n;; (list 2 1)\n\
  ;; Explanation: 2 has the smallest even value, and 2 has the smallest index.\n;;\
  \ Example 2:\n;; >>> (pluck (list 1 2 3))\n;; (list 2 1)\n;; Explanation: 2 has\
  \ the smallest even value, and 2 has the smallest index.\n;; Example 3:\n;; >>>\
  \ (pluck (list ))\n;; (list )\n;; Example 4:\n;; >>> (pluck (list 5 0 3 0 4 2))\n\
  ;; (list 0 1)\n;; Explanation: 0 is the smallest value, but  there are two zeros,\n\
  ;; so we will choose the first zero, which has the smallest index.\n;; Constraints:\n\
  ;; * 1 <= nodes.length <= 10000\n;; * 0 <= node.value\n(define (pluck arr)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pluck))\n\
  \    (check-equal? (candidate (list 4 2 3)) (list 2 1))\n    (check-equal? (candidate\
  \ (list 1 2 3)) (list 2 1))\n    (check-equal? (candidate (list )) (list ))\n  \
  \  (check-equal? (candidate (list 5 0 3 0 4 2)) (list 0 1))\n    (check-equal? (candidate\
  \ (list 1 2 3 0 5 3)) (list 0 3))\n    (check-equal? (candidate (list 5 4 8 4 8))\
  \ (list 4 1))\n    (check-equal? (candidate (list 7 6 7 1)) (list 6 1))\n    (check-equal?\
  \ (candidate (list 7 9 7 1)) (list ))\n))\n\n(test-humaneval)"
completions: ["  (cond [(empty? arr) (list)]\n        [(even? (first arr)) (list (first\
    \ arr) 0)]\n        [else (pluck (rest arr))]))\n", "  (cond\n    [(empty? arr)\
    \ (list)]\n    [(even? (first arr)) (list (first arr) 0)]\n    [else (pluck (rest\
    \ arr))]))\n", "  (cond\n    [(empty? arr) (list)]\n    [(even? (first arr)) (list\
    \ (first arr) 0)]\n    [else (pluck (rest arr))]))\n", "  (if (null? arr)\n  \
    \    (list)\n      (let ([evens (filter even? arr)])\n        (if (null? evens)\n\
    \            (list)\n            (let ([min-even (apply min evens)])\n       \
    \       (list min-even (index arr min-even)))))))\n", "  (if (empty? arr)\n  \
    \    (list)\n      (let ([evens (filter even? arr)])\n        (if (empty? evens)\n\
    \            (list)\n            (let ([min-even (apply min evens)])\n       \
    \       (list min-even (index-of min-even arr)))))))\n", "  (cond\n    [(empty?\
    \ arr) empty]\n    [(even? (first arr))\n     (let ([min-even (first arr)])\n\
    \       (for/fold ([min-even-index 0]) ([i (in-naturals)])\n         (if (and\
    \ (even? (list-ref arr i))\n                  (< (list-ref arr i) min-even))\n\
    \             (values (list-ref arr i) i)\n             (values min-even min-even-index)))]\n\
    \       (list min-even min-even-index))]\n    [else (pluck (rest arr))]))\n",
  "  (if (empty? arr)\n      (list)\n      (let* ([evens (filter even? arr)]\n   \
    \          [min-even (apply min evens)]\n             [min-even-index (index-of\
    \ min-even arr)])\n        (list min-even min-even-index))))\n", "  (cond\n  \
    \  [(empty? arr) (list)]\n    [(even? (first arr)) (list (first arr) 0)]\n   \
    \ [else (pluck (rest arr))]))\n", "  (cond [(empty? arr) empty]\n        [(even?\
    \ (first arr)) (list (first arr) 1)]\n        [else (pluck (rest arr))]))\n",
  "  (let ([evens (filter even? arr)])\n    (if (empty? evens)\n        (list)\n \
    \       (let ([min-even (apply min evens)])\n          (list min-even (index-of\
    \ min-even arr))))))\n", "  (if (empty? arr)\n      (list)\n      (let* ([evens\
    \ (filter even? arr)]\n             [min-even (apply min evens)]\n           \
    \  [min-even-index (index-of min-even arr)])\n        (list min-even min-even-index))))\n",
  "  (cond\n    [(empty? arr) empty]\n    [(even? (first arr)) (list (first arr) 0)]\n\
    \    [else (pluck (rest arr))]))\n", "  (cond [(empty? arr) (list)]\n        [(even?\
    \ (first arr)) (list (first arr) 0)]\n        [else (pluck (rest arr))]))\n",
  "  (cond\n    [(empty? arr) (list)]\n    [(even? (first arr)) (list (first arr)\
    \ 0)]\n    [else (pluck (rest arr))]))\n", "  (cond\n    [(empty? arr) (list)]\n\
    \    [(even? (first arr)) (list (first arr) 0)]\n    [else (pluck (rest arr))]))\n",
  "  (if (empty? arr)\n      (list)\n      (let ([evens (filter even? arr)])\n   \
    \     (if (empty? evens)\n            (list)\n            (let ([min-even (apply\
    \ min evens)])\n              (list min-even (index-of min-even arr)))))))\n",
  "  (cond [(empty? arr) empty]\n        [(even? (first arr)) (list (first arr) 0)]\n\
    \        [else (pluck (rest arr))]))\n", "  (cond\n    [(empty? arr) (list)]\n\
    \    [(even? (first arr)) (list (first arr) 0)]\n    [else (pluck (rest arr))]))\n",
  "  (cond\n    [(empty? arr) (list)]\n    [(even? (first arr)) (list (first arr)\
    \ 0)]\n    [else (pluck (rest arr))]))\n", "  (if (empty? arr)\n      '()\n  \
    \    (let* ([evens (filter even? arr)]\n             [min-even (apply min evens)])\n\
    \        (if (empty? evens)\n            '()\n            (list min-even\n   \
    \               (index-of min-even arr))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
