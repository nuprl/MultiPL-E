name: HumanEval_90_next_smallest
language: rkt
prompt: "#lang racket\n\n;; You are given a list of integers.\n;; Write a function\
  \ next_smallest() that returns the 2nd smallest element of the list.\n;; Return\
  \ None if there is no such element.\n;; >>> (next_smallest (list 1 2 3 4 5))\n;;\
  \ 2\n;; >>> (next_smallest (list 5 1 4 3 2))\n;; 2\n;; >>> (next_smallest (list\
  \ ))\n;; #f\n;; >>> (next_smallest (list 1 1))\n;; #f\n(define (next_smallest lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate next_smallest))\n\
  \    (check-equal? (candidate (list 1 2 3 4 5)) 2)\n    (check-equal? (candidate\
  \ (list 5 1 4 3 2)) 2)\n    (check-equal? (candidate (list )) #f)\n    (check-equal?\
  \ (candidate (list 1 1)) #f)\n    (check-equal? (candidate (list 1 1 1 1 0)) 1)\n\
  \    (check-equal? (candidate (list 1 1)) #f)\n    (check-equal? (candidate (list\
  \ -35 34 12 -45)) -35)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n\
    \     (let ([min (min (first lst) (second lst))]\n           [max (max (first\
    \ lst) (second lst))])\n       (for/fold ([min min] [max max]) ([x (in-list (rest\
    \ (rest lst)))])\n         (cond\n           [(< x min) (values x max)]\n    \
    \       [(< x max) (values min x)]\n           [else (values min max)])))]))\n",
  "  (define (next_smallest-helper lst smallest second-smallest)\n    (cond\n    \
    \  [(empty? lst) second-smallest]\n      [(< (first lst) smallest) (next_smallest-helper\
    \ (rest lst) (first lst) smallest)]\n      [(< (first lst) second-smallest) (next_smallest-helper\
    \ (rest lst) smallest (first lst))]\n      [else (next_smallest-helper (rest lst)\
    \ smallest second-smallest)]))\n  (next_smallest-helper lst (first lst) (first\
    \ lst)))\n", "  (cond\n    [(empty? lst) #f]\n    [(= (length lst) 1) #f]\n  \
    \  [(= (length lst) 2)\n     (if (= (first lst) (second lst))\n         #f\n \
    \        (second lst))]\n    [else\n     (let ([sorted (sort lst <)])\n      \
    \ (if (= (first sorted) (second sorted))\n           #f\n           (second sorted)))]))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let\
    \ ([min (min (first lst) (second lst))]\n           [max (max (first lst) (second\
    \ lst))])\n       (for/fold ([min min] [max max]) ([x (in-list (rest (rest lst)))])\n\
    \         (cond\n           [(< x min) (values x max)]\n           [(< x max)\
    \ (values min x)]\n           [else (values min max)])))]))\n", "  (cond\n   \
    \ [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let*\n   \
    \      ([min (apply min lst)]\n          [min-index (index-of min lst)]\n    \
    \      [min-index-2 (index-of min (remove-at min-index lst))]\n          [min-2\
    \ (list-ref lst min-index-2)])\n       min-2)]))\n", "  (cond\n    [(empty? lst)\
    \ #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let ([min (apply min lst)])\n\
    \       (cond\n         [(= min (car lst)) (next_smallest (rest lst))]\n     \
    \    [else min]))]))\n", "  (if (null? lst)\n      #f\n      (let ([sorted (sort\
    \ lst <)])\n        (if (null? (cdr sorted))\n            #f\n            (car\
    \ (cdr sorted))))))\n", "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst))\
    \ #f]\n    [else\n     (let ([min (min (first lst) (second lst))]\n          \
    \ [max (max (first lst) (second lst))])\n       (for/fold ([min min] [max max])\
    \ ([x (in-list (rest (rest lst)))])\n         (cond\n           [(< x min) (values\
    \ x max)]\n           [(< x max) (values min x)]\n           [else (values min\
    \ max)])))]))\n", "  (if (null? lst)\n      #f\n      (let ([min (apply min lst)]\n\
    \            [min2 (apply min (filter (lambda (x) (not (= x min))) lst))])\n \
    \       (if (= min min2)\n            #f\n            min2))))\n", "  (if (null?\
    \ lst)\n      #f\n      (let ([sorted (sort lst <)])\n        (if (null? (cdr\
    \ sorted))\n            #f\n            (cadr sorted)))))\n", "  (if (null? lst)\n\
    \      #f\n      (let* ([sorted (sort lst <)]\n             [min (car sorted)]\n\
    \             [rest (cdr sorted)])\n        (if (null? rest)\n            #f\n\
    \            (let ([second-min (car rest)])\n              (if (equal? min second-min)\n\
    \                  #f\n                  second-min))))))\n", "  (define (next_smallest-helper\
    \ lst smallest)\n    (cond\n      [(empty? lst) #f]\n      [(= (first lst) smallest)\
    \ (next_smallest-helper (rest lst) smallest)]\n      [(< (first lst) smallest)\
    \ (next_smallest-helper (rest lst) (first lst))]\n      [else (next_smallest-helper\
    \ (rest lst) smallest)]))\n  (next_smallest-helper (rest lst) (first lst)))\n",
  "  (if (null? lst)\n      #f\n      (let ([sorted (sort lst <)])\n        (if (null?\
    \ (cdr sorted))\n            #f\n            (cadr sorted)))))\n", "  (cond\n\
    \    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else (apply min (rest\
    \ lst))]))\n", "  (if (null? lst)\n      #f\n      (let ([sorted (sort lst <)])\n\
    \        (if (null? (cdr sorted))\n            #f\n            (cadr sorted)))))\n",
  "  (cond\n    [(empty? lst) #f]\n    [(empty? (rest lst)) #f]\n    [else (next_smallest-helper\
    \ lst (first lst) (first (rest lst)))]))\n", "  (define (next_smallest-iter lst\
    \ smallest second-smallest)\n    (cond\n      [(empty? lst) second-smallest]\n\
    \      [(< (first lst) smallest) (next_smallest-iter (rest lst) (first lst) smallest)]\n\
    \      [(< (first lst) second-smallest) (next_smallest-iter (rest lst) smallest\
    \ (first lst))]\n      [else (next_smallest-iter (rest lst) smallest second-smallest)]))\n\
    \  (next_smallest-iter lst (first lst) (first lst)))\n", "  (if (null? lst)\n\
    \      #f\n      (let ([min (apply min lst)]\n            [min-index (index-of\
    \ min lst)])\n        (if (null? (cdr (drop min-index lst)))\n            #f\n\
    \            (apply min (cdr (drop min-index lst)))))))\n", "  (cond\n    [(empty?\
    \ lst) #f]\n    [(empty? (rest lst)) #f]\n    [else\n     (let*\n         ([min\
    \ (apply min lst)]\n          [min-index (index-of min lst)]\n          [lst-without-min\
    \ (remove-at min-index lst)]\n          [min2 (apply min lst-without-min)])\n\
    \       min2)]))\n", "  (if (null? lst)\n      #f\n      (let ([min (apply min\
    \ lst)]\n            [min-index (index-of min lst)])\n        (if (null? (cdr\
    \ (cdr lst)))\n            #f\n            (let ([lst-without-min (remove min\
    \ lst)])\n              (apply min lst-without-min))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
