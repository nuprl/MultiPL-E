name: HumanEval_134_check_if_last_char_is_a_letter
language: rkt
prompt: "#lang racket\n\n;; Create a function that returns True if the last character\n\
  ;; of a given string is an alphabetical character and is not\n;; a part of a word,\
  \ and False otherwise.\n;; Note: \"word\" is a group of characters separated by\
  \ space.\n;; Examples:\n;; >>> (check_if_last_char_is_a_letter \"apple pie\")\n\
  ;; #f\n;; >>> (check_if_last_char_is_a_letter \"apple pi e\")\n;; #t\n;; >>> (check_if_last_char_is_a_letter\
  \ \"apple pi e \")\n;; #f\n;; >>> (check_if_last_char_is_a_letter \"\")\n;; #f\n\
  (define (check_if_last_char_is_a_letter txt)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_if_last_char_is_a_letter))\n\
  \    (check-equal? (candidate \"apple\") #f)\n    (check-equal? (candidate \"apple\
  \ pi e\") #t)\n    (check-equal? (candidate \"eeeee\") #f)\n    (check-equal? (candidate\
  \ \"A\") #t)\n    (check-equal? (candidate \"Pumpkin pie \") #f)\n    (check-equal?\
  \ (candidate \"Pumpkin pie 1\") #f)\n    (check-equal? (candidate \"\") #f)\n  \
  \  (check-equal? (candidate \"eeeee e \") #f)\n    (check-equal? (candidate \"apple\
  \ pie\") #f)\n    (check-equal? (candidate \"apple pi e \") #f)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? txt) #f]\n    [(and (char-alphabetic? (last-char\
    \ txt)) (not (char-alphabetic? (last-char (string-drop-right txt 1))))) #t]\n\
    \    [else #f]))\n", "  (let ([last-char (string-ref txt (sub1 (string-length\
    \ txt)))])\n    (and (char-alphabetic? last-char)\n         (not (member last-char\
    \ '(\"a\" \"e\" \"i\" \"o\" \"u\" \"A\" \"E\" \"I\" \"O\" \"U\"))))))\n", "  (if\
    \ (string=? txt \"\")\n      #f\n      (if (char-alphabetic? (string-ref txt (-\
    \ (string-length txt) 1)))\n          (if (char-alphabetic? (string-ref txt (-\
    \ (string-length txt) 2)))\n              #f\n              #t)\n          #f)))\n",
  "  (if (string=? txt \"\")\n      #f\n      (if (string=? (substring txt -1) \"\
    \ \")\n          #f\n          (if (char-alphabetic? (string-ref txt (- (string-length\
    \ txt) 1)))\n              #t\n              #f))))\n", "  (cond\n    [(string=?\
    \ txt \"\") #f]\n    [(string=? (substring txt -1) \" \") #f]\n    [(char-alphabetic?\
    \ (string-ref txt -1)) #t]\n    [else #f]))\n", "  (let ([last-char (string-ref\
    \ txt (sub1 (string-length txt)))])\n    (and (char-alphabetic? last-char)\n \
    \        (not (char-whitespace? last-char)))))\n", "  (let ([last-char (string-ref\
    \ txt (sub1 (string-length txt)))])\n    (and (char-alphabetic? last-char)\n \
    \        (not (char-whitespace? last-char)))))\n", "  (if (empty? txt)\n     \
    \ #f\n      (if (char-alphabetic? (last-char txt))\n          (if (char-whitespace?\
    \ (last-char (substring txt 0 (- (string-length txt) 1))))\n              #t\n\
    \              #f)\n          #f)))\n", "  (let ([last-char (string-ref txt (sub1\
    \ (string-length txt)))])\n    (and (char-alphabetic? last-char)\n         (not\
    \ (char-whitespace? last-char)))))\n", "  (if (string=? txt \"\")\n      #f\n\
    \      (let ((last-char (string-ref txt (- (string-length txt) 1))))\n       \
    \ (and (char-alphabetic? last-char)\n             (not (char-whitespace? last-char))))))\n",
  "  (cond\n    [(empty? txt) #f]\n    [(char-alphabetic? (last-char txt))\n     (if\
    \ (char-whitespace? (last-char (butlast txt)))\n         #t\n         #f)]\n \
    \   [else #f]))\n", "  (and (not (empty? txt))\n       (char-alphabetic? (last-char\
    \ txt))\n       (not (char-whitespace? (last-char txt)))\n       (not (char-word?\
    \ (last-char txt)))))\n", "  (and (not (empty? txt))\n       (char-alphabetic?\
    \ (last-char txt))\n       (not (char-alphabetic? (last-char (string-drop-right\
    \ txt 1))))))\n", "  (if (string=? txt \"\")\n      #f\n      (if (char-alphabetic?\
    \ (string-ref txt (- (string-length txt) 1)))\n          (if (char-whitespace?\
    \ (string-ref txt (- (string-length txt) 2)))\n              #t\n            \
    \  #f)\n          #f)))\n", "  (if (string=? \"\" txt)\n      #f\n      (let ([last-char\
    \ (string-ref txt (- (string-length txt) 1))])\n        (and (char-alphabetic?\
    \ last-char)\n             (not (char-whitespace? last-char))))))\n", "  (cond\n\
    \    [(empty? txt) #f]\n    [(and (char-alphabetic? (last-char txt))\n       \
    \   (not (char-alphabetic? (last-char (butlast txt))))) #t]\n    [else #f]))\n",
  "  (let ((last-char (string-ref txt (- (string-length txt) 1))))\n    (and (char-alphabetic?\
    \ last-char)\n         (not (char-whitespace? last-char)))))\n", "  (cond\n  \
    \  [(empty? txt) #f]\n    [(char-alphabetic? (last-char txt))\n     (if (char-whitespace?\
    \ (second-last-char txt))\n         #t\n         #f)]\n    [else #f]))\n", " \
    \ (cond\n    [(empty? txt) #f]\n    [(char-alphabetic? (last-char txt))\n    \
    \ (if (char-alphabetic? (last-char (substring txt 0 (- (string-length txt) 1))))\n\
    \         #f\n         #t)]\n    [else #f]))\n", "  (let ([last-char (string-ref\
    \ txt (sub1 (string-length txt)))])\n    (and (char-alphabetic? last-char)\n \
    \        (not (char-whitespace? last-char)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
