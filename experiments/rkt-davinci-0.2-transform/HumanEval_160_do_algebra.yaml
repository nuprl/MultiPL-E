name: HumanEval_160_do_algebra
language: rkt
prompt: "#lang racket\n\n;; Given two lists operator, and operand. The first list\
  \ has basic algebra operations, and \n;; the second list is a list of integers.\
  \ Use the two given lists to build the algebric \n;; expression and return the evaluation\
  \ of this expression.\n;; The basic algebra operations:\n;; Addition ( + ) \n;;\
  \ Subtraction ( - ) \n;; Multiplication ( * ) \n;; Floor division ( // ) \n;; Exponentiation\
  \ ( ** ) \n;; Example:\n;; operator['+', '*', '-']\n;; array = [2, 3, 4, 5]\n;;\
  \ result = 2 + 3 * 4 - 5\n;; => result = 9\n;; Note:\n;; The length of operator\
  \ list is equal to the length of operand list minus one.\n;; Operand is a list of\
  \ of non-negative integers.\n;; Operator list has at least one operator, and operand\
  \ list has at least two operands.\n(define (do_algebra operator operand)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate do_algebra))\n\
  \    (check-equal? (candidate (list \"**\" \"*\" \"+\") (list 2 3 4 5)) 37)\n  \
  \  (check-equal? (candidate (list \"+\" \"*\" \"-\") (list 2 3 4 5)) 9)\n    (check-equal?\
  \ (candidate (list \"//\" \"*\") (list 7 3 4)) 8)\n))\n\n(test-humaneval)"
completions: ["  (define (do_algebra_helper operator operand result)\n    (if (null?\
    \ operator)\n        result\n        (do_algebra_helper (cdr operator) (cdr operand)\n\
    \                           (cond\n                             ((equal? (car\
    \ operator) '+) (+ result (car operand)))\n                             ((equal?\
    \ (car operator) '-) (- result (car operand)))\n                             ((equal?\
    \ (car operator) '*) (* result (car operand)))\n                             ((equal?\
    \ (car operator) '//) (quotient result (car operand)))\n                     \
    \        ((equal? (car operator) '**) (expt result (car operand)))))))\n  (do_algebra_helper\
    \ operator operand (car operand)))\n", "  (let loop ([op operator] [opd operand]\
    \ [result (car opd)])\n    (cond [(empty? op) result]\n          [else (loop (cdr\
    \ op) (cdr opd)\n                      (cond [(equal? (car op) '+) (+ result (car\
    \ opd))]\n                            [(equal? (car op) '-) (- result (car opd))]\n\
    \                            [(equal? (car op) '*) (* result (car opd))]\n   \
    \                         [(equal? (car op) '//) (quotient result (car opd))]\n\
    \                            [(equal? (car op) '**) (expt result (car opd))]))])))\n",
  "  (let loop ([op operator] [opd operand] [acc (car opd)])\n    (if (null? op)\n\
    \        acc\n        (loop (cdr op) (cdr opd)\n              (cond\n        \
    \        [(equal? (car op) '+) (+ acc (car opd))]\n                [(equal? (car\
    \ op) '-) (- acc (car opd))]\n                [(equal? (car op) '*) (* acc (car\
    \ opd))]\n                [(equal? (car op) '//) (quotient acc (car opd))]\n \
    \               [(equal? (car op) '**) (expt acc (car opd))])))))\n", "  (define\
    \ (helper opers operands)\n    (cond [(empty? opers) (first operands)]\n     \
    \     [(empty? (rest operands)) (first operands)]\n          [else (helper (rest\
    \ opers) (cons (eval (list (first operands) (first opers) (second operands)))\
    \ (rest (rest operands))))]))\n  (helper operator operand))\n", "  (let loop ([operator\
    \ operator] [operand operand] [result (car operand)])\n    (cond [(empty? operator)\
    \ result]\n          [else (loop (cdr operator) (cdr operand)\n              \
    \        (cond [(equal? (car operator) '+) (+ result (car operand))]\n       \
    \                     [(equal? (car operator) '-) (- result (car operand))]\n\
    \                            [(equal? (car operator) '*) (* result (car operand))]\n\
    \                            [(equal? (car operator) '//) (quotient result (car\
    \ operand))]\n                            [(equal? (car operator) '**) (expt result\
    \ (car operand))]))])))\n", "  (cond\n    [(empty? operator) (car operand)]\n\
    \    [else (do_algebra (cdr operator) (cons (eval (list (car operand) (car operator)\
    \ (cadr operand))) (cddr operand)))]))\n", "  (cond\n    [(null? operator) (car\
    \ operand)]\n    [(= (length operator) 1) (eval (list (car operand) (car operator)\
    \ (cadr operand)))]\n    [else (eval (list (car operand) (car operator) (do_algebra\
    \ (cdr operator) (cdr operand))))]))\n", "  (let loop ([operator operator] [operand\
    \ operand] [result (car operand)])\n    (if (null? operator)\n        result\n\
    \        (loop (cdr operator) (cdr operand)\n              (match (car operator)\n\
    \                ['+ ( + result (car operand))]\n                ['* ( * result\
    \ (car operand))]\n                ['** (expt result (car operand))]\n       \
    \         ['// (quotient result (car operand))]\n                ['- ( - result\
    \ (car operand))])))))\n", "  (if (null? operator)\n      (car operand)\n    \
    \  (let* ([op (car operator)]\n             [op1 (car operand)]\n            \
    \ [op2 (cadr operand)])\n        (cond\n         ((equal? op '+) (+ op1 op2))\n\
    \         ((equal? op '-) (- op1 op2))\n         ((equal? op '*) (* op1 op2))\n\
    \         ((equal? op '//) (quotient op1 op2))\n         ((equal? op '**) (expt\
    \ op1 op2))))))\n", "  (define (do_algebra_helper operator operand result)\n \
    \   (cond\n      [(empty? operator) result]\n      [else (do_algebra_helper (rest\
    \ operator) (rest operand)\n                               (cond\n           \
    \                      [(equal? (first operator) '+) (+ result (first operand))]\n\
    \                                 [(equal? (first operator) '-) (- result (first\
    \ operand))]\n                                 [(equal? (first operator) '*) (*\
    \ result (first operand))]\n                                 [(equal? (first operator)\
    \ '//) (quotient result (first operand))]\n                                 [(equal?\
    \ (first operator) '**) (expt result (first operand))]))]))\n  (do_algebra_helper\
    \ operator operand (first operand)))\n", "  (let loop ([operator operator] [operand\
    \ operand] [result (car operand)])\n    (if (null? operator)\n        result\n\
    \        (loop (cdr operator) (cdr operand)\n              (match (car operator)\n\
    \                ['+ (+ result (car operand))]\n                ['* (* result\
    \ (car operand))]\n                ['** (expt result (car operand))]\n       \
    \         ['/ (/ result (car operand))]\n                ['- (- result (car operand))])))))\n",
  "  (let loop ([op operator] [opd operand] [acc (car opd)])\n    (if (null? op)\n\
    \        acc\n        (loop (cdr op) (cdr opd)\n              (match (car op)\n\
    \                ['+ (+ acc (car opd))]\n                ['* (* acc (car opd))]\n\
    \                ['** (expt acc (car opd))]\n                ['/ (/ acc (car opd))]\n\
    \                ['- (- acc (car opd))])))))\n", "  (define (do_algebra_iter operator\
    \ operand result)\n    (if (null? operator)\n        result\n        (do_algebra_iter\
    \ (cdr operator) (cdr operand)\n                         (cond\n             \
    \              ((equal? (car operator) '+) (+ result (car operand)))\n       \
    \                    ((equal? (car operator) '-) (- result (car operand)))\n \
    \                          ((equal? (car operator) '*) (* result (car operand)))\n\
    \                           ((equal? (car operator) '//) (quotient result (car\
    \ operand)))\n                           ((equal? (car operator) '**) (expt result\
    \ (car operand)))))))\n  (do_algebra_iter operator operand (car operand)))\n",
  "  (let ((result (car operand)))\n    (for ((op (in-list operator))\n          (opd\
    \ (in-list (cdr operand))))\n      (set! result (case op\n                   \
    \  ((+ - * // **) (eval `(,op ,result ,opd)))\n                     (else (error\
    \ \"Unknown operator\"))))\n      )\n    result))\n", "  (let loop ([operator\
    \ operator] [operand operand] [result (car operand)])\n    (if (null? operator)\n\
    \        result\n        (loop (cdr operator) (cdr operand)\n              (cond\n\
    \                [(equal? (car operator) '+) (+ result (car operand))]\n     \
    \           [(equal? (car operator) '-) (- result (car operand))]\n          \
    \      [(equal? (car operator) '*) (* result (car operand))]\n               \
    \ [(equal? (car operator) '//) (quotient result (car operand))]\n            \
    \    [(equal? (car operator) '**) (expt result (car operand))])))))\n", "  (define\
    \ (do_op op1 op2 op)\n    (cond\n      [(eq? op '+) (+ op1 op2)]\n      [(eq?\
    \ op '-) (- op1 op2)]\n      [(eq? op '*) (* op1 op2)]\n      [(eq? op '//) (quotient\
    \ op1 op2)]\n      [(eq? op '**) (expt op1 op2)]))\n  (define (do_ops ops op)\n\
    \    (cond\n      [(empty? ops) 0]\n      [(empty? (rest ops)) (first ops)]\n\
    \      [else (do_op (first ops) (do_ops (rest ops) op) op)]))\n  (do_ops operand\
    \ (first operator)))\n", "  (let loop ([operator operator] [operand operand] [result\
    \ (car operand)])\n    (if (null? operator)\n        result\n        (loop (cdr\
    \ operator) (cdr operand)\n              (match (car operator)\n             \
    \   ['+ (+ result (car operand))]\n                ['* (* result (car operand))]\n\
    \                ['** (expt result (car operand))]\n                ['/ (/ result\
    \ (car operand))]\n                ['- (- result (car operand))])))))\n", "  (let\
    \ loop ((operator operator)\n             (operand operand)\n             (result\
    \ (car operand)))\n    (if (null? operator)\n        result\n        (loop (cdr\
    \ operator)\n              (cdr operand)\n              (cond ((equal? (car operator)\
    \ '+)\n                     (+ result (car operand)))\n                    ((equal?\
    \ (car operator) '-)\n                     (- result (car operand)))\n       \
    \             ((equal? (car operator) '*)\n                     (* result (car\
    \ operand)))\n                    ((equal? (car operator) '//)\n             \
    \        (quotient result (car operand)))\n                    ((equal? (car operator)\
    \ '**)\n                     (expt result (car operand))))))))\n", "  (define\
    \ (do_algebra_iter operator operand result)\n    (cond\n      [(empty? operator)\
    \ result]\n      [else (do_algebra_iter (rest operator) (rest operand)\n     \
    \                        (match (first operator)\n                           \
    \    ['+ (+ result (first operand))]\n                               ['* (* result\
    \ (first operand))]\n                               ['- (- result (first operand))]\n\
    \                               ['// (quotient result (first operand))]\n    \
    \                           ['** (expt result (first operand))]))]))\n  (do_algebra_iter\
    \ operator operand (first operand)))\n", "  (letrec ([eval-op (lambda (op1 op2\
    \ op)\n                      (cond [(eq? op '+) (+ op1 op2)]\n               \
    \             [(eq? op '-) (- op1 op2)]\n                            [(eq? op\
    \ '*) (* op1 op2)]\n                            [(eq? op '//) (quotient op1 op2)]\n\
    \                            [(eq? op '**) (expt op1 op2)]))]\n           [eval-ops\
    \ (lambda (ops ops2)\n                       (if (null? ops2)\n              \
    \             (car ops)\n                           (eval-ops (eval-op (car ops)\
    \ (car ops2) (car operator)) (cdr ops2))))])\n    (eval-ops (car operand) (cdr\
    \ operand))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
