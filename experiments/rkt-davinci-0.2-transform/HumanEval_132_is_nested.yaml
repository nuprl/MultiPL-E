name: HumanEval_132_is_nested
language: rkt
prompt: "#lang racket\n\n;; Create a function that takes a string as input which contains\
  \ only square brackets.\n;; The function should return True if and only if there\
  \ is a valid subsequence of brackets \n;; where at least one bracket in the subsequence\
  \ is nested.\n;; >>> (is_nested \"[[]]\")\n;; #t\n;; >>> (is_nested \"[]]]]]]][[[[[]\"\
  )\n;; #f\n;; >>> (is_nested \"[][]\")\n;; #f\n;; >>> (is_nested \"[]\")\n;; #f\n\
  ;; >>> (is_nested \"[[][]]\")\n;; #t\n;; >>> (is_nested \"[[]][[\")\n;; #t\n(define\
  \ (is_nested string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_nested))\n\
  \    (check-equal? (candidate \"[[]]\") #t)\n    (check-equal? (candidate \"[]]]]]]][[[[[]\"\
  ) #f)\n    (check-equal? (candidate \"[][]\") #f)\n    (check-equal? (candidate\
  \ \"[]\") #f)\n    (check-equal? (candidate \"[[[[]]]]\") #t)\n    (check-equal?\
  \ (candidate \"[]]]]]]]]]]\") #f)\n    (check-equal? (candidate \"[][][[]]\") #t)\n\
  \    (check-equal? (candidate \"[[]\") #f)\n    (check-equal? (candidate \"[]]\"\
  ) #f)\n    (check-equal? (candidate \"[[]][[\") #t)\n    (check-equal? (candidate\
  \ \"[[][]]\") #t)\n    (check-equal? (candidate \"\") #f)\n    (check-equal? (candidate\
  \ \"[[[[[[[[\") #f)\n    (check-equal? (candidate \"]]]]]]]]\") #f)\n))\n\n(test-humaneval)"
completions: ["  (let loop ([string string] [count 0])\n    (cond\n      [(empty?\
    \ string)\n       (zero? count)]\n      [(equal? (first string) #\\[)\n      \
    \ (loop (rest string) (+ count 1))]\n      [(equal? (first string) #\\])\n   \
    \    (and (positive? count)\n            (loop (rest string) (- count 1)))]\n\
    \      [else\n       (loop (rest string) count)])))\n", "  (define (is_nested-helper\
    \ string stack)\n    (cond\n      [(empty? string) (empty? stack)]\n      [(equal?\
    \ (first string) \"[\") (is_nested-helper (rest string) (cons (first string) stack))]\n\
    \      [(equal? (first string) \"]\") (and (not (empty? stack)) (is_nested-helper\
    \ (rest string) (rest stack)))]))\n  (is_nested-helper string '()))\n", "  (define\
    \ (is_nested-helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n\
    \      [(char=? (first string) #\\[) (is_nested-helper (rest string) (+ count\
    \ 1))]\n      [(char=? (first string) #\\]) (and (not (zero? count)) (is_nested-helper\
    \ (rest string) (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n\
    \  (is_nested-helper string 0))\n", "  (define (is_nested-helper string)\n   \
    \ (if (empty? string)\n        #f\n        (if (equal? (first string) \"[\")\n\
    \            (if (is_nested-helper (rest string))\n                #t\n      \
    \          (if (equal? (first (rest string)) \"]\")\n                    #t\n\
    \                    #f))\n            (if (equal? (first string) \"]\")\n   \
    \             (if (is_nested-helper (rest string))\n                    #t\n \
    \                   #f)\n                (is_nested-helper (rest string))))))\n\
    \  (is_nested-helper (string->list string)))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (= count 0)]\n      [(char=?\
    \ (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n      [(char=?\
    \ (first string) #\\]) (and (not (zero? count)) (is_nested-helper (rest string)\
    \ (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (helper string count)\n    (cond\n      [(empty? string)\
    \ (if (= count 0) #t #f)]\n      [(char=? (first string) #\\[) (helper (rest string)\
    \ (+ count 1))]\n      [(char=? (first string) #\\]) (if (&gt; count 0) (helper\
    \ (rest string) (- count 1)) #f)]))\n  (helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (if (= count 0) #t #f)]\n \
    \     [(char=? (first string) #\\[) (is_nested-helper (rest string) (+ count 1))]\n\
    \      [(char=? (first string) #\\]) (if (> count 0) (is_nested-helper (rest string)\
    \ (- count 1)) #f)]\n      [else (is_nested-helper (rest string) count)]))\n \
    \ (is_nested-helper string 0))\n", "  (define (is_nested-helper string stack)\n\
    \    (cond\n      [(empty? string) (empty? stack)]\n      [(char=? (first string)\
    \ #\\[) (is_nested-helper (rest string) (cons #\\[ stack))]\n      [(char=? (first\
    \ string) #\\]) (and (not (empty? stack)) (is_nested-helper (rest string) (rest\
    \ stack)))]\n      [else (is_nested-helper (rest string) stack)]))\n  (is_nested-helper\
    \ string '()))\n", "  (let loop ([string string] [count 0])\n    (cond [(empty?\
    \ string) (zero? count)]\n          [(char=? (first string) #\\[) (loop (rest\
    \ string) (+ count 1))]\n          [(char=? (first string) #\\]) (and (positive?\
    \ count) (loop (rest string) (- count 1)))]\n          [else (loop (rest string)\
    \ count)])))\n", "  (let loop ([string string] [stack '()])\n    (cond [(empty?\
    \ string) (empty? stack)]\n          [(equal? (first string) #\\[)\n         \
    \  (loop (rest string) (cons (first string) stack))]\n          [(equal? (first\
    \ string) #\\])\n           (and (not (empty? stack))\n                (loop (rest\
    \ string) (rest stack)))]\n          [else (loop (rest string) stack)])))\n",
  "  (define (is_nested-helper string stack)\n    (cond\n      [(empty? string) (empty?\
    \ stack)]\n      [(char=? (first string) #\\[) (is_nested-helper (rest string)\
    \ (cons #\\[ stack))]\n      [(char=? (first string) #\\]) (and (not (empty? stack))\
    \ (is_nested-helper (rest string) (rest stack)))]\n      [else (is_nested-helper\
    \ (rest string) stack)]))\n  (is_nested-helper string '()))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond ((null? string) (if (= count 0) #t #f))\n         \
    \ ((= (string-length string) 1) (if (= count 1) #t #f))\n          ((string=?\
    \ (substring string 0 1) \"[\") (is_nested-helper (substring string 1) (+ count\
    \ 1)))\n          ((string=? (substring string 0 1) \"]\") (is_nested-helper (substring\
    \ string 1) (- count 1)))\n          (else (is_nested-helper (substring string\
    \ 1) count))))\n  (is_nested-helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond [(empty? string) (if (= count 0) #t #f)]\n        \
    \  [(equal? (first string) \"[\") (is_nested-helper (rest string) (+ count 1))]\n\
    \          [(equal? (first string) \"]\") (if (= count 0) #f (is_nested-helper\
    \ (rest string) (- count 1)))]))\n  (is_nested-helper string 0))\n", "  (define\
    \ (is_nested-helper string count)\n    (cond\n      [(empty? string) (zero? count)]\n\
    \      [(equal? (first string) #\\[) (is_nested-helper (rest string) (+ count\
    \ 1))]\n      [(equal? (first string) #\\]) (and (positive? count) (is_nested-helper\
    \ (rest string) (- count 1)))]\n      [else (is_nested-helper (rest string) count)]))\n\
    \  (is_nested-helper string 0))\n", "  (define (helper string)\n    (cond\n  \
    \    [(empty? string) #f]\n      [(equal? (first string) \"[\") (helper (rest\
    \ string))]\n      [(equal? (first string) \"]\") (or (helper (rest string)) (not\
    \ (empty? (rest string))))]))\n  (helper (string->list string)))\n", "  (define\
    \ (is_nested-helper string count)\n    (cond\n      [(empty? string) (= count\
    \ 0)]\n      [(string-contains? string \"[\") (is_nested-helper (substring string\
    \ 1) (+ count 1))]\n      [(string-contains? string \"]\") (is_nested-helper (substring\
    \ string 1) (- count 1))]))\n  (is_nested-helper string 0))\n", "  (define (is_nested-helper\
    \ string count)\n    (cond\n      [(empty? string) (zero? count)]\n      [(equal?\
    \ (first string) \"[\") (is_nested-helper (rest string) (+ count 1))]\n      [(equal?\
    \ (first string) \"]\") (is_nested-helper (rest string) (- count 1))]))\n  (is_nested-helper\
    \ string 0))\n", "  (define (is_nested-helper string stack)\n    (cond\n     \
    \ [(empty? string) (empty? stack)]\n      [(char=? (first string) #\\[) (is_nested-helper\
    \ (rest string) (cons #\\[ stack))]\n      [(char=? (first string) #\\]) (and\
    \ (not (empty? stack)) (is_nested-helper (rest string) (rest stack)))]\n     \
    \ [else (is_nested-helper (rest string) stack)]))\n  (is_nested-helper string\
    \ '()))\n", "  (define (is_nested-helper string count)\n    (cond\n      [(empty?\
    \ string) (if (= count 0) #t #f)]\n      [(= (first string) #\\[) (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(= (first string) #\\]) (if (&gt; count\
    \ 0) (is_nested-helper (rest string) (- count 1)) #f)]))\n  (is_nested-helper\
    \ string 0))\n</code>\n", "  (define (is_nested-helper string count)\n    (cond\n\
    \      [(empty? string) (zero? count)]\n      [(equal? (first string) \"[\") (is_nested-helper\
    \ (rest string) (+ count 1))]\n      [(equal? (first string) \"]\") (and (not\
    \ (zero? count)) (is_nested-helper (rest string) (- count 1)))]))\n  (is_nested-helper\
    \ (string-&gt;list string) 0))\n</code>\nI'm not sure if this is the most elegant\
    \ solution, but it works.\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
