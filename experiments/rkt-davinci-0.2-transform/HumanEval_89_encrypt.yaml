name: HumanEval_89_encrypt
language: rkt
prompt: "#lang racket\n\n;; Create a function encrypt that takes a string as an argument\
  \ and\n;; returns a string encrypted with the alphabet being rotated. \n;; The alphabet\
  \ should be rotated in a manner such that the letters \n;; shift down by two multiplied\
  \ to two places.\n;; For example:\n;; >>> (encrypt \"hi\")\n;; \"lm\"\n;; >>> (encrypt\
  \ \"asdfghjkl\")\n;; \"ewhjklnop\"\n;; >>> (encrypt \"gf\")\n;; \"kj\"\n;; >>> (encrypt\
  \ \"et\")\n;; \"ix\"\n(define (encrypt s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate encrypt))\n\
  \    (check-equal? (candidate \"hi\") \"lm\")\n    (check-equal? (candidate \"asdfghjkl\"\
  ) \"ewhjklnop\")\n    (check-equal? (candidate \"gf\") \"kj\")\n    (check-equal?\
  \ (candidate \"et\") \"ix\")\n    (check-equal? (candidate \"faewfawefaewg\") \"\
  jeiajeaijeiak\")\n    (check-equal? (candidate \"hellomyfriend\") \"lippsqcjvmirh\"\
  )\n    (check-equal? (candidate \"dxzdlmnilfuhmilufhlihufnmlimnufhlimnufhfucufh\"\
  ) \"hbdhpqrmpjylqmpyjlpmlyjrqpmqryjlpmqryjljygyjl\")\n    (check-equal? (candidate\
  \ \"a\") \"e\")\n))\n\n(test-humaneval)"
completions: ["  (define (rotate s)\n    (string-append (substring s 2) (substring\
    \ s 0 2)))\n  (define (encrypt-helper s)\n    (if (string=? s \"\")\n        \"\
    \"\n        (string-append (rotate s) (encrypt-helper (substring s 1)))))\n  (encrypt-helper\
    \ s))\n", "  (define (rotate-char c)\n    (define (rotate-char-helper c)\n   \
    \   (cond ((char=? c #\\a) #\\c)\n            ((char=? c #\\b) #\\d)\n       \
    \     ((char=? c #\\c) #\\e)\n            ((char=? c #\\d) #\\f)\n           \
    \ ((char=? c #\\e) #\\g)\n            ((char=? c #\\f) #\\h)\n            ((char=?\
    \ c #\\g) #\\i)\n            ((char=? c #\\h) #\\j)\n            ((char=? c #\\\
    i) #\\k)\n            ((char=? c #\\j) #\\l)\n            ((char=? c #\\k) #\\\
    m)\n            ((char=? c #\\l) #\\n)\n            ((char=? c #\\m) #\\o)\n \
    \           ((char=? c #\\n) #\\p)\n            ((char=? c #\\o) #\\q)\n     \
    \       ((char=? c #\\p) #\\r)\n            ((char=? c #\\q) #\\s)\n         \
    \   ((char=? c #\\r) #\\t)\n            ((char=? c #\\s) #\\u)\n            ((char=?\
    \ c #\\t) #\\v)\n            ((char=? c #\\u) #\\w)\n            ((char=? c #\\\
    v) #\\x)\n            ((char=? c #\\w) #\\y)\n            ((char=? c #\\x) #\\\
    z)\n            ((char=? c #\\y) #\\a)\n            ((char=? c #\\z) #\\b)))\n\
    \    (rotate-char-helper c))\n  (define (rotate-string s)\n    (cond ((string=?\
    \ s \"\") \"\")\n          (else (string-append (string (rotate-char (string-ref\
    \ s 0)))\n                               (rotate-string (substring s 1))))))\n\
    \  (rotate-string s))\n", "  (define (encrypt-helper s i)\n    (cond\n      [(empty?\
    \ s) empty]\n      [else (cons (string-ref (string-append s s) (+ i 2))\n    \
    \              (encrypt-helper (rest s) (+ i 1)))]))\n  (encrypt-helper s 0))\n",
  "  (define (rotate n s)\n    (if (zero? n)\n        s\n        (rotate (- n 1) (string-append\
    \ (substring s -1) (substring s 0 -1)))))\n  (rotate 2 s))\n", "  (define (rotate-char\
    \ c)\n    (let ([c (string-&gt;char c)])\n      (if (char&lt;=? #\\a c #\\z)\n\
    \          (char-&gt;string (char-&gt;integer c)\n                        (+ 2\
    \ (* 2 (modulo (- (char-&gt;integer c)\n                                     \
    \        (char-&gt;integer #\\a))\n                                          26))))\n\
    \          c)))\n  (string-join (map rotate-char (string-&gt;list s))\n      \
    \         \"\"))\n</code>\n", "  (let ([s (string->list s)])\n    (map (lambda\
    \ (c)\n           (let ([c (char-downcase c)])\n             (if (char-alphabetic?\
    \ c)\n                 (let ([c (+ c (* 2 2))])\n                   (if (> c 122)\n\
    \                       (char (+ (- c 122) 96))\n                       (char\
    \ c)))\n                 c)))\n         s)))\n", "  (define (rotate n s)\n   \
    \ (if (empty? s)\n        \"\"\n        (let ([c (first s)])\n          (if (char-alphabetic?\
    \ c)\n              (let ([n (modulo (+ n (char->integer c)) 26)])\n         \
    \       (if (char-lower-case? c)\n                    (integer->char (+ n (char->integer\
    \ #\\a)))\n                    (integer->char (+ n (char->integer #\\A)))))\n\
    \              c))))\n  (let ([s (string-upcase s)])\n    (string-join (map (lambda\
    \ (c) (rotate 2 c)) (string->list s)))))\n", "  (define (rotate-char c)\n    (let\
    \ ((c-num (char->integer c)))\n      (integer->char (+ c-num (* 2 2)))))\n  (string-map\
    \ rotate-char s))\n", "  (define (rotate n s)\n    (string-append (substring s\
    \ n) (substring s 0 n)))\n  (rotate (* 2 2) s))\n", "  (let ([alphabet (string->list\
    \ \"abcdefghijklmnopqrstuvwxyz\")])\n    (string-join\n     (map\n      (lambda\
    \ (c)\n        (list-ref alphabet (+ (list-index c alphabet) (* 2 2))))\n    \
    \  (string->list s)))))\n", "  (define (rotate-char c)\n    (define (rotate-char-helper\
    \ c)\n      (cond\n        [(char=? c #\\a) #\\c]\n        [(char=? c #\\b) #\\\
    d]\n        [(char=? c #\\c) #\\e]\n        [(char=? c #\\d) #\\f]\n        [(char=?\
    \ c #\\e) #\\g]\n        [(char=? c #\\f) #\\h]\n        [(char=? c #\\g) #\\\
    i]\n        [(char=? c #\\h) #\\j]\n        [(char=? c #\\i) #\\k]\n        [(char=?\
    \ c #\\j) #\\l]\n        [(char=? c #\\k) #\\m]\n        [(char=? c #\\l) #\\\
    n]\n        [(char=? c #\\m) #\\o]\n        [(char=? c #\\n) #\\p]\n        [(char=?\
    \ c #\\o) #\\q]\n        [(char=? c #\\p) #\\r]\n        [(char=? c #\\q) #\\\
    s]\n        [(char=? c #\\r) #\\t]\n        [(char=? c #\\s) #\\u]\n        [(char=?\
    \ c #\\t) #\\v]\n        [(char=? c #\\u) #\\w]\n        [(char=? c #\\v) #\\\
    x]\n        [(char=? c #\\w) #\\y]\n        [(char=? c #\\x) #\\z]\n        [(char=?\
    \ c #\\y) #\\a]\n        [(char=? c #\\z) #\\b]\n        [else c]))\n    (rotate-char-helper\
    \ c))\n  (define (rotate-string s)\n    (cond\n      [(empty? s) empty]\n    \
    \  [else (cons (rotate-char (first s)) (rotate-string (rest s)))]))\n  (rotate-string\
    \ s))\n", "  (define (encrypt-helper s)\n    (cond\n      [(empty? s) empty]\n\
    \      [else (cons (rotate-letter (first s)) (encrypt-helper (rest s)))]))\n \
    \ (list->string (encrypt-helper (string->list s))))\n", "  (define (shift-down\
    \ c)\n    (integer->char (+ c (* 2 2))))\n  (string-map shift-down s))\n", " \
    \ (define (rotate-char c)\n    (define (rotate-char-helper c)\n      (if (char=?\
    \ c #\\a)\n          #\\c\n          (if (char=? c #\\b)\n              #\\d\n\
    \              (if (char=? c #\\z)\n                  #\\b\n                 \
    \ (if (char=? c #\\y)\n                      #\\a\n                      (integer->char\
    \ (+ (char->integer c) 2)))))))\n    (rotate-char-helper c))\n  (define (encrypt-helper\
    \ s)\n    (if (empty? s)\n        empty\n        (cons (rotate-char (first s))\
    \ (encrypt-helper (rest s)))))\n  (list->string (encrypt-helper (string->list\
    \ s))))\n", "  (define (rotate n c)\n    (if (char-alphabetic? c)\n        (let\
    \ ([c (char-downcase c)])\n          (if (char-&gt;integer c)\n              (integer-&gt;char\
    \ (+ n (char-&gt;integer c)))\n              c))\n        c))\n  (define (rotate-string\
    \ s n)\n    (string-map (lambda (c) (rotate n c)) s))\n  (rotate-string s 2))\n",
  "  (define (rotate-char c)\n    (let ([c (char-downcase c)])\n      (cond\n    \
    \    [(char=? c #\\a) #\\c]\n        [(char=? c #\\b) #\\d]\n        [(char=?\
    \ c #\\c) #\\e]\n        [(char=? c #\\d) #\\f]\n        [(char=? c #\\e) #\\\
    g]\n        [(char=? c #\\f) #\\h]\n        [(char=? c #\\g) #\\i]\n        [(char=?\
    \ c #\\h) #\\j]\n        [(char=? c #\\i) #\\k]\n        [(char=? c #\\j) #\\\
    l]\n        [(char=? c #\\k) #\\m]\n        [(char=? c #\\l) #\\n]\n        [(char=?\
    \ c #\\m) #\\o]\n        [(char=? c #\\n) #\\p]\n        [(char=? c #\\o) #\\\
    q]\n        [(char=? c #\\p) #\\r]\n        [(char=? c #\\q) #\\s]\n        [(char=?\
    \ c #\\r) #\\t]\n        [(char=? c #\\s) #\\u]\n        [(char=? c #\\t) #\\\
    v]\n        [(char=? c #\\u) #\\w]\n        [(char=? c #\\v) #\\x]\n        [(char=?\
    \ c #\\w) #\\y]\n        [(char=? c #\\x) #\\z]\n        [(char=? c #\\y) #\\\
    a]\n        [(char=? c #\\z) #\\b]\n        [else c])))\n  (string-map rotate-char\
    \ s))\n", "  (define (rotate-char c)\n    (define (rotate-char-helper c)\n   \
    \   (if (char=? c #\\a)\n          #\\c\n          (if (char=? c #\\b)\n     \
    \         #\\d\n              (if (char=? c #\\c)\n                  #\\e\n  \
    \                (if (char=? c #\\d)\n                      #\\f\n           \
    \           (if (char=? c #\\e)\n                          #\\g\n            \
    \              (if (char=? c #\\f)\n                              #\\h\n     \
    \                         (if (char=? c #\\g)\n                              \
    \    #\\i\n                                  (if (char=? c #\\h)\n           \
    \                           #\\j\n                                      (if (char=?\
    \ c #\\i)\n                                          #\\k\n                  \
    \                        (if (char=? c #\\j)\n                               \
    \               #\\l\n                                              (if (char=?\
    \ c #\\k)\n                                                  #\\m\n          \
    \                                        (if (char=? c #\\l)\n               \
    \                                       #\\n\n                               \
    \                       (if (char=? c #\\m)\n                                \
    \                          #\\o\n                                            \
    \              (if (char=? c #\\n)\n                                         \
    \                     #\\p\n                                                 \
    \             (if (char=? c #\\o)\n                                          \
    \                        #\\q\n                                              \
    \                    (if (char=? c #\\p)\n                                   \
    \                                   #\\r\n                                   \
    \                                   (if (char=? c #\\q)\n                    \
    \                                                      #\\s\n                \
    \                                                          (if (char=? c #\\r)\n\
    \                                                                            \
    \  #\\t\n                                                                    \
    \          (if (char=? c #\\s)\n                                             \
    \                                     #\\u\n                                 \
    \                                                 (if (char=? c #\\t)\n      \
    \                                                                            \
    \    #\\v\n                                                                  \
    \                    (if (char=? c #\\u)\n                                   \
    \                                                       #\\w\n               \
    \                                                                           (if\
    \ (char=? c #\\v)\n                                                          \
    \                      ", "  (define (encrypt-helper s i)\n    (if (= i (string-length\
    \ s))\n        \"\"\n        (string-append (string (modulo (+ (string-ref s i)\
    \ (* 2 2)) 26) (+ (char->integer #\\a) 26)))\n        (encrypt-helper s (+ i 1))))\n\
    \  (encrypt-helper s 0))\n", "  (define (rotate n)\n    (if (zero? n)\n      \
    \  s\n        (rotate (- n 1))\n        (string-append (substring s (- n 1) n)\n\
    \                       (substring s 0 (- n 1)))))\n  (rotate 2))\n", "  (define\
    \ (rotate-by-two c)\n    (let ([c (string-ref s 0)])\n      (cond\n        [(char=?\
    \ c #\\a) #\\c]\n        [(char=? c #\\b) #\\d]\n        [(char=? c #\\c) #\\\
    e]\n        [(char=? c #\\d) #\\f]\n        [(char=? c #\\e) #\\g]\n        [(char=?\
    \ c #\\f) #\\h]\n        [(char=? c #\\g) #\\i]\n        [(char=? c #\\h) #\\\
    j]\n        [(char=? c #\\i) #\\k]\n        [(char=? c #\\j) #\\l]\n        [(char=?\
    \ c #\\k) #\\m]\n        [(char=? c #\\l) #\\n]\n        [(char=? c #\\m) #\\\
    o]\n        [(char=? c #\\n) #\\p]\n        [(char=? c #\\o) #\\q]\n        [(char=?\
    \ c #\\p) #\\r]\n        [(char=? c #\\q) #\\s]\n        [(char=? c #\\r) #\\\
    t]\n        [(char=? c #\\s) #\\u]\n        [(char=? c #\\t) #\\v]\n        [(char=?\
    \ c #\\u) #\\w]\n        [(char=? c #\\v) #\\x]\n        [(char=? c #\\w) #\\\
    y]\n        [(char=? c #\\x) #\\z]\n        [(char=? c #\\y) #\\a]\n        [(char=?\
    \ c #\\z) #\\b]\n        [else c])))\n  (string (rotate-by-two (string-ref s 0))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
