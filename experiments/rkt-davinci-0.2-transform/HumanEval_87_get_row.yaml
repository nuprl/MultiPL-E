name: HumanEval_87_get_row
language: rkt
prompt: "#lang racket\n\n;; You are given a 2 dimensional data, as a nested lists,\n\
  ;; which is similar to matrix, however, unlike matrices,\n;; each row may contain\
  \ a different number of columns.\n;; Given lst, and integer x, find integers x in\
  \ the list,\n;; and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n\
  ;; each tuple is a coordinate - (row, columns), starting with 0.\n;; Sort coordinates\
  \ initially by rows in ascending order.\n;; Also, sort coordinates of the row by\
  \ columns in descending order.\n;; Examples:\n;; >>> (get_row (list (list 1 2 3\
  \ 4 5 6) (list 1 2 3 4 1 6) (list 1 2 3 4 5 1)) 1)\n;; (list (list 0 0) (list 1\
  \ 4) (list 1 0) (list 2 5) (list 2 0))\n;; >>> (get_row (list ) 1)\n;; (list )\n\
  ;; >>> (get_row (list (list ) (list 1) (list 1 2 3)) 3)\n;; (list (list 2 2))\n\
  (define (get_row lst x)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate get_row))\n\
  \    (check-equal? (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 1 6) (list\
  \ 1 2 3 4 5 1)) 1) (list (list 0 0) (list 1 4) (list 1 0) (list 2 5) (list 2 0)))\n\
  \    (check-equal? (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list\
  \ 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 2 3 4 5 6)) 2) (list\
  \ (list 0 1) (list 1 1) (list 2 1) (list 3 1) (list 4 1) (list 5 1)))\n    (check-equal?\
  \ (candidate (list (list 1 2 3 4 5 6) (list 1 2 3 4 5 6) (list 1 1 3 4 5 6) (list\
  \ 1 2 1 4 5 6) (list 1 2 3 1 5 6) (list 1 2 3 4 1 6) (list 1 2 3 4 5 1)) 1) (list\
  \ (list 0 0) (list 1 0) (list 2 1) (list 2 0) (list 3 2) (list 3 0) (list 4 3) (list\
  \ 4 0) (list 5 4) (list 5 0) (list 6 5) (list 6 0)))\n    (check-equal? (candidate\
  \ (list ) 1) (list ))\n    (check-equal? (candidate (list (list 1)) 2) (list ))\n\
  \    (check-equal? (candidate (list (list ) (list 1) (list 1 2 3)) 3) (list (list\
  \ 2 2)))\n))\n\n(test-humaneval)"
completions: ["  (sort (for/list ([row (in-list lst)]\n                   [col (in-list\
    \ row)])\n        (when (= x col)\n          (list (length lst) col)))\n     \
    \   <))\n", "  (sort (for/list ([row (in-list lst)]\n                   [col (in-list\
    \ row)])\n         (if (= x col)\n             (list (list (length lst) col)\n\
    \                   (list (length row) col))))\n        <))\n", "  (sort (filter\
    \ (lambda (coord)\n                  (equal? x (list-ref (list-ref lst (car coord))\
    \ (cdr coord))))\n                (for/list ([i (in-range (length lst))]\n   \
    \                        [j (in-range (length (list-ref lst i)))])\n         \
    \         (list i j)))\n        (lambda (coord1 coord2)\n          (cond\n   \
    \         [(< (car coord1) (car coord2)) #t]\n            [(> (car coord1) (car\
    \ coord2)) #f]\n            [(> (cdr coord1) (cdr coord2)) #t]\n            [(<\
    \ (cdr coord1) (cdr coord2)) #f]))))\n", "  (define (get_row_helper lst x acc)\n\
    \    (cond\n      [(empty? lst) acc]\n      [(empty? (first lst)) (get_row_helper\
    \ (rest lst) x acc)]\n      [(equal? x (first (first lst)))\n       (get_row_helper\
    \ (rest lst) x (cons (list (length acc) (length (first lst))) acc))]\n      [else\
    \ (get_row_helper (rest lst) x (cons (list (length acc) 0) acc))]))\n  (sort (get_row_helper\
    \ lst x (list))\n        (lambda (lst1 lst2)\n          (cond\n            [(<\
    \ (first lst1) (first lst2)) #t]\n            [(> (first lst1) (first lst2)) #f]\n\
    \            [(> (second lst1) (second lst2)) #t]\n            [(< (second lst1)\
    \ (second lst2)) #f]\n            [else #f]))))\n", "  (sort (for/list ([row (in-list\
    \ lst)]\n                   [col (in-list row)])\n         (if (= x col)\n   \
    \          (list row col)))\n        (lambda (x y)\n          (cond\n        \
    \    [(< (car x) (car y)) #t]\n            [(> (car x) (car y)) #f]\n        \
    \    [(> (cadr x) (cadr y)) #t]\n            [(< (cadr x) (cadr y)) #f]))))\n",
  "  (define (get_row_helper lst x row col)\n    (cond\n      [(empty? lst) empty]\n\
    \      [(empty? (first lst)) (get_row_helper (rest lst) x (add1 row) 0)]\n   \
    \   [(= x (first (first lst)))\n       (cons (list row col) (get_row_helper (rest\
    \ lst) x row (add1 col)))]\n      [else (get_row_helper (rest lst) x row (add1\
    \ col))]))\n  (sort (get_row_helper lst x 0 0)\n        (lambda (lst1 lst2)\n\
    \          (cond\n            [(< (first lst1) (first lst2)) #t]\n           \
    \ [(> (first lst1) (first lst2)) #f]\n            [(> (second lst1) (second lst2))\
    \ #t]\n            [else #f]))))\n", "  (cond\n    [(empty? lst) empty]\n    [else\n\
    \     (append\n      (get_row (rest lst) x)\n      (get_row_in_row (first lst)\
    \ x 0 (add1 (length lst))))]))\n", "  (cond [(empty? lst) empty]\n        [else\
    \ (append (get_row (rest lst) x)\n                      (get_row_helper (first\
    \ lst) x (length lst) (rest lst)))]))\n", "  (define (get_row-helper lst x result)\n\
    \    (cond ((null? lst) result)\n          ((null? (car lst)) (get_row-helper\
    \ (cdr lst) x result))\n          ((= x (car (car lst)))\n           (get_row-helper\
    \ (cdr lst) x (cons (list (length result) (length (car lst))) result)))\n    \
    \      (else (get_row-helper (cdr lst) x (cons (car lst) result)))))\n  (sort\
    \ (get_row-helper lst x '())\n        (lambda (l1 l2)\n          (cond ((= (car\
    \ l1) (car l2))\n                 (if (< (cadr l1) (cadr l2)) #t #f))\n      \
    \          ((< (car l1) (car l2)) #t)\n                (else #f)))))\n", "  (sort\
    \ (for/list ([row (in-list lst)]\n                   [col (in-list row)])\n  \
    \       (when (= x col)\n           (list (list (length lst) col))))\n       \
    \ (\u03BB (a b)\n          (cond [(> (cadr a) (cadr b)) #t]\n                [(<\
    \ (cadr a) (cadr b)) #f]\n                [(> (car a) (car b)) #t]\n         \
    \       [(< (car a) (car b)) #f]))))\n", "  (sort (for/list ([(row . cols) (in-list\
    \ lst)]\n                   [col (in-list cols)])\n         (when (= x col)\n\
    \           (list row col)))\n        (\u03BB (x y) (cond [(< (car x) (car y))\
    \ #t]\n                       [(> (car x) (car y)) #f]\n                     \
    \  [(> (cadr x) (cadr y)) #t]\n                       [(< (cadr x) (cadr y)) #f]))))\n",
  "  (define (get_row-helper lst x acc)\n    (cond\n      [(empty? lst) acc]\n   \
    \   [(empty? (first lst)) (get_row-helper (rest lst) x acc)]\n      [(equal? x\
    \ (first (first lst)))\n       (get_row-helper (rest lst) x (cons (list (length\
    \ acc) (length (first lst))) acc))]\n      [else (get_row-helper (rest lst) x\
    \ (cons (list (length acc) 0) acc))]))\n  (sort (get_row-helper lst x (list))\n\
    \        (lambda (l1 l2)\n          (cond\n            [(< (first l1) (first l2))\
    \ #t]\n            [(> (first l1) (first l2)) #f]\n            [(> (second l1)\
    \ (second l2)) #t]\n            [(< (second l1) (second l2)) #f]\n           \
    \ [else #f]))))\n", "  (define (get_row_helper lst x acc)\n    (cond\n      [(empty?\
    \ lst) (reverse acc)]\n      [(empty? (first lst)) (get_row_helper (rest lst)\
    \ x acc)]\n      [(= x (first (first lst)))\n       (get_row_helper (rest lst)\
    \ x (cons (list (length acc) (length (first lst))) acc))]\n      [else (get_row_helper\
    \ (rest lst) x acc)]))\n  (get_row_helper lst x (list)))\n", "  (define (get_row-helper\
    \ lst x acc)\n    (cond\n      [(empty? lst) (reverse acc)]\n      [(empty? (first\
    \ lst)) (get_row-helper (rest lst) x acc)]\n      [(= x (first (first lst)))\n\
    \       (get_row-helper (rest lst) x (cons (list (length acc) 0) acc))]\n    \
    \  [(= x (first (rest (first lst))))\n       (get_row-helper (rest lst) x (cons\
    \ (list (length acc) 1) acc))]\n      [(= x (first (rest (rest (first lst)))))\n\
    \       (get_row-helper (rest lst) x (cons (list (length acc) 2) acc))]\n    \
    \  [else (get_row-helper (rest lst) x acc)]))\n  (get_row-helper lst x (list)))\n",
  "  (define (helper lst x acc)\n    (cond\n      [(empty? lst) (reverse acc)]\n \
    \     [(empty? (first lst)) (helper (rest lst) x acc)]\n      [(= x (first (first\
    \ lst)))\n       (helper (rest lst) x (cons (list (length acc) 0) acc))]\n   \
    \   [(> x (first (first lst)))\n       (helper (rest lst) x (cons (list (length\
    \ acc) 0) acc))]\n      [else\n       (helper (rest (first lst)) x (cons (list\
    \ (length acc) (add1 (length (first lst)))) acc))]))\n  (helper lst x (list)))\n",
  "  (sort (for/list ([row (in-list lst)]\n                   [col (in-list row)])\n\
    \         (if (= x col)\n             (list (list (length lst) col)\n        \
    \           (list (length row) col))))\n        (lambda (x y)\n          (cond\n\
    \            [(< (car (car x)) (car (car y))) #t]\n            [(> (car (car x))\
    \ (car (car y))) #f]\n            [(> (cadr (car x)) (cadr (car y))) #t]\n   \
    \         [(< (cadr (car x)) (cadr (car y))) #f]))))\n", "  (define (get_row_helper\
    \ lst x row col)\n    (cond\n      [(empty? lst) (list)]\n      [(empty? (first\
    \ lst)) (get_row_helper (rest lst) x (add1 row) 0)]\n      [(= x (first (first\
    \ lst)))\n       (cons (list row col) (get_row_helper (rest lst) x row (add1 col)))]\n\
    \      [else (get_row_helper (rest lst) x row (add1 col))]))\n  (sort (get_row_helper\
    \ lst x 0 0)\n        (lambda (x y)\n          (cond\n            [(< (first x)\
    \ (first y)) #t]\n            [(> (first x) (first y)) #f]\n            [(> (second\
    \ x) (second y)) #t]\n            [(< (second x) (second y)) #f]))))\n", "  (cond\n\
    \    [(empty? lst) empty]\n    [else\n     (append\n      (get_row (rest lst)\
    \ x)\n      (get_row_helper (first lst) x 0))]))\n", "  (sort (for/list ([row\
    \ (in-list lst)]\n                   [col (in-list row)])\n         (if (= x col)\
    \ (list (list (length lst) col) (list (length row) col))))\n        (\u03BB (x\
    \ y) (or (and (equal? (car x) (car y))\n                          (equal? (cadr\
    \ x) (cadr y)))\n                     (and (equal? (car x) (car y))\n        \
    \                  (equal? (cadr x) (cadr y)))\n                     (and (equal?\
    \ (car x) (car y))\n                          (equal? (cadr x) (cadr y)))))))\n",
  "  (define (get-row-helper lst x row-num)\n    (cond\n      [(empty? lst) empty]\n\
    \      [(empty? (first lst)) (get-row-helper (rest lst) x (+ row-num 1))]\n  \
    \    [(equal? x (first (first lst)))\n       (cons (list row-num 0) (get-row-helper\
    \ (rest lst) x row-num))]\n      [else (get-row-helper (rest (first lst)) x row-num)]))\n\
    \  (sort (get-row-helper lst x 0)\n        (lambda (l1 l2)\n          (cond\n\
    \            [(< (first l1) (first l2)) #t]\n            [(> (first l1) (first\
    \ l2)) #f]\n            [(> (second l1) (second l2)) #t]\n            [(< (second\
    \ l1) (second l2)) #f]))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
