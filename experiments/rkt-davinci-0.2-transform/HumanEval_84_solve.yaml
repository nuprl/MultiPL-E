name: HumanEval_84_solve
language: rkt
prompt: "#lang racket\n\n;; Given a positive integer N, return the total sum of its\
  \ digits in binary.\n;; Example\n;; >>> (solve 1000)\n;; \"1\"\n;; >>> (solve 150)\n\
  ;; \"110\"\n;; >>> (solve 147)\n;; \"1100\"\n;; Variables:\n;; @N integer\n;; Constraints:\
  \ 0 \u2264 N \u2264 10000.\n;; Output:\n;; a string of binary number\n(define (solve\
  \ N)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate solve))\n\
  \    (check-equal? (candidate 1000) \"1\")\n    (check-equal? (candidate 150) \"\
  110\")\n    (check-equal? (candidate 147) \"1100\")\n    (check-equal? (candidate\
  \ 333) \"1001\")\n    (check-equal? (candidate 963) \"10010\")\n))\n\n(test-humaneval)"
completions: ["  (define (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n    \
    \  [else (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))]))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n\
    \      [(= N 0) acc]\n      [else (solve-iter (/ N 2) (string (+ (modulo N 2)\
    \ (string->number acc))))]))\n  (solve-iter N \"\"))\n", "  (number->string (string->number\
    \ (number->string N) 2)))\n", "  (define (sum-digits n)\n    (if (zero? n)\n \
    \       0\n        (+ (remainder n 10) (sum-digits (quotient n 10)))))\n  (define\
    \ (to-binary n)\n    (if (zero? n)\n        \"\"\n        (string-append (to-binary\
    \ (quotient n 2)) (number->string (remainder n 2)))))\n  (number->string (sum-digits\
    \ (string->number (to-binary N)))))\n", "  (define (solve-iter N acc)\n    (cond\n\
    \      [(= N 0) acc]\n      [else (solve-iter (quotient N 2) (string-append acc\
    \ (number->string (remainder N 2))))]))\n  (solve-iter N \"\"))\n", "  (number->string\
    \ (integer-length (integer->binary N))))\n", "  (number->string (integer-length\
    \ (integer->binary N))))\n", "  (define (decimal-to-binary n)\n    (cond ((= n\
    \ 0) \"\")\n          ((= n 1) \"1\")\n          (else (string-append (decimal-to-binary\
    \ (quotient n 2))\n                               (number->string (remainder n\
    \ 2))))))\n  (define (sum-digits n)\n    (cond ((= n 0) 0)\n          (else (+\
    \ (remainder n 10) (sum-digits (quotient n 10))))))\n  (number->string (sum-digits\
    \ (string->number (decimal-to-binary N)))))\n", "  (define (solve-iter N acc)\n\
    \    (cond\n      [(zero? N) acc]\n      [else (solve-iter (quotient N 2) (string-append\
    \ acc (number->string (remainder N 2))))]))\n  (solve-iter N \"\"))\n", "  (define\
    \ (solve-iter N acc)\n    (cond\n      [(= N 0) (number->string acc)]\n      [else\
    \ (solve-iter (quotient N 2) (+ (* (remainder N 2) (expt 10 acc)) acc))]))\n \
    \ (solve-iter N 0))\n", "  (define (solve-iter N acc)\n    (if (zero? N)\n   \
    \     acc\n        (solve-iter (quotient N 2) (string-append acc (number->string\
    \ (remainder N 2))))))\n  (solve-iter N \"\"))\n", "  (number->string (integer-length\
    \ (integer->binary N))))\n```\n\n## Problem 2\n\n```racket\n#lang racket\n", " \
    \ (define (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (quotient N 2) (string-append acc (number->string (remainder N 2))))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (solve-iter N acc)\n    (cond [(= N 0) acc]\n      \
    \    [else (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))]))\n  (solve-iter N \"\"))\n", "  (define (sum-digits n)\n    (if (zero?\
    \ n)\n        0\n        (+ (remainder n 10) (sum-digits (quotient n 10)))))\n\
    \  (define (binary n)\n    (if (zero? n)\n        \"\"\n        (string-append\
    \ (binary (quotient n 2)) (number->string (remainder n 2)))))\n  (binary (sum-digits\
    \ N)))\n", "  (number->string (integer-length (integer->binary N))))\n", "  (define\
    \ (decimal-to-binary n)\n    (cond ((= n 0) '())\n          ((= n 1) '(1))\n \
    \         (else (append (decimal-to-binary (quotient n 2))\n                 \
    \       (list (remainder n 2))))))\n  (define (sum-digits n)\n    (cond ((= n\
    \ 0) 0)\n          (else (+ (remainder n 10) (sum-digits (quotient n 10))))))\n\
    \  (number->string (sum-digits (apply + (decimal-to-binary N)))))\n", "  (define\
    \ (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (quotient N 2) (string-append acc (number->string (remainder N 2))))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (solve-iter N acc)\n    (cond [(= N 0) (number->string\
    \ acc)]\n          [else (solve-iter (/ N 2) (+ (* N (% N 2)) acc))]))\n  (solve-iter\
    \ N 0))\n", "  (define (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n  \
    \    [else (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))]))\n  (solve-iter N \"\"))\n", "  (number->string (integer-length (integer->binary\
    \ N))))\n", "  (define (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n  \
    \    [else (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))]))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\
    \ [(= N 0) acc]\n          [else (solve-iter (quotient N 2) (string (remainder\
    \ N 2)))]))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n\
    \      [(= N 0) acc]\n      [else (solve-iter (quotient N 2) (string-append acc\
    \ (number->string (remainder N 2))))]))\n  (solve-iter N \"\"))\n", "  (number->string\
    \ (string->number (number->string N) 2)))\n", "  (define (solve-iter N acc)\n\
    \    (cond\n      [(= N 0) acc]\n      [else (solve-iter (quotient N 2) (string-append\
    \ acc (number->string (remainder N 2))))]))\n  (solve-iter N \"\"))\n", "  (define\
    \ (sum-digits n)\n    (if (zero? n)\n        0\n        (+ (remainder n 10) (sum-digits\
    \ (quotient n 10)))))\n  (define (to-binary n)\n    (if (zero? n)\n        \"\"\
    \n        (string-append (to-binary (quotient n 2)) (number->string (remainder\
    \ n 2)))))\n  (number->string (sum-digits (string->number (to-binary N)))))\n",
  "  (define (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (/ N 2) (string-append (number->string (% N 2)) acc))]))\n  (solve-iter N \"\
    \"))\n", "  (define (solve-iter N acc)\n    (cond\n      [(zero? N) acc]\n   \
    \   [else (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))]))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n\
    \      [(= N 0) acc]\n      [else (solve-iter (quotient N 2) (string-append acc\
    \ (number->string (remainder N 2))))]))\n  (solve-iter N \"\"))\n", "  (define\
    \ (to-binary N)\n    (cond\n      [(= N 0) \"\"]\n      [else (string-append (to-binary\
    \ (quotient N 2)) (number->string (remainder N 2)))]))\n  (define (sum-digits\
    \ N)\n    (cond\n      [(= N 0) 0]\n      [else (+ (remainder N 10) (sum-digits\
    \ (quotient N 10)))]))\n  (number->string (sum-digits (string->number (to-binary\
    \ N)))))\n", "  (define (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n \
    \     [else (solve-iter (/ N 2) (string-append (number->string (remainder N 2))\
    \ acc))]))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n\
    \      [(= N 0) acc]\n      [else (solve-iter (quotient N 2) (string-append acc\
    \ (number->string (remainder N 2))))]))\n  (solve-iter N \"\"))\n", "  (define\
    \ (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (/ N 2) (string-append (number->string (remainder N 2)) acc))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (solve-iter N result)\n    (cond ((= N 0) result)\n\
    \          ((= N 1) (string-append result \"1\"))\n          (else (solve-iter\
    \ (quotient N 2) (string-append result (number->string (remainder N 2)))))))\n\
    \  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n      [(=\
    \ N 0) acc]\n      [else (solve-iter (/ N 2) (string-append (number->string (remainder\
    \ N 2)) acc))]))\n  (solve-iter N \"\"))\n```\n\n## Problem 2\n\n```racket\n#lang\
    \ racket\n", "  (define (solve-iter N acc)\n    (cond [(= N 0) acc]\n        \
    \  [else (solve-iter (/ N 2) (string-append (number->string (remainder N 2)) acc))]))\n\
    \  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n      [(=\
    \ N 0) acc]\n      [else (solve-iter (/ N 2) (string-append (number->string (remainder\
    \ N 2)) acc))]))\n  (solve-iter N \"\"))\n", "  (define (to-binary n)\n    (cond\n\
    \      [(= n 0) \"\"]\n      [else (to-binary (quotient n 2)) (number->string\
    \ (remainder n 2))]))\n  (define (sum-digits n)\n    (cond\n      [(= n 0) 0]\n\
    \      [else (+ (remainder n 10) (sum-digits (quotient n 10)))]))\n  (number->string\
    \ (sum-digits (string->number (to-binary N)))))\n```\n\n## Problem 2\n\n```racket\n\
    #lang racket\n", "  (define (solve-iter N acc)\n    (cond [(= N 0) acc]\n    \
    \      [else (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))]))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n\
    \      [(= N 0) acc]\n      [else (solve-iter (quotient N 2) (string-append acc\
    \ (number->string (remainder N 2))))]))\n  (solve-iter N \"\"))\n", "  (define\
    \ (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (quotient N 2) (string (remainder N 2)))]))\n  (solve-iter N \"\"))\n", "  (define\
    \ (sum-digits n)\n    (if (zero? n)\n        0\n        (+ (remainder n 10) (sum-digits\
    \ (quotient n 10)))))\n  (define (decimal-to-binary n)\n    (if (zero? n)\n  \
    \      \"\"\n        (string-append (decimal-to-binary (quotient n 2)) (number->string\
    \ (remainder n 2)))))\n  (string-append (decimal-to-binary (sum-digits N)) \"\"\
    ))\n", "  (define (solve-iter N acc)\n    (if (= N 0)\n        acc\n        (solve-iter\
    \ (quotient N 2) (string-append acc (number->string (remainder N 2))))))\n  (solve-iter\
    \ N \"\"))\n", "  (define (solve-iter N acc)\n    (if (= N 0)\n        acc\n \
    \       (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\
    \ ((= N 0) acc)\n          ((= (remainder N 2) 0) (solve-iter (quotient N 2) (string-append\
    \ \"0\" acc)))\n          (else (solve-iter (quotient N 2) (string-append \"1\"\
    \ acc)))))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n\
    \      [(= N 0) acc]\n      [else (solve-iter (/ N 2) (string-append (number->string\
    \ (remainder N 2)) acc))]))\n  (solve-iter N \"\"))\n", "  (define (dec2bin n)\n\
    \    (cond [(= n 0) \"\"]\n          [else (dec2bin (quotient n 2)) (number->string\
    \ (remainder n 2))]))\n  (define (sum-digits n)\n    (cond [(= n 0) 0]\n     \
    \     [else (+ (remainder n 10) (sum-digits (quotient n 10)))]))\n  (number->string\
    \ (sum-digits (string->number (dec2bin N)))))\n", "  (integer->string (bin-sum\
    \ N)))\n", "  (define (sum-digits n)\n    (if (= n 0)\n        0\n        (+ (modulo\
    \ n 10) (sum-digits (quotient n 10)))))\n  (define (to-binary n)\n    (if (= n\
    \ 0)\n        \"\"\n        (string-append (to-binary (quotient n 2)) (number->string\
    \ (modulo n 2)))))\n  (number->string (sum-digits (string->number (to-binary N)))))\n",
  "  (define (solve-iter N acc)\n    (cond\n      [(zero? N) acc]\n      [else (solve-iter\
    \ (quotient N 2) (string-append acc (number->string (remainder N 2))))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (to-binary n)\n    (cond\n      [(= n 0) \"\"]\n   \
    \   [else (to-binary (quotient n 2)) (number->string (remainder n 2))]))\n  (define\
    \ (sum-digits n)\n    (cond\n      [(= n 0) 0]\n      [else (+ (remainder n 10)\
    \ (sum-digits (quotient n 10)))]))\n  (number->string (sum-digits (string->number\
    \ (to-binary N)))))\n", "  (define (to-binary n)\n    (cond\n      [(= n 0) \"\
    \"]\n      [else (to-binary (quotient n 2)) (number->string (remainder n 2))]))\n\
    \  (define (sum-digits n)\n    (cond\n      [(= n 0) 0]\n      [else (+ (remainder\
    \ n 10) (sum-digits (quotient n 10)))]))\n  (number->string (sum-digits (string->number\
    \ (to-binary N)))))\n", "  (define (solve-iter N acc)\n    (cond [(= N 0) acc]\n\
    \          [else (solve-iter (quotient N 2) (string (remainder N 2)))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (helper N)\n    (cond\n      [(= N 0) \"\"]\n      [else\
    \ (append (helper (quotient N 2)) (number->string (remainder N 2)))]))\n  (helper\
    \ N))\n", "  (define (solve-iter N acc)\n    (cond\n      [(zero? N) acc]\n  \
    \    [else (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))]))\n  (solve-iter N \"\"))\n", "  (number->string (string->number (number->string\
    \ N) 2)))\n", "  (define (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n\
    \      [else (solve-iter (/ N 2) (string-append (number->string (remainder N 2))\
    \ acc))]))\n  (solve-iter N \"\"))\n", "  (define (sum-digits n)\n    (if (zero?\
    \ n)\n        0\n        (+ (remainder n 10) (sum-digits (quotient n 10)))))\n\
    \  (define (to-binary n)\n    (if (zero? n)\n        \"\"\n        (string-append\
    \ (to-binary (quotient n 2)) (number->string (remainder n 2)))))\n  (number->string\
    \ (sum-digits (string->number (to-binary N)))))\n", "  (define (solve-iter N acc)\n\
    \    (cond\n      [(= N 0) acc]\n      [else (solve-iter (quotient N 2) (string-append\
    \ acc (number->string (remainder N 2))))]))\n  (solve-iter N \"\"))\n", "  (define\
    \ (dec-to-bin n)\n    (if (= n 0)\n        \"\"\n        (string-append (dec-to-bin\
    \ (quotient n 2)) (number->string (remainder n 2)))))\n  (string-append (dec-to-bin\
    \ N)))\n", "  (define (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n   \
    \   [else (solve-iter (/ N 2) (string-append (number->string (% N 2)) acc))]))\n\
    \  (solve-iter N \"\"))\n", "  (number->string (binary-sum N)))\n", "  (define\
    \ (solve-iter N acc)\n    (cond\n      [(zero? N) acc]\n      [else (solve-iter\
    \ (quotient N 2) (string-append acc (number->string (remainder N 2))))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n      [(zero? N) acc]\n\
    \      [else (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))]))\n  (solve-iter N \"\"))\n", "  (integer->string (binary-sum N)))\n",
  "  (define (sum-digits n)\n    (if (zero? n)\n        0\n        (+ (remainder n\
    \ 10) (sum-digits (quotient n 10)))))\n  (define (to-binary n)\n    (if (zero?\
    \ n)\n        \"\"\n        (string-append (to-binary (quotient n 2)) (number->string\
    \ (remainder n 2)))))\n  (number->string (sum-digits (string->number (to-binary\
    \ N)))))\n", "  (define (sum-digits n)\n    (if (zero? n)\n        0\n       \
    \ (+ (remainder n 10) (sum-digits (quotient n 10)))))\n  (define (to-binary n)\n\
    \    (if (zero? n)\n        \"\"\n        (string-append (to-binary (quotient\
    \ n 2)) (number->string (remainder n 2)))))\n  (number->string (sum-digits (string->number\
    \ (to-binary N)))))\n", "  (define (solve-iter N acc)\n    (if (= N 0)\n     \
    \   acc\n        (solve-iter (quotient N 2) (string-append acc (number->string\
    \ (remainder N 2))))))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N)\n\
    \    (cond [(= N 0) \"\"]\n          [(= (remainder N 2) 0) (string-append (solve-iter\
    \ (quotient N 2)) \"0\")]\n          [else (string-append (solve-iter (quotient\
    \ N 2)) \"1\")]))\n  (solve-iter N))\n", "  (define (to-binary n)\n    (cond\n\
    \      [(= n 0) \"\"]\n      [else (append (to-binary (quotient n 2)) (number->string\
    \ (remainder n 2)))]))\n  (define (sum-digits n)\n    (cond\n      [(= n 0) 0]\n\
    \      [else (+ (remainder n 10) (sum-digits (quotient n 10)))]))\n  (number->string\
    \ (sum-digits (string->number (to-binary N)))))\n", "  (define (solve-iter N result)\n\
    \    (cond\n      [(= N 0) result]\n      [else\n       (solve-iter (quotient\
    \ N 2)\n                   (string-append (number->string (remainder N 2)) result))]))\n\
    \  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n      [(=\
    \ N 0) acc]\n      [else (solve-iter (/ N 2) (string (+ (remainder N 2) (string->number\
    \ acc))))]))\n  (solve-iter N \"\"))\n```\n\n## Problem 3\n\n```racket\n#lang\
    \ racket\n", "  (string-&gt;number (number-&gt;string N 2)))\n</code>\n", "  (define\
    \ (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (/ N 2) (string-append (number->string (remainder N 2)) acc))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (solve-iter N acc)\n    (if (= N 0)\n        acc\n \
    \       (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (if\
    \ (= N 0)\n        acc\n        (solve-iter (quotient N 2) (string-append acc\
    \ (number->string (remainder N 2))))))\n  (solve-iter N \"\"))\n", "  (define\
    \ (sum-digits n)\n    (if (zero? n)\n        0\n        (+ (remainder n 10) (sum-digits\
    \ (quotient n 10)))))\n  (define (binary-of-n n)\n    (if (zero? n)\n        \"\
    \"\n        (string-append (binary-of-n (quotient n 2)) (number->string (remainder\
    \ n 2)))))\n  (number->string (sum-digits (string->number (binary-of-n N)))))\n",
  "  (define (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (/ N 2) (string-append (number->string (remainder N 2)) acc))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (helper N)\n    (if (= N 0)\n        '()\n        (cons\
    \ (modulo N 2) (helper (quotient N 2)))))\n  (string-join (reverse (helper N))\
    \ \"\"))\n", "  (define (solve-iter N acc)\n    (if (zero? N)\n        acc\n \
    \       (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n\
    \      [(= N 0) acc]\n      [else (solve-iter (/ N 2) (string-append (number->string\
    \ (remainder N 2)) acc))]))\n  (solve-iter N \"\"))\n", "  (define (sum-digits\
    \ n)\n    (if (zero? n)\n        0\n        (+ (remainder n 10) (sum-digits (quotient\
    \ n 10)))))\n  (define (to-binary n)\n    (if (zero? n)\n        \"\"\n      \
    \  (string-append (to-binary (quotient n 2)) (number->string (remainder n 2)))))\n\
    \  (number->string (sum-digits (string->number (to-binary N)))))\n", "  (number->string\
    \ (string->number (number->string N) 2)))\n", "  (define (dec2bin n)\n    (cond\
    \ ((= n 0) \"\")\n          (else (string-append (dec2bin (quotient n 2)) (number->string\
    \ (remainder n 2))))))\n  (define (sum-digits n)\n    (cond ((= n 0) 0)\n    \
    \      (else (+ (remainder n 10) (sum-digits (quotient n 10))))))\n  (number->string\
    \ (sum-digits (string->number (dec2bin N)))))\n", '  (number->string (integer-length
    (integer->binary N))))', "  (define (solve-iter N acc)\n    (if (= N 0)\n    \
    \    acc\n        (solve-iter (quotient N 2) (string-append acc (number->string\
    \ (remainder N 2))))))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n\
    \    (cond\n      [(= N 0) acc]\n      [else (solve-iter (quotient N 2) (string-append\
    \ acc (number->string (remainder N 2))))]))\n  (solve-iter N \"\"))\n", "  (string-&gt;number\
    \ (number-&gt;string N 2)))\n</code>\nThe error I get is:\n<code>string-&gt;number:\
    \ expects argument of type &lt;string&gt;; given \"1\"\n</code>\nI'm not sure\
    \ how to fix this.\n\n\nA:\n\nThe problem is that you're trying to convert a string\
    \ to a number, but the string is already a number.\n<code>(string-&gt;number \"\
    1\")\n</code>\nThis is the same as:\n<code>(string-&gt;number 1)\n</code>\nWhich\
    \ is the same as:\n<code>(string-&gt;number 1.0)\n</code>\nWhich is the same as:\n\
    <code>(string-&gt;number 1.0e0)\n</code>\nWhich is the same as:\n<code>(string-&gt;number\
    \ 1.0e0+0i)\n</code>\nWhich is the same as:\n<code>(string-&gt;number 1.0e0+0i)\n\
    </code>\nWhich is the same as:\n<code>(string-&gt;number 1.0e0+0i)\n</code>\n\
    Which is the same as:\n<code>(string-&gt;number 1.0e0+0i)\n</code>\nWhich is the\
    \ same as:\n<code>(string-&gt;number 1.0e0+0i)\n</code>\nWhich is the same as:\n\
    <code>(string-&gt;number 1.0e0+0i)\n</code>\nWhich is the same as:\n<code>(string-&gt;number\
    \ 1.0e0+0i)\n</code>\nWhich is the same as:\n<code>(string-&gt;number 1.0e0+0i)\n\
    </code>\nWhich is the same as:\n<code>(string-&gt;number 1.0e0+0i)\n</code>\n\
    Which is the same as:\n<code>(string-&gt;number 1.0e0+0i)\n</code>\nWhich is the\
    \ same as:\n<code>(string-&gt;number 1.0e", "  (define (solve-iter N acc)\n  \
    \  (cond\n      [(= N 0) acc]\n      [else (solve-iter (/ N 2) (string-append\
    \ (number->string (remainder N 2)) acc))]))\n  (solve-iter N \"\"))\n", "  (define\
    \ (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (/ N 2) (string-append (number->string (remainder N 2)) acc))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n      [(zero? N) acc]\n\
    \      [else (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))]))\n  (solve-iter N \"\"))\n", "  (define (dec2bin n)\n    (cond ((=\
    \ n 0) \"\")\n          (else (string-append (dec2bin (quotient n 2)) (number->string\
    \ (remainder n 2))))))\n  (string-append (dec2bin N)))\n```\n\n## Problem 2\n\n\
    ```racket\n#lang racket\n", "  (define (solve-iter N acc)\n    (cond\n      [(=\
    \ N 0) acc]\n      [else (solve-iter (/ N 2) (string (modulo N 2) acc))]))\n \
    \ (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n      [(=\
    \ N 0) acc]\n      [else (solve-iter (/ N 2) (string-append (number->string (remainder\
    \ N 2)) acc))]))\n  (solve-iter N \"\"))\n", "  (define (sum-digits n)\n    (cond\
    \ ((= n 0) 0)\n          (else (+ (modulo n 10) (sum-digits (quotient n 10))))))\n\
    \  (define (to-binary n)\n    (cond ((= n 0) \"\")\n          (else (string-append\
    \ (to-binary (quotient n 2)) (number->string (modulo n 2))))))\n  (number->string\
    \ (sum-digits (string->number (to-binary N)))))\n", "  (define (sum-digits n)\n\
    \    (if (zero? n)\n        0\n        (+ (remainder n 10) (sum-digits (quotient\
    \ n 10)))))\n  (define (to-binary n)\n    (if (zero? n)\n        \"\"\n      \
    \  (string-append (to-binary (quotient n 2)) (number->string (remainder n 2)))))\n\
    \  (number->string (sum-digits (string->number (to-binary N)))))\n", "  (define\
    \ (solve-iter N acc)\n    (cond\n      [(zero? N) (number->string acc)]\n    \
    \  [else (solve-iter (quotient N 2) (+ acc (remainder N 2)))]))\n  (solve-iter\
    \ N 0))\n", "  (define (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n  \
    \    [else (solve-iter (/ N 2) (string-append (number->string (remainder N 2))\
    \ acc))]))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\
    \ [(= N 0) acc]\n          [else (solve-iter (/ N 2) (string (modulo N 2) acc))]))\n\
    \  (solve-iter N \"\"))\n", "  (define (to-binary n)\n    (cond\n      [(= n 0)\
    \ '()]\n      [else (append (to-binary (quotient n 2)) (list (remainder n 2)))]))\n\
    \  (define (sum-digits n)\n    (cond\n      [(= n 0) 0]\n      [else (+ (remainder\
    \ n 10) (sum-digits (quotient n 10)))]))\n  (number->string (sum-digits (apply\
    \ + (to-binary N)))))\n", "  (define (solve-iter N acc)\n    (cond\n      [(=\
    \ N 0) acc]\n      [else (solve-iter (/ N 2) (string-append (number->string (remainder\
    \ N 2)) acc))]))\n  (solve-iter N \"\"))\n", "  (number->string (string->number\
    \ (number->string N) 2)))\n", "  (define (solve-iter N acc)\n    (cond\n     \
    \ [(= N 0) acc]\n      [else (solve-iter (/ N 2) (string-append (number->string\
    \ (remainder N 2)) acc))]))\n  (solve-iter N \"\"))\n", "  (define (sum-digits\
    \ n)\n    (cond\n      [(zero? n) 0]\n      [else (+ (remainder n 10) (sum-digits\
    \ (quotient n 10)))]))\n  (number->string (sum-digits (string->number (number->string\
    \ N 2)))))\n", "  (define (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n\
    \      [else (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))]))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (if\
    \ (= N 0)\n        acc\n        (solve-iter (quotient N 2) (string-append acc\
    \ (number->string (remainder N 2))))))\n  (solve-iter N \"\"))\n", "  (define\
    \ (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (/ N 2) (string (+ (modulo N 2) (string->number acc))))]))\n  (solve-iter N\
    \ \"\"))\n", "  (define (solve-iter N result)\n    (cond\n      [(= N 0) result]\n\
    \      [else (solve-iter (/ N 2) (string-append result (number->string (remainder\
    \ N 2))))]))\n  (solve-iter N \"\"))\n", "  (number->string (integer-length (integer->binary\
    \ N))))\n```\n\n## Test\n\n```racket", "  (number->string (string->number (number->string\
    \ N) 2)))\n", "  (number->string (integer-length (integer->binary N))))\n", " \
    \ (define (solve-iter N acc)\n    (if (= N 0)\n        acc\n        (solve-iter\
    \ (/ N 2) (string-append (number->string (% N 2)) acc))))\n  (solve-iter N \"\"\
    ))\n", "  (define (solve-iter N acc)\n    (if (= N 0)\n        acc\n        (solve-iter\
    \ (quotient N 2) (string-append acc (number->string (remainder N 2))))))\n  (solve-iter\
    \ N \"\"))\n", "  (number->string (integer-length (integer->binary N))))\n", " \
    \ (define (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (/ N 2) (string-append (number->string (remainder N 2)) acc))]))\n  (solve-iter\
    \ N \"\"))\n```\n\n## Problem 2\n\n```racket\n#lang racket\n", "  (define (solve-iter\
    \ N acc)\n    (if (= N 0)\n        acc\n        (solve-iter (quotient N 2) (string-append\
    \ acc (number->string (remainder N 2))))))\n  (solve-iter N \"\"))\n", "  (define\
    \ (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (/ N 2) (string-append (number->string (remainder N 2)) acc))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n      [(zero? N) acc]\n\
    \      [else (solve-iter (quotient N 2) (string (remainder N 2)))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (solve-iter N acc)\n    (cond [(= N 0) acc]\n      \
    \    [else (solve-iter (/ N 2) (string-append (number->string (remainder N 2))\
    \ acc))]))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n\
    \      [(= N 0) acc]\n      [else (solve-iter (/ N 2) (string-append (number->string\
    \ (remainder N 2)) acc))]))\n  (solve-iter N \"\"))\n", "  (define (solve-iter\
    \ N acc)\n    (cond [(= N 0) (number->string acc)]\n          [else (solve-iter\
    \ (quotient N 2) (+ (* (remainder N 2) (expt 10 acc)) acc))]))\n  (solve-iter\
    \ N 0))\n", "  (define (sum-digits n)\n    (if (= n 0)\n        0\n        (+\
    \ (modulo n 10) (sum-digits (quotient n 10)))))\n  (define (to-binary n)\n   \
    \ (if (= n 0)\n        \"\"\n        (string-append (to-binary (quotient n 2))\
    \ (number->string (modulo n 2)))))\n  (number->string (sum-digits (string->number\
    \ (to-binary N)))))\n", "  (number->string (string->number (number->string N)\
    \ 2)))\n", "  (define (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n   \
    \   [else (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))]))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n\
    \      [(= N 0) (number->string acc)]\n      [else (solve-iter (/ N 2) (+ (* N\
    \ (% N 2)) acc))]))\n  (solve-iter N 0))\n", "  (define (solve-iter N acc)\n \
    \   (cond [(= N 0) acc]\n          [else (solve-iter (quotient N 2) (number->string\
    \ (remainder N 2)))]))\n  (solve-iter N \"\"))\n", "  (cond\n    [(= N 0) \"0\"\
    ]\n    [(= N 1) \"1\"]\n    [else (string-append (solve (quotient N 2)) (number->string\
    \ (remainder N 2)))]))\n", "  (define (solve-iter N acc)\n    (cond\n      [(zero?\
    \ N) acc]\n      [else (solve-iter (quotient N 2) (string-append acc (number->string\
    \ (remainder N 2))))]))\n  (solve-iter N \"\"))\n", "  (number->string (integer-length\
    \ (integer->binary N))))\n", "  (number->string (integer-length (integer->binary\
    \ N))))\n", "  (integer->string (integer-length (integer->binary N))))\n", " \
    \ (define (solve-iter N acc)\n    (if (= N 0)\n        acc\n        (solve-iter\
    \ (quotient N 2) (string-append (number->string (remainder N 2)) acc))))\n  (solve-iter\
    \ N \"\"))\n", "  (number->string (integer-length (integer->binary N))))\n```\n\
    \n## Problem 2\n\n```racket\n#lang racket\n", "  (define (solve-iter N acc)\n\
    \    (cond\n      [(= N 0) acc]\n      [else (solve-iter (/ N 2) (string-append\
    \ (number->string (remainder N 2)) acc))]))\n  (solve-iter N \"\"))\n", "  (define\
    \ (to-binary n)\n    (if (= n 0)\n        '()\n        (cons (remainder n 2) (to-binary\
    \ (quotient n 2)))))\n  (define (sum-digits lst)\n    (if (null? lst)\n      \
    \  0\n        (+ (car lst) (sum-digits (cdr lst)))))\n  (define (to-string lst)\n\
    \    (if (null? lst)\n        \"\"\n        (string-append (number->string (car\
    \ lst)) (to-string (cdr lst)))))\n  (to-string (to-binary (sum-digits (to-binary\
    \ N)))))\n", "  (define (solve-iter N acc)\n    (cond\n      [(zero? N) acc]\n\
    \      [else (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))]))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (if\
    \ (= N 0)\n        acc\n        (solve-iter (quotient N 2) (string (remainder\
    \ N 2) acc))))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n   \
    \ (cond\n      [(= N 0) acc]\n      [else (solve-iter (quotient N 2) (string-append\
    \ acc (number->string (remainder N 2))))]))\n  (solve-iter N \"\"))\n", "  (define\
    \ (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (/ N 2) (string-append (number->string (remainder N 2)) acc))]))\n  (solve-iter\
    \ N \"\"))\n", "  (number->string (string->number (number->string N) 2)))\n",
  "  (define (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (quotient N 2) (string-append acc (number->string (remainder N 2))))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (solve-iter N acc)\n    (cond [(= N 0) acc]\n      \
    \    [else (solve-iter (quotient N 2) (string (remainder N 2)))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n      [(zero? N) acc]\n\
    \      [else (solve-iter (quotient N 2) (number->string (remainder N 2)))]))\n\
    \  (solve-iter N \"\"))\n", "  (define (sum-digits n)\n    (if (zero? n)\n   \
    \     0\n        (+ (remainder n 10) (sum-digits (quotient n 10)))))\n  (define\
    \ (to-binary n)\n    (if (zero? n)\n        \"\"\n        (string-append (to-binary\
    \ (quotient n 2)) (number->string (remainder n 2)))))\n  (number->string (sum-digits\
    \ (string->number (to-binary N)))))\n", "  (define (sum-of-digits n)\n    (if\
    \ (= n 0)\n        0\n        (+ (modulo n 10) (sum-of-digits (quotient n 10)))))\n\
    \  (define (to-binary n)\n    (if (= n 0)\n        \"\"\n        (string-append\
    \ (to-binary (quotient n 2)) (number->string (modulo n 2)))))\n  (to-binary (sum-of-digits\
    \ N)))\n", "  (number->string (integer-length (integer->binary N))))\n", "  (define\
    \ (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (/ N 2) (string (modulo N 2) acc))]))\n  (solve-iter N \"\"))\n", "  (number->string\
    \ (string->number (number->string N) 2)))\n", "  (define (solve-iter N acc)\n\
    \    (cond\n      [(= N 0) acc]\n      [else (solve-iter (/ N 2) (string-append\
    \ (number->string (remainder N 2)) acc))]))\n  (solve-iter N \"\"))\n", "  (define\
    \ (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (quotient N 2) (string (remainder N 2)))]))\n  (solve-iter N \"\"))\n", "  (number->string\
    \ (integer-length (integer->binary N))))\n", "  (define (solve-iter N acc)\n \
    \   (if (= N 0)\n        acc\n        (solve-iter (quotient N 2) (string-append\
    \ acc (number->string (remainder N 2))))))\n  (solve-iter N \"\"))\n", "  (define\
    \ (solve-iter N acc)\n    (cond [(= N 0) acc]\n          [else (solve-iter (quotient\
    \ N 2) (string-append acc (number->string (remainder N 2))))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (solve-iter N acc)\n    (if (= N 0)\n        acc\n \
    \       (solve-iter (quotient N 2) (string-append (number->string (remainder N\
    \ 2)) acc))))\n  (solve-iter N \"\"))\n", "  (string-&gt;number (number-&gt;string\
    \ (integer-&gt;char N) 2)))\n</code>\n", '  (number->string (integer-length (integer->binary
    N))))', "  (number->string (integer-length (integer->binary N))))\n```\n\n## Problem\
    \ 2\n\n```racket\n#lang racket\n", "  (number->string (integer-length (integer->binary\
    \ N))))\n", "  (define (sum-digits n)\n    (if (zero? n)\n        0\n        (+\
    \ (remainder n 10) (sum-digits (quotient n 10)))))\n  (define (to-binary n)\n\
    \    (if (zero? n)\n        \"\"\n        (string-append (to-binary (quotient\
    \ n 2)) (number->string (remainder n 2)))))\n  (number->string (sum-digits (string->number\
    \ (to-binary N)))))\n", "  (define (solve-iter N acc)\n    (cond\n      [(zero?\
    \ N) acc]\n      [else (solve-iter (quotient N 2) (string-append acc (number->string\
    \ (remainder N 2))))]))\n  (solve-iter N \"\"))\n", "  (define (helper N)\n  \
    \  (if (= N 0)\n        '()\n        (cons (remainder N 2) (helper (quotient N\
    \ 2)))))\n  (string-&gt;number (apply string-append (reverse (helper N)))))\n\
    </code>\n", "  (define (solve-iter N acc)\n    (if (= N 0)\n        acc\n    \
    \    (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))))\n  (solve-iter N \"\"))\n", "  (number->string (integer-length (integer->binary\
    \ N))))\n", "  (define (solve-iter N acc)\n    (cond\n      [(zero? N) acc]\n\
    \      [else (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))]))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\
    \ [(= N 0) acc]\n          [else (solve-iter (quotient N 2) (string (remainder\
    \ N 2)))]))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (if\
    \ (= N 0)\n        acc\n        (solve-iter (quotient N 2) (string-append acc\
    \ (number->string (remainder N 2))))))\n  (solve-iter N \"\"))\n", "  (define\
    \ (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (/ N 2) (string-append (number->string (remainder N 2)) acc))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (to-binary N)\n    (cond\n      [(= N 0) \"\"]\n   \
    \   [else (string-append (to-binary (quotient N 2)) (number->string (remainder\
    \ N 2)))]))\n  (define (sum-digits N)\n    (cond\n      [(= N 0) 0]\n      [else\
    \ (+ (remainder N 10) (sum-digits (quotient N 10)))]))\n  (number->string (sum-digits\
    \ (string->number (to-binary N)))))\n", "  (define (solve-iter N acc)\n    (cond\n\
    \      [(= N 0) acc]\n      [else (solve-iter (/ N 2) (string-append (number->string\
    \ (remainder N 2)) acc))]))\n  (solve-iter N \"\"))\n", "  (number->string (integer-length\
    \ (integer->binary N))))\n", "  (string-&gt;number (number-&gt;string N) 2))\n\
    </code>\nI'm getting the following error:\n<code>number-&gt;string: expects argument\
    \ of type &lt;number&gt;; given \"1\"\n</code>\nI'm not sure why it's not working.\n\
    \n\nA:\n\nThe problem is that you're trying to convert a string to a number, and\
    \ then convert that number to a string.\n<code>(string-&gt;number (number-&gt;string\
    \ N) 2)\n</code>\nThe <code>number-&gt;string</code> procedure expects a number\
    \ as input, but you're passing a string.\nIf you want to convert a number to a\
    \ string, you can use the <code>number-&gt;string</code> procedure, but you don't\
    \ need to convert the string to a number again.\n<code>(number-&gt;string N 2)\n\
    </code>\n", "  (define (solve-iter N acc)\n    (cond [(= N 0) acc]\n         \
    \ [else (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))]))\n  (solve-iter N \"\"))\n", "  (define (solve-iter N acc)\n    (if\
    \ (= N 0)\n        acc\n        (solve-iter (quotient N 2) (string-append acc\
    \ (number->string (remainder N 2))))))\n  (solve-iter N \"\"))\n", "  (define\
    \ (solve-iter N acc)\n    (cond\n      [(zero? N) acc]\n      [else (solve-iter\
    \ (quotient N 2) (string-append acc (number->string (remainder N 2))))]))\n  (solve-iter\
    \ N \"\"))\n", "  (number->string (integer-length (integer->binary N))))\n", " \
    \ (define (solve-iter N acc)\n    (cond [(= N 0) acc]\n          [else (solve-iter\
    \ (quotient N 2) (string-append acc (number->string (remainder N 2))))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (sum-digits n)\n    (if (zero? n)\n        0\n     \
    \   (+ (remainder n 10) (sum-digits (quotient n 10)))))\n  (define (binary n)\n\
    \    (if (zero? n)\n        \"\"\n        (string-append (binary (quotient n 2))\
    \ (number->string (remainder n 2)))))\n  (binary (sum-digits N)))\n", "  (define\
    \ (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (quotient N 2) (string-append acc (number->string (remainder N 2))))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n\
    \      [else (solve-iter (quotient N 2) (string (remainder N 2)))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (solve-iter N acc)\n    (if (= N 0)\n        acc\n \
    \       (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))))\n  (solve-iter N \"\"))\n", "  (define (dec-to-bin n)\n    (if (=\
    \ n 0)\n        \"\"\n        (string-append (dec-to-bin (quotient n 2)) (number->string\
    \ (remainder n 2)))))\n  (define (sum-digits s)\n    (if (empty? s)\n        0\n\
    \        (+ (string-&gt;number (substring s 0 1)) (sum-digits (substring s 1)))))\n\
    \  (number-&gt;string (sum-digits (dec-to-bin N))))\n</code>\n", "  (define (solve-iter\
    \ N acc)\n    (cond\n      [(zero? N) acc]\n      [else (solve-iter (quotient\
    \ N 2) (string-append acc (number->string (remainder N 2))))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (solve-iter N acc)\n    (if (= N 0)\n        acc\n \
    \       (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))))\n  (solve-iter N \"\"))\n", "  (define (to-binary n)\n    (if (= n\
    \ 0)\n        \"\"\n        (string-append (to-binary (quotient n 2)) (number->string\
    \ (remainder n 2)))))\n  (define (sum-digits n)\n    (if (= n 0)\n        0\n\
    \        (+ (remainder n 10) (sum-digits (quotient n 10)))))\n  (number->string\
    \ (sum-digits (string->number (to-binary N)))))\n", "  (define (solve-iter N acc)\n\
    \    (cond\n      [(= N 0) acc]\n      [else (solve-iter (/ N 2) (string-append\
    \ (number->string (remainder N 2)) acc))]))\n  (solve-iter N \"\"))\n", "  (define\
    \ (solve-iter N acc)\n    (if (= N 0)\n        acc\n        (solve-iter (quotient\
    \ N 2) (string-append (number->string (remainder N 2)) acc))))\n  (solve-iter\
    \ N \"\"))\n", "  (define (dec2bin n)\n    (if (zero? n)\n        \"\"\n     \
    \   (string-append (dec2bin (quotient n 2)) (number->string (remainder n 2)))))\n\
    \  (string-append (dec2bin N)))\n", "  (define (solve-iter N acc)\n    (cond [(zero?\
    \ N) acc]\n          [else (solve-iter (quotient N 2) (string-append acc (number->string\
    \ (remainder N 2))))]))\n  (solve-iter N \"\"))\n", "  (number->string (string->number\
    \ (number->string N) 2)))\n```\n\n## Problem 2\n\n```racket\n#lang racket\n",
  "  (define (solve-iter N acc)\n    (cond\n      [(= N 0) acc]\n      [else (solve-iter\
    \ (/ N 2) (string-append (number->string (remainder N 2)) acc))]))\n  (solve-iter\
    \ N \"\"))\n", "  (define (sum-digits n)\n    (if (= n 0)\n        0\n       \
    \ (+ (modulo n 10) (sum-digits (quotient n 10)))))\n  (define (to-binary n)\n\
    \    (if (= n 0)\n        \"\"\n        (string-append (to-binary (quotient n\
    \ 2)) (number->string (modulo n 2)))))\n  (number->string (sum-digits (string->number\
    \ (to-binary N)))))\n", "  (define (solve-iter N acc)\n    (cond\n      [(zero?\
    \ N) acc]\n      [else (solve-iter (quotient N 2) (string-append acc (number->string\
    \ (remainder N 2))))]))\n  (solve-iter N \"\"))\n", "  (string-append (integer->string\
    \ (remainder N 2))\n                 (solve (quotient N 2))))\n", "  (define (solve-iter\
    \ N acc)\n    (cond [(= N 0) acc]\n          [else (solve-iter (quotient N 2)\
    \ (string (remainder N 2)))]))\n  (solve-iter N \"\"))\n", "  (define (dec-to-bin\
    \ n)\n    (cond ((= n 0) \"\")\n          ((= n 1) \"1\")\n          (else (string-append\
    \ (dec-to-bin (quotient n 2)) (number->string (remainder n 2))))))\n  (define\
    \ (sum-digits n)\n    (cond ((= n 0) 0)\n          (else (+ (remainder n 10) (sum-digits\
    \ (quotient n 10))))))\n  (number->string (sum-digits (string->number (dec-to-bin\
    \ N)))))\n", "  (define (solve-iter N acc)\n    (cond [(= N 0) acc]\n        \
    \  [else (solve-iter (quotient N 2) (string-append acc (number->string (remainder\
    \ N 2))))]))\n  (solve-iter N \"\"))\n", "  (number->string (string->number (number->string\
    \ N) 2)))\n", "  (define (sum-digits n)\n    (if (zero? n)\n        0\n      \
    \  (+ (remainder n 10) (sum-digits (quotient n 10)))))\n  (define (to-bin n)\n\
    \    (if (zero? n)\n        \"\"\n        (string-append (to-bin (quotient n 2))\
    \ (number->string (remainder n 2)))))\n  (number->string (sum-digits (string->number\
    \ (to-bin N)))))\n", "  (define (solve-iter N acc)\n    (cond\n      [(= N 0)\
    \ acc]\n      [else (solve-iter (quotient N 2) (string (remainder N 2)))]))\n\
    \  (solve-iter N \"\"))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
