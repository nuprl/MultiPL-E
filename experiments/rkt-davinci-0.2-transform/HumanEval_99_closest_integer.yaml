name: HumanEval_99_closest_integer
language: rkt
prompt: "#lang racket\n\n;; Create a function that takes a value (string) representing\
  \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
  ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
  \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
  \ away from zero means that if the given number is equidistant\n;; from two integers,\
  \ the one you should return is the one that is the\n;; farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\n(define (closest_integer value)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
  \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
  ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
  \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
completions: ["  (let* ((num (string->number value))\n         (int (round num)))\n\
    \    (if (and (integer? num)\n             (integer? int))\n        int\n    \
    \    (if (> num 0)\n            (ceiling num)\n            (floor num)))))\n",
  "  (cond\n    [(string=? value \"0\") 0]\n    [(string=? value \"0.0\") 0]\n   \
    \ [(string=? value \"0.00\") 0]\n    [(string=? value \"0.000\") 0]\n    [(string=?\
    \ value \"0.0000\") 0]\n    [(string=? value \"0.00000\") 0]\n    [(string=? value\
    \ \"0.000000\") 0]\n    [(string=? value \"0.0000000\") 0]\n    [(string=? value\
    \ \"0.00000000\") 0]\n    [(string=? value \"0.000000000\") 0]\n    [(string=?\
    \ value \"0.0000000000\") 0]\n    [(string=? value \"0.00000000000\") 0]\n   \
    \ [(string=? value \"0.000000000000\") 0]\n    [(string=? value \"0.0000000000000\"\
    ) 0]\n    [(string=? value \"0.00000000000000\") 0]\n    [(string=? value \"0.000000000000000\"\
    ) 0]\n    [(string=? value \"0.0000000000000000\") 0]\n    [(string=? value \"\
    0.00000000000000000\") 0]\n    [(string=? value \"0.000000000000000000\") 0]\n\
    \    [(string=? value \"0.0000000000000000000\") 0]\n    [(string=? value \"0.00000000000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000000000\") 0]\n    [(string=? value\
    \ \"0.0000000000000000000000\") 0]\n    [(string=? value \"0.00000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.0000000000000000000000000\") 0]\n    [(string=? value \"0.00000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.0000000000000000000000000000\") 0]\n    [(string=? value \"0.00000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000000000000000000\") 0]\n    [(string=?\
    \ value \"0.0000000000000000000000000000000\") 0]\n    [(string=? value \"0.00000000000000000000000000000000\"\
    ) 0]\n    [(string=? value \"0.000000000000000000000000000000000\") 0]", "  (round\
    \ (string->number value)))\n", "  (if (string=? (substring value (sub1 (string-length\
    \ value)) (string-length value)) \".\")\n      (string->number (substring value\
    \ 0 (sub1 (string-length value))))\n      (if (> (string->number (substring value\
    \ (sub1 (string-length value)) (string-length value))) 5)\n          (string->number\
    \ (substring value 0 (sub1 (string-length value))))\n          (string->number\
    \ (substring value 0 (sub1 (string-length value)))))))\n", "  (if (negative? (string->number\
    \ value))\n      (- (round (string->number value)))\n      (round (string->number\
    \ value))))\n", "  (round (string->number value)))\n", "  (let ([value (string->number\
    \ value)])\n    (if (negative? value)\n        (- (round (abs value)))\n     \
    \   (round value))))\n", "  (round (string->number value)))\n", "  (cond\n   \
    \ [(< (string->number value) 0)\n     (round (string->number value) -1)]\n   \
    \ [else\n     (round (string->number value) 1)]))\n", "  (round (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (if (negative? (string->number\
    \ value))\n      (- (round (string->number value)))\n      (round (string->number\
    \ value))))\n", "  (define (round-away-from-zero n)\n    (if (negative? n)\n \
    \       (round (add1 n))\n        (round n)))\n  (round-away-from-zero (string->number\
    \ value)))\n", "  (round (string->number value)))\n", "  (cond\n    [(< (string->number\
    \ value) 0)\n     (round (string->number value) -1)]\n    [else\n     (round (string->number\
    \ value) 1)]))\n", "  (let ((num (string->number value)))\n    (if (integer? num)\n\
    \        num\n        (if (>= num 0)\n            (round num)\n            (round\
    \ (- num))))))\n", "  (round (string->number value)))\n", "  (cond ((= (round\
    \ value) value) (round value))\n        ((< (round value) value) (round value))\n\
    \        ((> (round value) value) (round value))))\n", "  (cond\n    [(< (string->number\
    \ value) 0)\n     (- (round (string->number value)))]\n    [else\n     (round\
    \ (string->number value))]))\n", "  (let ([num (string->number value)])\n    (if\
    \ (and (integer? num) (not (zero? num)))\n        num\n        (let ([floor (floor\
    \ num)]\n              [ceil (ceiling num)])\n          (if (> (abs (- num floor))\
    \ (abs (- num ceil)))\n              ceil\n              floor)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
