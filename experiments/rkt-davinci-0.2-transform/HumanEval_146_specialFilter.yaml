name: HumanEval_146_specialFilter
language: rkt
prompt: "#lang racket\n\n;; Write a function that takes an array of numbers as input\
  \ and returns \n;; the number of elements in the array that are greater than 10\
  \ and both \n;; first and last digits of a number are odd (1, 3, 5, 7, 9).\n;; For\
  \ example:\n;; >>> (specialFilter (list 15 -73 14 -15))\n;; 1\n;; >>> (specialFilter\
  \ (list 33 -2 -3 45 21 109))\n;; 2\n(define (specialFilter nums)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate specialFilter))\n\
  \    (check-equal? (candidate (list 5 -2 1 -5)) 0)\n    (check-equal? (candidate\
  \ (list 15 -73 14 -15)) 1)\n    (check-equal? (candidate (list 33 -2 -3 45 21 109))\
  \ 2)\n    (check-equal? (candidate (list 43 -12 93 125 121 109)) 4)\n    (check-equal?\
  \ (candidate (list 71 -2 -33 75 21 19)) 3)\n    (check-equal? (candidate (list 1))\
  \ 0)\n    (check-equal? (candidate (list )) 0)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? nums) 0]\n    [(and (odd? (first nums)) (odd?\
    \ (last nums)) (> (first nums) 10))\n     (+ 1 (specialFilter (rest nums)))]\n\
    \    [else (specialFilter (rest nums))]))\n", "  (cond\n    [(empty? nums) 0]\n\
    \    [(and (odd? (first nums))\n          (odd? (last-digit (first nums)))\n \
    \         (> (first nums) 10))\n     (+ 1 (specialFilter (rest nums)))]\n    [else\
    \ (specialFilter (rest nums))]))\n", "  (define (firstDigit n)\n    (if (negative?\
    \ n)\n        (- (firstDigit (- n)))\n        (if (< n 10)\n            n\n  \
    \          (firstDigit (/ n 10)))))\n  (define (lastDigit n)\n    (if (negative?\
    \ n)\n        (- (lastDigit (- n)))\n        (modulo n 10)))\n  (define (isOdd\
    \ n)\n    (if (zero? (modulo n 2))\n        #f\n        #t))\n  (define (isSpecial\
    \ n)\n    (and (isOdd (firstDigit n))\n         (isOdd (lastDigit n))))\n  (define\
    \ (countSpecial nums)\n    (if (null? nums)\n        0\n        (if (and (> (car\
    \ nums) 10)\n                 (isSpecial (car nums)))\n            (+ 1 (countSpecial\
    \ (cdr nums)))\n            (countSpecial (cdr nums)))))\n  (countSpecial nums))\n",
  "  (define (firstDigit n)\n    (if (negative? n)\n        (- (firstDigit (- n)))\n\
    \        (if (zero? n)\n            0\n            (firstDigit (quotient n 10)))))\n\
    \  (define (lastDigit n)\n    (remainder n 10))\n  (define (isOdd n)\n    (if\
    \ (zero? (remainder n 2))\n        #f\n        #t))\n  (define (isSpecial n)\n\
    \    (and (isOdd (firstDigit n))\n         (isOdd (lastDigit n))))\n  (define\
    \ (countSpecial nums)\n    (if (null? nums)\n        0\n        (if (and (> (car\
    \ nums) 10)\n                 (isSpecial (car nums)))\n            (+ 1 (countSpecial\
    \ (cdr nums)))\n            (countSpecial (cdr nums)))))\n  (countSpecial nums))\n",
  "  (define (firstDigit n)\n    (if (zero? n)\n        0\n        (firstDigit (quotient\
    \ n 10))))\n  (define (lastDigit n)\n    (modulo n 10))\n  (define (isOdd n)\n\
    \    (if (zero? (modulo n 2))\n        #f\n        #t))\n  (define (isGreaterThanTen\
    \ n)\n    (if (&gt; n 10)\n        #t\n        #f))\n  (define (isSpecial n)\n\
    \    (and (isGreaterThanTen n)\n         (isOdd (firstDigit n))\n         (isOdd\
    \ (lastDigit n))))\n  (define (countSpecial nums)\n    (if (null? nums)\n    \
    \    0\n        (+ (if (isSpecial (car nums))\n               1\n            \
    \   0)\n           (countSpecial (cdr nums)))))\n  (countSpecial nums))\n</code>\n",
  "  (length (filter (lambda (x)\n                    (and (odd? (first-digit x))\n\
    \                         (odd? (last-digit x))\n                         (> x\
    \ 10)))\n                  nums)))\n", "  (length (filter (lambda (x)\n      \
    \              (and (odd? (first-digit x))\n                         (odd? (last-digit\
    \ x))\n                         (> x 10)))\n                  nums)))\n", "  (cond\n\
    \    [(empty? nums) 0]\n    [(and (odd? (first nums))\n          (odd? (last-digit\
    \ (first nums)))\n          (> (first nums) 10))\n     (+ 1 (specialFilter (rest\
    \ nums)))]\n    [else (specialFilter (rest nums))]))\n", "  (cond\n    [(empty?\
    \ nums) 0]\n    [(and (> (first nums) 10)\n          (odd? (first (number->digits\
    \ (first nums))))\n          (odd? (last (number->digits (first nums)))))\n  \
    \   (+ 1 (specialFilter (rest nums)))]\n    [else (specialFilter (rest nums))]))\n",
  "  (length (filter (lambda (n)\n                    (and (odd? (first-digit n))\n\
    \                         (odd? (last-digit n))\n                         (> n\
    \ 10)))\n                  nums)))\n", "  (length (filter (lambda (n)\n      \
    \              (and (> n 10)\n                         (odd? (first-digit n))\n\
    \                         (odd? (last-digit n))))\n                  nums)))\n",
  "  (define (first-digit n)\n    (quotient n (expt 10 (floor (log n 10)))))\n  (define\
    \ (last-digit n)\n    (modulo n 10))\n  (define (odd? n)\n    (and (odd? (first-digit\
    \ n)) (odd? (last-digit n))))\n  (length (filter (lambda (n) (and (> n 10) (odd?\
    \ n))) nums)))\n", "  (length (filter (lambda (x)\n                    (and (odd?\
    \ (remainder x 10))\n                         (odd? (quotient x 10))\n       \
    \                  (> x 10)))\n                  nums)))\n", "  (length (filter\
    \ (lambda (x)\n                    (and (> x 10)\n                         (odd?\
    \ (first-digit x))\n                         (odd? (last-digit x))))\n       \
    \           nums)))\n", "  (cond\n    [(empty? nums) 0]\n    [(and (odd? (first\
    \ nums))\n          (odd? (last-digit (first nums)))\n          (> (first nums)\
    \ 10))\n     (+ 1 (specialFilter (rest nums)))]\n    [else (specialFilter (rest\
    \ nums))]))\n", "  (length (filter (lambda (x)\n                    (and (odd?\
    \ (first-digit x))\n                         (odd? (last-digit x))\n         \
    \                (> x 10)))\n                  nums)))\n", "  (length (filter\
    \ (lambda (n)\n                    (and (odd? (first-digit n))\n             \
    \            (odd? (last-digit n))\n                         (> n 10)))\n    \
    \              nums)))\n", "  (define (firstDigit n)\n    (if (zero? n)\n    \
    \    0\n        (firstDigit (quotient n 10))))\n  (define (lastDigit n)\n    (modulo\
    \ n 10))\n  (define (isOdd n)\n    (if (zero? (modulo n 2))\n        #f\n    \
    \    #t))\n  (define (greaterThanTen n)\n    (if (> n 10)\n        #t\n      \
    \  #f))\n  (define (isSpecial n)\n    (and (isOdd (firstDigit n))\n         (isOdd\
    \ (lastDigit n))\n         (greaterThanTen n)))\n  (define (countSpecial nums)\n\
    \    (if (null? nums)\n        0\n        (if (isSpecial (car nums))\n       \
    \     (+ 1 (countSpecial (cdr nums)))\n            (countSpecial (cdr nums)))))\n\
    \  (countSpecial nums))\n", "  (length (filter (lambda (x)\n                 \
    \   (and (odd? (first-digit x))\n                         (odd? (last-digit x))\n\
    \                         (> x 10)))\n                  nums)))\n", "  (length\
    \ (filter (lambda (x) (and (odd? (first-digit x)) (odd? (last-digit x)) (> x 10)))\
    \ nums)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
