name: HumanEval_11_string_xor
language: rkt
prompt: "#lang racket\n\n;; Input are two strings a and b consisting only of 1s and\
  \ 0s.\n;; Perform binary XOR on these inputs and return result also as a string.\n\
  ;; >>> (string_xor \"010\" \"110\")\n;; \"100\"\n(define (string_xor a b)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate string_xor))\n\
  \    (check-equal? (candidate \"111000\" \"101010\") \"010010\")\n    (check-equal?\
  \ (candidate \"1\" \"1\") \"0\")\n    (check-equal? (candidate \"0101\" \"0000\"\
  ) \"0101\")\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else (string-append\n\
    \           (if (equal? (first a) (first b)) \"0\" \"1\")\n           (string_xor\
    \ (rest a) (rest b)))]))\n", "  (string-join (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string-ref x 0)) (string->number (string-ref x\
    \ 1))))) (zip (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (string-append\
    \ (string-map (\u03BB (x) (if (equal? x #\\1) #\\0 #\\1)) a)\n               \
    \  (string-map (\u03BB (x) (if (equal? x #\\1) #\\0 #\\1)) b)))\n", "  (define\
    \ (xor-char a b)\n    (cond\n      [(string=? a \"0\") b]\n      [(string=? a\
    \ \"1\") (if (string=? b \"0\") \"1\" \"0\")]))\n  (string-join (map (lambda (x)\
    \ (xor-char (car x) (cadr x))) (zip (string->list a) (string->list b))) \"\"))\n",
  "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n\
    \      (string (bitwise-xor (string-&gt;number (string-ref a 0))\n           \
    \                (string-&gt;number (string-ref b 0))))\n      (string_xor (substring\
    \ a 1) (substring b 1)))]))\n</code>\n", "  (cond\n    [(empty? a) b]\n    [(empty?\
    \ b) a]\n    [else\n     (string-append\n      (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                           (string-&gt;number (string-ref\
    \ b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n</code>\n",
  "  (cond\n    [(string=? a \"\") b]\n    [(string=? b \"\") a]\n    [else (string-append\
    \ (string_xor (substring a 1) (substring b 1))\n                        (string\
    \ (xor (string->number (substring a 0 1))\n                                  \
    \   (string->number (substring b 0 1)))))]))\n", "  (string-join\n   (map\n  \
    \  (lambda (x)\n      (number->string (bitwise-xor (string->number (string-ref\
    \ x 0))\n                                   (string->number (string-ref x 1)))))\n\
    \    (string-split (string-append a b) \"\"))\n   \"\"))\n", "  (string-join\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref\
    \ x 0)) (string->number (string-ref x 1)))))\n        (map (lambda (x) (string\
    \ x)) (string-split (string-append a b) \"\")))\n   \"\"))\n", "  (string-append\
    \ (map (lambda (x) (number->string (xor (string-&gt;number (string x)) (string-&gt;number\
    \ (string x))))) (string-&gt;list a))))\n</code>\nI get the following error:\n\
    <code>string_xor.rkt:7:0: string_xor: unbound identifier in module in: string_xor\n\
    </code>\nI am not sure what is wrong with my code.\n\n\nA:\n\nThe problem is that\
    \ you're trying to use a function that's not defined in the current scope. The\
    \ <code>xor</code> function is defined in the <code>racket/base</code> module,\
    \ so you need to import it first:\n<code>(require racket/base)\n</code>\nAlso,\
    \ you're using <code>string-&gt;number</code> and <code>number-&gt;string</code>\
    \ in the wrong way, they're not unary functions, they expect a base as a second\
    \ argument, and you're using them with the wrong base. You need to use <code>string-&gt;number</code>\
    \ with base 2, and <code>number-&gt;string</code> with base 10:\n<code>(define\
    \ (string_xor a b)\n  (string-append (map (lambda (x) (number-&gt;string (xor\
    \ (string-&gt;number (string x) 2) (string-&gt;number (string x) 2)) 10)) (string-&gt;list\
    \ a))))\n</code>\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n\
    \     (string-append\n      (string\n       (if (equal? (first a) (first b))\n\
    \           #\\0\n           #\\1))\n      (string_xor (rest a) (rest b)))]))\n",
  "  (define (xor-char a b)\n    (if (equal? a b) \"0\" \"1\"))\n  (define (xor-string\
    \ a b)\n    (if (equal? (string-length a) 0) \"\"\n      (string-append (xor-char\
    \ (string-ref a 0) (string-ref b 0))\n                    (xor-string (substring\
    \ a 1) (substring b 1)))))\n  (xor-string a b))\n", "  (string-join\n   (map (lambda\
    \ (x) (number->string (bitwise-xor (string->number (string-ref x 0)) (string->number\
    \ (string-ref x 1)))))\n        (map (lambda (x) (string (string-ref a x) (string-ref\
    \ b x)))\n             (build-list (string-length a) (lambda (x) x))))))\n", " \
    \ (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string (bitwise-xor\
    \ (string-&gt;number (string-ref a 0))\n                          (string-&gt;number\
    \ (string-ref b 0))))\n     (string_xor (substring a 1) (substring b 1))]))\n\
    </code>\nThe problem is that the result is not a string, but a list of characters.\n\
    <code>&gt; (string_xor \"010\" \"110\")\n'(#\\1 #\\0 #\\0)\n</code>\nI tried to\
    \ use <code>string-join</code> but it doesn't work.\n<code>&gt; (string-join (string_xor\
    \ \"010\" \"110\"))", "  (string-join (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string-ref x 0)) (string->number (string-ref x 1))))) (zip\
    \ (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (cond\n    [(empty?\
    \ a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n      (string (bitwise-xor\
    \ (string-&gt;number (string-take a 1))\n                           (string-&gt;number\
    \ (string-take b 1))))\n      (string_xor (string-drop a 1) (string-drop b 1)))]))\n",
  "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n\
    \      (string (bitwise-xor (string-&gt;number (string-ref a 0))\n           \
    \                (string-&gt;number (string-ref b 0))))\n      (string_xor (substring\
    \ a 1) (substring b 1)))]))\n</code>\n", "  (string-join\n   (map (lambda (x)\
    \ (number->string (bitwise-xor (string->number (string-ref x 0)) (string->number\
    \ (string-ref x 1)))))\n        (map (lambda (x) (string x)) (string-split (string-append\
    \ a b) \"\")))\n   \"\"))\n", "  (define (xor-char a b)\n    (if (equal? a b)\n\
    \        #\\0\n        #\\1))\n  (string-join (map (lambda (x) (xor-char (car\
    \ x) (cadr x))) (zip (string->list a) (string->list b)))))\n", "  (cond\n    [(empty?\
    \ a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n      (string (bitwise-xor\
    \ (string-&gt;number (string-ref a 0))\n                           (string-&gt;number\
    \ (string-ref b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n\
    </code>\n", "  (define (xor a b)\n    (if (or (and (eq? a 0) (eq? b 1))\n    \
    \        (and (eq? a 1) (eq? b 0)))\n        1\n        0))\n  (define (string-&gt;list\
    \ s)\n    (if (eq? (string-length s) 0)\n        '()\n        (cons (string-&gt;number\
    \ (substring s 0 1))\n              (string-&gt;list (substring s 1)))))\n  (define\
    \ (list-&gt;string l)\n    (if (eq? (length l) 0)\n        \"\"\n        (string-append\
    \ (number-&gt;string (car l))\n                       (list-&gt;string (cdr l)))))\n\
    \  (list-&gt;string (map xor (string-&gt;list a) (string-&gt;list b))))\n</code>\n",
  "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (string x) 2) (string->number (string (cdr x)) 2))))\n        (zip (string-&gt;list\
    \ a) (string-&gt;list b)))\n   \"\"))\n", "  (string-join\n   (map (lambda (x)\
    \ (number->string (bitwise-xor (string->number (string x) 2) (string->number (string\
    \ (list-ref b (string-index x a))) 2))))\n        (string-&gt;list a))\n   \"\"\
    ))\n</code>\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string-ref x 0)) (string->number (string-ref x 1))))) (map\
    \ list (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (define (xor-char\
    \ a b)\n    (if (equal? a b)\n        #\\0\n        #\\1))\n  (define (xor-string\
    \ a b)\n    (if (equal? (string-length a) 0)\n        \"\"\n        (string-append\
    \ (string (xor-char (string-ref a 0) (string-ref b 0)))\n                    \
    \   (xor-string (substring a 1) (substring b 1)))))\n  (xor-string a b))\n", " \
    \ (define (xor-char a b)\n    (cond\n      [(and (char=? a #\\1) (char=? b #\\\
    0)) #\\1]\n      [(and (char=? a #\\0) (char=? b #\\1)) #\\1]\n      [else #\\\
    0]))\n  (define (xor-string a b)\n    (cond\n      [(empty? a) b]\n      [(empty?\
    \ b) a]\n      [else (cons (xor-char (first a) (first b)) (xor-string (rest a)\
    \ (rest b)))]))\n  (xor-string (string->list a) (string->list b)))\n", "  (string-join\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string->number (string x) 2)\
    \ (string->number (string (list-ref b (string-index x a))) 2))))\n        (string-&gt;list\
    \ a))\n   \"\"))\n</code>\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n\
    \    [else\n     (string-append\n      (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                           (string-&gt;number (string-ref\
    \ b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n</code>\n",
  "  (string-join (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref\
    \ x 0)) (string->number (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list\
    \ b))) \"\"))\n", "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string x) 2) (string->number (string (list-ref b (string-index\
    \ x a))) 2))))\n        (string-&gt;list a))\n   \"\"))\n</code>\n", "  (define\
    \ (xor-char a b)\n    (if (equal? a b)\n        #\\0\n        #\\1))\n  (define\
    \ (xor-string a b)\n    (string-append (list (xor-char (string-ref a 0) (string-ref\
    \ b 0)))\n                   (xor-string (substring a 1) (substring b 1))))\n\
    \  (if (equal? (string-length a) (string-length b))\n      (xor-string a b)\n\
    \      (error \"Strings must be of equal length\")))\n", "  (cond\n    [(and (string=?\
    \ a \"0\") (string=? b \"0\")) \"0\"]\n    [(and (string=? a \"0\") (string=?\
    \ b \"1\")) \"1\"]\n    [(and (string=? a \"1\") (string=? b \"0\")) \"1\"]\n\
    \    [(and (string=? a \"1\") (string=? b \"1\")) \"0\"]))\n", "  (define (xor-char\
    \ a b)\n    (cond ((and (equal? a #\\1) (equal? b #\\0)) #\\1)\n          ((and\
    \ (equal? a #\\0) (equal? b #\\1)) #\\1)\n          (else #\\0)))\n  (string-join\
    \ (map (lambda (x) (xor-char (car x) (cadr x))) (zip (string->list a) (string->list\
    \ b))) \"\"))\n", "  (define (xor-char a b)\n    (string (if (or (and (char=?\
    \ a #\\1) (char=? b #\\0))\n                    (and (char=? a #\\0) (char=? b\
    \ #\\1)))\n                #\\1\n                #\\0)))\n  (string-join (map\
    \ (lambda (x y) (xor-char x y)) (string->list a) (string->list b))))\n", "  (string-join\
    \ (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref x\
    \ 0)) (string->number (string-ref x 1))))) (map list (string-&gt;list a) (string-&gt;list\
    \ b))) \"\"))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n\
    \     (string-append\n      (string (bitwise-xor (string-&gt;number (string-ref\
    \ a 0))\n                           (string-&gt;number (string-ref b 0))))\n \
    \     (string_xor (substring a 1) (substring b 1)))]))\n</code>\n", "  (define\
    \ (xor-char c1 c2)\n    (if (equal? c1 c2)\n        #\\0\n        #\\1))\n  (string-append\
    \ (map (lambda (c1 c2) (xor-char c1 c2)) a b)))\n", "  (cond\n    [(empty? a)\
    \ b]\n    [(empty? b) a]\n    [else\n     (string-append\n      (string (bitwise-xor\
    \ (string-&gt;number (string-ref a 0))\n                           (string-&gt;number\
    \ (string-ref b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n\
    </code>\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n    \
    \ (string-append\n      (string (bitwise-xor (string-&gt;number (string-ref a\
    \ 0))\n                           (string-&gt;number (string-ref b 0))))\n   \
    \   (string_xor (substring a 1) (substring b 1)))]))\n</code>\n", "  (cond\n \
    \   [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n     \
    \ (string (bitwise-xor (string-&gt;number (string-take a 1))\n               \
    \            (string-&gt;number (string-take b 1))))\n      (string_xor (string-drop\
    \ a 1) (string-drop b 1)))]))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b)\
    \ a]\n    [else\n     (string-append\n      (string\n       (bitwise-xor\n   \
    \     (string-&gt;number (string-take a 1))\n        (string-&gt;number (string-take\
    \ b 1))))\n      (string_xor (string-drop a 1) (string-drop b 1)))]))\n</code>\n",
  "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n\
    \      (string-append\n       (string-append\n        (string-append\n       \
    \  (string-append\n          (string-append\n           (string-append\n     \
    \       (string-append\n             (string-append\n              (string-append\n\
    \               (string-append\n                (string-append\n             \
    \    (string-append\n                  (string-append\n                   (string-append\n\
    \                    (string-append\n                     (string-append\n   \
    \                   (string-append\n                       (string-append\n  \
    \                      (string-append\n                         (string-append\n\
    \                          (string-append\n                           (string-append\n\
    \                            (string-append\n                             (string-append\n\
    \                              (string-append\n                              \
    \ (string-append\n                                (string-append\n           \
    \                      (string-append\n                                  (string-append\n\
    \                                   (string-append\n                         \
    \           (string-append\n                                     (string-append\n\
    \                                      (string-append\n                      \
    \                 (string-append\n                                        (string-append\n\
    \                                         (string-append\n                   \
    \                       (string-append\n                                     \
    \      (string-append\n                                            (string-append\n\
    \                                             (string-append\n               \
    \                               (string-append\n                             \
    \                  (string-append\n                                          \
    \      (string-append\n                                                 (string-append\n\
    \                                                  (string-append\n          \
    \                                         (string-append\n                   \
    \                                 (string-append\n                           \
    \                          (string-append\n                                  \
    \                    (string-append\n                                        \
    \               (string-append\n                                             \
    \           (string-append\n                                                 \
    \        (string-append\n                                                    \
    \      (string-append\n                                                      \
    \     (string-append\n                                                       \
    \     (string-append\n                                                       \
    \      (string-append\n                                                      \
    \        (string-append\n                                                    \
    \           (string-append\n                                                 \
    \               (string-append\n                                             \
    \                    (string-append\n                                        \
    \                          (string-append\n                                  \
    \                                 (string-append\n                           \
    \                                         (string-append\n                   \
    \                                                  (string-append\n          \
    \                                                            (string-append\n\
    \                                ", "  (string-join (map (lambda (x) (if (equal?\
    \ (car x) (cadr x)) \"0\" \"1\")) (zip (string->list a) (string->list b))) \"\"\
    ))\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (string-ref x 0)) (string->number (string-ref x 1))))) (zip (string-&gt;list\
    \ a) (string-&gt;list b))) \"\"))\n", "  (let ([a (string->list a)]\n        [b\
    \ (string->list b)])\n    (string-join (map (lambda (x) (string (xor (car x) (cadr\
    \ x)))) (zip a b)))))\n", "  (define (xor-char a b)\n    (cond ((and (equal? a\
    \ #\\1) (equal? b #\\0)) #\\1)\n          ((and (equal? a #\\0) (equal? b #\\\
    1)) #\\1)\n          (else #\\0)))\n  (define (xor-string a b)\n    (cond ((equal?\
    \ (string-length a) 0) \"\")\n          ((equal? (string-length b) 0) \"\")\n\
    \          (else (string-append (string (xor-char (string-ref a 0) (string-ref\
    \ b 0)))\n                               (xor-string (substring a 1) (substring\
    \ b 1))))))\n  (xor-string a b))\n", "  (string-join (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string-ref x 0)) (string->number (string-ref x\
    \ 1))))) (zip (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (define\
    \ (xor-char a b)\n    (if (equal? a b)\n        #\\0\n        #\\1))\n  (define\
    \ (xor-chars a b)\n    (string-append (list (xor-char (string-ref a 0) (string-ref\
    \ b 0)))\n                   (xor-chars (string-drop a 1) (string-drop b 1))))\n\
    \  (if (equal? (string-length a) (string-length b))\n      (xor-chars a b)\n \
    \     (error \"Strings must be the same length\")))\n", "  (define (xor-char a\
    \ b)\n    (cond\n      [(char=? a b) #\\0]\n      [else #\\1]))\n  (string-join\
    \ (map (\u03BB (x) (xor-char (car x) (cadr x))) (zip (string->list a) (string->list\
    \ b))) \"\"))\n", "  (define (xor-char a b)\n    (if (equal? a b)\n        #\\\
    0\n        #\\1))\n  (string-map xor-char a b))\n", "  (string-join (map (lambda\
    \ (x) (number->string (bitwise-xor (string->number (string-ref x 0)) (string->number\
    \ (string-ref x 1))))) (map (lambda (x) (list (string-ref a x) (string-ref b x)))\
    \ (build-list (string-length a) (lambda (x) x)))) \"\"))\n", "  (define (xor-char\
    \ a b)\n    (cond\n      [(char=? a #\\0) b]\n      [(char=? a #\\1) (if (char=?\
    \ b #\\0) #\\1 #\\0)]))\n  (apply string (map xor-char (string->list a) (string->list\
    \ b))))\n", "  (string-join\n   (map\n    (lambda (x)\n      (number->string (bitwise-xor\
    \ (string->number (string-ref x 0))\n                                   (string->number\
    \ (string-ref x 1)))))\n    (map list (string->list a) (string->list b)))\n  \
    \ \"\"))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else (string_xor\
    \ (rest a) (rest b))]))\n", "  (string-join\n   (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string-ref x 0)) (string->number (string-ref x\
    \ 1)))))\n        (map (lambda (x) (string (string-ref a x) (string-ref b x)))\n\
    \             (build-list (string-length a) (lambda (x) x))))\n   \"\"))\n", " \
    \ (string-join (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref\
    \ x 0)) (string->number (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list\
    \ b))) \"\"))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n\
    \     (string-append\n      (string_xor (substring a 1) (substring b 1))\n   \
    \   (string (bitwise-xor (string-&gt;number (string-ref a 0))\n              \
    \             (string-&gt;number (string-ref b 0)))))]))\n</code>\n", "  (cond\n\
    \    [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n    \
    \  (string-append\n       (if (equal? (first a) (first b)) \"0\" \"1\")\n    \
    \   (string_xor (rest a) (rest b))))]))\n", "  (cond\n    [(empty? a) b]\n   \
    \ [(empty? b) a]\n    [else\n     (string-append\n      (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                           (string-&gt;number (string-ref\
    \ b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n</code>\n",
  "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (string-ref x 0)) (string->number (string-ref x 1)))))\n        (map (lambda\
    \ (x) (string (string-ref a x) (string-ref b x)))\n             (build-list (string-length\
    \ a) (lambda (x) x))))\n   \"\"))\n", "  (string-join (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string-ref x 0)) (string->number (string-ref x\
    \ 1))))) (string-split (string-append a b) \"\")) \"\"))\n", "  (cond\n    [(empty?\
    \ a) b]\n    [(empty? b) a]\n    [else (string-append (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0)) (string-&gt;number (string-ref b 0)))) (string_xor (substring\
    \ a 1) (substring b 1)))]))\n", "  (define (xor-char a b)\n    (if (or (and (equal?\
    \ a #\\1) (equal? b #\\0))\n            (and (equal? a #\\0) (equal? b #\\1)))\n\
    \        #\\1\n        #\\0))\n  (define (xor-string a b)\n    (if (equal? (string-length\
    \ a) 0)\n        \"\"\n        (string-append (list (xor-char (string-ref a 0)\
    \ (string-ref b 0)))\n                       (xor-string (substring a 1) (substring\
    \ b 1)))))\n  (xor-string a b))\n", "  (string-join (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string-ref x 0)) (string->number (string-ref x\
    \ 1))))) (zip (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (string-join\
    \ (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref x\
    \ 0)) (string->number (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list\
    \ b))) \"\"))\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string x) 2) (string->number (string x) 2)))) (string-&gt;list\
    \ a)) \"\"))\n</code>\nI'm getting an error:\n<code>string_xor: expects type &lt;string&gt;\
    \ as 1st argument, given: \"010\"; other arguments were: \"110\"\n</code>\nI'm\
    \ not sure what I'm doing wrong.\n\n\nA:\n\nThe problem is that <code>string-&gt;list</code>\
    \ returns a list of characters, not a list of strings. So you're trying to convert\
    \ <code>#\\0</code> to a number, which is not a string.\nYou can fix this by using\
    \ <code>string-ref</code> to get the characters from the strings, and then converting\
    \ them to numbers:\n<code>(define (string_xor a b)\n  (string-join (map (lambda\
    \ (x) (number-&gt;string (bitwise-xor (string-&gt;number (string (string-ref a\
    \ x)) 2)\n                                                             (string-&gt;number\
    \ (string (string-ref b x)) 2))))\n                    (build-list (string-length\
    \ a) add1))\n               \"\"))\n</code>\n", "  (string-join (map (lambda (x)\
    \ (number->string (bitwise-xor (string->number (string-ref x 0)) (string->number\
    \ (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list b))) \"\"))\n",
  "  (define (xor-char a b)\n    (if (equal? a b) \"0\" \"1\"))\n  (if (equal? (string-length\
    \ a) (string-length b))\n      (string-join (map (lambda (x y) (xor-char x y))\
    \ (string->list a) (string->list b)))\n      (error \"Inputs must be of equal\
    \ length\")))\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string-ref x 0)) (string->number (string-ref x 1))))) (zip\
    \ (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (if (or (empty? a) (empty?\
    \ b))\n      \"\"\n      (string (bitwise-xor (string-&gt;number (string-ref a\
    \ 0))\n                           (string-&gt;number (string-ref b 0))))\n   \
    \   (string_xor (substring a 1) (substring b 1))))\n</code>\nI'm not sure if this\
    \ is the best way to do it, but it works.\n\n\nA:\n\nI think you're overcomplicating\
    \ things.\n<code>(define (string-xor a b)\n  (string-&gt;list (string-append a\
    \ b)))\n</code>\n", "  (define (xor-char a b)\n    (if (equal? a b)\n        #\\\
    0\n        #\\1))\n  (string-join (map (lambda (x) (xor-char (car x) (cadr x)))\
    \ (zip (string->list a) (string->list b)))))\n", "  (string-join\n   (map\n  \
    \  (lambda (x)\n      (number->string (bitwise-xor (string->number (string-ref\
    \ x 0))\n                                   (string->number (string-ref x 1)))))\n\
    \    (string-zip a b))\n   \"\"))\n", "  (define (xor-char a b)\n    (cond\n \
    \     [(char=? a b) \"0\"]\n      [else \"1\"]))\n  (string-join (map xor-char\
    \ a b)))\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (string-ref x 0)) (string->number (string-ref x 1))))) (string-zip a b)) \"\"\
    ))\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (string-ref x 0)) (string->number (string-ref x 1))))) (zip (string-&gt;list\
    \ a) (string-&gt;list b))) \"\"))\n", "  (cond\n    [(empty? a) b]\n    [(empty?\
    \ b) a]\n    [else\n     (string-append\n      (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                           (string-&gt;number (string-ref\
    \ b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n</code>\n",
  "  (define (xor-char a b)\n    (cond\n      ((and (char=? a #\\0) (char=? b #\\\
    0)) #\\0)\n      ((and (char=? a #\\1) (char=? b #\\1)) #\\0)\n      (else #\\\
    1)))\n  (define (xor-string a b)\n    (cond\n      ((string=? a \"\") b)\n   \
    \   ((string=? b \"\") a)\n      (else (string-append (string (xor-char (string-ref\
    \ a 0) (string-ref b 0)))\n                           (xor-string (substring a\
    \ 1) (substring b 1))))))\n  (xor-string a b))\n", "  (cond\n    [(empty? a) b]\n\
    \    [(empty? b) a]\n    [else\n     (string-append\n      (string (bitwise-xor\
    \ (string-&gt;number (string-ref a 0))\n                           (string-&gt;number\
    \ (string-ref b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n\
    </code>\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n    \
    \ (string-append\n      (string (bitwise-xor (string-&gt;number (string-ref a\
    \ 0))\n                           (string-&gt;number (string-ref b 0))))\n   \
    \   (string_xor (substring a 1) (substring b 1)))]))\n</code>\n", "  (define (string-xor-iter\
    \ a b)\n    (if (or (null? a) (null? b))\n        '()\n        (cons (if (equal?\
    \ (car a) (car b))\n                  #\\0\n                  #\\1)\n        \
    \      (string-xor-iter (cdr a) (cdr b)))))\n  (list->string (string-xor-iter\
    \ (string->list a) (string->list b))))\n", "  (string-join (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string-ref x 0)) (string->number (string-ref x\
    \ 1))))) (zip (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (define\
    \ (xor-char a b)\n    (if (equal? a b)\n        #\\0\n        #\\1))\n  (string-join\
    \ (map (lambda (x) (xor-char (car x) (cadr x))) (zip (string->list a) (string->list\
    \ b)))))\n", "  (define (xor-char a b)\n    (cond\n      [(char=? a b) \"0\"]\n\
    \      [else \"1\"]))\n  (string-join (map (lambda (x) (xor-char (car x) (cadr\
    \ x))) (zip (string->list a) (string->list b))) \"\"))\n", "  (string-join (map\
    \ (lambda (x) (number->string (bitwise-xor (string->number (string-ref x 0)) (string->number\
    \ (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list b))) \"\"))\n",
  "  (string-join\n   (map\n    (lambda (x)\n      (number->string (bitwise-xor (string->number\
    \ (string-ref x 0))\n                                   (string->number (string-ref\
    \ x 1)))))\n    (map (lambda (x) (list (string-ref a x) (string-ref b x)))\n \
    \        (iota (string-length a))))))\n", "  (string-join (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string-ref x 0)) (string->number (string-ref x\
    \ 1))))) (zip (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (string-join\
    \ (map (\u03BB (x) (number->string (bitwise-xor (string->number (string-ref x\
    \ 0)) (string->number (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list\
    \ b))) \"\"))\n", "  (string-append (map (lambda (x) (if (equal? (car x) (cadr\
    \ x)) \"0\" \"1\")) (zip (string->list a) (string->list b)))))\n", "  (string-join\
    \ (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref x\
    \ 0)) (string->number (string-ref x 1))))) (map list (string-&gt;list a) (string-&gt;list\
    \ b))) \"\"))\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string-ref x 0)) (string->number (string-ref x 1))))) (zip\
    \ (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (let ([a (string->list\
    \ a)]\n        [b (string->list b)])\n    (list->string (map (lambda (x y) (if\
    \ (equal? x y) #\\0 #\\1)) a b))))\n", "  (string-join (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string-ref x 0)) (string->number (string-ref x\
    \ 1))))) (zip (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (define\
    \ (xor-char a b)\n    (cond\n      [(char=? a b) \"0\"]\n      [else \"1\"]))\n\
    \  (string-join (map (lambda (x) (xor-char (car x) (cadr x))) (zip (string->list\
    \ a) (string->list b))) \"\"))\n", "  (define (xor-char a b)\n    (if (or (and\
    \ (char=? a #\\1) (char=? b #\\0))\n            (and (char=? a #\\0) (char=? b\
    \ #\\1)))\n        #\\1\n        #\\0))\n  (define (xor-chars a b)\n    (if (or\
    \ (string-null? a) (string-null? b))\n        \"\"\n        (string-append (xor-char\
    \ (string-ref a 0) (string-ref b 0))\n                       (xor-chars (string-drop\
    \ a 1) (string-drop b 1)))))\n  (xor-chars a b))\n", "  (define (xor-char a b)\n\
    \    (cond\n      [(char=? a b) \"0\"]\n      [else \"1\"]))\n  (define (xor-string\
    \ a b)\n    (if (or (string=? a \"\") (string=? b \"\"))\n        \"\"\n     \
    \   (string-append (xor-char (string-ref a 0) (string-ref b 0))\n            \
    \           (xor-string (substring a 1) (substring b 1)))))\n  (xor-string a b))\n",
  "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else (string-append (string_xor\
    \ (rest a) (rest b))\n                         (string (bitwise-xor (string->number\
    \ (string (first a)))\n                                              (string->number\
    \ (string (first b))))))]))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b)\
    \ a]\n    [else\n     (string-append\n      (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                           (string-&gt;number (string-ref\
    \ b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n</code>\n",
  "  (define (xor-char a b)\n    (cond\n      [(char=? a b) '0]\n      [else '1]))\n\
    \  (string-join (map (lambda (a b) (xor-char a b)) a b)))\n", "  (cond\n    [(empty?\
    \ a) b]\n    [(empty? b) a]\n    [else (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                               (string-&gt;number (string-ref\
    \ b 0))))\n          (string_xor (substring a 1) (substring b 1))]))\n</code>\n",
  "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n\
    \      (string (bitwise-xor (string-&gt;number (string-ref a 0))\n           \
    \                (string-&gt;number (string-ref b 0))))\n      (string_xor (substring\
    \ a 1) (substring b 1)))]))\n</code>\n", "  (let ([a (string->list a)]\n     \
    \   [b (string->list b)])\n    (list->string (map (lambda (x y)\n            \
    \             (if (equal? x y)\n                             #\\0\n          \
    \                   #\\1))\n                       a b))))\n", "  (string-join\n\
    \   (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref\
    \ x 0)) (string->number (string-ref x 1)))))\n        (map (lambda (x) (string\
    \ (car x) (cadr x)))\n             (zip (string->list a) (string->list b))))))\n",
  "  (string-join (map (\u03BB (x) (number->string (bitwise-xor (string->number (string-ref\
    \ x 0)) (string->number (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list\
    \ b))) \"\"))\n", "  (define (xor-char a b)\n    (if (string=? a b) \"0\" \"1\"\
    ))\n  (string-join (map (lambda (x) (xor-char (string-ref a (car x)) (string-ref\
    \ b (car x)))) (iota (string-length a))) \"\"))\n", "  (define (xor-char a b)\n\
    \    (cond\n      [(char=? a #\\0) b]\n      [(char=? a #\\1) (if (char=? b #\\\
    0) #\\1 #\\0)]))\n  (string-append (list-&gt;string (map xor-char (string-&gt;list\
    \ a) (string-&gt;list b)))))\n</code>\n", "  (string-join (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string-ref x 0)) (string->number (string-ref x\
    \ 1))))) (zip (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (string-join\
    \ (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref x\
    \ 0)) (string->number (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list\
    \ b))) \"\"))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\
    \ (string-append (string (bitwise-xor (string-&gt;number (string-ref a 0)) (string-&gt;number\
    \ (string-ref b 0)))) (string_xor (substring a 1) (substring b 1)))]))\n", " \
    \ (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n\
    \      (string_xor (substring a 1) (substring b 1))\n      (string (bitwise-xor\
    \ (string-&gt;number (string-ref a 0))\n                           (string-&gt;number\
    \ (string-ref b 0)))))]))\n</code>\n", "  (cond\n    [(empty? a) b]\n    [(empty?\
    \ b) a]\n    [else (string (bitwise-xor (string-&gt;number (string-ref a 0))\n\
    \                               (string-&gt;number (string-ref b 0))))\n     \
    \     (string_xor (substring a 1) (substring b 1))]))\n</code>\n", "  (string-join\
    \ (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref x\
    \ 0)) (string->number (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list\
    \ b))) \"\"))\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string-ref x 0)) (string->number (string-ref x 1))))) (zip\
    \ (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (apply string (map (lambda\
    \ (x y) (xor x y)) (string->list a) (string->list b))))\n", "  (string-join\n\
    \   (map\n    (lambda (x)\n      (number->string (bitwise-xor (string->number\
    \ (string-ref x 0))\n                                   (string->number (string-ref\
    \ x 1)))))\n    (string-zip a b))\n   \"\"))\n", "  (string-join (map (lambda\
    \ (x) (number->string (bitwise-xor (string->number (string-ref x 0)) (string->number\
    \ (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list b))) \"\"))\n",
  "  (string-join (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref\
    \ x 0)) (string->number (string-ref x 1))))) (string-zip a b)) \"\"))\n", "  (string-join\
    \ (map (\u03BB (x) (number->string (bitwise-xor (string->number (string-ref x\
    \ 0)) (string->number (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list\
    \ b))) \"\"))\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string-ref x 0)) (string->number (string-ref x 1))))) (zip\
    \ (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (cond\n    [(empty?\
    \ a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n      (string (bitwise-xor\
    \ (string-&gt;number (string-ref a 0))\n                           (string-&gt;number\
    \ (string-ref b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n\
    </code>\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n    \
    \ (string-append\n      (string (bitwise-xor (string-&gt;number (string-ref a\
    \ 0))\n                           (string-&gt;number (string-ref b 0))))\n   \
    \   (string_xor (substring a 1) (substring b 1)))]))\n</code>\n", "  (cond\n \
    \   [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n     \
    \ (string-append\n       (if (equal? (first a) (first b)) \"0\" \"1\")\n     \
    \  (string_xor (rest a) (rest b)))\n      \"\")]))\n", "  (string-join (map (lambda\
    \ (x) (number->string (bitwise-xor (string->number (string-ref x 0)) (string->number\
    \ (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list b))) \"\"))\n",
  "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n\
    \      (string (bitwise-xor (string-&gt;number (string-ref a 0))\n           \
    \                (string-&gt;number (string-ref b 0))))\n      (string_xor (substring\
    \ a 1) (substring b 1)))]))\n</code>\n", "  (define (xor-char a b)\n    (if (equal?\
    \ a b) \"0\" \"1\"))\n  (define (xor-string a b)\n    (if (empty? a) \"\"\n  \
    \      (string-append (xor-char (first a) (first b))\n                       (xor-string\
    \ (rest a) (rest b)))))\n  (xor-string a b))\n", "  (string-join\n   (map (lambda\
    \ (x) (number->string (bitwise-xor (string->number (string x) 2) (string->number\
    \ (string (list-ref b (string-index x a))) 2))))\n        (string-&gt;list a))\n\
    \   \"\"))\n</code>\n", "  (define (xor-char a b)\n    (cond\n      [(= a b) \"\
    0\"]\n      [else \"1\"]))\n  (define (xor-chars a b)\n    (cond\n      [(empty?\
    \ a) b]\n      [(empty? b) a]\n      [else (string-append (xor-char (first a)\
    \ (first b))\n                           (xor-chars (rest a) (rest b)))]))\n \
    \ (xor-chars a b))\n", "  (string-append\n   (if (eq? (string-ref a 0) #\\1)\n\
    \       (string-append (substring a 1) (string-append #\\0 (substring b 1)))\n\
    \       (string-append (substring a 1) (string-append #\\1 (substring b 1))))))\n",
  "  (string-join (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref\
    \ x 0)) (string->number (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list\
    \ b))) \"\"))\n", "  (string-join (map (\u03BB (x) (number->string (bitwise-xor\
    \ (string->number (string-ref x 0)) (string->number (string-ref x 1))))) (map\
    \ list (string->list a) (string->list b))) \"\"))\n", "  (cond\n    [(empty? a)\
    \ b]\n    [(empty? b) a]\n    [else\n     (string-append\n      (string (bitwise-xor\
    \ (string-&gt;number (string-take a 1))\n                           (string-&gt;number\
    \ (string-take b 1))))\n      (string_xor (string-drop a 1) (string-drop b 1)))]))\n",
  "  (define (xor-char a b)\n    (cond\n      [(char=? a b) #\\0]\n      [else #\\\
    1]))\n  (define (xor-string a b)\n    (string-append\n      (list (xor-char (string-ref\
    \ a 0) (string-ref b 0)))\n      (xor-string (substring a 1) (substring b 1))))\n\
    \  (cond\n    [(string=? a \"\") b]\n    [(string=? b \"\") a]\n    [else (xor-string\
    \ a b)]))\n", "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string-ref x 0)) (string->number (string-ref x 1)))))\n   \
    \     (map list (string->list a) (string->list b)))\n   \"\"))\n", "  (string-join\
    \ (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref x\
    \ 0)) (string->number (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list\
    \ b))) \"\"))\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string-ref x 0)) (string->number (string-ref x 1))))) (map\
    \ list (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (cond\n    [(empty?\
    \ a) b]\n    [(empty? b) a]\n    [else (string-append (string_xor (rest a) (rest\
    \ b))\n                         (string (xor (string->number (string (first a)))\n\
    \                                      (string->number (string (first b))))))]))\n",
  "  (cond\n    [(string=? a \"\") b]\n    [(string=? b \"\") a]\n    [else (string-append\n\
    \           (string (bitwise-xor (string->number (substring a 0 1))\n        \
    \                        (string->number (substring b 0 1))))\n           (string_xor\
    \ (substring a 1) (substring b 1)))]))\n", "  (cond [(string=? a \"\") b]\n  \
    \      [(string=? b \"\") a]\n        [else (string-append (string_xor (substring\
    \ a 1) (substring b 1))\n                             (string (xor (string->number\
    \ (substring a 0 1))\n                                          (string->number\
    \ (substring b 0 1)))))]))\n", "  (string-join (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string-ref x 0)) (string->number (string-ref x\
    \ 1))))) (zip (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (define\
    \ (xor-char a b)\n    (if (equal? a b)\n        #\\0\n        #\\1))\n  (string-join\
    \ (map (lambda (x) (xor-char (car x) (cadr x))) (zip (string->list a) (string->list\
    \ b)))))\n", "  (define (xor-char a b)\n    (if (equal? a b) \"0\" \"1\"))\n \
    \ (if (and (equal? (string-length a) (string-length b))\n           (not (equal?\
    \ a \"\")))\n      (string-append (xor-char (string-ref a 0) (string-ref b 0))\n\
    \                     (string_xor (substring a 1) (substring b 1)))\n      \"\"\
    ))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n\
    \      (string (bitwise-xor (string-&gt;number (string-ref a 0))\n           \
    \                (string-&gt;number (string-ref b 0))))\n      (string_xor (substring\
    \ a 1) (substring b 1)))]))\n</code>\n", "  (define (xor-char a b)\n    (cond\
    \ ((and (char=? a #\\0) (char=? b #\\0)) #\\0)\n          ((and (char=? a #\\\
    1) (char=? b #\\1)) #\\0)\n          (else #\\1)))\n  (define (xor-string a b)\n\
    \    (cond ((string=? a \"\") b)\n          ((string=? b \"\") a)\n          (else\
    \ (string-append (string (xor-char (string-ref a 0) (string-ref b 0)))\n     \
    \                          (xor-string (substring a 1) (substring b 1))))))\n\
    \  (xor-string a b))\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string-ref x 0)) (string->number (string-ref x 1))))) (map\
    \ list (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (string-join (map\
    \ (lambda (x) (number->string (bitwise-xor (string->number (string-ref x 0)) (string->number\
    \ (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list b))) \"\"))\n",
  "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n\
    \      (string (bitwise-xor (string-&gt;number (string-ref a 0))\n           \
    \                (string-&gt;number (string-ref b 0))))\n      (string_xor (substring\
    \ a 1) (substring b 1)))]))\n</code>\n", "  (cond\n    [(empty? a) b]\n    [(empty?\
    \ b) a]\n    [else\n     (string-append\n      (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                           (string-&gt;number (string-ref\
    \ b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n</code>\n",
  "  (string-join (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref\
    \ x 0)) (string->number (string-ref x 1))))) (map list (string-&gt;list a) (string-&gt;list\
    \ b))) \"\"))\n", "  (define (xor-char a b)\n    (cond ((and (char=? a #\\0) (char=?\
    \ b #\\0)) #\\0)\n          ((and (char=? a #\\1) (char=? b #\\1)) #\\0)\n   \
    \       (else #\\1)))\n  (define (xor-string a b)\n    (if (or (string-null? a)\
    \ (string-null? b))\n        \"\"\n        (string-append (string (xor-char (string-ref\
    \ a 0) (string-ref b 0)))\n                       (xor-string (substring a 1)\
    \ (substring b 1)))))\n  (xor-string a b))\n", "  (cond\n    [(empty? a) b]\n\
    \    [(empty? b) a]\n    [else\n     (string-append\n      (string (bitwise-xor\
    \ (string-&gt;number (string-take a 1))\n                           (string-&gt;number\
    \ (string-take b 1))))\n      (string_xor (string-drop a 1) (string-drop b 1)))]))\n",
  "  (define (xor-char a b)\n    (if (equal? a b)\n        #\\0\n        #\\1))\n\
    \  (string-join (map (lambda (x) (xor-char (car x) (cadr x))) (zip (string->list\
    \ a) (string->list b)))))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n\
    \    [else (string-append (string (bitwise-xor (string-&gt;number (string-take\
    \ a 1)) (string-&gt;number (string-take b 1)))) (string_xor (string-drop a 1)\
    \ (string-drop b 1)))]))\n", "  (string-join (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string-ref x 0)) (string->number (string-ref x\
    \ 1))))) (map list (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (define\
    \ (xor-char a b)\n    (cond ((and (char=? a #\\0) (char=? b #\\0)) #\\0)\n   \
    \       ((and (char=? a #\\1) (char=? b #\\1)) #\\0)\n          (else #\\1)))\n\
    \  (define (xor-string a b)\n    (if (or (string-null? a) (string-null? b))\n\
    \        \"\"\n        (string-append (string (xor-char (string-ref a 0) (string-ref\
    \ b 0)))\n                       (xor-string (substring a 1) (substring b 1)))))\n\
    \  (xor-string a b))\n", "  (string-append\n   (if (equal? (string-ref a 0) #\\\
    1)\n       (string-append (string-ref a 0) (string-ref b 0))\n       (string-append\
    \ (string-ref a 0) (string-ref b 0)))\n   (if (equal? (string-ref a 1) #\\1)\n\
    \       (string-append (string-ref a 1) (string-ref b 1))\n       (string-append\
    \ (string-ref a 1) (string-ref b 1)))\n   (if (equal? (string-ref a 2) #\\1)\n\
    \       (string-append (string-ref a 2) (string-ref b 2))\n       (string-append\
    \ (string-ref a 2) (string-ref b 2)))))\n", "  (string-join\n   (map (lambda (x)\
    \ (number->string (bitwise-xor (string->number (string-ref x 0)) (string->number\
    \ (string-ref x 1)))))\n        (map (lambda (x) (string (car x) (cadr x)))\n\
    \             (zip (string->list a) (string->list b))))))\n", "  (cond\n    [(empty?\
    \ a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n      (string (bitwise-xor\
    \ (string-&gt;number (string-ref a 0))\n                           (string-&gt;number\
    \ (string-ref b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n\
    </code>\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (string-ref x 0)) (string->number (string-ref x 1))))) (zip (string-&gt;list\
    \ a) (string-&gt;list b))) \"\"))\n", "  (cond\n    [(empty? a) b]\n    [(empty?\
    \ b) a]\n    [else\n     (string-append\n      (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                           (string-&gt;number (string-ref\
    \ b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n</code>\n",
  "  (string-join (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref\
    \ x 0)) (string->number (string-ref x 1))))) (zip (string-&gt;list a) (string-&gt;list\
    \ b))) \"\"))\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string-ref x 0)) (string->number (string-ref x 1))))) (map\
    \ list (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (cond\n    [(empty?\
    \ a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n      (string-append\n\
    \       (if (equal? (first a) (first b)) \"0\" \"1\")\n       (string_xor (rest\
    \ a) (rest b))))]))\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string-ref x 0)) (string->number (string-ref x 1))))) (map\
    \ list (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (cond\n    [(empty?\
    \ a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n      (string (bitwise-xor\
    \ (string-&gt;number (string-ref a 0))\n                           (string-&gt;number\
    \ (string-ref b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n\
    </code>\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (string-ref x 0)) (string->number (string-ref x 1))))) (zip (string-&gt;list\
    \ a) (string-&gt;list b))) \"\"))\n", "  (cond\n    [(empty? a) b]\n    [(empty?\
    \ b) a]\n    [else\n     (string-append\n      (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                           (string-&gt;number (string-ref\
    \ b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n</code>\n",
  "  (define (xor-char a b)\n    (cond\n      [(char=? a #\\0) b]\n      [(char=?\
    \ a #\\1) (if (char=? b #\\0) #\\1 #\\0)]))\n  (string-join (map (lambda (x) (xor-char\
    \ (car x) (cadr x))) (zip (string->list a) (string->list b))) \"\"))\n", "  (apply\
    \ string (map (lambda (x y) (xor x y)) (string->list a) (string->list b))))\n",
  "  (define (xor-char a b)\n    (cond\n      [(char=? a b) \"0\"]\n      [else \"\
    1\"]))\n  (string-join (map (lambda (x) (xor-char (car x) (cadr x))) (zip (string->list\
    \ a) (string->list b))) \"\"))\n", "  (string-append (map (lambda (x y) (if (equal?\
    \ x y) #\\0 #\\1)) a b)))\n", "  (string-join (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string x) 2) (string->number (string x) 2))))\
    \ (string-&gt;list a)) \"\"))\n</code>\nI get the error:\n<code>string_xor: expects\
    \ type &lt;string&gt; as 1st argument, given: \"010\"; other arguments were: \"\
    110\"\n</code>\nI'm not sure what's going on here.\n\n\nA:\n\nYou have a typo\
    \ in your code, you're using <code>string-&gt;list</code> instead of <code>string-&gt;list</code>.\n\
    Also, you're using <code>string</code> when you should be using <code>list-ref</code>,\
    \ and you're using <code>string-join</code> when you should be using <code>list-&gt;string</code>.\n\
    Here's a fixed version:\n<code>(define (string_xor a b)\n  (list-&gt;string\n\
    \   (map (lambda (x) (number-&gt;string (bitwise-xor (string-&gt;number (list-ref\
    \ a x) 2)\n                                                 (string-&gt;number\
    \ (list-ref b x) 2))))\n        (build-list (string-length a) identity))))\n</code>\n",
  "  (define (xor-char a b)\n    (cond ((and (char=? a #\\0) (char=? b #\\0)) #\\\
    0)\n          ((and (char=? a #\\1) (char=? b #\\1)) #\\0)\n          (else #\\\
    1)))\n  (define (xor-string a b)\n    (if (or (string-null? a) (string-null? b))\n\
    \        \"\"\n        (string-append (string (xor-char (string-ref a 0) (string-ref\
    \ b 0)))\n                       (xor-string (substring a 1) (substring b 1)))))\n\
    \  (xor-string a b))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n  \
    \  [else\n     (string-append\n      (string (bitwise-xor (string-&gt;number (string-ref\
    \ a 0))\n                           (string-&gt;number (string-ref b 0))))\n \
    \     (string_xor (substring a 1) (substring b 1)))]))\n</code>\n", "  (cond\n\
    \    [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n    \
    \  (string (bitwise-xor (string-&gt;number (string-ref a 0))\n               \
    \            (string-&gt;number (string-ref b 0))))\n      (string_xor (substring\
    \ a 1) (substring b 1)))]))\n</code>\n", "  (cond\n    [(empty? a) b]\n    [(empty?\
    \ b) a]\n    [else (string-append (string_xor (rest a) (rest b))\n           \
    \              (number->string (bitwise-xor (string->number (first a))\n     \
    \                                                 (string->number (first b)))))]))\n",
  "  (let ([a (string->list a)]\n        [b (string->list b)])\n    (string-join (map\
    \ (lambda (x) (if (equal? (car x) (cadr x)) \"0\" \"1\")) (list-zip a b)))))\n",
  "  (define (xor-char a b)\n    (if (equal? a b)\n        #\\0\n        #\\1))\n\
    \  (define (xor-string a b)\n    (if (equal? (string-length a) 0)\n        \"\"\
    \n        (string-append (string (xor-char (string-ref a 0) (string-ref b 0)))\n\
    \                       (xor-string (substring a 1) (substring b 1)))))\n  (xor-string\
    \ a b))\n", "  (define (xor-char a b)\n    (cond\n      [(char=? a b) \"0\"]\n\
    \      [else \"1\"]))\n  (string-join (map (lambda (x) (xor-char (car x) (cadr\
    \ x))) (zip (string->list a) (string->list b))) \"\"))\n", "  (string-join\n \
    \  (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref x\
    \ 0)) (string->number (string-ref x 1)))))\n        (map (lambda (x) (string (car\
    \ x) (cadr x)))\n             (map (lambda (x) (list (string-ref a x) (string-ref\
    \ b x)))\n                  (build-list (string-length a) (lambda (x) x)))))))\n",
  "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n\
    \      (string (bitwise-xor (string-&gt;number (string-take a 1))\n          \
    \                 (string-&gt;number (string-take b 1))))\n      (string_xor (string-drop\
    \ a 1) (string-drop b 1)))]))\n", "  (string-join (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string-ref x 0)) (string->number (string-ref x\
    \ 1))))) (zip (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (string-join\
    \ (map (lambda (x) (number->string (bitwise-xor (string->number (string-ref x\
    \ 0)) (string->number (string-ref x 1))))) (map (lambda (x) (list (string-ref\
    \ a x) (string-ref b x))) (build-list (string-length a) (lambda (x) x)))) \"\"\
    ))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else (string_xor\
    \ (rest a) (rest b))]))\n", "  (define (xor a b)\n    (cond ((and (eq? a 0) (eq?\
    \ b 0)) 0)\n          ((and (eq? a 1) (eq? b 1)) 0)\n          (else 1)))\n  (define\
    \ (xor-string a b)\n    (cond ((null? a) b)\n          ((null? b) a)\n       \
    \   (else (cons (xor (car a) (car b)) (xor-string (cdr a) (cdr b))))))\n  (string-&gt;number\
    \ (list-&gt;string (xor-string (string-&gt;list a) (string-&gt;list b)))))\n</code>\n",
  "  (string-join\n   (map (lambda (x) (number->string (bitwise-xor (string->number\
    \ (string-ref x 0)) (string->number (string-ref x 1)))))\n        (map (lambda\
    \ (x) (string x)) (string-split (string-append a b) \"\")))\n   \"\"))\n", " \
    \ (define (xor-char a b)\n    (cond ((and (char=? a #\\0) (char=? b #\\0)) #\\\
    0)\n          ((and (char=? a #\\1) (char=? b #\\1)) #\\0)\n          (else #\\\
    1)))\n  (string-append (map (lambda (x) (xor-char (car x) (cadr x))) (zip (string->list\
    \ a) (string->list b)))))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n\
    \    [else\n     (string-append\n      (string (bitwise-xor (string-&gt;number\
    \ (string-ref a 0))\n                           (string-&gt;number (string-ref\
    \ b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n</code>\n",
  "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n\
    \      (string (bitwise-xor (string-&gt;number (string-ref a 0))\n           \
    \                (string-&gt;number (string-ref b 0))))\n      (string_xor (substring\
    \ a 1) (substring b 1)))]))\n</code>\n", "  (define (xor-char a b)\n    (cond\n\
    \      [(char=? a b) \"0\"]\n      [else \"1\"]))\n  (string-join (map (lambda\
    \ (x) (xor-char (car x) (cadr x))) (zip (string->list a) (string->list b))) \"\
    \"))\n", "  (cond\n    [(string=? a \"\") b]\n    [(string=? b \"\") a]\n    [else\
    \ (string-append (string_xor (substring a 1) (substring b 1))\n              \
    \          (string (logxor (string->number (substring a 0 1))\n              \
    \                          (string->number (substring b 0 1)))))]))\n", "  (define\
    \ (xor-char a b)\n    (cond\n      [(char=? a b) \"0\"]\n      [else \"1\"]))\n\
    \  (string-join (map xor-char a b)))\n", "  (string-join (map (lambda (x) (if\
    \ (equal? (car x) (cadr x)) \"0\" \"1\")) (list-zip (string->list a) (string->list\
    \ b))) \"\"))\n", "  (string-join (map (lambda (x) (number->string (bitwise-xor\
    \ (string->number (string-ref x 0)) (string->number (string-ref x 1))))) (map\
    \ list (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (cond\n    [(empty?\
    \ a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n      (string (bitwise-xor\
    \ (string-&gt;number (string-ref a 0))\n                           (string-&gt;number\
    \ (string-ref b 0))))\n      (string_xor (substring a 1) (substring b 1)))]))\n\
    </code>\n", "  (string-join (map (lambda (x) (number->string (xor (string-&gt;number\
    \ (string-ref x 0)) (string-&gt;number (string-ref x 1))))) (map list (string-&gt;list\
    \ a) (string-&gt;list b))) \"\"))\n", "  (cond\n    [(empty? a) b]\n    [(empty?\
    \ b) a]\n    [else\n     (string-append\n      (string-append\n       (string-append\n\
    \        (string-append\n         (string-append\n          (string-append\n \
    \          (string-append\n            (string-append\n             (string-append\n\
    \              (string-append\n               (string-append\n               \
    \ (string-append\n                 (string-append\n                  (string-append\n\
    \                   (string-append\n                    (string-append\n     \
    \                (string-append\n                      (string-append\n      \
    \                 (string-append\n                        (string-append\n   \
    \                      (string-append\n                          (string-append\n\
    \                           (string-append\n                            (string-append\n\
    \                             (string-append\n                              (string-append\n\
    \                               (string-append\n                             \
    \   (string-append\n                                 (string-append\n        \
    \                          (string-append\n                                  \
    \ (string-append\n                                    (string-append\n       \
    \                              (string-append\n                              \
    \        (string-append\n                                       (string-append\n\
    \                                        (string-append\n                    \
    \                     (string-append\n                                       \
    \   (string-append\n                                           (string-append\n\
    \                                            (string-append\n                \
    \                             (string-append\n                               \
    \               (string-append\n                                             \
    \  (string-append\n                                                (string-append\n\
    \                                                 (string-append\n           \
    \                                       (string-append\n                     \
    \                              (string-append\n                              \
    \                      (string-append\n                                      \
    \               (string-append\n                                             \
    \         (string-append\n                                                   \
    \    (string-append\n                                                        (string-append\n\
    \                                                         (string-append\n   \
    \                                                       (string-append\n     \
    \                                                      (string-append\n      \
    \                                                      (string-append\n      \
    \                                                       (string-append\n     \
    \                                                         (string-append\n   \
    \                                                            (string-append\n\
    \                                                                (string-append\n\
    \                                                                 (string-append\n\
    \                                                                  (string-append\n\
    \                                                                   (string-append\n\
    \                                                                    (string-append\n\
    \                                                                     (string-append\n\
    \                                                                      (string-append\n\
    \                                ", "  (cond\n    [(string=? a \"\") b]\n    [(string=?\
    \ b \"\") a]\n    [else (string-append\n           (string_xor (substring a 1)\
    \ (substring b 1))\n           (if (string=? (substring a 0 1) (substring b 0\
    \ 1)) \"0\" \"1\"))]))\n", "  (define (xor-char a b)\n    (if (eq? a b)\n    \
    \    #\\0\n        #\\1))\n  (string-join (map (lambda (a b) (xor-char a b)) a\
    \ b)))\n", "  (cond\n    [(empty? a) b]\n    [(empty? b) a]\n    [else\n     (string-append\n\
    \      (string (bitwise-xor (string-&gt;number (string-ref a 0))\n           \
    \                (string-&gt;number (string-ref b 0))))\n      (string_xor (substring\
    \ a 1) (substring b 1)))]))\n</code>\n", "  (string-join (map (lambda (x) (number->string\
    \ (bitwise-xor (string->number (string-ref x 0)) (string->number (string-ref x\
    \ 1))))) (zip (string-&gt;list a) (string-&gt;list b))) \"\"))\n", "  (cond\n\
    \    [(empty? a) b]\n    [(empty? b) a]\n    [else (string-append (string_xor\
    \ (rest a) (rest b))\n                         (string (xor (string->number (string\
    \ (first a)))\n                                      (string->number (string (first\
    \ b))))))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
