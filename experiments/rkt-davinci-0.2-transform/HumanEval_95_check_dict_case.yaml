name: HumanEval_95_check_dict_case
language: rkt
prompt: "#lang racket\n\n;; Given a dictionary, return True if all keys are strings\
  \ in lower \n;; case or all keys are strings in upper case, else return False.\n\
  ;; The function should return False is the given dictionary is empty.\n;; Examples:\n\
  ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"b\" .  \"banana\")))\n;; #t\n\
  ;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (\"A\" .  \"banana\") (\"B\"\
  \ .  \"banana\")))\n;; #f\n;; >>> (check_dict_case #hash((\"a\" .  \"apple\") (8\
  \ .  \"banana\") (\"a\" .  \"apple\")))\n;; #f\n;; >>> (check_dict_case #hash((\"\
  Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\")))\n;; #f\n;; >>>\
  \ (check_dict_case #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"12345\")))\n;; #t\n\
  (define (check_dict_case dict)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate check_dict_case))\n\
  \    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (\"b\" .  \"banana\"\
  ))) #t)\n    (check-equal? (candidate #hash((\"p\" .  \"pineapple\") (\"A\" .  \"\
  banana\") (\"B\" .  \"banana\"))) #f)\n    (check-equal? (candidate #hash((\"p\"\
  \ .  \"pineapple\") (\"5\" .  \"banana\") (\"a\" .  \"apple\"))) #f)\n    (check-equal?\
  \ (candidate #hash((\"Name\" .  \"John\") (\"Age\" .  \"36\") (\"City\" .  \"Houston\"\
  ))) #f)\n    (check-equal? (candidate #hash((\"STATE\" .  \"NC\") (\"ZIP\" .  \"\
  12345\"))) #t)\n    (check-equal? (candidate #hash((\"fruit\" .  \"Orange\") (\"\
  taste\" .  \"Sweet\"))) #t)\n    (check-equal? (candidate #hash()) #f)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? dict) #f]\n    [(and (string? (hash-ref dict\
    \ (hash-key dict)))\n          (string-ci=? (hash-ref dict (hash-key dict))\n\
    \                       (string-downcase (hash-ref dict (hash-key dict)))))\n\
    \     (check_dict_case (hash-remove dict (hash-key dict)))]\n    [(and (string?\
    \ (hash-ref dict (hash-key dict)))\n          (string-ci=? (hash-ref dict (hash-key\
    \ dict))\n                       (string-upcase (hash-ref dict (hash-key dict)))))\n\
    \     (check_dict_case (hash-remove dict (hash-key dict)))]\n    [else #f]))\n",
  "  (cond\n    [(empty? dict) #f]\n    [(and (string? (hash-ref dict (hash-keys dict\
    \ 0)))\n          (string-ci=? (hash-ref dict (hash-keys dict 0))\n          \
    \              (string-upcase (hash-ref dict (hash-keys dict 0)))))\n     (check-dict-case-helper\
    \ dict)]\n    [(and (string? (hash-ref dict (hash-keys dict 0)))\n          (string-ci=?\
    \ (hash-ref dict (hash-keys dict 0))\n                        (string-downcase\
    \ (hash-ref dict (hash-keys dict 0)))))\n     (check-dict-case-helper dict)]\n\
    \    [else #f]))\n", "  (if (empty? dict)\n      #f\n      (let ([keys (hash-keys\
    \ dict)])\n        (if (andmap string? keys)\n            (if (andmap (\u03BB\
    \ (x) (string-ci=? x (string-downcase x))) keys)\n                #t\n       \
    \         (andmap (\u03BB (x) (string-ci=? x (string-upcase x))) keys))\n    \
    \        #f))))\n", "  (if (empty? dict)\n      #f\n      (let ([keys (hash-keys\
    \ dict)])\n        (if (andmap string? keys)\n            (if (andmap (lambda\
    \ (x) (string-ci=? x (string-downcase x))) keys)\n                #t\n       \
    \         (andmap (lambda (x) (string-ci=? x (string-upcase x))) keys))\n    \
    \        #f))))\n", "  (if (empty? dict)\n      #f\n      (let ([keys (hash-keys\
    \ dict)])\n        (if (andmap (\u03BB (x) (string? x)) keys)\n            (if\
    \ (andmap (\u03BB (x) (string-ci=? x (string-upcase x))) keys)\n             \
    \   #t\n                #f)\n            #f))))\n</code>\n", "  (cond\n    [(empty?\
    \ dict) #f]\n    [(and (string? (hash-ref dict (hash-keys dict 0)))\n        \
    \  (string-ci=? (string-upcase (hash-ref dict (hash-keys dict 0)))\n         \
    \              (hash-ref dict (hash-keys dict 0))))\n     (check-dict-case (hash-remove\
    \ dict (hash-keys dict 0)))]\n    [(and (string? (hash-ref dict (hash-keys dict\
    \ 0)))\n          (string-ci=? (string-downcase (hash-ref dict (hash-keys dict\
    \ 0)))\n                       (hash-ref dict (hash-keys dict 0))))\n     (check-dict-case\
    \ (hash-remove dict (hash-keys dict 0)))]\n    [else #f]))\n", "  (cond\n    [(empty?\
    \ dict) #f]\n    [(and (string? (hash-ref dict (hash-key dict)))\n          (string-ci=?\
    \ (hash-ref dict (hash-key dict))\n                        (string-downcase (hash-ref\
    \ dict (hash-key dict)))))\n     (check_dict_case (hash-remove dict (hash-key\
    \ dict)))]\n    [(and (string? (hash-ref dict (hash-key dict)))\n          (string-ci=?\
    \ (hash-ref dict (hash-key dict))\n                        (string-upcase (hash-ref\
    \ dict (hash-key dict)))))\n     (check_dict_case (hash-remove dict (hash-key\
    \ dict)))]\n    [else #f]))\n", "  (cond\n    [(empty? dict) #f]\n    [(and (string?\
    \ (hash-ref dict (hash-key dict)))\n          (string-ci=? (hash-ref dict (hash-key\
    \ dict)) (hash-ref dict (hash-key dict))))\n     (check_dict_case (hash-remove\
    \ dict (hash-key dict)))]\n    [else #f]))\n", "  (let ([keys (hash-keys dict)])\n\
    \    (cond\n      [(empty? keys) #f]\n      [(andmap string? keys) #t]\n     \
    \ [(andmap symbol? keys) #t]\n      [else #f])))\n", "  (cond\n    [(empty? dict)\
    \ #f]\n    [(and (string? (hash-ref dict (hash-keys dict 0)))\n          (string-ci=?\
    \ (string-upcase (hash-ref dict (hash-keys dict 0)))\n                       (hash-ref\
    \ dict (hash-keys dict 0))))\n     (check_dict_case (hash-remove dict (hash-keys\
    \ dict 0)))]\n    [(and (string? (hash-ref dict (hash-keys dict 0)))\n       \
    \   (string-ci=? (string-downcase (hash-ref dict (hash-keys dict 0)))\n      \
    \                 (hash-ref dict (hash-keys dict 0))))\n     (check_dict_case\
    \ (hash-remove dict (hash-keys dict 0)))]\n    [else #f]))\n", "  (cond\n    [(empty?\
    \ dict) #f]\n    [(and (string? (hash-ref dict (hash-keys dict 0)))\n        \
    \  (string-ci=? (hash-ref dict (hash-keys dict 0))\n                        (string-upcase\
    \ (hash-ref dict (hash-keys dict 0)))))\n     (check-dict-case-helper dict)]\n\
    \    [(and (string? (hash-ref dict (hash-keys dict 0)))\n          (string-ci=?\
    \ (hash-ref dict (hash-keys dict 0))\n                        (string-downcase\
    \ (hash-ref dict (hash-keys dict 0)))))\n     (check-dict-case-helper dict)]\n\
    \    [else #f]))\n", "  (cond\n    [(empty? dict) #f]\n    [(and (string? (hash-ref\
    \ dict (hash-key dict)))\n          (string-ci=? (hash-ref dict (hash-key dict))\
    \ (hash-ref dict (hash-key dict))))\n     (check_dict_case (hash-remove dict (hash-key\
    \ dict)))]\n    [else #f]))\n", "  (cond\n    [(empty? dict) #f]\n    [(and (string?\
    \ (hash-ref dict (hash-key dict)))\n          (string? (hash-ref dict (hash-key\
    \ (hash-rest dict))))\n          (string-ci=? (hash-ref dict (hash-key dict))\n\
    \                       (hash-ref dict (hash-key (hash-rest dict)))))\n     (check_dict_case\
    \ (hash-rest (hash-rest dict)))]\n    [else #f]))\n", "  (cond\n    [(empty? dict)\
    \ #f]\n    [(and (string? (hash-ref dict (hash-key dict)))\n          (string-ci=?\
    \ (hash-ref dict (hash-key dict)) \"apple\")) #t]\n    [else #f]))\n</code>\n\
    I am trying to check if the first key is a string and if the value is \"apple\"\
    . If it is, then return true. If not, return false. I am getting an error:\n<code>hash-ref:\
    \ expects type &lt;hash-table&gt; as 1st argument, given: \"apple\"; other arguments\
    \ were: \"a\"\n</code>\nI am not sure what I am doing wrong.\n\n\nA:\n\nThe problem\
    \ is that <code>hash-ref</code> expects a hash table as its first argument, but\
    \ you're passing it a string. You can fix it by using <code>hash-ref</code> twice,\
    \ first to get the value of the first key, and then to get the value of the key\
    \ <code>\"apple\"</code>:\n<code>(define (check_dict_case dict)\n  (cond\n   \
    \ [(empty? dict) #f]\n    [(and (string? (hash-ref dict (hash-key dict)))\n  \
    \        (string-ci=? (hash-ref dict (hash-ref dict (hash-key dict))) \"apple\"\
    )) #t]\n    [else #f]))\n</code>\n", "  (cond\n    [(empty? dict) #f]\n    [(and\
    \ (string? (hash-ref dict (hash-key dict)))\n          (string-ci=? (hash-ref\
    \ dict (hash-key dict))\n                       (string-downcase (hash-ref dict\
    \ (hash-key dict)))))\n     (check_dict_case (hash-remove dict (hash-key dict)))]\n\
    \    [(and (string? (hash-ref dict (hash-key dict)))\n          (string-ci=? (hash-ref\
    \ dict (hash-key dict))\n                       (string-upcase (hash-ref dict\
    \ (hash-key dict)))))\n     (check_dict_case (hash-remove dict (hash-key dict)))]\n\
    \    [else #f]))\n", "  (define (check-keys dict)\n    (cond ((empty? dict) #t)\n\
    \          ((and (string? (key dict))\n                (string-ci=? (key dict)\
    \ (key dict)))\n           (check-keys (rest dict)))\n          (else #f)))\n\
    \  (check-keys dict))\n</code>\n", "  (cond\n    [(empty? dict) #f]\n    [(and\
    \ (string? (hash-ref dict (hash-keys dict 0)))\n          (string-ci=? (string-upcase\
    \ (hash-ref dict (hash-keys dict 0)))\n                       (hash-ref dict (hash-keys\
    \ dict 0))))\n     (check_dict_case (hash-remove dict (hash-keys dict 0)))]\n\
    \    [(and (string? (hash-ref dict (hash-keys dict 0)))\n          (string-ci=?\
    \ (string-downcase (hash-ref dict (hash-keys dict 0)))\n                     \
    \  (hash-ref dict (hash-keys dict 0))))\n     (check_dict_case (hash-remove dict\
    \ (hash-keys dict 0)))]\n    [else #f]))\n", "  (if (empty? dict)\n      #f\n\
    \      (let ([keys (hash-keys dict)])\n        (if (andmap string? keys)\n   \
    \         (let ([lower-keys (map string-downcase keys)])\n              (equal?\
    \ keys lower-keys))\n            (let ([upper-keys (map string-upcase keys)])\n\
    \              (equal? keys upper-keys))))))\n", "  (cond\n    [(empty? dict)\
    \ #f]\n    [(and (string? (hash-ref dict (hash-key dict)))\n          (string?\
    \ (hash-ref dict (hash-key (hash-rest dict))))\n          (string-ci=? (hash-ref\
    \ dict (hash-key dict))\n                       (hash-ref dict (hash-key (hash-rest\
    \ dict)))))\n     (check_dict_case (hash-rest (hash-rest dict)))]\n    [else #f]))\n",
  "  (cond\n    [(empty? dict) false]\n    [(and (string? (hash-ref dict (hash-key\
    \ dict)))\n          (string-ci=? (hash-ref dict (hash-key dict))\n          \
    \             (string-upcase (hash-ref dict (hash-key dict)))))\n     (check-dict-case\
    \ (hash-remove dict (hash-key dict)))]\n    [(and (string? (hash-ref dict (hash-key\
    \ dict)))\n          (string-ci=? (hash-ref dict (hash-key dict))\n          \
    \             (string-downcase (hash-ref dict (hash-key dict)))))\n     (check-dict-case\
    \ (hash-remove dict (hash-key dict)))]\n    [else false]))\n</code>\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
