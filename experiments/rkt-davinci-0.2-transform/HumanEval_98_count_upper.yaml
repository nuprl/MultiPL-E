name: HumanEval_98_count_upper
language: rkt
prompt: "#lang racket\n\n;; Given a string s, count the number of uppercase vowels\
  \ in even indices.\n;; For example:\n;; >>> (count_upper \"aBCdEf\")\n;; 1\n;; >>>\
  \ (count_upper \"abcdefg\")\n;; 0\n;; >>> (count_upper \"dBBE\")\n;; 0\n(define\
  \ (count_upper s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate count_upper))\n\
  \    (check-equal? (candidate \"aBCdEf\") 1)\n    (check-equal? (candidate \"abcdefg\"\
  ) 0)\n    (check-equal? (candidate \"dBBE\") 0)\n    (check-equal? (candidate \"\
  B\") 0)\n    (check-equal? (candidate \"U\") 1)\n    (check-equal? (candidate \"\
  \") 0)\n    (check-equal? (candidate \"EEEE\") 2)\n))\n\n(test-humaneval)"
completions: ["  (define (is_upper? c)\n    (and (char-upper-case? c)\n         (member\
    \ c '(#\\A #\\E #\\I #\\O #\\U))))\n  (define (count-upper-even-indices s)\n \
    \   (if (null? s)\n        0\n        (if (even? (string-length s))\n        \
    \    (if (is_upper? (string-ref s 0))\n                (+ 1 (count-upper-even-indices\
    \ (substring s 1)))\n                (count-upper-even-indices (substring s 1)))\n\
    \            (count-upper-even-indices (substring s 1)))))\n  (count-upper-even-indices\
    \ s))\n", "  (define (count_upper-helper s i)\n    (cond\n      [(empty? s) i]\n\
    \      [(char-upper-case? (first s))\n       (if (even? (add1 i))\n          \
    \ (count_upper-helper (rest s) (add1 i))\n           (count_upper-helper (rest\
    \ s) i))]\n      [else (count_upper-helper (rest s) i)]))\n  (count_upper-helper\
    \ s 0))\n", "  (let loop ([s s] [i 0] [count 0])\n    (cond [(empty? s) count]\n\
    \          [(and (char-upper-case? (first s))\n                (even? i))\n  \
    \         (loop (rest s) (+ i 1) (+ count 1))]\n          [else (loop (rest s)\
    \ (+ i 1) count)])))\n", "  (let loop ([i 0] [count 0])\n    (cond\n      [(=\
    \ i (string-length s)) count]\n      [(and (even? i) (char-upper-case? (string-ref\
    \ s i)))\n       (loop (+ i 1) (+ count 1))]\n      [else (loop (+ i 1) count)])))\n",
  "  (define (is_upper? c)\n    (and (char-upper-case? c)\n         (member c '(#\\\
    A #\\E #\\I #\\O #\\U))))\n  (define (count_upper_helper s i acc)\n    (cond\n\
    \      [(empty? s) acc]\n      [(is_upper? (first s))\n       (if (even? i)\n\
    \           (count_upper_helper (rest s) (+ i 1) (+ acc 1))\n           (count_upper_helper\
    \ (rest s) (+ i 1) acc))]\n      [else (count_upper_helper (rest s) (+ i 1) acc)]))\n\
    \  (count_upper_helper s 0 0))\n", "  (cond [(empty? s) 0]\n        [(and (vowel?\
    \ (first s))\n              (upper? (first s))\n              (even? (remainder\
    \ (string-length s) 2)))\n         (+ 1 (count_upper (rest s)))]\n        [else\
    \ (count_upper (rest s))]))\n", "  (let loop ([s s] [i 0] [count 0])\n    (cond\n\
    \      [(empty? s) count]\n      [(and (char-upper-case? (first s))\n        \
    \    (even? i))\n       (loop (rest s) (+ i 1) (+ count 1))]\n      [else (loop\
    \ (rest s) (+ i 1) count)])))\n", "  (define (count_upper_helper s i)\n    (cond\n\
    \      [(= i (string-length s)) 0]\n      [(and (char-upper-case? (string-ref\
    \ s i))\n            (vowel? (string-ref s i)))\n       (+ 1 (count_upper_helper\
    \ s (+ i 2)))]\n      [else (count_upper_helper s (+ i 2))]))\n  (count_upper_helper\
    \ s 0))\n", "  (cond\n    [(empty? s) 0]\n    [(and (vowel? (first s)) (even?\
    \ (index s)))\n     (+ 1 (count_upper (rest s)))]\n    [else (count_upper (rest\
    \ s))]))\n", "  (let loop ([s s] [i 0] [count 0])\n    (cond [(empty? s) count]\n\
    \          [(and (char-upper-case? (first s))\n                (even? i))\n  \
    \         (loop (rest s) (+ i 1) (+ count 1))]\n          [else (loop (rest s)\
    \ (+ i 1) count)])))\n", "  (let ([s (string-upcase s)])\n    (for/sum ([i (in-range\
    \ (string-length s))]\n              #:when (even? i)\n              #:when (member\
    \ (string-ref s i) '#(\"A\" \"E\" \"I\" \"O\" \"U\")))\n      1)))\n", "  (let\
    \ loop ([s s] [i 0] [count 0])\n    (cond\n      [(empty? s) count]\n      [(and\
    \ (char-upcase? (first s))\n            (vowel? (first s))\n            (even?\
    \ i))\n       (loop (rest s) (add1 i) (add1 count))]\n      [else (loop (rest\
    \ s) (add1 i) count)])))\n", "  (cond\n    [(empty? s) 0]\n    [(and (vowel? (first\
    \ s)) (even? (index s))) (+ 1 (count_upper (rest s)))]\n    [else (count_upper\
    \ (rest s))]))\n", "  (let loop ([s s] [i 0] [count 0])\n    (cond [(empty? s)\
    \ count]\n          [(and (char-upper-case? (first s))\n                (even?\
    \ i))\n           (loop (rest s) (add1 i) (add1 count))]\n          [else (loop\
    \ (rest s) (add1 i) count)])))\n", "  (define (count-upper-helper s i)\n    (cond\n\
    \      [(empty? s) 0]\n      [(and (even? i) (char-upper-case? (first s)))\n \
    \      (+ 1 (count-upper-helper (rest s) (+ i 1)))]\n      [else (count-upper-helper\
    \ (rest s) (+ i 1))]))\n  (count-upper-helper s 0))\n", "  (define (is_upper?\
    \ c)\n    (and (char-upper-case? c)\n         (member c '(#\\A #\\E #\\I #\\O\
    \ #\\U))))\n  (define (count-upper-vowels s)\n    (if (null? s)\n        0\n \
    \       (+ (if (is_upper? (car s)) 1 0)\n           (if (even? (car (cdr s)))\n\
    \               (count-upper-vowels (cdr s))\n               0))))\n  (count-upper-vowels\
    \ (string->list s)))\n", "  (let loop ([s s] [i 0] [count 0])\n    (cond [(empty?\
    \ s) count]\n          [(and (char-upper-case? (first s))\n                (even?\
    \ i))\n           (loop (rest s) (+ i 1) (+ count 1))]\n          [else (loop\
    \ (rest s) (+ i 1) count)])))\n", "  (define (count_upper-helper s i)\n    (cond\n\
    \      [(= i (string-length s)) 0]\n      [(and (even? i) (char-upper-case? (string-ref\
    \ s i)))\n       (+ 1 (count_upper-helper s (+ i 1)))]\n      [else (count_upper-helper\
    \ s (+ i 1))]))\n  (count_upper-helper s 0))\n", "  (cond\n    [(empty? s) 0]\n\
    \    [(and (char-upper-case? (first s))\n          (member (first s) '(#\\A #\\\
    E #\\I #\\O #\\U)))\n     (+ 1 (count_upper (rest s)))]\n    [else (count_upper\
    \ (rest s))]))\n", "  (let loop ([i 0] [count 0])\n    (cond\n      [(= i (string-length\
    \ s)) count]\n      [(and (even? i) (vowel? (string-ref s i)))\n       (loop (+\
    \ i 1) (+ count 1))]\n      [else (loop (+ i 1) count)])))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
