name: HumanEval_57_monotonic
language: rkt
prompt: "#lang racket\n\n;; Return True is list elements are monotonically increasing\
  \ or decreasing.\n;; >>> (monotonic (list 1 2 4 20))\n;; #t\n;; >>> (monotonic (list\
  \ 1 20 4 10))\n;; #f\n;; >>> (monotonic (list 4 1 0 -10))\n;; #t\n(define (monotonic\
  \ l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate monotonic))\n\
  \    (check-equal? (candidate (list 1 2 4 10)) #t)\n    (check-equal? (candidate\
  \ (list 1 2 4 20)) #t)\n    (check-equal? (candidate (list 1 20 4 10)) #f)\n   \
  \ (check-equal? (candidate (list 4 1 0 -10)) #t)\n    (check-equal? (candidate (list\
  \ 4 1 1 0)) #t)\n    (check-equal? (candidate (list 1 2 3 2 5 60)) #f)\n    (check-equal?\
  \ (candidate (list 1 2 3 4 5 60)) #t)\n    (check-equal? (candidate (list 9 9 9\
  \ 9)) #t)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(> (first\
    \ l) (second l)) (and (monotonic (rest l)) (> (first l) (second l)))]\n    [(<\
    \ (first l) (second l)) (and (monotonic (rest l)) (< (first l) (second l)))]\n\
    \    [else #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n\
    \    [(> (first l) (second l))\n     (and (monotonic (rest l))\n          (or\
    \ (empty? (rest (rest l)))\n              (> (second l) (third l))))]\n    [(<\
    \ (first l) (second l))\n     (and (monotonic (rest l))\n          (or (empty?\
    \ (rest (rest l)))\n              (< (second l) (third l))))]\n    [else #f]))\n",
  "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(> (first l) (second\
    \ l)) (and (monotonic (rest l)) (<= (first l) (second l)))]\n    [(< (first l)\
    \ (second l)) (and (monotonic (rest l)) (>= (first l) (second l)))]\n    [else\
    \ #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(<\
    \ (first l) (second l)) (monotonic (rest l))]\n    [(> (first l) (second l)) (monotonic\
    \ (rest l))]\n    [else #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty?\
    \ (rest l)) #t]\n    [(> (first l) (second l)) (monotonic (rest l))]\n    [(<\
    \ (first l) (second l)) (monotonic (rest l))]\n    [else #f]))\n", "  (cond\n\
    \    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(> (first l) (second l))\
    \ (monotonic (rest l))]\n    [(< (first l) (second l)) (monotonic (rest l))]\n\
    \    [else #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n\
    \    [(> (first l) (second l)) (monotonic-decreasing (rest l))]\n    [(< (first\
    \ l) (second l)) (monotonic-increasing (rest l))]\n    [else #f]))\n", "  (cond\n\
    \    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(> (first l) (second l))\n\
    \     (and (monotonic (rest l))\n          (or (empty? (rest (rest l)))\n    \
    \          (< (second l) (third l))))]\n    [(< (first l) (second l))\n     (and\
    \ (monotonic (rest l))\n          (or (empty? (rest (rest l)))\n             \
    \ (> (second l) (third l))))]\n    [else #f]))\n", "  (cond [(empty? l) #t]\n\
    \        [(empty? (rest l)) #t]\n        [(or (and (> (first l) (second l)) (monotonic\
    \ (rest l)))\n             (and (< (first l) (second l)) (monotonic (rest l))))\
    \ #t]\n        [else #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest\
    \ l)) #t]\n    [(> (first l) (second l))\n     (and (monotonic (rest l))\n   \
    \       (or (empty? (rest (rest l)))\n              (> (second l) (third l))))]\n\
    \    [(< (first l) (second l))\n     (and (monotonic (rest l))\n          (or\
    \ (empty? (rest (rest l)))\n              (< (second l) (third l))))]\n    [else\
    \ #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(>\
    \ (first l) (second l)) (monotonic-decreasing (rest l))]\n    [(< (first l) (second\
    \ l)) (monotonic-increasing (rest l))]\n    [else #f]))\n", "  (cond\n    [(empty?\
    \ l) #t]\n    [(empty? (rest l)) #t]\n    [(> (first l) (second l)) (monotonic\
    \ (rest l))]\n    [(< (first l) (second l)) (monotonic (rest l))]\n    [else #f]))\n",
  "  (cond\n    [(empty? l) #t]\n    [(= (length l) 1) #t]\n    [(and (>= (first l)\
    \ (second l)) (monotonic (rest l))) #t]\n    [(and (<= (first l) (second l)) (monotonic\
    \ (rest l))) #t]\n    [else #f]))\n", "  (cond [(empty? l) #t]\n        [(empty?\
    \ (rest l)) #t]\n        [(> (first l) (second l))\n         (and (monotonic (rest\
    \ l))\n              (or (= (first l) (second l))\n                  (< (first\
    \ l) (second l))))]\n        [else\n         (and (monotonic (rest l))\n     \
    \         (or (= (first l) (second l))\n                  (> (first l) (second\
    \ l))))]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n   \
    \ [(> (first l) (second l)) (monotonic (rest l))]\n    [(< (first l) (second l))\
    \ (monotonic (rest l))]\n    [else #f]))\n", "  (cond [(empty? l) #t]\n      \
    \  [(empty? (rest l)) #t]\n        [(> (first l) (second l)) (monotonic-dec (rest\
    \ l))]\n        [(< (first l) (second l)) (monotonic-inc (rest l))]\n        [else\
    \ #f]))\n", "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(>\
    \ (first l) (second l)) (monotonic-decreasing (rest l))]\n    [(< (first l) (second\
    \ l)) (monotonic-increasing (rest l))]\n    [else #f]))\n", "  (cond\n    [(empty?\
    \ l) #t]\n    [(empty? (rest l)) #t]\n    [(> (first l) (second l)) (monotonic\
    \ (rest l))]\n    [(< (first l) (second l)) (monotonic (rest l))]\n    [else #f]))\n",
  "  (cond\n    [(empty? l) #t]\n    [(empty? (rest l)) #t]\n    [(or (and (< (first\
    \ l) (second l)) (monotonic (rest l)))\n         (and (> (first l) (second l))\
    \ (monotonic (rest l)))) #t]\n    [else #f]))\n", "  (cond\n    [(empty? l) #t]\n\
    \    [(empty? (rest l)) #t]\n    [(> (first l) (second l)) (monotonic (rest l))]\n\
    \    [(< (first l) (second l)) (monotonic (rest l))]\n    [else #f]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
