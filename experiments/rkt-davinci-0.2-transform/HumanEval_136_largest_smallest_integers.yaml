name: HumanEval_136_largest_smallest_integers
language: rkt
prompt: "#lang racket\n\n;; Create a function that returns a tuple (a, b), where 'a'\
  \ is\n;; the largest of negative integers, and 'b' is the smallest\n;; of positive\
  \ integers in a list.\n;; If there is no negative or positive integers, return them\
  \ as None.\n;; Examples:\n;; >>> (largest_smallest_integers (list 2 4 1 3 5 7))\n\
  ;; (list #f 1)\n;; >>> (largest_smallest_integers (list ))\n;; (list #f #f)\n;;\
  \ >>> (largest_smallest_integers (list 0))\n;; (list #f #f)\n(define (largest_smallest_integers\
  \ lst)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate largest_smallest_integers))\n\
  \    (check-equal? (candidate (list 2 4 1 3 5 7)) (list #f 1))\n    (check-equal?\
  \ (candidate (list 2 4 1 3 5 7 0)) (list #f 1))\n    (check-equal? (candidate (list\
  \ 1 3 2 4 5 6 -2)) (list -2 1))\n    (check-equal? (candidate (list 4 5 3 6 2 7\
  \ -7)) (list -7 2))\n    (check-equal? (candidate (list 7 3 8 4 9 2 5 -9)) (list\
  \ -9 2))\n    (check-equal? (candidate (list )) (list #f #f))\n    (check-equal?\
  \ (candidate (list 0)) (list #f #f))\n    (check-equal? (candidate (list -1 -3 -5\
  \ -6)) (list -1 #f))\n    (check-equal? (candidate (list -1 -3 -5 -6 0)) (list -1\
  \ #f))\n    (check-equal? (candidate (list -6 -4 -4 -3 1)) (list -3 1))\n    (check-equal?\
  \ (candidate (list -6 -4 -4 -3 -100 1)) (list -3 1))\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? lst) (list #f #f)]\n    [(and (positive? (first\
    \ lst)) (negative? (first lst))) (list #f #f)]\n    [(positive? (first lst)) (list\
    \ #f (first lst))]\n    [(negative? (first lst)) (list (first lst) #f)]\n    [else\
    \ (largest_smallest_integers (rest lst))]))\n", "  (define (largest_negative lst)\n\
    \    (cond ((null? lst) #f)\n          ((and (number? (car lst)) (< (car lst)\
    \ 0))\n           (max (car lst) (largest_negative (cdr lst))))\n          (else\
    \ (largest_negative (cdr lst)))))\n  (define (smallest_positive lst)\n    (cond\
    \ ((null? lst) #f)\n          ((and (number? (car lst)) (> (car lst) 0))\n   \
    \        (min (car lst) (smallest_positive (cdr lst))))\n          (else (smallest_positive\
    \ (cdr lst)))))\n  (list (largest_negative lst) (smallest_positive lst)))\n",
  "  (define (largest_smallest_integers_helper lst largest smallest)\n    (cond\n\
    \      [(empty? lst) (list largest smallest)]\n      [(and (positive? (first lst))\
    \ (or (not smallest) (&lt; (first lst) smallest)))\n       (largest_smallest_integers_helper\
    \ (rest lst) largest (first lst))]\n      [(and (negative? (first lst)) (or (not\
    \ largest) (&gt; (first lst) largest)))\n       (largest_smallest_integers_helper\
    \ (rest lst) (first lst) smallest)]\n      [else (largest_smallest_integers_helper\
    \ (rest lst) largest smallest)]))\n  (largest_smallest_integers_helper lst #f\
    \ #f))\n</code>\n", "  (let ([neg (filter (lambda (x) (and (number? x) (< x 0)))\
    \ lst)]\n        [pos (filter (lambda (x) (and (number? x) (> x 0))) lst)])\n\
    \    (if (or (empty? neg) (empty? pos))\n        (list #f #f)\n        (list (apply\
    \ max neg) (apply min pos)))))\n", "  (define (largest_negative lst)\n    (cond\n\
    \      [(empty? lst) #f]\n      [(and (negative? (first lst))\n            (or\
    \ (not (negative? (second lst)))\n                (empty? (rest lst)))) (first\
    \ lst)]\n      [else (largest_negative (rest lst))]))\n  (define (smallest_positive\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (positive? (first lst))\n\
    \            (or (not (positive? (second lst)))\n                (empty? (rest\
    \ lst)))) (first lst)]\n      [else (smallest_positive (rest lst))]))\n  (list\
    \ (largest_negative lst) (smallest_positive lst)))\n", "  (define (helper lst\
    \ largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (negative? (first lst)) (or (not largest) (&gt; (first lst) largest)))\n\
    \       (helper (rest lst) (first lst) smallest)]\n      [(and (positive? (first\
    \ lst)) (or (not smallest) (&lt; (first lst) smallest)))\n       (helper (rest\
    \ lst) largest (first lst))]\n      [else (helper (rest lst) largest smallest)]))\n\
    \  (helper lst #f #f))\n</code>\n", "  (define (largest_smallest_integers_iter\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (positive? (first lst)) (or (not (positive? smallest)) (< (first\
    \ lst) smallest)))\n       (largest_smallest_integers_iter (rest lst) largest\
    \ (first lst))]\n      [(and (negative? (first lst)) (or (not (negative? largest))\
    \ (> (first lst) largest)))\n       (largest_smallest_integers_iter (rest lst)\
    \ (first lst) smallest)]\n      [else (largest_smallest_integers_iter (rest lst)\
    \ largest smallest)]))\n  (largest_smallest_integers_iter lst #f #f))\n", "  (let\
    \ ([negs (filter (lambda (x) (and (integer? x) (< x 0))) lst)]\n        [pos (filter\
    \ (lambda (x) (and (integer? x) (> x 0))) lst)])\n    (if (or (null? negs) (null?\
    \ pos))\n        (list #f #f)\n        (list (apply max negs) (apply min pos)))))\n",
  "  (define (helper lst largest smallest)\n    (cond\n      [(empty? lst) (list largest\
    \ smallest)]\n      [(and (positive? (first lst)) (or (not smallest) (< (first\
    \ lst) smallest)))\n       (helper (rest lst) largest (first lst))]\n      [(and\
    \ (negative? (first lst)) (or (not largest) (> (first lst) largest)))\n      \
    \ (helper (rest lst) (first lst) smallest)]\n      [else (helper (rest lst) largest\
    \ smallest)]))\n  (helper lst #f #f))\n", "  (define (largest_negative_integer\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(and (negative? (first lst))\n\
    \            (or (not (negative? (second lst)))\n                (empty? (rest\
    \ lst))))\n       (first lst)]\n      [else (largest_negative_integer (rest lst))]))\n\
    \  (define (smallest_positive_integer lst)\n    (cond\n      [(empty? lst) #f]\n\
    \      [(and (positive? (first lst))\n            (or (not (positive? (second\
    \ lst)))\n                (empty? (rest lst))))\n       (first lst)]\n      [else\
    \ (smallest_positive_integer (rest lst))]))\n  (list (largest_negative_integer\
    \ lst)\n        (smallest_positive_integer lst)))\n", "  (define (largest_smallest_integers_iter\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (positive? (first lst)) (or (not smallest) (&lt; (first lst) smallest)))\n\
    \       (largest_smallest_integers_iter (rest lst) largest (first lst))]\n   \
    \   [(and (negative? (first lst)) (or (not largest) (&gt; (first lst) largest)))\n\
    \       (largest_smallest_integers_iter (rest lst) (first lst) smallest)]\n  \
    \    [else (largest_smallest_integers_iter (rest lst) largest smallest)]))\n \
    \ (largest_smallest_integers_iter lst #f #f))\n</code>\n", "  (define (helper\
    \ lst largest smallest)\n    (cond\n      [(empty? lst) (list largest smallest)]\n\
    \      [(and (positive? (first lst)) (or (not (positive? smallest)) (< (first\
    \ lst) smallest)))\n       (helper (rest lst) largest (first lst))]\n      [(and\
    \ (negative? (first lst)) (or (not (negative? largest)) (> (first lst) largest)))\n\
    \       (helper (rest lst) (first lst) smallest)]\n      [else (helper (rest lst)\
    \ largest smallest)]))\n  (helper lst #f #f))\n", "  (define (largest_negative\
    \ lst)\n    (cond\n      [(empty? lst) #f]\n      [(negative? (first lst)) (max\
    \ (first lst) (largest_negative (rest lst)))]\n      [else (largest_negative (rest\
    \ lst))]))\n  (define (smallest_positive lst)\n    (cond\n      [(empty? lst)\
    \ #f]\n      [(positive? (first lst)) (min (first lst) (smallest_positive (rest\
    \ lst)))]\n      [else (smallest_positive (rest lst))]))\n  (list (largest_negative\
    \ lst) (smallest_positive lst)))\n", "  (define (helper lst largest smallest)\n\
    \    (cond\n      [(empty? lst) (list largest smallest)]\n      [(and (positive?\
    \ (first lst)) (or (not smallest) (< (first lst) smallest)))\n       (helper (rest\
    \ lst) largest (first lst))]\n      [(and (negative? (first lst)) (or (not largest)\
    \ (> (first lst) largest)))\n       (helper (rest lst) (first lst) smallest)]\n\
    \      [else (helper (rest lst) largest smallest)]))\n  (helper lst #f #f))\n",
  "  (define (largest_smallest_integers_helper lst largest smallest)\n    (cond\n\
    \      [(empty? lst) (list largest smallest)]\n      [(and (positive? (first lst))\
    \ (or (not smallest) (< (first lst) smallest)))\n       (largest_smallest_integers_helper\
    \ (rest lst) largest (first lst))]\n      [(and (negative? (first lst)) (or (not\
    \ largest) (> (first lst) largest)))\n       (largest_smallest_integers_helper\
    \ (rest lst) (first lst) smallest)]\n      [else (largest_smallest_integers_helper\
    \ (rest lst) largest smallest)]))\n  (largest_smallest_integers_helper lst #f\
    \ #f))\n", "  (define (largest_smallest_integers_iter lst largest smallest)\n\
    \    (cond\n      [(empty? lst) (list largest smallest)]\n      [(and (positive?\
    \ (first lst)) (not smallest))\n       (largest_smallest_integers_iter (rest lst)\
    \ largest (first lst))]\n      [(and (negative? (first lst)) (not largest))\n\
    \       (largest_smallest_integers_iter (rest lst) (first lst) smallest)]\n  \
    \    [(and (positive? (first lst)) (< (first lst) smallest))\n       (largest_smallest_integers_iter\
    \ (rest lst) largest (first lst))]\n      [(and (negative? (first lst)) (> (first\
    \ lst) largest))\n       (largest_smallest_integers_iter (rest lst) (first lst)\
    \ smallest)]\n      [else (largest_smallest_integers_iter (rest lst) largest smallest)]))\n\
    \  (largest_smallest_integers_iter lst #f #f))\n", "  (let* ([negatives (filter\
    \ (lambda (x) (< x 0)) lst)]\n         [positives (filter (lambda (x) (> x 0))\
    \ lst)])\n    (if (or (empty? negatives) (empty? positives))\n        (list #f\
    \ #f)\n        (list (apply max negatives) (apply min positives)))))\n", "  (define\
    \ (helper lst largest smallest)\n    (cond [(empty? lst) (list largest smallest)]\n\
    \          [(and (positive? (first lst)) (or (not (positive? smallest)) (< (first\
    \ lst) smallest)))\n           (helper (rest lst) largest (first lst))]\n    \
    \      [(and (negative? (first lst)) (or (not (negative? largest)) (> (first lst)\
    \ largest)))\n           (helper (rest lst) (first lst) smallest)]\n         \
    \ [else (helper (rest lst) largest smallest)]))\n  (helper lst #f #f))\n", " \
    \ (define (largest_smallest_integers_iter lst largest smallest)\n    (cond\n \
    \     [(null? lst) (list largest smallest)]\n      [(and (positive? (car lst))\
    \ (or (not (positive? smallest)) (< (car lst) smallest)))\n       (largest_smallest_integers_iter\
    \ (cdr lst) largest (car lst))]\n      [(and (negative? (car lst)) (or (not (negative?\
    \ largest)) (> (car lst) largest)))\n       (largest_smallest_integers_iter (cdr\
    \ lst) (car lst) smallest)]\n      [else (largest_smallest_integers_iter (cdr\
    \ lst) largest smallest)]))\n  (largest_smallest_integers_iter lst #f #f))\n",
  "  (define (largest_negative lst)\n    (cond\n      [(empty? lst) #f]\n      [(and\
    \ (negative? (first lst))\n            (or (not (negative? (second lst)))\n  \
    \              (negative? (first lst))\n                (not (negative? (second\
    \ lst)))))\n       (first lst)]\n      [else (largest_negative (rest lst))]))\n\
    \  (define (smallest_positive lst)\n    (cond\n      [(empty? lst) #f]\n     \
    \ [(and (positive? (first lst))\n            (or (not (positive? (second lst)))\n\
    \                (positive? (first lst))\n                (not (positive? (second\
    \ lst)))))\n       (first lst)]\n      [else (smallest_positive (rest lst))]))\n\
    \  (list (largest_negative lst) (smallest_positive lst)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
