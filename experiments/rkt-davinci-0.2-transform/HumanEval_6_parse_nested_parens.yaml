name: HumanEval_6_parse_nested_parens
language: rkt
prompt: "#lang racket\n\n;; Input to this function is a string represented multiple\
  \ groups for nested parentheses separated by spaces.\n;; For each of the group,\
  \ output the deepest level of nesting of parentheses.\n;; E.g. (()()) has maximum\
  \ two levels of nesting while ((())) has three.\n;; >>> (parse_nested_parens \"\
  (()()) ((())) () ((())()())\")\n;; (list 2 3 1 3)\n(define (parse_nested_parens\
  \ paren_string)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate parse_nested_parens))\n\
  \    (check-equal? (candidate \"(()()) ((())) () ((())()())\") (list 2 3 1 3))\n\
  \    (check-equal? (candidate \"() (()) ((())) (((())))\") (list 1 2 3 4))\n   \
  \ (check-equal? (candidate \"(()(())((())))\") (list 4))\n))\n\n(test-humaneval)"
completions: ["  (define (parse_nested_parens_helper paren_string current_level max_level)\n\
    \    (cond ((empty? paren_string) (list max_level))\n          ((char=? (first\
    \ paren_string) #\\()\n           (parse_nested_parens_helper (rest paren_string)\
    \ (+ current_level 1) (max current_level max_level)))\n          ((char=? (first\
    \ paren_string) #\\))\n           (parse_nested_parens_helper (rest paren_string)\
    \ (- current_level 1) (max current_level max_level)))\n          ((char=? (first\
    \ paren_string) #\\space)\n           (cons max_level (parse_nested_parens_helper\
    \ (rest paren_string) 0 0)))\n          (else (error \"Invalid input\"))))\n \
    \ (parse_nested_parens_helper paren_string 0 0))\n", "  (define (parse-parens-helper\
    \ paren_string level)\n    (if (empty? paren_string)\n        (list level)\n \
    \       (if (equal? (first paren_string) #\\()\n            (parse-parens-helper\
    \ (rest paren_string) (+ level 1))\n            (if (equal? (first paren_string)\
    \ #\\))\n                (parse-parens-helper (rest paren_string) (- level 1))\n\
    \                (parse-parens-helper (rest paren_string) level)))))\n  (parse-parens-helper\
    \ (string->list paren_string) 0))\n", "  (map (lambda (paren_group)\n        \
    \ (foldl (lambda (paren_char max_nesting)\n                  (cond\n         \
    \           [(char=? paren_char #\\() (+ max_nesting 1)]\n                   \
    \ [(char=? paren_char #\\)) (- max_nesting 1)]\n                    [else max_nesting]))\n\
    \                0\n                paren_group))\n       (string-split paren_string\
    \ #\\space)))\n", "  (map (lambda (paren_group)\n         (string-length (regexp-replace*\
    \ #rx\"\\\\(\\\\)\" paren_group \"\")))\n       (regexp-split #rx\" \" paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (if (empty? paren_string)\n        0\n\
    \        (max (parse_parens (rest paren_string))\n             (if (equal? (first\
    \ paren_string) \"(\")\n                 (+ 1 (parse_parens (rest paren_string)))\n\
    \                 0))))\n  (map parse_parens (string-split paren_string \" \"\
    )))\n", "  (define (parse_parens paren_string)\n    (cond\n      [(empty? paren_string)\
    \ 0]\n      [(equal? (first paren_string) #\\()\n       (+ 1 (parse_parens (rest\
    \ paren_string)))]\n      [(equal? (first paren_string) #\\))\n       (parse_parens\
    \ (rest paren_string))]))\n  (map parse_parens (string-split paren_string #\\\
    space)))\n", "  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group]\
    \ [max_level 0] [current_level 0])\n           (cond [(empty? paren_group) max_level]\n\
    \                 [(char=? (first paren_group) #\\()\n                  (loop\
    \ (rest paren_group) max_level (+ current_level 1))]\n                 [(char=?\
    \ (first paren_group) #\\))\n                  (loop (rest paren_group) (max max_level\
    \ current_level) (- current_level 1))]\n                 [else (loop (rest paren_group)\
    \ max_level current_level)])))\n       (string-split paren_string)))\n", "  (define\
    \ (parse_parens paren_string)\n    (define (parse_parens-iter paren_string level)\n\
    \      (cond ((null? paren_string) level)\n            ((char=? (car paren_string)\
    \ #\\() (parse_parens-iter (cdr paren_string) (+ level 1)))\n            ((char=?\
    \ (car paren_string) #\\)) (parse_parens-iter (cdr paren_string) (- level 1)))\n\
    \            (else (parse_parens-iter (cdr paren_string) level))))\n    (parse_parens-iter\
    \ paren_string 0))\n  (map parse_parens (string-split paren_string)))\n", "  (map\
    \ (lambda (paren_group)\n         (paren_depth paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group) (parse_nested_parens_helper\
    \ paren_group 0)) (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (cond\n      [(empty? paren_string) 0]\n      [(equal? (first paren_string)\
    \ #\\()\n       (+ 1 (parse_parens (rest paren_string)))]\n      [(equal? (first\
    \ paren_string) #\\))\n       (- 1 (parse_parens (rest paren_string)))]\n    \
    \  [else (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string \" \")))\n", "  (map (lambda (paren_group)\n         (paren_nesting_level\
    \ paren_group))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_nesting_level paren_group))\n   \
    \    (string-split paren_string)))\n", "  (map (lambda (paren_group)\n       \
    \  (paren_nesting_level paren_group))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (define (parse_parens_helper paren_string\
    \ depth)\n      (cond\n        [(empty? paren_string) depth]\n        [(equal?\
    \ (first paren_string) #\\() (parse_parens_helper (rest paren_string) (+ depth\
    \ 1))]\n        [(equal? (first paren_string) #\\)) (parse_parens_helper (rest\
    \ paren_string) (- depth 1))]\n        [else (parse_parens_helper (rest paren_string)\
    \ depth)]))\n    (parse_parens_helper paren_string 0))\n  (define (parse_parens_list\
    \ paren_string)\n    (cond\n      [(empty? paren_string) empty]\n      [(equal?\
    \ (first paren_string) #\\ ) (cons (parse_parens (rest paren_string)) (parse_parens_list\
    \ (rest paren_string)))]\n      [else (cons (parse_parens paren_string) (parse_parens_list\
    \ (rest paren_string)))]))\n  (parse_parens_list paren_string))\n", "  (map (lambda\
    \ (paren_group)\n         (paren_group_max_nesting paren_group))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (let loop ([paren_group\
    \ paren_group] [level 0] [max_level 0])\n           (cond [(empty? paren_group)\
    \ max_level]\n                 [(char=? (first paren_group) #\\()\n          \
    \        (loop (rest paren_group) (+ level 1) (if (> level max_level) level max_level))]\n\
    \                 [(char=? (first paren_group) #\\))\n                  (loop\
    \ (rest paren_group) (- level 1) max_level)]\n                 [else (loop (rest\
    \ paren_group) level max_level)])))\n       (regexp-split #rx\" \" paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_depth paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_group_depth\
    \ paren_group))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (length (parse_nested_parens_helper paren_group 0)))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_group_depth\
    \ paren_group))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (parse_nested_parens_helper paren_group 0))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (define (parse_parens_iter paren_string\
    \ paren_stack)\n      (cond ((null? paren_string) (list (length paren_stack)))\n\
    \            ((char=? (car paren_string) #\\() (parse_parens_iter (cdr paren_string)\
    \ (cons #\\( paren_stack)))\n            ((char=? (car paren_string) #\\)) (parse_parens_iter\
    \ (cdr paren_string) (cdr paren_stack)))\n            (else (parse_parens_iter\
    \ (cdr paren_string) paren_stack))))\n    (parse_parens_iter paren_string '()))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n", "  (map (lambda\
    \ (paren_group)\n         (let loop ([paren_group paren_group] [level 0] [max_level\
    \ 0])\n           (cond [(empty? paren_group) max_level]\n                 [(char=?\
    \ (first paren_group) #\\()\n                  (loop (rest paren_group) (+ level\
    \ 1) max_level)]\n                 [(char=? (first paren_group) #\\))\n      \
    \            (loop (rest paren_group) (- level 1) (max max_level level))]\n  \
    \               [else (loop (rest paren_group) level max_level)])))\n       (regexp-split\
    \ #rx\" \" paren_string)))\n", "  (map (lambda (paren_group)\n         (parse_nested_parens_helper\
    \ paren_group 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\
    \ (parse_nested_parens_helper paren_group 0)) (string-split paren_string)))\n",
  "  (define (parse-parens paren-string)\n    (define (parse-parens-iter paren-string\
    \ depth max-depth)\n      (cond ((null? paren-string) max-depth)\n           \
    \ ((char=? (car paren-string) #\\()\n             (parse-parens-iter (cdr paren-string)\
    \ (+ depth 1) (max depth max-depth)))\n            ((char=? (car paren-string)\
    \ #\\))\n             (parse-parens-iter (cdr paren-string) (- depth 1) (max depth\
    \ max-depth)))\n            (else (parse-parens-iter (cdr paren-string) depth\
    \ max-depth))))\n    (parse-parens-iter paren-string 0 0))\n  (define (parse-parens-string\
    \ paren-string)\n    (define (parse-parens-string-iter paren-string paren-string-list)\n\
    \      (cond ((null? paren-string) paren-string-list)\n            ((char=? (car\
    \ paren-string) #\\ )\n             (parse-parens-string-iter (cdr paren-string)\
    \ (cons \"\" paren-string-list)))\n            (else (parse-parens-string-iter\
    \ (cdr paren-string) (cons (string-append (car paren-string-list) (string (car\
    \ paren-string))) (cdr paren-string-list))))))\n    (parse-parens-string-iter\
    \ paren-string (list \"\")))\n  (map parse-parens (parse-parens-string paren-string)))\n",
  "  (define (parse_parens paren_string)\n    (let loop ([paren_string paren_string]\
    \ [depth 0] [max_depth 0])\n      (cond\n        [(empty? paren_string) (list\
    \ max_depth)]\n        [(char=? (first paren_string) #\\()\n         (loop (rest\
    \ paren_string) (+ depth 1) (max max_depth depth))]\n        [(char=? (first paren_string)\
    \ #\\))\n         (loop (rest paren_string) (- depth 1) max_depth)]\n        [else\
    \ (loop (rest paren_string) depth max_depth)])))\n  (map parse_parens (string-split\
    \ paren_string)))\n", "  (define (parse_parens paren_string)\n    (cond\n    \
    \  [(empty? paren_string) 0]\n      [(equal? (first paren_string) #\\() (add1\
    \ (parse_parens (rest paren_string)))]\n      [(equal? (first paren_string) #\\\
    )) (sub1 (parse_parens (rest paren_string)))]\n      [else (parse_parens (rest\
    \ paren_string))]))\n  (map parse_parens (string-split paren_string #\\space)))\n",
  "  (define (parse_parens paren_string)\n    (let ((paren_string (string-append paren_string\
    \ \" \")))\n      (let loop ((paren_string paren_string)\n                 (paren_stack\
    \ '())\n                 (max_depth 0)\n                 (current_depth 0))\n\
    \        (cond\n          [(empty? paren_string)\n           (list max_depth paren_stack)]\n\
    \          [(char=? (string-ref paren_string 0) #\\()\n           (loop (substring\
    \ paren_string 1)\n                 (cons #\\( paren_stack)\n                \
    \ (if (> current_depth max_depth)\n                     (+ current_depth 1)\n\
    \                     max_depth)\n                 (+ current_depth 1))]\n   \
    \       [(char=? (string-ref paren_string 0) #\\))\n           (loop (substring\
    \ paren_string 1)\n                 (cdr paren_stack)\n                 max_depth\n\
    \                 (- current_depth 1))]\n          [else\n           (loop (substring\
    \ paren_string 1)\n                 paren_stack\n                 max_depth\n\
    \                 current_depth)]))))\n  (let loop ((paren_string paren_string)\n\
    \             (paren_list '()))\n    (cond\n      [(empty? paren_string)\n   \
    \    (reverse paren_list)]\n      [else\n       (let* ((paren_group (string-trim\
    \ (substring paren_string 0 (string-index paren_string #\\space))))\n        \
    \      (paren_result (parse_parens paren_group)))\n         (loop (substring paren_string\
    \ (+ (string-length paren_group) 1))\n               (cons (car paren_result)\
    \ paren_list)))))))\n", "  (map (lambda (paren_group)\n         (paren_group_depth\
    \ paren_group))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_group_depth paren_group))\n       (string-split paren_string)))\n",
  "  (map (\u03BB (paren_group) (parse_nested_parens_helper paren_group 0)) (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (let loop ([paren_group\
    \ paren_group] [level 0] [max_level 0])\n           (cond [(empty? paren_group)\
    \ max_level]\n                 [(char=? (first paren_group) #\\()\n          \
    \        (loop (rest paren_group) (+ level 1) (if (> level max_level) level max_level))]\n\
    \                 [(char=? (first paren_group) #\\))\n                  (loop\
    \ (rest paren_group) (- level 1) max_level)]\n                 [else (loop (rest\
    \ paren_group) level max_level)])))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (define (parse_parens_iter paren_string\
    \ max_depth depth)\n      (cond\n        [(empty? paren_string) (list max_depth)]\n\
    \        [(char=? (first paren_string) #\\()\n         (parse_parens_iter (rest\
    \ paren_string)\n                            (if (> depth max_depth) depth max_depth)\n\
    \                            (+ depth 1))]\n        [(char=? (first paren_string)\
    \ #\\))\n         (parse_parens_iter (rest paren_string)\n                   \
    \         (if (> depth max_depth) depth max_depth)\n                         \
    \   (- depth 1))]\n        [else (parse_parens_iter (rest paren_string)\n    \
    \                             max_depth\n                                 depth)]))\n\
    \    (parse_parens_iter paren_string 0 0))\n  (define (parse_parens_iter paren_string\
    \ paren_list)\n    (cond\n      [(empty? paren_string) (reverse paren_list)]\n\
    \      [(char=? (first paren_string) #\\ )\n       (parse_parens_iter (rest paren_string)\n\
    \                          paren_list)]\n      [else (parse_parens_iter (rest\
    \ paren_string)\n                               (cons (parse_parens paren_string)\n\
    \                                     paren_list))]))\n  (parse_parens_iter paren_string\
    \ '()))\n", "  (define (parse_parens paren_string)\n    (let loop ([paren_string\
    \ paren_string] [level 0] [max_level 0])\n      (cond [(empty? paren_string) max_level]\n\
    \            [(equal? (first paren_string) #\\()\n             (loop (rest paren_string)\
    \ (+ level 1) (if (> level max_level) level max_level))]\n            [(equal?\
    \ (first paren_string) #\\))\n             (loop (rest paren_string) (- level\
    \ 1) max_level)]\n            [else (loop (rest paren_string) level max_level)])))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n", "  (map (lambda\
    \ (paren_group)\n         (let loop ([paren_group paren_group] [count 0] [max_count\
    \ 0])\n           (cond [(empty? paren_group) max_count]\n                 [(equal?\
    \ (first paren_group) #\\()\n                  (loop (rest paren_group) (+ count\
    \ 1) (if (> count max_count) count max_count))]\n                 [(equal? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group) (- count 1) max_count)]\n\
    \                 [else (loop (rest paren_group) count max_count)])))\n      \
    \ (regexp-split #rx\" \" paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (let loop ([paren_string paren_string] [paren_count 0] [max_paren_count 0])\n\
    \      (cond\n        [(empty? paren_string) (list paren_count max_paren_count)]\n\
    \        [(char=? (first paren_string) #\\()\n         (loop (rest paren_string)\
    \ (+ paren_count 1) (max paren_count max_paren_count))]\n        [(char=? (first\
    \ paren_string) #\\))\n         (loop (rest paren_string) (- paren_count 1) (max\
    \ paren_count max_paren_count))]\n        [else (loop (rest paren_string) paren_count\
    \ max_paren_count)])))\n  (map (curry list-ref (parse_parens paren_string)) '(1\
    \ 2)))\n", "  (map (lambda (paren_group)\n         (paren_nesting_level paren_group))\n\
    \       (string-split paren_string)))\n", "  (define (parse_parens parens)\n \
    \   (cond\n      [(empty? parens) 0]\n      [(equal? (first parens) \")\") 0]\n\
    \      [(equal? (first parens) \"(\")\n       (add1 (max (parse_parens (rest parens))\n\
    \                  (parse_parens (rest (parse_parens (rest parens))))))]))\n \
    \ (map parse_parens (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (let loop ([paren_group paren_group] [level 0] [max_level 0])\n    \
    \       (cond [(empty? paren_group) max_level]\n                 [(char=? (first\
    \ paren_group) #\\()\n                  (loop (rest paren_group) (+ level 1) max_level)]\n\
    \                 [(char=? (first paren_group) #\\))\n                  (loop\
    \ (rest paren_group) (- level 1) (max max_level level))]\n                 [else\
    \ (loop (rest paren_group) level max_level)])))\n       (regexp-split #rx\" \"\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (parse_nested_parens_helper\
    \ paren_group 0))\n       (string-split paren_string #\\space)))\n", "  (map (lambda\
    \ (paren_group)\n         (paren_depth paren_group 0))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (cond\n      [(empty? paren_string)\
    \ 0]\n      [(equal? (first paren_string) #\\()\n       (+ 1 (parse_parens (rest\
    \ paren_string)))]\n      [(equal? (first paren_string) #\\))\n       (- 1 (parse_parens\
    \ (rest paren_string)))]\n      [else\n       (parse_parens (rest paren_string))]))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n", "  (define (parse_parens\
    \ paren_string)\n    (let loop ([paren_string paren_string] [depth 0] [max_depth\
    \ 0])\n      (cond [(empty? paren_string) max_depth]\n            [(char=? (first\
    \ paren_string) #\\()\n             (loop (rest paren_string) (+ depth 1) (if\
    \ (> depth max_depth) depth max_depth))]\n            [(char=? (first paren_string)\
    \ #\\))\n             (loop (rest paren_string) (- depth 1) max_depth)]\n    \
    \        [else (loop (rest paren_string) depth max_depth)])))\n  (map parse_parens\
    \ (string-split paren_string #\\space)))\n", "  (map (lambda (paren_group)\n \
    \        (paren_nesting_level paren_group))\n       (string-split paren_string\
    \ #\\space)))\n", "  (map (lambda (paren_group)\n         (parse_nested_parens_helper\
    \ paren_group 0))\n       (string-split paren_string)))\n", "  (map (lambda (x)\
    \ (parse_nested_parens_helper x 0)) (string-split paren_string)))\n", "  (map\
    \ (lambda (x) (count_parens x)) (string-split paren_string)))\n", "  (map (lambda\
    \ (paren_group)\n         (let ([paren_stack '()])\n           (for ([paren_char\
    \ (in-string paren_group)])\n             (cond\n               [(equal? paren_char\
    \ #\\()\n                (push paren_char paren_stack)]\n               [(equal?\
    \ paren_char #\\))\n                (pop paren_stack)]))\n           (length paren_stack)))\n\
    \       (regexp-split #rx\" \" paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (define (parse_parens_helper paren_string count)\n      (cond\n        [(empty?\
    \ paren_string) count]\n        [(equal? (first paren_string) #\\() (parse_parens_helper\
    \ (rest paren_string) (+ count 1))]\n        [(equal? (first paren_string) #\\\
    )) (parse_parens_helper (rest paren_string) (- count 1))]\n        [else (parse_parens_helper\
    \ (rest paren_string) count)]))\n    (parse_parens_helper paren_string 0))\n \
    \ (define (parse_parens_list paren_string)\n    (cond\n      [(empty? paren_string)\
    \ empty]\n      [(equal? (first paren_string) #\\ ) (parse_parens_list (rest paren_string))]\n\
    \      [else (cons (parse_parens paren_string) (parse_parens_list (rest paren_string)))]))\n\
    \  (parse_parens_list paren_string))\n", "  (define (parse_parens paren_string)\n\
    \    (let loop ([paren_string paren_string] [acc 0] [max_acc 0])\n      (cond\
    \ [(empty? paren_string) max_acc]\n            [(char=? (first paren_string) #\\\
    ()\n             (loop (rest paren_string) (+ acc 1) (max acc max_acc))]\n   \
    \         [(char=? (first paren_string) #\\))\n             (loop (rest paren_string)\
    \ (- acc 1) (max acc max_acc))]\n            [else (loop (rest paren_string) acc\
    \ max_acc)])))\n  (map parse_parens (string-split paren_string)))\n", "  (map\
    \ (lambda (paren_group)\n         (paren_nesting_level paren_group))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group) (count_parens paren_group\
    \ 0)) (string-split paren_string)))\n", "  (map (lambda (paren_group) (parse_nested_parens_helper\
    \ paren_group 0)) (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (define (parse-parens-iter paren_string count max-count)\n      (cond\n \
    \       [(empty? paren_string) (list count max-count)]\n        [(equal? (first\
    \ paren_string) #\\()\n         (parse-parens-iter (rest paren_string) (+ count\
    \ 1) max-count)]\n        [(equal? (first paren_string) #\\))\n         (parse-parens-iter\
    \ (rest paren_string) (- count 1) (max count max-count))]\n        [else (parse-parens-iter\
    \ (rest paren_string) count max-count)]))\n    (parse-parens-iter paren_string\
    \ 0 0))\n  (define (parse-parens-iter paren_string paren_list)\n    (cond\n  \
    \    [(empty? paren_string) paren_list]\n      [(equal? (first paren_string) #\\\
    \ )\n       (parse-parens-iter (rest paren_string) paren_list)]\n      [else\n\
    \       (let* ([paren-string (string-append (first paren_string) (rest paren_string))]\n\
    \              [paren-list (append paren_list (list (parse_parens paren-string)))])\n\
    \         (parse-parens-iter (rest paren_string) paren_list))]))\n  (parse-parens-iter\
    \ paren_string '()))\n", "  (define (parse_parens paren_string)\n    (cond\n \
    \     [(empty? paren_string) 0]\n      [(equal? (first paren_string) #\\() (add1\
    \ (parse_parens (rest paren_string)))]\n      [(equal? (first paren_string) #\\\
    )) (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split paren_string\
    \ #\\space)))\n", "  (define (parse_parens paren_string)\n    (cond\n      [(empty?\
    \ paren_string) 0]\n      [(equal? (first paren_string) #\\()\n       (+ 1 (parse_parens\
    \ (rest paren_string)))]\n      [(equal? (first paren_string) #\\))\n       (-\
    \ 1 (parse_parens (rest paren_string)))]\n      [else (parse_parens (rest paren_string))]))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n", "  (map (lambda\
    \ (paren_group) (parse_nested_parens_helper paren_group 0)) (string-split paren_string)))\n",
  "  (map (\u03BB (paren_group)\n         (let loop ([paren_group paren_group] [nesting\
    \ 0] [max_nesting 0])\n           (cond [(empty? paren_group) max_nesting]\n \
    \                [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) (+ nesting 1) (max nesting max_nesting))]\n                 [(char=?\
    \ (first paren_group) #\\))\n                  (loop (rest paren_group) (- nesting\
    \ 1) (max nesting max_nesting))]\n                 [else (loop (rest paren_group)\
    \ nesting max_nesting)])))\n       (string-split paren_string #\\space)))\n",
  "  (define (parse_parens paren_string)\n    (define (parse-parens-helper paren_string\
    \ paren_count)\n      (cond\n        [(empty? paren_string) paren_count]\n   \
    \     [(equal? (first paren_string) #\\() (parse-parens-helper (rest paren_string)\
    \ (+ paren_count 1))]\n        [(equal? (first paren_string) #\\)) (parse-parens-helper\
    \ (rest paren_string) (- paren_count 1))]\n        [else (parse-parens-helper\
    \ (rest paren_string) paren_count)]))\n    (parse-parens-helper paren_string 0))\n\
    \  (define (parse-parens-list paren_string)\n    (cond\n      [(empty? paren_string)\
    \ empty]\n      [(equal? (first paren_string) #\\ ) (cons (parse_parens (rest\
    \ paren_string)) (parse-parens-list (rest paren_string)))]\n      [else (cons\
    \ (parse_parens paren_string) (parse-parens-list (rest paren_string)))]))\n  (parse-parens-list\
    \ paren_string))\n", "  (define (parse_parens paren_string)\n    (cond\n     \
    \ [(empty? paren_string) 0]\n      [(equal? (first paren_string) #\\()\n     \
    \  (add1 (parse_parens (rest paren_string)))]\n      [(equal? (first paren_string)\
    \ #\\))\n       (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n", "  (map (lambda (paren_group)\n         (count_parens\
    \ paren_group 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (let ([paren_group_list (string->list paren_group)])\n           (let\
    \ loop ([paren_group_list paren_group_list]\n                      [current_depth\
    \ 0]\n                      [max_depth 0])\n             (cond [(empty? paren_group_list)\
    \ max_depth]\n                   [else (let ([current_char (first paren_group_list)])\n\
    \                           (cond [(char=? current_char #\\()\n              \
    \                    (loop (rest paren_group_list)\n                         \
    \               (+ current_depth 1)\n                                        (if\
    \ (> current_depth max_depth)\n                                            current_depth\n\
    \                                            max_depth))]\n                  \
    \               [(char=? current_char #\\))\n                                \
    \  (loop (rest paren_group_list)\n                                        (- current_depth\
    \ 1)\n                                        max_depth)]\n                  \
    \               [else (loop (rest paren_group_list)\n                        \
    \                     current_depth\n                                        \
    \     max_depth)]))])))))\n        (string-split paren_string)))\n", "  (define\
    \ (parse_parens paren_string)\n    (let loop ([paren_string paren_string] [count\
    \ 0] [max_count 0])\n      (cond [(empty? paren_string) max_count]\n         \
    \   [(char=? (first paren_string) #\\()\n             (loop (rest paren_string)\
    \ (+ count 1) (if (> count max_count) count max_count))]\n            [(char=?\
    \ (first paren_string) #\\))\n             (loop (rest paren_string) (- count\
    \ 1) max_count)]\n            [else (loop (rest paren_string) count max_count)])))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n", "  (define (parse_parens\
    \ paren_string)\n    (define (parse_parens-helper paren_string current_max)\n\
    \      (cond\n        [(empty? paren_string) current_max]\n        [(char=? (first\
    \ paren_string) #\\()\n         (parse_parens-helper (rest paren_string) (+ current_max\
    \ 1))]\n        [(char=? (first paren_string) #\\))\n         (parse_parens-helper\
    \ (rest paren_string) (- current_max 1))]\n        [else (parse_parens-helper\
    \ (rest paren_string) current_max)]))\n    (parse_parens-helper paren_string 0))\n\
    \  (define (parse_parens-list paren_string)\n    (cond\n      [(empty? paren_string)\
    \ empty]\n      [(char=? (first paren_string) #\\ )\n       (cons (parse_parens\
    \ (rest paren_string)) (parse_parens-list (rest paren_string)))]\n      [else\
    \ (parse_parens-list (rest paren_string))]))\n  (parse_parens-list paren_string))\n",
  "  (define (parse_parens paren_string)\n    (let loop ([paren_string paren_string]\
    \ [paren_count 0] [max_paren_count 0])\n      (cond [(empty? paren_string) max_paren_count]\n\
    \            [(equal? (first paren_string) #\\()\n             (loop (rest paren_string)\
    \ (+ paren_count 1) (if (> paren_count max_paren_count) paren_count max_paren_count))]\n\
    \            [(equal? (first paren_string) #\\))\n             (loop (rest paren_string)\
    \ (- paren_count 1) max_paren_count)]\n            [else (loop (rest paren_string)\
    \ paren_count max_paren_count)])))\n  (map parse_parens (string-split paren_string\
    \ #\\space)))\n", "  (map (lambda (paren_group) (parse_nested_parens_helper paren_group\
    \ 0)) (string-split paren_string)))\n", "  (map (\u03BB (x) (parse_nested_parens_helper\
    \ x 0)) (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (cond ((empty? paren_string) 0)\n          ((equal? (first paren_string)\
    \ #\\()\n           (+ 1 (parse_parens (rest paren_string))))\n          ((equal?\
    \ (first paren_string) #\\))\n           (parse_parens (rest paren_string)))))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n", "  (map (lambda\
    \ (paren_group)\n         (paren_nesting_level paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_depth paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (let loop ([paren_group paren_group] [max_level 0] [cur_level 0])\n\
    \           (cond\n             [(empty? paren_group) max_level]\n           \
    \  [(char=? (first paren_group) #\\()\n              (loop (rest paren_group)\
    \ max_level (+ cur_level 1))]\n             [(char=? (first paren_group) #\\))\n\
    \              (loop (rest paren_group) (max max_level cur_level) (- cur_level\
    \ 1))]\n             [else (loop (rest paren_group) max_level cur_level)])))\n\
    \       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n    \
    \     (paren_depth paren_group 0))\n       (string-split paren_string)))\n", " \
    \ (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [max_nesting\
    \ 0] [current_nesting 0])\n           (cond [(empty? paren_group) max_nesting]\n\
    \                 [(char=? (first paren_group) #\\()\n                  (loop\
    \ (rest paren_group)\n                        (if (> current_nesting max_nesting)\n\
    \                            (+ current_nesting 1)\n                         \
    \   max_nesting)\n                        (+ current_nesting 1))]\n          \
    \       [(char=? (first paren_group) #\\))\n                  (loop (rest paren_group)\n\
    \                        max_nesting\n                        (- current_nesting\
    \ 1))]\n                 [else (loop (rest paren_group)\n                    \
    \         max_nesting\n                             current_nesting)])))\n   \
    \    (string-split paren_string #\\space)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_group_max_nesting paren_group))\n       (string-&gt;list paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (let loop ([paren_string paren_string]\
    \ [paren_count 0] [max_paren_count 0])\n      (cond [(empty? paren_string) (list\
    \ paren_count max_paren_count)]\n            [(char=? (first paren_string) #\\\
    ()\n             (loop (rest paren_string) (+ paren_count 1) (if (> paren_count\
    \ max_paren_count) paren_count max_paren_count))]\n            [(char=? (first\
    \ paren_string) #\\))\n             (loop (rest paren_string) (- paren_count 1)\
    \ max_paren_count)]\n            [else (loop (rest paren_string) paren_count max_paren_count)])))\n\
    \  (map (lambda (paren_string) (apply values (parse_parens paren_string))) (string-split\
    \ paren_string)))\n", "  (define (parse_parens paren_string)\n    (define (parse_parens_helper\
    \ paren_string count)\n      (cond\n        [(empty? paren_string) count]\n  \
    \      [(equal? (first paren_string) #\\() (parse_parens_helper (rest paren_string)\
    \ (+ count 1))]\n        [(equal? (first paren_string) #\\)) (parse_parens_helper\
    \ (rest paren_string) (- count 1))]\n        [else (parse_parens_helper (rest\
    \ paren_string) count)]))\n    (parse_parens_helper paren_string 0))\n  (define\
    \ (parse_parens_groups paren_string)\n    (cond\n      [(empty? paren_string)\
    \ empty]\n      [(equal? (first paren_string) #\\space) (parse_parens_groups (rest\
    \ paren_string))]\n      [else (cons (parse_parens paren_string) (parse_parens_groups\
    \ (rest paren_string)))]))\n  (parse_parens_groups paren_string))\n", "  (define\
    \ (parse_parens paren_string)\n    (cond\n      [(empty? paren_string) 0]\n  \
    \    [(equal? (first paren_string) #\\() (add1 (parse_parens (rest paren_string)))]\n\
    \      [(equal? (first paren_string) #\\)) (sub1 (parse_parens (rest paren_string)))]\n\
    \      [else (parse_parens (rest paren_string))]))\n  (map (lambda (x) (parse_parens\
    \ x)) (string-split paren_string #\\space)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_depth paren_group 0))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (cond\n      [(empty? paren_string)\
    \ 0]\n      [(equal? (first paren_string) #\\() (+ 1 (parse_parens (rest paren_string)))]\n\
    \      [(equal? (first paren_string) #\\)) (- 1 (parse_parens (rest paren_string)))]\n\
    \      [else (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string)))\n", "  (define (parse_parens paren_string)\n    (let loop ([paren_string\
    \ paren_string] [paren_count 0] [max_paren_count 0])\n      (cond [(empty? paren_string)\
    \ max_paren_count]\n            [(char=? (first paren_string) #\\()\n        \
    \     (loop (rest paren_string) (+ paren_count 1)\n                   (if (> paren_count\
    \ max_paren_count)\n                       paren_count\n                     \
    \  max_paren_count))]\n            [(char=? (first paren_string) #\\))\n     \
    \        (loop (rest paren_string) (- paren_count 1) max_paren_count)]\n     \
    \       [else (loop (rest paren_string) paren_count max_paren_count)])))\n  (map\
    \ parse_parens (string-split paren_string #\\space)))\n", "  (map (lambda (paren_group)\n\
    \         (count-parens paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (parse_nested_parens_helper paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (let loop ([paren_group paren_group] [max_depth 0] [current_depth 0])\n\
    \           (cond [(empty? paren_group) max_depth]\n                 [(char=?\
    \ (first paren_group) #\\()\n                  (loop (rest paren_group) max_depth\
    \ (+ current_depth 1))]\n                 [(char=? (first paren_group) #\\))\n\
    \                  (loop (rest paren_group) (max max_depth current_depth) (- current_depth\
    \ 1))]\n                 [else (loop (rest paren_group) max_depth current_depth)])))\n\
    \       (string-split paren_string #\\space)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (define (parse_parens_helper paren_string\
    \ level max_level)\n      (cond\n        [(empty? paren_string) max_level]\n \
    \       [(equal? (first paren_string) #\\() (parse_parens_helper (rest paren_string)\
    \ (+ level 1) (max level max_level))]\n        [(equal? (first paren_string) #\\\
    )) (parse_parens_helper (rest paren_string) (- level 1) max_level)]\n        [else\
    \ (parse_parens_helper (rest paren_string) level max_level)]))\n    (parse_parens_helper\
    \ paren_string 0 0))\n  (define (parse_parens_list paren_string)\n    (cond\n\
    \      [(empty? paren_string) empty]\n      [(equal? (first paren_string) #\\\
    \ ) (cons (parse_parens (rest paren_string)) (parse_parens_list (rest paren_string)))]\n\
    \      [else (cons (parse_parens paren_string) (parse_parens_list (rest paren_string)))]))\n\
    \  (parse_parens_list paren_string))\n", "  (map (lambda (paren_group)\n     \
    \    (paren_depth paren_group 0))\n       (string-split paren_string)))\n", " \
    \ (map (lambda (paren_group) (paren_depth paren_group)) (string-split paren_string)))\n",
  "  (map (lambda (paren_group) (count_parens paren_group)) (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (cond ((null? paren_string) 0)\n   \
    \       ((equal? (car paren_string) \"(\") (+ 1 (parse_parens (cdr paren_string))))\n\
    \          ((equal? (car paren_string) \")\") (- 1 (parse_parens (cdr paren_string))))\n\
    \          (else (parse_parens (cdr paren_string)))))\n  (map parse_parens (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_group_depth\
    \ paren_group))\n       (string-split paren_string)))\n", "  (define (paren-level\
    \ paren_string)\n    (define (paren-level-iter paren_string level)\n      (cond\
    \ ((null? paren_string) level)\n            ((char=? (car paren_string) #\\()\
    \ (paren-level-iter (cdr paren_string) (+ level 1)))\n            ((char=? (car\
    \ paren_string) #\\)) (paren-level-iter (cdr paren_string) (- level 1)))\n   \
    \         (else (paren-level-iter (cdr paren_string) level))))\n    (paren-level-iter\
    \ paren_string 0))\n  (map paren-level (string-split paren_string)))\n", "  (define\
    \ (parse_parens paren_string)\n    (let loop ([paren_string paren_string] [paren_count\
    \ 0] [max_paren_count 0])\n      (cond\n        [(empty? paren_string) (list paren_count\
    \ max_paren_count)]\n        [(char=? (first paren_string) #\\()\n         (loop\
    \ (rest paren_string) (+ paren_count 1) (max paren_count max_paren_count))]\n\
    \        [(char=? (first paren_string) #\\))\n         (loop (rest paren_string)\
    \ (- paren_count 1) (max paren_count max_paren_count))]\n        [else (loop (rest\
    \ paren_string) paren_count max_paren_count)])))\n  (let loop ([paren_string paren_string]\
    \ [paren_counts '()])\n    (cond\n      [(empty? paren_string) (reverse paren_counts)]\n\
    \      [(char=? (first paren_string) #\\ )\n       (loop (rest paren_string) paren_counts)]\n\
    \      [else\n       (let ([paren_count (parse_parens paren_string)])\n      \
    \   (loop (substring paren_string (add1 (second paren_count)))\n             \
    \  (cons (first paren_count) paren_counts)))])))\n", "  (define (parse_parens\
    \ paren_string)\n    (define (parse_parens_iter paren_string depth max_depth)\n\
    \      (cond\n        [(empty? paren_string) max_depth]\n        [(equal? (first\
    \ paren_string) #\\()\n         (parse_parens_iter (rest paren_string) (+ depth\
    \ 1) (max depth max_depth))]\n        [(equal? (first paren_string) #\\))\n  \
    \       (parse_parens_iter (rest paren_string) (- depth 1) (max depth max_depth))]\n\
    \        [else (parse_parens_iter (rest paren_string) depth max_depth)]))\n  \
    \  (parse_parens_iter paren_string 0 0))\n  (define (parse_parens_iter paren_string\
    \ acc)\n    (cond\n      [(empty? paren_string) (reverse acc)]\n      [else (parse_parens_iter\
    \ (rest paren_string) (cons (parse_parens (first paren_string)) acc))]))\n  (parse_parens_iter\
    \ (string-split paren_string #\\space) '()))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_depth paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_group_max_depth\
    \ paren_group))\n       (string-split paren_string #\\space)))\n", "  (define\
    \ (parse_parens paren_string)\n    (let loop ([paren_string paren_string] [max_depth\
    \ 0] [current_depth 0])\n      (cond\n        [(empty? paren_string) max_depth]\n\
    \        [(char=? (first paren_string) #\\()\n         (loop (rest paren_string)\n\
    \               (if (> current_depth max_depth)\n                   (+ current_depth\
    \ 1)\n                   max_depth)\n               (+ current_depth 1))]\n  \
    \      [(char=? (first paren_string) #\\))\n         (loop (rest paren_string)\n\
    \               max_depth\n               (- current_depth 1))]\n        [else\
    \ (loop (rest paren_string)\n                    max_depth\n                 \
    \   current_depth)])))\n  (map parse_parens (string-split paren_string #\\space)))\n",
  "  (map (lambda (paren_group)\n         (paren_group_max_nesting paren_group))\n\
    \       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n    \
    \     (paren_group_depth paren_group))\n       (paren_groups paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_nesting_level paren_group))\n   \
    \    (string-split paren_string)))\n", "  (define (parse-parens parens)\n    (cond\n\
    \      [(empty? parens) 0]\n      [(eq? (first parens) #\\()\n       (add1 (parse-parens\
    \ (rest parens)))]\n      [(eq? (first parens) #\\))\n       (parse-parens (rest\
    \ parens))]))\n  (map parse-parens (string-split paren_string #\\space)))\n",
  "  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [count\
    \ 0] [max_count 0])\n           (cond [(empty? paren_group) max_count]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) (+ count 1) (if (> count max_count) count max_count))]\n      \
    \           [(char=? (first paren_group) #\\))\n                  (loop (rest\
    \ paren_group) (- count 1) max_count)]\n                 [else (loop (rest paren_group)\
    \ count max_count)])))\n       (string-split paren_string #\\space)))\n", "  (map\
    \ (lambda (paren_group)\n         (paren_nesting_level paren_group))\n       (string-split\
    \ paren_string)))\n", "  (define (parse_parens paren_string)\n    (let loop ([paren_string\
    \ paren_string] [paren_count 0] [max_paren_count 0])\n      (cond\n        [(empty?\
    \ paren_string) (list paren_count max_paren_count)]\n        [(char=? (first paren_string)\
    \ #\\()\n         (loop (rest paren_string) (+ paren_count 1) (max paren_count\
    \ max_paren_count))]\n        [(char=? (first paren_string) #\\))\n         (loop\
    \ (rest paren_string) (- paren_count 1) (max paren_count max_paren_count))]\n\
    \        [else (loop (rest paren_string) paren_count max_paren_count)])))\n  (map\
    \ (lambda (paren_string) (first (parse_parens paren_string))) (regexp-split #rx\"\
    \ \" paren_string)))\n", "  (define (parse_parens paren_string)\n    (cond\n \
    \     [(empty? paren_string) 0]\n      [(equal? (first paren_string) #\\()\n \
    \      (+ 1 (parse_parens (rest paren_string)))]\n      [(equal? (first paren_string)\
    \ #\\))\n       (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n", "  (define (parse_parens paren_string)\n    (define\
    \ (parse_parens_iter paren_string level)\n      (cond ((empty? paren_string) level)\n\
    \            ((char=? (first paren_string) #\\()\n             (parse_parens_iter\
    \ (rest paren_string) (+ level 1)))\n            ((char=? (first paren_string)\
    \ #\\))\n             (parse_parens_iter (rest paren_string) (- level 1)))))\n\
    \    (parse_parens_iter paren_string 0))\n  (map parse_parens (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (cond\n      [(empty? paren_string)\
    \ 0]\n      [(equal? (first paren_string) #\\()\n       (+ 1 (parse_parens (rest\
    \ paren_string)))]\n      [(equal? (first paren_string) #\\))\n       (- 1 (parse_parens\
    \ (rest paren_string)))]\n      [else (parse_parens (rest paren_string))]))\n\
    \  (define (parse_parens_with_depth paren_string depth)\n    (cond\n      [(empty?\
    \ paren_string) depth]\n      [(equal? (first paren_string) #\\()\n       (parse_parens_with_depth\
    \ (rest paren_string) (+ 1 depth))]\n      [(equal? (first paren_string) #\\))\n\
    \       (parse_parens_with_depth (rest paren_string) (- 1 depth))]\n      [else\
    \ (parse_parens_with_depth (rest paren_string) depth)]))\n  (define (parse_parens_with_depth_and_max\
    \ paren_string depth max)\n    (cond\n      [(empty? paren_string) max]\n    \
    \  [(equal? (first paren_string) #\\()\n       (parse_parens_with_depth_and_max\
    \ (rest paren_string) (+ 1 depth)\n                                        (if\
    \ (> depth max) depth max))]\n      [(equal? (first paren_string) #\\))\n    \
    \   (parse_parens_with_depth_and_max (rest paren_string) (- 1 depth)\n       \
    \                                 (if (> depth max) depth max))]\n      [else\
    \ (parse_parens_with_depth_and_max (rest paren_string) depth max)]))\n  (define\
    \ (parse_parens_with_depth_and_max_and_list paren_string depth max paren_list)\n\
    \    (cond\n      [(empty? paren_string) paren_list]\n      [(equal? (first paren_string)\
    \ #\\()\n       (parse_parens_with_depth_and_max_and_list (rest paren_", "  (map\
    \ (lambda (paren_group)\n         (paren_group_max_nesting paren_group))\n   \
    \    (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (define (parse-parens-helper paren_string depth max-depth)\n      (cond\n\
    \        [(empty? paren_string) max-depth]\n        [(char=? (first paren_string)\
    \ #\\()\n         (parse-parens-helper (rest paren_string) (+ depth 1) (max depth\
    \ max-depth))]\n        [(char=? (first paren_string) #\\))\n         (parse-parens-helper\
    \ (rest paren_string) (- depth 1) (max depth max-depth))]\n        [else (parse-parens-helper\
    \ (rest paren_string) depth max-depth)]))\n    (parse-parens-helper paren_string\
    \ 0 0))\n  (map parse_parens (string-split paren_string #\\space)))\n", "  (define\
    \ (parse_parens paren_string)\n    (cond\n      [(empty? paren_string) 0]\n  \
    \    [(eq? (first paren_string) #\\() (add1 (parse_parens (rest paren_string)))]\n\
    \      [(eq? (first paren_string) #\\)) (sub1 (parse_parens (rest paren_string)))]\n\
    \      [else (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n", "  (define (parse_parens paren_string)\n    (cond\
    \ ((empty? paren_string) 0)\n          ((eq? (first paren_string) #\\() (add1\
    \ (parse_parens (rest paren_string))))\n          ((eq? (first paren_string) #\\\
    )) (sub1 (parse_parens (rest paren_string))))\n          (else (parse_parens (rest\
    \ paren_string)))))\n  (define (parse_parens_helper paren_string)\n    (cond ((empty?\
    \ paren_string) '())\n          ((eq? (first paren_string) #\\ ) (cons (parse_parens\
    \ (rest paren_string)) (parse_parens_helper (rest paren_string))))\n         \
    \ (else (parse_parens_helper (rest paren_string)))))\n  (parse_parens_helper paren_string))\n",
  "  (map (lambda (paren_group)\n         (paren_group_max_nesting paren_group))\n\
    \       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n    \
    \     (let loop ([paren_group paren_group] [max_nesting 0] [current_nesting 0])\n\
    \           (cond [(empty? paren_group) max_nesting]\n                 [(char=?\
    \ (first paren_group) #\\()\n                  (loop (rest paren_group)\n    \
    \                    (if (> (+ current_nesting 1) max_nesting)\n             \
    \               (+ current_nesting 1)\n                            max_nesting)\n\
    \                        (+ current_nesting 1))]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group)\n           \
    \             max_nesting\n                        (- current_nesting 1))]\n \
    \                [else (loop (rest paren_group) max_nesting current_nesting)])))\n\
    \       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n    \
    \     (paren_nesting_level paren_group))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (cond\n      [(empty? paren_string)\
    \ 0]\n      [(char=? (first paren_string) #\\()\n       (+ 1 (parse_parens (rest\
    \ paren_string)))]\n      [(char=? (first paren_string) #\\))\n       (parse_parens\
    \ (rest paren_string))]))\n  (map parse_parens (string-split paren_string #\\\
    space)))\n", "  (map (lambda (paren_group) (parse_nested_parens_helper paren_group\
    \ 0)) (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (cond ((null? paren_string) 0)\n          ((equal? (car paren_string) \"\
    (\") (+ 1 (parse_parens (cdr paren_string))))\n          ((equal? (car paren_string)\
    \ \")\") (- 1 (parse_parens (cdr paren_string))))\n          (else (parse_parens\
    \ (cdr paren_string)))))\n  (map parse_parens (string-split paren_string \" \"\
    )))\n", "  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group]\
    \ [level 0] [max_level 0])\n           (cond [(empty? paren_group) max_level]\n\
    \                 [(char=? (first paren_group) #\\()\n                  (loop\
    \ (rest paren_group) (+ level 1) max_level)]\n                 [(char=? (first\
    \ paren_group) #\\))\n                  (loop (rest paren_group) (- level 1) (max\
    \ max_level level))]\n                 [else (loop (rest paren_group) level max_level)])))\n\
    \       (regexp-split #rx\" \" paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (let loop ([paren_group paren_group] [max_depth 0] [curr_depth 0])\n\
    \           (cond [(empty? paren_group) max_depth]\n                 [(char=?\
    \ (first paren_group) #\\()\n                  (loop (rest paren_group)\n    \
    \                    (if (> curr_depth max_depth) curr_depth max_depth)\n    \
    \                    (+ curr_depth 1))]\n                 [(char=? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group)\n                        (if\
    \ (> curr_depth max_depth) curr_depth max_depth)\n                        (- curr_depth\
    \ 1))]\n                 [else (loop (rest paren_group) max_depth curr_depth)])))\n\
    \       (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (let loop ([paren_string paren_string] [max_level 0] [current_level 0])\n\
    \      (cond [(empty? paren_string) max_level]\n            [(char=? (first paren_string)\
    \ #\\()\n             (loop (rest paren_string) max_level (+ current_level 1))]\n\
    \            [(char=? (first paren_string) #\\))\n             (loop (rest paren_string)\
    \ (max max_level current_level) (- current_level 1))]\n            [else (loop\
    \ (rest paren_string) max_level current_level)])))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n", "  (map (lambda (paren_group)\n         (parse_nested_parens_helper\
    \ paren_group 0))\n       (string-split paren_string #\\space)))\n", "  (map (lambda\
    \ (paren_group)\n         (count_parens paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (define (parse_parens paren_string)\n    (cond [(empty?\
    \ paren_string) 0]\n          [(eq? (first paren_string) #\\()\n           (+\
    \ 1 (parse_parens (rest paren_string)))]\n          [(eq? (first paren_string)\
    \ #\\))\n           (- 1 (parse_parens (rest paren_string)))]\n          [else\
    \ (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split paren_string\
    \ #\\space)))\n", "  (define (parse_parens paren_string)\n    (define (parse_parens-iter\
    \ paren_string depth max-depth)\n      (cond ((null? paren_string) max-depth)\n\
    \            ((char=? (car paren_string) #\\()\n             (parse_parens-iter\
    \ (cdr paren_string) (+ depth 1) (if (> depth max-depth) depth max-depth)))\n\
    \            ((char=? (car paren_string) #\\))\n             (parse_parens-iter\
    \ (cdr paren_string) (- depth 1) max-depth))\n            (else (parse_parens-iter\
    \ (cdr paren_string) depth max-depth))))\n    (parse_parens-iter paren_string\
    \ 0 0))\n  (map parse_parens (string-split paren_string #\\space)))\n", "  (define\
    \ (parse_parens paren_string)\n    (cond ((empty? paren_string) 0)\n         \
    \ ((equal? (first paren_string) #\\()\n           (+ 1 (parse_parens (rest paren_string))))\n\
    \          ((equal? (first paren_string) #\\))\n           (- 1 (parse_parens\
    \ (rest paren_string))))))\n  (parse_parens (string->list paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_group_max_nesting paren_group))\n\
    \       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n    \
    \     (paren_group_max_nesting paren_group))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [level\
    \ 0] [max_level 0])\n           (cond [(empty? paren_group) max_level]\n     \
    \            [(char=? (first paren_group) #\\()\n                  (loop (rest\
    \ paren_group) (+ level 1) (if (> level max_level) level max_level))]\n      \
    \           [(char=? (first paren_group) #\\))\n                  (loop (rest\
    \ paren_group) (- level 1) max_level)]\n                 [else (loop (rest paren_group)\
    \ level max_level)])))\n       (regexp-split #rx\" \" paren_string)))\n", "  (define\
    \ (parse_parens paren_string)\n    (define (parse_parens_helper paren_string level)\n\
    \      (cond\n        [(empty? paren_string) level]\n        [(char=? (first paren_string)\
    \ #\\() (parse_parens_helper (rest paren_string) (+ level 1))]\n        [(char=?\
    \ (first paren_string) #\\)) (parse_parens_helper (rest paren_string) (- level\
    \ 1))]\n        [else (parse_parens_helper (rest paren_string) level)]))\n   \
    \ (parse_parens_helper paren_string 0))\n  (define (parse_parens_list paren_string)\n\
    \    (cond\n      [(empty? paren_string) empty]\n      [(char=? (first paren_string)\
    \ #\\ ) (cons (parse_parens (rest paren_string)) (parse_parens_list (rest paren_string)))]\n\
    \      [else (cons (parse_parens paren_string) (parse_parens_list (rest paren_string)))]))\n\
    \  (parse_parens_list paren_string))\n", "  (map (lambda (paren_group)\n     \
    \    (let loop ([paren_group paren_group] [max_level 0] [cur_level 0])\n     \
    \      (cond [(empty? paren_group) max_level]\n                 [(char=? (first\
    \ paren_group) #\\()\n                  (loop (rest paren_group)\n           \
    \             (if (> cur_level max_level)\n                            cur_level\n\
    \                            max_level)\n                        (+ cur_level\
    \ 1))]\n                 [(char=? (first paren_group) #\\))\n                \
    \  (loop (rest paren_group)\n                        (if (> cur_level max_level)\n\
    \                            cur_level\n                            max_level)\n\
    \                        (- cur_level 1))]\n                 [else (loop (rest\
    \ paren_group) max_level cur_level)])))\n       (regexp-split #rx\" \" paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (define (parse_parens_helper paren_string\
    \ count)\n      (cond\n        [(empty? paren_string) count]\n        [(equal?\
    \ (first paren_string) #\\() (parse_parens_helper (rest paren_string) (+ count\
    \ 1))]\n        [(equal? (first paren_string) #\\)) (parse_parens_helper (rest\
    \ paren_string) (- count 1))]\n        [else (parse_parens_helper (rest paren_string)\
    \ count)]))\n    (parse_parens_helper paren_string 0))\n  (define (parse_parens_list\
    \ paren_string)\n    (cond\n      [(empty? paren_string) '()]\n      [(equal?\
    \ (first paren_string) #\\ ) (cons (parse_parens (rest paren_string)) (parse_parens_list\
    \ (rest paren_string)))]\n      [else (parse_parens_list (rest paren_string))]))\n\
    \  (parse_parens_list paren_string))\n", "  (map (lambda (paren_group)\n     \
    \    (string-length (regexp-replace* #rx\"\\\\(\\\\)\" paren_group \"\")))\n \
    \      (regexp-split #rx\" \" paren_string)))\n", "  (map (lambda (paren_group)\
    \ (paren_depth paren_group)) (string-split paren_string)))\n", "  (map (\u03BB\
    \ (paren_group) (parse_parens paren_group)) (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (length (regexp-match #rx\"([()])*\" paren_group)))\n\
    \       (regexp-match #rx\"([()]*)\" paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_nesting_level paren_group))\n       (string-tokenize paren_string\
    \ #\\space)))\n", "  (define (parse_parens paren_string)\n    (cond\n      [(empty?\
    \ paren_string) 0]\n      [(char=? (first paren_string) #\\()\n       (+ 1 (parse_parens\
    \ (rest paren_string)))]\n      [(char=? (first paren_string) #\\))\n       (parse_parens\
    \ (rest paren_string))]))\n  (map parse_parens (string-split paren_string #\\\
    space)))\n", "  (let ([paren_list (string-&gt;list paren_string)])\n    (for/list\
    \ ([paren_group (in-list (regexp-match* #rx\"([^ ]+)\" paren_string))])\n    \
    \  (let loop ([paren_group paren_group] [depth 0] [max_depth 0])\n        (cond\n\
    \          [(empty? paren_group) max_depth]\n          [(char=? (first paren_group)\
    \ #\\()\n           (loop (rest paren_group) (+ depth 1) (max depth max_depth))]\n\
    \          [(char=? (first paren_group) #\\))\n           (loop (rest paren_group)\
    \ (- depth 1) max_depth)])))))\n</code>\n", "  (map (lambda (paren_group)\n  \
    \       (parse_nested_parens_helper paren_group 0))\n       (string-split paren_string\
    \ #\\space)))\n", "  (define (parse_parens paren_string)\n    (define (parse_parens_helper\
    \ paren_string level)\n      (cond\n        [(empty? paren_string) level]\n  \
    \      [(char=? (first paren_string) #\\() (parse_parens_helper (rest paren_string)\
    \ (+ level 1))]\n        [(char=? (first paren_string) #\\)) (parse_parens_helper\
    \ (rest paren_string) (- level 1))]\n        [else (parse_parens_helper (rest\
    \ paren_string) level)]))\n    (parse_parens_helper paren_string 0))\n  (define\
    \ (parse_parens_list paren_string)\n    (cond\n      [(empty? paren_string) '()]\n\
    \      [(char=? (first paren_string) #\\ ) (cons (parse_parens (rest paren_string))\
    \ (parse_parens_list (rest paren_string)))]\n      [else (parse_parens_list (rest\
    \ paren_string))]))\n  (parse_parens_list paren_string))\n", "  (map (lambda (paren_group)\n\
    \         (paren_group_max_nesting paren_group))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (define (parse_parens_helper paren_string\
    \ counter)\n      (cond\n        [(empty? paren_string) counter]\n        [(char=?\
    \ (first paren_string) #\\() (parse_parens_helper (rest paren_string) (+ counter\
    \ 1))]\n        [(char=? (first paren_string) #\\)) (parse_parens_helper (rest\
    \ paren_string) (- counter 1))]\n        [else (parse_parens_helper (rest paren_string)\
    \ counter)]))\n    (parse_parens_helper paren_string 0))\n  (define (parse_parens_list\
    \ paren_string)\n    (cond\n      [(empty? paren_string) empty]\n      [(char=?\
    \ (first paren_string) #\\ ) (parse_parens_list (rest paren_string))]\n      [else\
    \ (cons (parse_parens paren_string) (parse_parens_list (rest paren_string)))]))\n\
    \  (parse_parens_list paren_string))\n", "  (map (lambda (paren_group)\n     \
    \    (max-depth paren_group 0 0))\n       (string-split paren_string #\\space)))\n",
  "  (define (parse-parens-helper paren_string paren_count)\n    (cond\n      [(empty?\
    \ paren_string) (list paren_count)]\n      [(char=? (first paren_string) #\\()\n\
    \       (parse-parens-helper (rest paren_string) (+ paren_count 1))]\n      [(char=?\
    \ (first paren_string) #\\))\n       (parse-parens-helper (rest paren_string)\
    \ (- paren_count 1))]\n      [else (parse-parens-helper (rest paren_string) paren_count)]))\n\
    \  (parse-parens-helper paren_string 0))\n", "  (map (lambda (paren_group)\n \
    \        (let loop ([paren_group paren_group] [level 0] [max-level 0])\n     \
    \      (cond [(empty? paren_group) max-level]\n                 [(char=? (first\
    \ paren_group) #\\()\n                  (loop (rest paren_group) (+ level 1) (if\
    \ (> level max-level) level max-level))]\n                 [(char=? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group) (- level 1) max-level)]\n\
    \                 [else (loop (rest paren_group) level max-level)])))\n      \
    \ (string-split paren_string #\\space)))\n", "  (map (lambda (paren_group)\n \
    \        (parse_nested_parens_helper paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (parse_nested_parens_helper paren_group\
    \ 0))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (parse_nested_parens_helper paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (paren_group_max_nesting paren_group))\n\
    \       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n    \
    \     (count_parens paren_group 0))\n       (string-split paren_string #\\space)))\n",
  "  (define (parse-parens paren-string)\n    (define (parse-parens-iter paren-string\
    \ max-depth depth)\n      (cond ((empty? paren-string) (list max-depth))\n   \
    \         ((char=? (first paren-string) #\\()\n             (parse-parens-iter\
    \ (rest paren-string)\n                                (if (> depth max-depth)\
    \ depth max-depth)\n                                (+ depth 1)))\n          \
    \  ((char=? (first paren-string) #\\))\n             (parse-parens-iter (rest\
    \ paren-string)\n                                (if (> depth max-depth) depth\
    \ max-depth)\n                                (- depth 1)))\n            (else\
    \ (parse-parens-iter (rest paren-string)\n                                   \
    \  (if (> depth max-depth) depth max-depth)\n                                \
    \     depth))))\n    (parse-parens-iter paren-string 0 0))\n  (map parse-parens\
    \ (string-split paren-string)))\n", "  (map (lambda (paren_group)\n         (paren_group_max_nesting\
    \ paren_group))\n       (string-split paren_string #\\space)))\n", "  (define\
    \ (parse_parens paren_string)\n    (define (parse_parens_helper paren_string level)\n\
    \      (cond\n        [(empty? paren_string) level]\n        [(char=? (first paren_string)\
    \ #\\() (parse_parens_helper (rest paren_string) (+ level 1))]\n        [(char=?\
    \ (first paren_string) #\\)) (parse_parens_helper (rest paren_string) (- level\
    \ 1))]\n        [else (parse_parens_helper (rest paren_string) level)]))\n   \
    \ (parse_parens_helper paren_string 0))\n  (define (parse_parens_list paren_string)\n\
    \    (cond\n      [(empty? paren_string) empty]\n      [(char=? (first paren_string)\
    \ #\\() (cons (parse_parens paren_string) (parse_parens_list (rest paren_string)))]\n\
    \      [else (parse_parens_list (rest paren_string))]))\n  (parse_parens_list\
    \ paren_string))\n", "  (map (lambda (paren_group)\n         (let loop ([paren_group\
    \ paren_group] [count 0] [max_count 0])\n           (cond [(empty? paren_group)\
    \ max_count]\n                 [(char=? (first paren_group) #\\()\n          \
    \        (loop (rest paren_group) (add1 count) (if (> count max_count) count max_count))]\n\
    \                 [(char=? (first paren_group) #\\))\n                  (loop\
    \ (rest paren_group) (sub1 count) max_count)]\n                 [else (loop (rest\
    \ paren_group) count max_count)])))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (let loop ([paren_group paren_group] [level\
    \ 0] [max_level 0])\n           (cond\n             [(empty? paren_group) max_level]\n\
    \             [(char=? (first paren_group) #\\()\n              (loop (rest paren_group)\
    \ (+ level 1) (max level max_level))]\n             [(char=? (first paren_group)\
    \ #\\))\n              (loop (rest paren_group) (- level 1) max_level)]\n    \
    \         [else (loop (rest paren_group) level max_level)])))\n       (regexp-split\
    \ #rx\" \" paren_string)))\n", "  (map (lambda (paren_group)\n         (let ([paren_group\
    \ (string->list paren_group)])\n           (let loop ([paren_group paren_group]\
    \ [level 0] [max_level 0])\n             (cond\n               [(empty? paren_group)\
    \ max_level]\n               [(char=? (first paren_group) #\\()\n            \
    \    (loop (rest paren_group) (+ level 1) (max level max_level))]\n          \
    \     [(char=? (first paren_group) #\\))\n                (loop (rest paren_group)\
    \ (- level 1) (max level max_level))]\n               [else (loop (rest paren_group)\
    \ level max_level)]))))\n       (string-split paren_string)))\n", "  (map (lambda\
    \ (paren_group)\n         (let loop ([paren_group paren_group] [level 0] [max_level\
    \ 0])\n           (cond\n             [(empty? paren_group) max_level]\n     \
    \        [(char=? (first paren_group) #\\()\n              (loop (rest paren_group)\
    \ (+ level 1) (if (> level max_level) level max_level))]\n             [(char=?\
    \ (first paren_group) #\\))\n              (loop (rest paren_group) (- level 1)\
    \ max_level)]\n             [else (loop (rest paren_group) level max_level)])))\n\
    \       (string-split paren_string #\\space)))\n", "  (define (parse_parens paren_string)\n\
    \    (cond [(empty? paren_string) 0]\n          [(char=? (first paren_string)\
    \ #\\()\n           (+ 1 (parse_parens (rest paren_string)))]\n          [(char=?\
    \ (first paren_string) #\\))\n           (- 1 (parse_parens (rest paren_string)))]\n\
    \          [else (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n", "  (define (parse_parens paren_string)\n    (cond\n\
    \      [(empty? paren_string) 0]\n      [(equal? (first paren_string) \"(\") (+\
    \ 1 (parse_parens (rest paren_string)))]\n      [(equal? (first paren_string)\
    \ \")\") (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (let loop ([paren_group\
    \ paren_group] [max_depth 0] [current_depth 0])\n           (cond [(empty? paren_group)\
    \ max_depth]\n                 [(char=? (first paren_group) #\\()\n          \
    \        (loop (rest paren_group)\n                        (if (> (+ current_depth\
    \ 1) max_depth)\n                            (+ current_depth 1)\n           \
    \                 max_depth)\n                        (+ current_depth 1))]\n\
    \                 [(char=? (first paren_group) #\\))\n                  (loop\
    \ (rest paren_group)\n                        max_depth\n                    \
    \    (- current_depth 1))]\n                 [else (loop (rest paren_group) max_depth\
    \ current_depth)])))\n       (string-split paren_string #\\space)))\n", "  (define\
    \ (parse_parens paren_string)\n    (cond\n      [(empty? paren_string) 0]\n  \
    \    [(equal? (first paren_string) #\\() (add1 (parse_parens (rest paren_string)))]\n\
    \      [(equal? (first paren_string) #\\)) (parse_parens (rest paren_string))]))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n", "  (map (lambda\
    \ (paren_group)\n         (parse_nested_parens_helper paren_group 0))\n      \
    \ (string-split paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_group_max_nesting\
    \ paren_group))\n       (string-split paren_string)))\n", "  (define (parse_parens\
    \ paren_string)\n    (define (parse_parens_helper paren_string acc)\n      (cond\
    \ ((null? paren_string) acc)\n            ((equal? (car paren_string) \"(\") (parse_parens_helper\
    \ (cdr paren_string) (add1 acc)))\n            ((equal? (car paren_string) \"\
    )\") (parse_parens_helper (cdr paren_string) (sub1 acc)))\n            (else (parse_parens_helper\
    \ (cdr paren_string) acc))))\n    (parse_parens_helper paren_string 0))\n  (map\
    \ parse_parens (string-split paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (define (parse-parens-iter paren_string count max-count)\n      (cond ((empty?\
    \ paren_string) (list count max-count))\n            ((equal? (first paren_string)\
    \ #\\()\n             (parse-parens-iter (rest paren_string) (+ count 1) (max\
    \ count max-count)))\n            ((equal? (first paren_string) #\\))\n      \
    \       (parse-parens-iter (rest paren_string) (- count 1) (max count max-count)))\n\
    \            (else (parse-parens-iter (rest paren_string) count max-count))))\n\
    \    (parse-parens-iter paren_string 0 0))\n  (define (parse-parens-iter paren_string\
    \ result)\n    (cond ((empty? paren_string) result)\n          ((equal? (first\
    \ paren_string) #\\()\n           (parse-parens-iter (rest paren_string) (append\
    \ result (list (parse_parens paren_string)))))\n          ((equal? (first paren_string)\
    \ #\\))\n           (parse-parens-iter (rest paren_string) (append result (list\
    \ (parse_parens paren_string)))))\n          (else (parse-parens-iter (rest paren_string)\
    \ result))))\n  (parse-parens-iter paren_string '()))\n", "  (map (lambda (paren_group)\n\
    \         (parse_nested_parens_helper paren_group 0))\n       (string-split paren_string)))\n",
  "  (map (lambda (paren_group)\n         (count_parens paren_group 0))\n       (string-split\
    \ paren_string)))\n", "  (define (parse_parens paren_string)\n    (define (parse_parens_helper\
    \ paren_string depth)\n      (cond\n        [(empty? paren_string) depth]\n  \
    \      [(char=? (first paren_string) #\\() (parse_parens_helper (rest paren_string)\
    \ (+ depth 1))]\n        [(char=? (first paren_string) #\\)) (parse_parens_helper\
    \ (rest paren_string) (- depth 1))]\n        [else (parse_parens_helper (rest\
    \ paren_string) depth)]))\n    (parse_parens_helper paren_string 0))\n  (define\
    \ (parse_parens_list paren_string)\n    (cond\n      [(empty? paren_string) empty]\n\
    \      [(char=? (first paren_string) #\\ ) (parse_parens_list (rest paren_string))]\n\
    \      [else (cons (parse_parens paren_string) (parse_parens_list (rest paren_string)))]))\n\
    \  (parse_parens_list paren_string))\n", "  (map (lambda (paren_group)\n     \
    \    (paren_nesting_level paren_group))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (cond\n      [(empty? paren_string)\
    \ 0]\n      [(eq? (first paren_string) #\\() (add1 (parse_parens (rest paren_string)))]\n\
    \      [(eq? (first paren_string) #\\)) (parse_parens (rest paren_string))]))\n\
    \  (map parse_parens (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (let loop ([paren_group paren_group] [max_level 0] [cur_level 0])\n\
    \           (cond [(empty? paren_group) max_level]\n                 [(char=?\
    \ (first paren_group) #\\()\n                  (loop (rest paren_group) max_level\
    \ (+ cur_level 1))]\n                 [(char=? (first paren_group) #\\))\n   \
    \               (loop (rest paren_group) (max max_level cur_level) (- cur_level\
    \ 1))]\n                 [else (loop (rest paren_group) max_level cur_level)])))\n\
    \       (regexp-split #rx\" \" paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (let loop ([paren_group paren_group] [nest_level 0] [max_nest_level\
    \ 0])\n           (cond [(empty? paren_group) max_nest_level]\n              \
    \   [(char=? (first paren_group) #\\()\n                  (loop (rest paren_group)\
    \ (+ nest_level 1) max_nest_level)]\n                 [(char=? (first paren_group)\
    \ #\\))\n                  (loop (rest paren_group) (- nest_level 1) (max nest_level\
    \ max_nest_level))]\n                 [else (loop (rest paren_group) nest_level\
    \ max_nest_level)])))\n       (string-split paren_string)))\n", "  (define (parse_parens\
    \ paren_string)\n    (cond\n      [(empty? paren_string) 0]\n      [(equal? (first\
    \ paren_string) #\\() (add1 (parse_parens (rest paren_string)))]\n      [(equal?\
    \ (first paren_string) #\\)) (sub1 (parse_parens (rest paren_string)))]\n    \
    \  [else (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n", "  (map (lambda (paren_group)\n         (paren_nesting_level\
    \ paren_group))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\n\
    \         (paren_depth paren_group 0))\n       (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (let loop ([paren_string paren_string]\
    \ [paren_count 0] [max_paren_count 0])\n      (cond\n        [(empty? paren_string)\
    \ (list paren_count max_paren_count)]\n        [(char=? (first paren_string) #\\\
    ()\n         (loop (rest paren_string) (+ paren_count 1) max_paren_count)]\n \
    \       [(char=? (first paren_string) #\\))\n         (loop (rest paren_string)\
    \ (- paren_count 1) (max paren_count max_paren_count))]\n        [else (loop (rest\
    \ paren_string) paren_count max_paren_count)])))\n  (define (parse_paren_groups\
    \ paren_groups)\n    (cond\n      [(empty? paren_groups) '()]\n      [else (cons\
    \ (second (parse_parens (first paren_groups))) (parse_paren_groups (rest paren_groups)))]))\n\
    \  (parse_paren_groups (string-split paren_string)))\n", "  (define (parse_nested_parens_helper\
    \ paren_string max_level)\n    (cond\n      [(empty? paren_string) max_level]\n\
    \      [(eq? (first paren_string) #\\()\n       (parse_nested_parens_helper (rest\
    \ paren_string) (+ max_level 1))]\n      [(eq? (first paren_string) #\\))\n  \
    \     (parse_nested_parens_helper (rest paren_string) (- max_level 1))]\n    \
    \  [else (parse_nested_parens_helper (rest paren_string) max_level)]))\n  (parse_nested_parens_helper\
    \ paren_string 0))\n", "  (define (parse_parens paren_string)\n    (cond ((null?\
    \ paren_string) 0)\n          ((eq? (car paren_string) #\\() (+ 1 (parse_parens\
    \ (cdr paren_string))))\n          ((eq? (car paren_string) #\\)) (- 1 (parse_parens\
    \ (cdr paren_string))))))\n  (map parse_parens (string-split paren_string #\\\
    space)))\n", "  (map (lambda (paren_group)\n         (parse_nested_parens_helper\
    \ paren_group 0))\n       (string-split paren_string)))\n", "  (define (parse_parens\
    \ paren_string)\n    (cond\n      [(empty? paren_string) 0]\n      [(equal? (first\
    \ paren_string) #\\()\n       (+ 1 (parse_parens (rest paren_string)))]\n    \
    \  [(equal? (first paren_string) #\\))\n       (- 1 (parse_parens (rest paren_string)))]\n\
    \      [else (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n", "  (map (lambda (paren_group)\n         (let loop\
    \ ([paren_group paren_group] [max_level 0] [current_level 0])\n           (cond\
    \ [(empty? paren_group) max_level]\n                 [(char=? (first paren_group)\
    \ #\\()\n                  (loop (rest paren_group) max_level (+ current_level\
    \ 1))]\n                 [(char=? (first paren_group) #\\))\n                \
    \  (loop (rest paren_group) (max max_level current_level) (- current_level 1))]\n\
    \                 [else (loop (rest paren_group) max_level current_level)])))\n\
    \       (split-at (regexp #rx\" \") paren_string)))\n", "  (define (parse_parens\
    \ paren_string)\n    (define (parse_parens_helper paren_string depth)\n      (cond\n\
    \        [(empty? paren_string) depth]\n        [(char=? (first paren_string)\
    \ #\\() (parse_parens_helper (rest paren_string) (+ depth 1))]\n        [(char=?\
    \ (first paren_string) #\\)) (parse_parens_helper (rest paren_string) (- depth\
    \ 1))]\n        [else (parse_parens_helper (rest paren_string) depth)]))\n   \
    \ (parse_parens_helper paren_string 0))\n  (define (parse_parens_list paren_string)\n\
    \    (cond\n      [(empty? paren_string) empty]\n      [(char=? (first paren_string)\
    \ #\\ ) (parse_parens_list (rest paren_string))]\n      [else (cons (parse_parens\
    \ paren_string) (parse_parens_list (rest paren_string)))]))\n  (parse_parens_list\
    \ paren_string))\n", "  (map (lambda (paren_group)\n         (let loop ([paren_group\
    \ paren_group] [max_depth 0] [current_depth 0])\n           (cond [(empty? paren_group)\
    \ max_depth]\n                 [(char=? (first paren_group) #\\()\n          \
    \        (loop (rest paren_group)\n                        (if (> current_depth\
    \ max_depth)\n                            current_depth\n                    \
    \        max_depth)\n                        (+ current_depth 1))]\n         \
    \        [(char=? (first paren_group) #\\))\n                  (loop (rest paren_group)\n\
    \                        (if (> current_depth max_depth)\n                   \
    \         current_depth\n                            max_depth)\n            \
    \            (- current_depth 1))]\n                 [else (loop (rest paren_group)\n\
    \                             max_depth\n                             current_depth)])))\n\
    \       (regexp-split #rx\" \" paren_string)))\n", "  (define (parse_parens paren_string)\n\
    \    (let loop ([paren_string paren_string] [count 0] [max_count 0])\n      (cond\
    \ [(empty? paren_string) max_count]\n            [(char=? (first paren_string)\
    \ #\\()\n             (loop (rest paren_string) (+ count 1) (if (> count max_count)\
    \ count max_count))]\n            [(char=? (first paren_string) #\\))\n      \
    \       (loop (rest paren_string) (- count 1) max_count)]\n            [else (loop\
    \ (rest paren_string) count max_count)])))\n  (map parse_parens (string-split\
    \ paren_string)))\n", "  (map (lambda (paren_group)\n         (paren_nesting_level\
    \ paren_group))\n       (string-split paren_string)))\n", "  (map (lambda (paren_group)\
    \ (parse_nested_parens_helper paren_group 0)) (string-split paren_string)))\n",
  "  (define (parse_parens paren_string)\n    (cond\n      [(empty? paren_string)\
    \ 0]\n      [(eq? (first paren_string) #\\()\n       (add1 (parse_parens (rest\
    \ paren_string)))]\n      [(eq? (first paren_string) #\\))\n       (sub1 (parse_parens\
    \ (rest paren_string)))]\n      [else (parse_parens (rest paren_string))]))\n\
    \  (map parse_parens (string-split paren_string #\\space)))\n", "  (define (parse_parens\
    \ paren_string)\n    (cond\n      [(empty? paren_string) 0]\n      [(eq? (first\
    \ paren_string) #\\() (add1 (parse_parens (rest paren_string)))]\n      [(eq?\
    \ (first paren_string) #\\)) (sub1 (parse_parens (rest paren_string)))]\n    \
    \  [else (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n", "  (map (lambda (paren_group)\n         (max-depth\
    \ paren_group 0 0))\n       (string-split paren_string)))\n", "  (map (\u03BB\
    \ (paren_group) (parse_nested_parens_helper paren_group 0)) (string-split paren_string\
    \ #\\space)))\n", "  (define (parse_parens paren_string)\n    (cond ((null? paren_string)\
    \ 0)\n          ((equal? (car paren_string) \"(\")\n           (+ 1 (parse_parens\
    \ (cdr paren_string))))\n          ((equal? (car paren_string) \")\")\n      \
    \     (- 1 (parse_parens (cdr paren_string))))\n          (else (parse_parens\
    \ (cdr paren_string)))))\n  (map (lambda (paren_string) (parse_parens paren_string))\
    \ (string-split paren_string)))\n", "  (define (helper paren_string current_level\
    \ max_level)\n    (cond\n      [(empty? paren_string) (list max_level)]\n    \
    \  [(char=? (first paren_string) #\\()\n       (helper (rest paren_string) (+\
    \ current_level 1) (max max_level current_level))]\n      [(char=? (first paren_string)\
    \ #\\))\n       (helper (rest paren_string) (- current_level 1) max_level)]\n\
    \      [else (helper (rest paren_string) current_level max_level)]))\n  (helper\
    \ paren_string 0 0))\n", "  (define (parse_parens paren_string)\n    (cond\n \
    \     [(empty? paren_string) 0]\n      [(eq? (first paren_string) #\\()\n    \
    \   (add1 (parse_parens (rest paren_string)))]\n      [(eq? (first paren_string)\
    \ #\\))\n       (sub1 (parse_parens (rest paren_string)))]\n      [else (parse_parens\
    \ (rest paren_string))]))\n  (map parse_parens (string-split paren_string #\\\
    space)))\n", "  (define (parse_parens paren_string)\n    (let loop ([paren_string\
    \ paren_string] [level 0] [max-level 0])\n      (cond\n        [(empty? paren_string)\
    \ max-level]\n        [(char=? (first paren_string) #\\()\n         (loop (rest\
    \ paren_string) (+ level 1) (if (&gt; level max-level) level max-level))]\n  \
    \      [(char=? (first paren_string) #\\))\n         (loop (rest paren_string)\
    \ (- level 1) max-level)]\n        [else (loop (rest paren_string) level max-level)])))\n\
    \  (map parse_parens (string-split paren_string)))\n</code>\n", "  (map (lambda\
    \ (paren_group)\n         (let loop ([paren_group paren_group] [max_level 0] [level\
    \ 0])\n           (cond [(empty? paren_group) max_level]\n                 [(char=?\
    \ (first paren_group) #\\()\n                  (loop (rest paren_group)\n    \
    \                    (if (> level max_level) level max_level)\n              \
    \          (+ level 1))]\n                 [(char=? (first paren_group) #\\))\n\
    \                  (loop (rest paren_group)\n                        (if (> level\
    \ max_level) level max_level)\n                        (- level 1))]\n       \
    \          [else (loop (rest paren_group) max_level level)])))\n       (regexp-split\
    \ #rx\" \" paren_string)))\n", "  (define (parse_parens paren_string)\n    (cond\n\
    \      [(empty? paren_string) 0]\n      [(equal? (first paren_string) #\\()\n\
    \       (+ 1 (parse_parens (rest paren_string)))]\n      [(equal? (first paren_string)\
    \ #\\))\n       (parse_parens (rest paren_string))]))\n  (map parse_parens (string-split\
    \ paren_string #\\space)))\n", "  (define (parse_nested_parens_helper paren_string\
    \ max_nest_level)\n    (cond\n      [(empty? paren_string) max_nest_level]\n \
    \     [(equal? (first paren_string) #\\()\n       (parse_nested_parens_helper\
    \ (rest paren_string) (+ max_nest_level 1))]\n      [(equal? (first paren_string)\
    \ #\\))\n       (parse_nested_parens_helper (rest paren_string) (- max_nest_level\
    \ 1))]\n      [else (parse_nested_parens_helper (rest paren_string) max_nest_level)]))\n\
    \  (define (parse_nested_parens_helper_2 paren_string max_nest_level result)\n\
    \    (cond\n      [(empty? paren_string) (cons max_nest_level result)]\n     \
    \ [(equal? (first paren_string) #\\ )\n       (parse_nested_parens_helper_2 (rest\
    \ paren_string) 0 (cons max_nest_level result))]\n      [(equal? (first paren_string)\
    \ #\\()\n       (parse_nested_parens_helper_2 (rest paren_string) (+ max_nest_level\
    \ 1) result)]\n      [(equal? (first paren_string) #\\))\n       (parse_nested_parens_helper_2\
    \ (rest paren_string) (- max_nest_level 1) result)]\n      [else (parse_nested_parens_helper_2\
    \ (rest paren_string) max_nest_level result)]))\n  (parse_nested_parens_helper_2\
    \ paren_string 0 '()))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
