name: HumanEval_54_same_chars
language: rkt
prompt: "#lang racket\n\n;; Check if two words have the same characters.\n;; >>> (same_chars\
  \ \"eabcdzzzz\" \"dddzzzzzzzddeddabc\")\n;; #t\n;; >>> (same_chars \"abcd\" \"dddddddabc\"\
  )\n;; #t\n;; >>> (same_chars \"dddddddabc\" \"abcd\")\n;; #t\n;; >>> (same_chars\
  \ \"eabcd\" \"dddddddabc\")\n;; #f\n;; >>> (same_chars \"abcd\" \"dddddddabce\"\
  )\n;; #f\n;; >>> (same_chars \"eabcdzzzz\" \"dddzzzzzzzddddabc\")\n;; #f\n(define\
  \ (same_chars s0 s1)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate same_chars))\n\
  \    (check-equal? (candidate \"eabcdzzzz\" \"dddzzzzzzzddeddabc\") #t)\n    (check-equal?\
  \ (candidate \"abcd\" \"dddddddabc\") #t)\n    (check-equal? (candidate \"dddddddabc\"\
  \ \"abcd\") #t)\n    (check-equal? (candidate \"eabcd\" \"dddddddabc\") #f)\n  \
  \  (check-equal? (candidate \"abcd\" \"dddddddabcf\") #f)\n    (check-equal? (candidate\
  \ \"eabcdzzzz\" \"dddzzzzzzzddddabc\") #f)\n    (check-equal? (candidate \"aabb\"\
  \ \"aaccc\") #f)\n))\n\n(test-humaneval)"
completions: ["  (define (same-chars-helper s0 s1)\n    (if (null? s0)\n        (if\
    \ (null? s1)\n            #t\n            #f)\n        (if (null? s1)\n      \
    \      #f\n            (if (char=? (car s0) (car s1))\n                (same-chars-helper\
    \ (cdr s0) (cdr s1))\n                (same-chars-helper (cdr s0) s1)))))\n  (same-chars-helper\
    \ (string->list s0) (string->list s1)))\n", "  (define (same-chars-helper s0 s1)\n\
    \    (cond\n      [(empty? s0) #t]\n      [(empty? s1) #f]\n      [(char=? (first\
    \ s0) (first s1)) (same-chars-helper (rest s0) (rest s1))]\n      [else (same-chars-helper\
    \ (rest s0) s1)]))\n  (same-chars-helper (string->list s0) (string->list s1)))\n",
  "  (define (same-chars-iter s0 s1)\n    (cond [(empty? s0) #t]\n          [(empty?\
    \ s1) #f]\n          [(char=? (first s0) (first s1)) (same-chars-iter (rest s0)\
    \ (rest s1))]\n          [else (same-chars-iter s0 (rest s1))]))\n  (same-chars-iter\
    \ s0 s1))\n", "  (define (same-chars-helper s0 s1)\n    (cond\n      [(empty?\
    \ s0) #t]\n      [(empty? s1) #f]\n      [(char=? (first s0) (first s1)) (same-chars-helper\
    \ (rest s0) (rest s1))]\n      [else (same-chars-helper (rest s0) s1)]))\n  (same-chars-helper\
    \ (string->list s0) (string->list s1)))\n", "  (define (same-chars-helper s0 s1)\n\
    \    (cond ((and (string=? s0 \"\") (string=? s1 \"\")) #t)\n          ((string=?\
    \ s0 \"\") #f)\n          ((string=? s1 \"\") #f)\n          ((string-contains\
    \ s1 (string-ref s0 0))\n           (same-chars-helper (substring s0 1 (string-length\
    \ s0))\n                              (substring s1 0 (string-index s1 (string-ref\
    \ s0 0)))))\n          (else #f)))\n  (same-chars-helper s0 s1))\n", "  (define\
    \ (same-chars-iter s0 s1)\n    (cond\n      [(empty? s0) #t]\n      [(empty? s1)\
    \ #f]\n      [(char=? (first s0) (first s1)) (same-chars-iter (rest s0) (rest\
    \ s1))]\n      [else (same-chars-iter s0 (rest s1))]))\n  (same-chars-iter s0\
    \ s1))\n", "  (define (count-chars s)\n    (for/fold ([counts (make-hash)])\n\
    \              ([c (in-string s)])\n      (hash-update counts c add1 0)))\n  (define\
    \ (count-diff counts0 counts1)\n    (for/fold ([diff 0])\n              ([c (in-hash\
    \ counts0)])\n      (let ([c0 (hash-ref counts0 c 0)]\n            [c1 (hash-ref\
    \ counts1 c 0)])\n        (if (< c0 c1)\n            (add1 diff)\n           \
    \ (if (> c0 c1)\n                (add1 diff))))))\n  (= 0 (count-diff (count-chars\
    \ s0) (count-chars s1))))\n", "  (and (equal? (sort s0) (sort s1))\n       (equal?\
    \ (string-length s0) (string-length s1))))\n", "  (define (same_chars-iter s0\
    \ s1)\n    (cond\n      [(empty? s0) #t]\n      [(empty? s1) #f]\n      [(char=?\
    \ (first s0) (first s1)) (same_chars-iter (rest s0) (rest s1))]\n      [else (same_chars-iter\
    \ s0 (rest s1))]))\n  (same_chars-iter s0 s1))\n", "  (define (same-chars-iter\
    \ s0 s1)\n    (cond ((and (string=? s0 \"\") (string=? s1 \"\")) #t)\n       \
    \   ((string=? s0 \"\") #f)\n          ((string=? s1 \"\") #f)\n          ((string-contains\
    \ s1 (string-ref s0 0))\n           (same-chars-iter (substring s0 1 (string-length\
    \ s0))\n                            (substring s1 0 (string-index s1 (string-ref\
    \ s0 0)))))\n          (else (same-chars-iter (substring s0 1 (string-length s0))\
    \ s1))))\n  (same-chars-iter s0 s1))\n", "  (define (same-chars-helper s0 s1)\n\
    \    (cond\n      [(empty? s0) #t]\n      [(empty? s1) #f]\n      [(char=? (first\
    \ s0) (first s1)) (same-chars-helper (rest s0) (rest s1))]\n      [else (same-chars-helper\
    \ (rest s0) s1)]))\n  (same-chars-helper (string->list s0) (string->list s1)))\n",
  "  (define (same_chars-helper s0 s1)\n    (cond\n      [(empty? s0) #t]\n      [(empty?\
    \ s1) #f]\n      [(char=? (first s0) (first s1)) (same_chars-helper (rest s0)\
    \ (rest s1))]\n      [else (same_chars-helper s0 (rest s1))]))\n  (same_chars-helper\
    \ (string->list s0) (string->list s1)))\n", "  (define (same-chars-helper s0 s1)\n\
    \    (cond\n      [(empty? s0) (empty? s1)]\n      [(empty? s1) #f]\n      [else\
    \ (and (member (first s0) s1)\n                 (same-chars-helper (rest s0) (remove\
    \ (first s0) s1)))]))\n  (same-chars-helper (string->list s0) (string->list s1)))\n",
  "  (define (count-chars s)\n    (let loop ([s s] [counts (make-hash)])\n      (cond\
    \ [(empty? s) counts]\n            [else (let ([c (first s)])\n              \
    \      (hash-update counts c add1 0)\n                    (loop (rest s) counts))])))\n\
    \  (let ([counts0 (count-chars s0)]\n        [counts1 (count-chars s1)])\n   \
    \ (andmap (lambda (c) (= (hash-ref counts0 c 0) (hash-ref counts1 c 0)))\n   \
    \         (hash-keys counts0))))\n", "  (define (same-chars-helper s0 s1)\n  \
    \  (cond\n      [(empty? s0) (empty? s1)]\n      [(empty? s1) #f]\n      [else\
    \ (and (char=? (first s0) (first s1))\n                 (same-chars-helper (rest\
    \ s0) (rest s1)))]))\n  (same-chars-helper (string-sort s0) (string-sort s1)))\n",
  "  (and (every (lambda (c) (member c s0)) s1)\n       (every (lambda (c) (member\
    \ c s1)) s0)))\n", "  (define (same-chars-helper s0 s1)\n    (cond\n      [(empty?\
    \ s0) #t]\n      [(empty? s1) #f]\n      [(char=? (first s0) (first s1)) (same-chars-helper\
    \ (rest s0) (rest s1))]\n      [else (same-chars-helper (rest s0) s1)]))\n  (same-chars-helper\
    \ (string->list s0) (string->list s1)))\n", "  (let ([s0 (string->list s0)]\n\
    \        [s1 (string->list s1)])\n    (and (every (lambda (c) (member c s0)) s1)\n\
    \         (every (lambda (c) (member c s1)) s0))))\n", "  (define (same-chars-helper\
    \ s0 s1)\n    (cond\n      [(empty? s0) #t]\n      [(empty? s1) #f]\n      [(char=?\
    \ (first s0) (first s1)) (same-chars-helper (rest s0) (rest s1))]\n      [else\
    \ (same-chars-helper (rest s0) s1)]))\n  (same-chars-helper (string->list s0)\
    \ (string->list s1)))\n", "  (define (count-chars s)\n    (define (count-chars-iter\
    \ s acc)\n      (if (empty? s)\n          acc\n          (let ([c (first s)])\n\
    \            (count-chars-iter (rest s) (cons (cons c (add1 (or (assoc c acc)\
    \ 0))) (remove (lambda (pair) (equal? c (car pair))) acc))))))\n    (count-chars-iter\
    \ s '()))\n  (equal? (count-chars s0) (count-chars s1)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
