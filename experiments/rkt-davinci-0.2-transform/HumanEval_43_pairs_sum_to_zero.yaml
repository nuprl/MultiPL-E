name: HumanEval_43_pairs_sum_to_zero
language: rkt
prompt: "#lang racket\n\n;; pairs_sum_to_zero takes a list of integers as an input.\n\
  ;; it returns True if there are two distinct elements in the list that\n;; sum to\
  \ zero, and False otherwise.\n;; >>> (pairs_sum_to_zero (list 1 3 5 0))\n;; #f\n\
  ;; >>> (pairs_sum_to_zero (list 1 3 -2 1))\n;; #f\n;; >>> (pairs_sum_to_zero (list\
  \ 1 2 3 7))\n;; #f\n;; >>> (pairs_sum_to_zero (list 2 4 -5 3 5 7))\n;; #t\n;; >>>\
  \ (pairs_sum_to_zero (list 1))\n;; #f\n(define (pairs_sum_to_zero l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate pairs_sum_to_zero))\n\
  \    (check-equal? (candidate (list 1 3 5 0)) #f)\n    (check-equal? (candidate\
  \ (list 1 3 -2 1)) #f)\n    (check-equal? (candidate (list 1 2 3 7)) #f)\n    (check-equal?\
  \ (candidate (list 2 4 -5 3 5 7)) #t)\n    (check-equal? (candidate (list 1)) #f)\n\
  \    (check-equal? (candidate (list -3 9 -1 3 2 30)) #t)\n    (check-equal? (candidate\
  \ (list -3 9 -1 3 2 31)) #t)\n    (check-equal? (candidate (list -3 9 -1 4 2 30))\
  \ #f)\n    (check-equal? (candidate (list -3 9 -1 4 2 31)) #f)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(member\
    \ (sub1 (first l) (second l)) (rest (rest l))) #t]\n    [else (pairs_sum_to_zero\
    \ (rest l))]))\n", "  (cond\n    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n\
    \    [(member (- (first l) (first (rest l))) (rest (rest l))) #t]\n    [else (pairs_sum_to_zero\
    \ (rest l))]))\n", "  (cond\n    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n\
    \    [(= 0 (apply + (take l 2))) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n",
  "  (cond\n    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(= (sum (first l)\
    \ (first (rest l))) 0) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n", "  (cond\n\
    \    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(member (- (first l) (first\
    \ (rest l))) (rest (rest l))) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n",
  "  (cond\n    [(empty? l) #f]\n    [(member (sub1 (first l)) (rest l)) #t]\n   \
    \ [else (pairs_sum_to_zero (rest l))]))\n", "  (cond\n    [(empty? l) #f]\n  \
    \  [(empty? (rest l)) #f]\n    [(zero? (+ (first l) (first (rest l)))) #t]\n \
    \   [else (pairs_sum_to_zero (rest l))]))\n", "  (cond\n    [(empty? l) #f]\n\
    \    [(empty? (rest l)) #f]\n    [(member (add1 (first l)) (rest l)) #t]\n   \
    \ [else (pairs_sum_to_zero (rest l))]))\n", "  (cond\n    [(empty? l) #f]\n  \
    \  [(empty? (rest l)) #f]\n    [(member (sub1 (first l) (first (rest l))) (rest\
    \ (rest l))) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n", "  (define (helper\
    \ l)\n    (if (null? l)\n        #f\n        (if (member (- (car l)) (cdr l))\n\
    \            #t\n            (helper (cdr l)))))\n  (helper l))\n", "  (cond\n\
    \    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(zero? (+ (first l) (first\
    \ (rest l)))) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n", "  (cond\n  \
    \  [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(= (sum (first l) (first\
    \ (rest l))) 0) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n", "  (cond\n\
    \    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(member (sub1 (first l)\
    \ (second l)) (rest (rest l))) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n",
  "  (cond\n    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(= (sum (first l)\
    \ (first (rest l))) 0) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n", "  (cond\n\
    \    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(= (sum (first l) (first\
    \ (rest l))) 0) #t]\n    [else (pairs_sum_to_zero (rest l))]))\n", "  (cond\n\
    \    [(empty? l) false]\n    [(empty? (rest l)) false]\n    [(member (sub1 (first\
    \ l) (second l)) (rest (rest l))) true]\n    [else (pairs_sum_to_zero (rest l))]))\n",
  "  (cond\n    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(member (sum (first\
    \ l) (first (rest l))) (rest (rest l))) #t]\n    [else (pairs_sum_to_zero (rest\
    \ l))]))\n", "  (cond\n    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n    [(member\
    \ (sum (first l) (second l)) (rest (rest l))) #t]\n    [else (pairs_sum_to_zero\
    \ (rest l))]))\n", "  (cond\n    [(empty? l) #f]\n    [(empty? (rest l)) #f]\n\
    \    [(= (list-ref l 0) (- (list-ref l 1))) #t]\n    [else (pairs_sum_to_zero\
    \ (rest l))]))\n", "  (cond\n    [(null? l) #f]\n    [(member (car l) (cdr l))\
    \ #t]\n    [else (pairs_sum_to_zero (cdr l))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
