name: HumanEval_62_derivative
language: rkt
prompt: "#lang racket\n\n;; xs represent coefficients of a polynomial.\n;; xs[0] +\
  \ xs[1] * x + xs[2] * x^2 + ....\n;; Return derivative of this polynomial in the\
  \ same form.\n;; >>> (derivative (list 3 1 2 4 5))\n;; (list 1 4 12 20)\n;; >>>\
  \ (derivative (list 1 2 3))\n;; (list 2 6)\n(define (derivative xs)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate derivative))\n\
  \    (check-equal? (candidate (list 3 1 2 4 5)) (list 1 4 12 20))\n    (check-equal?\
  \ (candidate (list 1 2 3)) (list 2 6))\n    (check-equal? (candidate (list 3 2 1))\
  \ (list 2 2))\n    (check-equal? (candidate (list 3 2 1 0 4)) (list 2 2 0 16))\n\
  \    (check-equal? (candidate (list 1)) (list ))\n))\n\n(test-humaneval)"
completions: ["  (if (null? xs)\n      '()\n      (cons (* (car xs) (length xs))\n\
    \            (derivative (cdr xs)))))\n", "  (if (null? xs)\n      '()\n     \
    \ (cons (* (car xs) (length xs))\n            (derivative (cdr xs)))))\n", " \
    \ (cond [(empty? xs) empty]\n        [(empty? (rest xs)) empty]\n        [else\
    \ (cons (* (first xs) (add1 (length xs)))\n                     (derivative (rest\
    \ xs)))]))\n", "  (if (empty? xs)\n      empty\n      (cons (* (first xs) (length\
    \ xs))\n            (derivative (rest xs)))))\n", "  (cond [(empty? xs) empty]\n\
    \        [(empty? (rest xs)) empty]\n        [else (cons (* (first xs) (add1 (length\
    \ xs)))\n                     (derivative (rest xs)))]))\n", "  (if (null? xs)\n\
    \      '()\n      (cons (* (car xs) (length xs))\n            (derivative (cdr\
    \ xs)))))\n", "  (cond [(empty? xs) empty]\n        [(empty? (rest xs)) empty]\n\
    \        [else (cons (* (first xs) (add1 (length xs)))\n                     (derivative\
    \ (rest xs)))]))\n", "  (cond\n    [(empty? xs) empty]\n    [(= (length xs) 1)\
    \ (list 0)]\n    [else (cons (* (first xs) (length xs)) (derivative (rest xs)))]))\n",
  "  (if (null? xs)\n      '()\n      (cons (* (car xs) (length xs))\n           \
    \ (derivative (cdr xs)))))\n", "  (if (empty? xs)\n      empty\n      (cons (*\
    \ (first xs) (sub1 (length xs)))\n            (derivative (rest xs)))))\n", " \
    \ (let loop ([xs xs] [i 1])\n    (if (null? xs)\n        '()\n        (cons (*\
    \ i (car xs)) (loop (cdr xs) (+ i 1))))))\n", "  (cond\n    [(empty? xs) empty]\n\
    \    [(empty? (rest xs)) empty]\n    [else (cons (* (first xs) (add1 (length xs)))\n\
    \                 (derivative (rest xs)))]))\n", "  (if (null? xs)\n      '()\n\
    \      (cons (* (car xs) (length xs))\n            (derivative (cdr xs)))))\n",
  "  (if (null? xs)\n      '()\n      (cons (* (car xs) (length xs))\n           \
    \ (derivative (cdr xs)))))\n", "  (if (null? xs)\n      '()\n      (cons (* (car\
    \ xs) (length xs))\n            (derivative (cdr xs)))))\n", "  (define (derivative-iter\
    \ xs n)\n    (if (empty? xs)\n        empty\n        (cons (* n (first xs))\n\
    \              (derivative-iter (rest xs) (+ n 1)))))\n  (derivative-iter xs 1))\n",
  "  (if (null? xs)\n      '()\n      (cons (* (car xs) (length xs))\n           \
    \ (derivative (cdr xs)))))\n", "  (cond\n    [(empty? xs) empty]\n    [(empty?\
    \ (rest xs)) empty]\n    [else (cons (* (first xs) (add1 (length xs)))\n     \
    \            (derivative (rest xs)))]))\n", "  (if (null? xs)\n      '()\n   \
    \   (cons (* (car xs) (length xs))\n            (derivative (cdr xs)))))\n", " \
    \ (cond\n    [(empty? xs) empty]\n    [(empty? (rest xs)) empty]\n    [else (cons\
    \ (* (first xs) (add1 (length xs)))\n                 (derivative (rest xs)))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
