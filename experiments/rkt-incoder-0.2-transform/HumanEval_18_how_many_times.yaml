name: HumanEval_18_how_many_times
language: rkt
prompt: "#lang racket\n\n;; Find how many times a given substring can be found in\
  \ the original string. Count overlaping cases.\n;; >>> (how_many_times \"\" \"a\"\
  )\n;; 0\n;; >>> (how_many_times \"aaa\" \"a\")\n;; 3\n;; >>> (how_many_times \"\
  aaaa\" \"aa\")\n;; 3\n(define (how_many_times string substring)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate how_many_times))\n\
  \    (check-equal? (candidate \"\" \"x\") 0)\n    (check-equal? (candidate \"xyxyxyx\"\
  \ \"x\") 4)\n    (check-equal? (candidate \"cacacacac\" \"cac\") 4)\n    (check-equal?\
  \ (candidate \"john doe\" \"john\") 1)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? string) 0]\n    [(equal? (substring string) (string-ref\
    \ string 0)) 1]\n    [else (+ 1 (how_many_times (string->list string) (substring\
    \ string)))]))\n", "  (define (how_many_times-helper string substring i count)\n\
    \    (cond [(empty? string) count]\n          [(equal? (substring string) (string-ref\
    \ string i)) (how_many_times-helper (string->list string) (substring string) (+\
    \ i 1) (+ count 1))]\n          [(equal? (substring string) (string-ref string\
    \ i)) (how_many_times-helper (string->list string) (substring string) (+ i 1)\
    \ count)]\n          [else (how_many_times-helper (string->list string) (substring\
    \ string) (+ i 1) count)]))\n  (how_many_times-helper string substring 0 (length\
    \ string)))\n", "  (let loop ((count 0) (index 0))\n    (cond\n      [(empty?\
    \ string) count]\n      [(eq? (car string) substring) (loop (+ count 1) (+ index\
    \ 1))]\n      [else (loop (+ count 1) (+ index 1))])))\n", "  (let ((count 0))\n\
    \    (for-each (lambda (c)\n                (when (string-match substring c)\n\
    \                  (set! count (+ count 1)))\n              string)\n        \
    \      (lambda (c)\n                (when (string-match substring c)\n       \
    \           (set! count (+ count 1))))\n              (lambda (c)\n          \
    \      (when (string-match substring c)\n                  (set! count (+ count\
    \ 1))))\n              (lambda (c)\n                (when (string-match substring\
    \ c)\n                  (set! count (+ count 1))))\n              (lambda (c)\n\
    \                (when (string-match substring c)\n                  (set! count\
    \ (+ count 1))))\n              (lambda (c)\n                (when (string-match\
    \ substring c)\n                  (set! count (+ count 1))))\n              (lambda\
    \ (c)\n                (when (string-match substring c)\n                  (set!\
    \ count (+ count 1))))\n              (lambda (c)\n                (when (string-match\
    \ substring c)\n                  (set! count (+ count 1))))\n              (lambda\
    \ (c)\n                (when (string-match substring c)\n                  (set!\
    \ count (+ count 1))))\n              (lambda (c)\n                (when (string-match\
    \ substring c)\n                  (set! count (+ count 1))))\n              (lambda\
    \ (c)\n                (when (string-match substring c)\n                  (set!\
    \ count (+ count 1))))\n              (lambda (c)\n                (when (string-match\
    \ substring c)\n                  (set! count (+ count 1))))\n              (lambda\
    \ (c)\n                (when (string-match substring c)\n                  (set!\
    \ count (+ count 1))))\n              (lambda (c)\n                (when (string-match\
    \ substring c)\n                  (set! count (+ count 1))))\n              (lambda\
    \ (c)\n                (when (string-match substring c)\n                  (set!\
    \ count (+ count 1))))\n              (lambda (c)\n                (when (string-match\
    \ substring c)\n                  (set! count (+ count 1))))\n              (lambda\
    \ (c)\n                (when (string-match substring c)\n                  (set!\
    \ count (+ count 1))))\n              (lambda (c)\n                (when (string-match\
    \ substring c)\n                  (set! count (+ count 1))))\n              (lambda\
    \ (c)\n                (when (string-match substring c)\n                  (set!\
    \ count (+ count 1))))\n              (lambda (c)\n                (when (string-match\
    \ substring c)\n                  (set! count (+ count 1))))\n              (",
  "  (let loop ((i 0)\n             (count 0))\n    (cond ((eq? i 0) count)\n    \
    \      ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n   \
    \       ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n  \
    \        ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n \
    \         ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (string-length string) i)\n           (loop (+ i 1) count))\n\
    \          ((eq? (", "  (let loop ((i 0)\n             (count 0))\n    (if (string-empty?\
    \ string)\n        count\n        (loop (+ i 1) (if (equal? (substring string)\
    \ (string-ref string i)) (+ count 1) count))))))\n", "  (let loop ((i 0)\n   \
    \          (count 0))\n    (cond\n      [(empty? string) count]\n      [(equal?\
    \ (char-ref string i) substring) (loop (+ i 1) (+ count 1))]\n      [else (loop\
    \ (+ i 1) (+ count 1))]))\n  )\n", "  (cond [(empty? string) 0]\n        [(equal?\
    \ (first string) substring) (+ 1 (how_many_times (rest string) substring))]\n\
    \        [else (+ (how_many_times (rest string) substring) (how_many_times (first\
    \ string) substring))]))\n", "  (cond [(empty? string) 0]\n        [(equal? (substring\
    \ string) (string-ref string 0)) 1]\n        [else (+ 1 (how_many_times (string->list\
    \ string) (substring string)))]))\n", "  (cond [(empty? string) 0]\n        [(equal?\
    \ (substring string) (string-ref string 0)) 1]\n        [else (+ (how_many_times\
    \ (string->list string) (substring string)) 1)]))\n", "  (cond\n    [(empty? string)\
    \ 0]\n    [(equal? (substring string) (string-ref string 0)) 1]\n    [else (+\
    \ 1 (how_many_times (string->list string) (substring string)))]))\n", "  (define\
    \ (how_many_times-helper string substring count)\n    (cond [(empty? string) count]\n\
    \          [(equal? (first string) substring) (how_many_times-helper (rest string)\
    \ substring (+ count 1))]\n          [else (how_many_times-helper (rest string)\
    \ substring (+ count 1))]))\n  (how_many_times-helper string substring 0))\n",
  "  (cond [(empty? string) 0]\n        [(equal? (substring string) (string-ref string\
    \ 0)) 1]\n        [else (+ 1 (how_many_times (string->list string) (substring\
    \ string)))]))\n", "  (let ((count 0))\n    (for-each (lambda (c)\n          \
    \      (if (string-match substring c)\n                    (set! count (+ count\
    \ 1))\n                    (set! count 0))\n              string)\n          \
    \    (lambda (c)\n                (if (string-match substring c)\n           \
    \         (set! count (+ count 1))\n                    (set! count 0))\n    \
    \          string)))\n</code>\n<|/ a tags=racket,scheme |>\n<| c |>\nI like your\
    \ solution, it's very elegant. However I cannot get it to work. I've tried it\
    \ on http://racket-lang.org/ and on http://ideone.com/. Both give me an error\
    \ on the \"(define (how_many_times string substring)\" line. Do you know why this\
    \ is?\n<|/ c |>\n<| c |>\nI got it to work. Thanks for your help. I didn't realize\
    \ that Racket had a for-each function.\n<|/ c |>\n<| c |>\n: Racket has `for`\
    \ loops, not `for-each`.\n<|/ c |>\n<| a tags=racket,scheme |>\nHere's a solution\
    \ that doesn't use any libraries:\n<code>", "  (let ((count 0))\n    (for-each\
    \ (lambda (c)\n                (when (string=? c substring)\n                \
    \  (set! count (add1 count)))\n              (string-length string))\n       \
    \       string)))\n", "  (cond [(empty? string) 0]\n        [(equal? (substring\
    \ string) (string-ref string 0)) 1]\n        [else (+ 1 (how_many_times (string->list\
    \ string) (substring string)))]))\n", "  (let ((count 0))\n    (loop for i from\
    \ 0 to (string-length string)\n          for j from 0 to (string-length substring)\n\
    \          when (string=? (substring i j) string)\n          do (set! count (+\
    \ count 1)))))\n", "  (let loop ((i 0)\n             (count 0))\n    (cond\n \
    \     [(empty? string) count]\n      [(equal? (substring string) (string-ref string\
    \ i)) (loop (+ i 1) (+ count 1))]\n      [else (loop (+ i 1) (+ count 1))])))\n",
  "  (let ((count 0))\n    (loop for i from 0 to (length string) by 1\n          for\
    \ j from 0 to (length substring) by 1\n          when (string= (string-ref string\
    \ i) (string-ref substring j))\n          do (incf count)\n          finally (return\
    \ count))\n  )\n)\n", "  (define (how_many string substring count)\n    (cond\n\
    \      [(empty? string) count]\n      [(equal? (car string) substring) (how_many\
    \ (cdr string) substring (incf count))]\n      [else (how_many (cdr string) substring\
    \ count)]\n      ))\n  (how_many string substring 0))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
