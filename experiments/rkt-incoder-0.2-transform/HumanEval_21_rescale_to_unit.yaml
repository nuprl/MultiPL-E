name: HumanEval_21_rescale_to_unit
language: rkt
prompt: "#lang racket\n\n;; Given list of numbers (of at least two elements), apply\
  \ a linear transform to that list,\n;; such that the smallest number will become\
  \ 0 and the largest will become 1\n;; >>> (rescale_to_unit (list 1.0 2.0 3.0 4.0\
  \ 5.0))\n;; (list 0.0 0.25 0.5 0.75 1.0)\n(define (rescale_to_unit numbers)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate rescale_to_unit))\n\
  \    (check-equal? (candidate (list 2.0 49.9)) (list 0.0 1.0))\n    (check-equal?\
  \ (candidate (list 100.0 49.9)) (list 1.0 0.0))\n    (check-equal? (candidate (list\
  \ 1.0 2.0 3.0 4.0 5.0)) (list 0.0 0.25 0.5 0.75 1.0))\n    (check-equal? (candidate\
  \ (list 2.0 1.0 5.0 3.0 4.0)) (list 0.25 0.0 1.0 0.5 0.75))\n    (check-equal? (candidate\
  \ (list 12.0 11.0 15.0 13.0 14.0)) (list 0.25 0.0 1.0 0.5 0.75))\n))\n\n(test-humaneval)"
completions: ["  (let ((min (min numbers))\n        (max (max numbers)))\n    (map\
    \ (lambda (x) (/ x max)) numbers)))\n", "  (let ((min (min numbers)))\n    (let\
    \ ((max (max numbers)))\n      (map (lambda (x) (/ x max)) numbers))))\n", " \
    \ (let ((min (first numbers))\n        (max (second numbers)))\n    (map #(/ %\
    \ max) numbers)))\n", "  (let ((min (first numbers))\n        (max (second numbers)))\n\
    \    (map (lambda (x) (/ x max)) numbers)))\n", "  (let ((min (min numbers)))\n\
    \    (let ((max (max numbers)))\n      (map (lambda (x) (/ x max)) numbers))))\n",
  "  (let ((min (first numbers))\n        (max (second numbers)))\n    (map (lambda\
    \ (x) (/ (- x min) max)) numbers)))\n", "  (let ((min (first numbers))\n     \
    \   (max (second numbers)))\n    (if (= min max)\n        (list 0.0 1.0)\n   \
    \     (let ((range (- max min)))\n          (map (lambda (x) (/ x range)) numbers)))))\n",
  "  (let ((min (first numbers))\n        (max (second numbers)))\n    (map (lambda\
    \ (x) (/ (- x min) (- x max))) numbers)))\n", "  (let ((min (first numbers))\n\
    \        (max (second numbers)))\n    (map (lambda (x) (/ (- x min) max)) numbers)))\n",
  "  (let loop ((numbers numbers)\n             (result '()))\n    (if (null? numbers)\n\
    \        result\n        (loop (rest numbers)\n              (cons (min numbers)\
    \ result)))))\n", "  (let ((min (min numbers)))\n    (let ((max (max numbers)))\n\
    \      (map (lambda (x) (/ x max)) numbers))))\n", "  (let ((min (first numbers))\n\
    \        (max (second numbers)))\n    (map (lambda (x)\n           (/ (- x min)\
    \ (- max min)))\n         numbers)))\n", "  (let ((min (first numbers))\n    \
    \    (max (second numbers)))\n    (map (lambda (x) (/ x max)) numbers)))\n", " \
    \ (let ((min (first numbers))\n        (max (second numbers)))\n    (map (lambda\
    \ (x) (/ x max)) numbers)))\n", "  (let ((min (first numbers))\n        (max (second\
    \ numbers)))\n    (map (lambda (x) (/ (- x min) (- x max))) numbers)))\n", " \
    \ (let ((min (first numbers))\n        (max (second numbers)))\n    (map (lambda\
    \ (x) (/ (- x min) (- x max))) numbers)))\n", "  (let ((min (min numbers)))\n\
    \    (map #(/ % min) numbers)))\n", "  (let ((min (first numbers))\n        (max\
    \ (second numbers)))\n    (map (lambda (x) (/ (- x min) max)) numbers)))\n", " \
    \ (let ((min (min numbers)))\n    (map #(/ (- %1 min) 1.0) numbers)))\n", "  (let\
    \ ((min (first numbers))\n        (max (second numbers)))\n    (map (lambda (x)\
    \ (/ (- x min) max)) numbers)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
