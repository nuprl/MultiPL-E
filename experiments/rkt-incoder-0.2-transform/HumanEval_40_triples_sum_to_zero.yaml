name: HumanEval_40_triples_sum_to_zero
language: rkt
prompt: "#lang racket\n\n;; triples_sum_to_zero takes a list of integers as an input.\n\
  ;; it returns True if there are three distinct elements in the list that\n;; sum\
  \ to zero, and False otherwise.\n;; >>> (triples_sum_to_zero (list 1 3 5 0))\n;;\
  \ #f\n;; >>> (triples_sum_to_zero (list 1 3 -2 1))\n;; #t\n;; >>> (triples_sum_to_zero\
  \ (list 1 2 3 7))\n;; #f\n;; >>> (triples_sum_to_zero (list 2 4 -5 3 9 7))\n;; #t\n\
  ;; >>> (triples_sum_to_zero (list 1))\n;; #f\n(define (triples_sum_to_zero l)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate triples_sum_to_zero))\n\
  \    (check-equal? (candidate (list 1 3 5 0)) #f)\n    (check-equal? (candidate\
  \ (list 1 3 5 -1)) #f)\n    (check-equal? (candidate (list 1 3 -2 1)) #t)\n    (check-equal?\
  \ (candidate (list 1 2 3 7)) #f)\n    (check-equal? (candidate (list 1 2 5 7)) #f)\n\
  \    (check-equal? (candidate (list 2 4 -5 3 9 7)) #t)\n    (check-equal? (candidate\
  \ (list 1)) #f)\n    (check-equal? (candidate (list 1 3 5 -100)) #f)\n    (check-equal?\
  \ (candidate (list 100 3 5 -100)) #f)\n))\n\n(test-humaneval)"
completions: ["  (let loop ((l l) (sum 0))\n    (cond\n      [(empty? l) #f]\n   \
    \   [(equal? (first l) sum) #t]\n      [else (loop (rest l) (+ sum (first l)))]\n\
    \    )))\n", "  (let ((sum (apply + l)))\n    (cond\n      [(= sum 0) #f]\n  \
    \    [(= sum 1) #t]\n      [else (triples_sum_to_zero (cdr l))]))", "  (let loop\
    \ ((l l) (sum 0))\n    (cond ((null? l) false)\n          ((= (first l) sum) true)\n\
    \          ((= (first l) (+ sum 1))\n           (loop (rest l) (+ sum 1)))\n \
    \         (else (loop (rest l) (+ sum 1))))))\n", "  (let loop ((l l) (acc #f))\n\
    \    (cond ((null? l) acc)\n          ((= 3 (car l)) (loop (cdr l) (not acc)))\n\
    \          ((= 0 (+ (car l) (cadr l))) (loop (cdr l) (not acc)))\n          (else\
    \ (loop (cdr l) (not acc))))))\n", "  (let loop ((l l) (acc #f))\n    (cond ((null?\
    \ l) acc)\n          ((= (first l) (first l)) (loop (rest l) (not acc)))\n   \
    \       ((= (first l) (- (first l) (first l))) (loop (rest l) (not acc)))\n  \
    \        (else (loop (rest l) (and acc (= (first l) (first l))))))))\n", "  (let\
    \ loop ((l l) (sum 0))\n    (cond ((null? l) #f)\n          ((= (first l) sum)\
    \ #t)\n          (else (loop (rest l) (+ sum (first l)))))))\n", "  (let loop\
    \ ((lst l) (acc #f))\n    (cond ((null? lst) acc)\n          ((= 3 (car lst))\
    \ (loop (cdr lst) (not acc)))\n          ((= 0 (+ (car lst) (cadr lst))) (loop\
    \ (cdr lst) (not acc)))\n          (else (loop (cdr lst) (and acc (= 0 (+ (car\
    \ lst) (cadr lst)))))) )))\n", "  (let loop ((l l) (acc #f))\n    (cond ((null?\
    \ l) acc)\n          ((= (+ (car l) (car l)) 0)\n           (loop (cdr l) (not\
    \ acc)))\n          (else (loop (cdr l) (and acc (= (+ (car l) (car l)) 0))))))\n",
  "  (let loop ((l l) (sum 0))\n    (cond ((null? l) true)\n          ((= (first l)\
    \ sum) false)\n          ((= (first l) (+ sum first)) (loop (rest l) (+ sum first)))\n\
    \          (else (loop (rest l) (+ sum first)))))\n  (if (triples_sum_to_zero\
    \ (reverse l))\n      #t\n      #f))\n", "  (let ((sum (apply + l)))\n    (cond\n\
    \      [(= sum 0) #f]\n      [(= sum 1) #t]\n      [else (triples_sum_to_zero\
    \ (rest l))]))) ;; #f or #t\n", "  (let loop ((l l) (acc #f))\n    (cond\n   \
    \   [(empty? l) #f]\n      [(equal? (first l) 0)\n       (set! acc (not acc))]\n\
    \      [(equal? (first l) (second l))\n       (loop (rest l) (not acc))]\n   \
    \   [else\n       (loop (rest l) (equal? (first l) (second l)))]\n    )))\n",
  "  (let loop ((l l) (sum 0))\n    (cond ((null? l) #f)\n          ((null? (cdr l))\
    \ (= sum (abs (car l))))\n          ((= sum (abs (car l)))\n           (loop (cdr\
    \ l) (+ sum (abs (car l))))\n          (else (loop (cdr l) (+ sum (abs (car l)))))\n\
    \          )))\n", "  (let loop ((lst l) (acc #f))\n    (cond ((null? lst) acc)\n\
    \          ((eqv? (car lst) (cadr lst)) (loop (cdr lst) (not acc)))\n        \
    \  (else (loop (cdr lst) (and acc (eqv? (car lst) (cadr lst))))))))\n", "  (cond\n\
    \    [(empty? l) #f]\n    [(equal? (first l) 0) #f]\n    [else (and (equal? (first\
    \ l) (- (first l) (first l)))\n               (triples_sum_to_zero (rest l)))]))\n",
  "  (let loop ((lst l) (acc #f))\n    (cond\n      [(empty? lst) acc]\n      [(equal?\
    \ (first lst) 0) (loop (rest lst) (not acc))]\n      [(equal? (first lst) 1) (loop\
    \ (rest lst) (not acc))]\n      [(equal? (first lst) 2) (loop (rest lst) (not\
    \ acc))]\n      [else (loop (rest lst) (and acc (equal? (first lst) 3)))]\n  \
    \  )))\n", "  (let loop ((l l) (sum 0))\n    (cond ((null? l) #f)\n          ((=\
    \ (first l) sum) #t)\n          (else (loop (rest l) (+ sum (first l)))))))\n",
  "  (let ((sum (apply + l)))\n    (= 3 (modulo sum 3))))\n", "  (cond\n    [(empty?\
    \ l) #f]\n    [(equal? (first l) 0) #f]\n    [else (equal? (first l) (+ (first\
    \ l) (second l) (third l)))]))\n", "  (let loop ((l l) (acc #f))\n    (cond ((null?\
    \ l) acc)\n          ((= (first l) (first l)) (loop (rest l) (not acc)))\n   \
    \       ((= (first l) 0) (loop (rest l) (not acc)))\n          ((= (first l) (first\
    \ l)) (loop (rest l) (not acc)))\n          (else (loop (rest l) (or (not acc)\
    \ (= (first l) (first l))))))))\n", "  (cond ((null? l) #f)\n        ((equal?\
    \ (first l) (first l)) #t)\n        (else (triples_sum_to_zero (rest l)))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
