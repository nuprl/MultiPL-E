name: HumanEval_125_split_words
language: rkt
prompt: "#lang racket\n\n;; Given a string of words, return a list of words split\
  \ on whitespace, if no whitespaces exists in the text you\n;; should split on commas\
  \ ',' if no commas exists you should return the number of lower-case letters with\
  \ odd order in the\n;; alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n\
  ;; Examples\n;; >>> (split_words \"Hello world!\")\n;; (list \"Hello\" \"world!\"\
  )\n;; >>> (split_words \"Hello,world!\")\n;; (list \"Hello\" \"world!\")\n;; >>>\
  \ (split_words \"abcdef\")\n;; 3\n(define (split_words txt)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate split_words))\n\
  \    (check-equal? (candidate \"Hello world!\") (list \"Hello\" \"world!\"))\n \
  \   (check-equal? (candidate \"Hello,world!\") (list \"Hello\" \"world!\"))\n  \
  \  (check-equal? (candidate \"Hello world,!\") (list \"Hello\" \"world,!\"))\n \
  \   (check-equal? (candidate \"Hello,Hello,world !\") (list \"Hello,Hello,world\"\
  \ \"!\"))\n    (check-equal? (candidate \"abcdef\") 3)\n    (check-equal? (candidate\
  \ \"aaabb\") 2)\n    (check-equal? (candidate \"aaaBb\") 1)\n    (check-equal? (candidate\
  \ \"\") 0)\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? txt) '()]\n    [(whitespace? txt) (list txt)]\n\
    \    [else (cons (first txt) (split_words (rest txt)))]))\n", "  (cond\n    [(empty?\
    \ txt) '()]\n    [(equal? (first txt) ',) (split_words (rest txt))]\n    [else\
    \ (cons (first txt) (split_words (rest txt)))]))\n", "  (cond\n    [(empty? txt)\
    \ '()]\n    [(equal? (first txt) ',) (split_words (rest txt))]\n    [(equal? (first\
    \ txt) '-) (split_words (rest txt))]\n    [(equal? (first txt) '!) (split_words\
    \ (rest txt))]\n    [else (cons (first txt) (split_words (rest txt)))]))\n", " \
    \ (cond\n    [(empty? txt) '()]\n    [(equal? (first txt) ',') '()]\n    [(equal?\
    \ (first txt) '-) '()]\n    [(equal? (first txt) '(') '()]\n    [(equal? (first\
    \ txt) ')') '()]\n    [else (cons (first txt) (split_words (rest txt)))]))\n",
  "  (let ([words (string->list txt)])\n    (cond\n      [(empty? words) (list '())]\n\
    \      [(not (whitespace? first (first words))) (list '())]\n      [else (cons\
    \ (first words) (split_words (rest words)))])))\n", "  (cond\n    [(empty? txt)\
    \ '()]\n    [(empty? (rest txt)) (list (first txt))]\n    [(equal? (first txt)\
    \ ',') (list (first txt) (split_words (rest txt)))]\n    [else (list (first txt)\
    \ (split_words (rest txt)))]))\n", "  (let ([chars (string->list (string->symbol\
    \ txt))])\n    (cond\n      [(empty? chars) '()]\n      [(not (whitespace? chars))\
    \ '()]\n      [(not (comma? chars)) (string->list txt)]\n      [else (cons (first\
    \ chars) (split_words (rest chars)))])))\n", "  (cond\n    [(empty? txt) '()]\n\
    \    [(equal? (first txt) ',') (split_words (rest txt))]\n    [(equal? (first\
    \ txt) '-) (split_words (rest txt))]\n    [else (cons (first txt) (split_words\
    \ (rest txt)))]))\n", "  (cond\n    [(empty? txt) '()]\n    [(equal? (first txt)\
    \ ',') (split_words (rest txt))]\n    [else (cons (first txt) (split_words (rest\
    \ txt)))]))\n", "  (cond\n    [(empty? txt) empty]\n    [(equal? (first txt) ',)\
    \ (split_words (rest txt))]\n    [else (cons (first txt) (split_words (rest txt)))]))\n",
  "  (cond\n    [(empty? txt) empty]\n    [(equal? (first txt) ',) (split_words (rest\
    \ txt))]\n    [else (cons (first txt) (split_words (rest txt)))]))\n", "  (let\
    \ ([split-char (char->string #\\Space)])\n    (cond\n      [(empty? txt) empty]\n\
    \      [(char->string=? #\\Space (first txt)) (split_words txt)]\n      [(char->string=?\
    \ #\\Comma (first txt)) (split_words txt)]\n      [(char->string=? #\\Lower (first\
    \ txt)) (+ 1 ((length txt) (rest txt)))]\n      [(char->string=? #\\Upper (first\
    \ txt)) (+ 1 ((length txt) (rest txt)))]\n      [(char->string=? #\\Number (first\
    \ txt)) (+ 1 ((length txt) (rest txt)))]\n      [else (cons (first txt) (split_words\
    \ (rest txt)))])))\n", "  (cond\n    [(empty? txt) '()]\n    [(equal? (first txt)\
    \ ',) (split_words (rest txt))]\n    [else (cons (first txt) (split_words (rest\
    \ txt)))]))\n", "  (let ([letters (string->list txt)]\n        [words (list->string\
    \ letters)])\n    (cond\n      [(empty? letters) words]\n      [(not (whitespace?\
    \ letters)) (list->string letters)]\n      [else (let ([split (split-on whitespace?\
    \ letters)])\n               (cond\n                 [(empty? split) (list->string\
    \ letters)]\n                 [(not (empty? split)) (cons (first split) (split_words\
    \ (rest split)))]\n                 [else (cons (first split) (split_words (rest\
    \ split)))]))]))))\n", "  (cond\n    [(empty? txt) '()]\n    [(equal? (first txt)\
    \ ',') (split_words (rest txt))]\n    [else (cons (first txt) (split_words (rest\
    \ txt)))]))\n", "  (cond\n    [(empty? txt) '()]\n    [(equal? (first txt) ',)\
    \ (split_words (rest txt))]\n    [else (cons (first txt) (split_words (rest txt)))]))\n",
  "  (cond\n    [(empty? txt) '()]\n    [(equal? (first txt) ',') (split_words (rest\
    \ txt))]\n    [else (cons (first txt) (split_words (rest txt)))]))\n", "  (cond\n\
    \    [(empty? txt) '()]\n    [(equal? (first txt) ',') (split_words (rest txt))]\n\
    \    [else (cons (first txt) (split_words (rest txt)))]))\n", "  (cond\n    [(empty?\
    \ txt) '()]\n    [(equal? (first txt) ',) (split_words (rest txt))]\n    [else\
    \ (cons (first txt) (split_words (rest txt)))]))\n", "  (cond\n    [(empty? txt)\
    \ empty]\n    [(equal? (first txt) ',) (split_words (rest txt))]\n    [else (cons\
    \ (first txt) (split_words (rest txt)))]))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
