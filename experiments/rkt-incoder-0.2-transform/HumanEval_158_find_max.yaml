name: HumanEval_158_find_max
language: rkt
prompt: "#lang racket\n\n;; Write a function that accepts a list of strings.\n;; The\
  \ list contains different words. Return the word with maximum number\n;; of unique\
  \ characters. If multiple strings have maximum number of unique\n;; characters,\
  \ return the one which comes first in lexicographical order.\n;; >>> (find_max (list\
  \ \"name\" \"of\" \"string\"))\n;; \"string\"\n;; >>> (find_max (list \"name\" \"\
  enam\" \"game\"))\n;; \"enam\"\n;; >>> (find_max (list \"aaaaaaa\" \"bb\" \"cc\"\
  ))\n;; \"aaaaaaa\"\n(define (find_max words)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate find_max))\n\
  \    (check-equal? (candidate (list \"name\" \"of\" \"string\")) \"string\")\n \
  \   (check-equal? (candidate (list \"name\" \"enam\" \"game\")) \"enam\")\n    (check-equal?\
  \ (candidate (list \"aaaaaaa\" \"bb\" \"cc\")) \"aaaaaaa\")\n    (check-equal? (candidate\
  \ (list \"abc\" \"cba\")) \"abc\")\n    (check-equal? (candidate (list \"play\"\
  \ \"this\" \"game\" \"of\" \"footbott\")) \"footbott\")\n    (check-equal? (candidate\
  \ (list \"we\" \"are\" \"gonna\" \"rock\")) \"gonna\")\n    (check-equal? (candidate\
  \ (list \"we\" \"are\" \"a\" \"mad\" \"nation\")) \"nation\")\n    (check-equal?\
  \ (candidate (list \"this\" \"is\" \"a\" \"prrk\")) \"this\")\n    (check-equal?\
  \ (candidate (list \"b\")) \"b\")\n    (check-equal? (candidate (list \"play\" \"\
  play\" \"play\")) \"play\")\n))\n\n(test-humaneval)"
completions: ["  (cond\n    [(empty? words) empty]\n    [(equal? (length (first words))\
    \ 1) (first words)]\n    [else (find_max (rest words))]))\n", "  (define (helper\
    \ word count)\n    (cond\n      [(empty? words) word]\n      [(equal? (length\
    \ word) count) (helper word (+ count 1))]\n      [else (helper (cdr word) (+ count\
    \ 1))]))\n  (helper words (length words)))\n", "  (define (helper word count)\n\
    \    (cond\n      [(empty? words) word]\n      [(equal? count (length word)) word]\n\
    \      [else (helper (cdr word) (+ count 1))]))\n  (helper words 0))\n", "  (define\
    \ (helper word count)\n    (cond\n      [(empty? words) word]\n      [(equal?\
    \ count (length word)) word]\n      [else (helper (cdr word) (+ count 1))]))\n\
    \  (helper words 0))\n", "  (define (count-unique str)\n    (define (count-unique-helper\
    \ str count)\n      (if (null? str)\n          count\n          (count-unique-helper\
    \ (cdr str) (+ count (length str))))\n    (count-unique-helper str 0))\n  (define\
    \ (count-unique-helper words count)\n    (if (null? words)\n        count\n  \
    \      (count-unique-helper (cdr words) (+ count (count-unique (car words))))))\n\
    \  (define (count-unique-helper-helper words count)\n    (if (null? words)\n \
    \       count\n        (count-unique-helper-helper (cdr words) (+ count (count-unique-helper\
    \ (car words))))))\n  (define (count-unique-helper-helper-helper words count)\n\
    \    (if (null? words)\n        count\n        (count-unique-helper-helper-helper\
    \ (cdr words) (+ count (count-unique-helper-helper (car words))))))\n  (define\
    \ (count-unique-helper-helper-helper-helper words count)\n    (if (null? words)\n\
    \        count\n        (count-unique-helper-helper-helper-helper (cdr words)\
    \ (+ count (count-unique-helper-helper-helper (car words))))))\n  (define (count-unique-helper-helper-helper-helper-helper\
    \ words count)\n    (if (null? words)\n        count\n        (count-unique-helper-helper-helper-helper-helper\
    \ (cdr words) (+ count (count-unique-helper-helper-helper-helper (car words))))))\n\
    \  (define (count-unique-helper-helper-helper-helper-helper-helper words count)\n\
    \    (if (null? words)\n        count\n        (count-unique-helper-helper-helper-helper-helper-helper\
    \ (cdr words) (+ count (count-unique-helper-helper-helper-helper-helper (car words))))))\n\
    \  (define (count-unique-helper-helper-helper-helper-helper-helper-helper words\
    \ count)\n    (if (null? words)\n        count\n        (count-unique-helper-helper-helper-helper-helper-helper-helper\
    \ (cdr words) (+ count (count-unique-helper-helper-helper-helper-helper-helper\
    \ (car words))))))\n  (define (count-unique-helper-helper-helper-helper-helper-helper-helper-helper\
    \ words ", "  (let ((max-count 0))\n    (map #(let ((word (car %)))\n        \
    \     (if (> (length word) max-count)\n                 (set! max-count (length\
    \ word))\n                 word))\n         words)))\n", "  (cond\n    [(empty?\
    \ words) empty]\n    [(equal? (length words) 1) (first words)]\n    [else (let\
    \ ([max (first words)])\n            (cond\n              [(empty? (rest words))\
    \ max]\n              [(equal? (length words) (length (rest words))) (max max)]\n\
    \              [else (let ([next (find_max (rest words))])\n                 \
    \     (cond\n                        [(empty? next) max]\n                   \
    \     [(equal? (length words) (length (rest words))) (max max)]\n            \
    \            [else (max max)]\n                      ))]\n            ))]\n  )\n\
    )\n", "  (let loop ((max-count 0) (max-word '()) (words words))\n    (cond ((null?\
    \ words) max-word)\n          ((> (length max-word) max-count) (cons max-word\
    \ max-count))\n          (else (loop (length max-word) (first words) (rest words))))))\n",
  "  (cond\n    [(empty? words) empty]\n    [(equal? (length words) 1) (first words)]\n\
    \    [else (let ([max (length words)])\n            (let ([chars (count-chars\
    \ words)])\n              (cond\n                [(chars > (max chars)) (first\
    \ words)]\n                [else (find_max (rest words))])))])))\n", "  (cond\n\
    \    [(empty? words) empty]\n    [(equal? (length words) 1) (first words)]\n \
    \   [else (find_max (rest words))]))\n", "  (cond\n    [(empty? words) empty]\n\
    \    [(equal? (length words) 1) (first words)]\n    [else (let ([max (first words)])\n\
    \            (cond\n              [(empty? (rest words)) max]\n              [(equal?\
    \ (length words) (length (rest words))) (max words)]\n              [else (let\
    \ ([count (count (first words))])\n                      (cond\n             \
    \           [(> count max) (find_max (rest words))]\n                        [(<\
    \ count max) (find_max (list max (first words) (rest words)))]\n             \
    \           [else (find_max (list max (first words) (rest words)))])]))]))]))\n",
  "  (let loop ((max-count 0)\n             (max-word (first words))\n           \
    \  (words words))\n    (cond\n      [(empty? words) max-word]\n      [(equal?\
    \ (length max-word) max-count) (first words)]\n      [else (loop (+ max-count\
    \ (length max-word))\n                 (if (equal? (length max-word) max-count)\n\
    \                     (first words)\n                     (first words))\n   \
    \              (rest words))])))\n", "  (define (helper word count)\n    (cond\n\
    \      [(empty? words) word]\n      [(char-count (first word)) (helper (rest word)\
    \ (add1 count))]))\n  (helper words 0))\n", "  (let loop ((max-count (max 0 (length\
    \ words))\n                (max-word (first words))\n                (max-word\
    \ (first words))\n                (max-word (first words))\n                (max-word\
    \ (first words))\n                (max-word (first words)))\n           (word\
    \ (first words))\n           (count 0))\n    (if (null? word)\n        (if (=\
    \ count max-count)\n            (cons max-word max-count)\n            (loop (max\
    \ max-count (length word)) max-word max-count max-word max-word max-word))\n \
    \       (loop (max max-count (length word)) word count max-word max-word max-word))))\n",
  "  (cond\n    [(empty? words) empty]\n    [(equal? (count (first words))\n     \
    \         (count (second words))) \n     (first words)]\n    [else (find_max (rest\
    \ words))]))\n", "  (cond\n    [(empty? words) empty]\n    [(equal? (length words)\
    \ 1) (first words)]\n    [else (let ([max (first words)])\n            (cond\n\
    \              [(equal? (count max words) (count words words)) (first words)]\n\
    \              [else (find_max (rest words))])))]))\n", "  (cond\n    [(empty?\
    \ words) empty]\n    [(equal? (length words) 1) (first words)]\n    [else (let\
    \ ([max (first words)])\n            (cond\n              [(empty? (rest words))\
    \ max]\n              [(equal? (length words) (length (rest words))) max]\n  \
    \            [else (let ([count (count (first words) (first words))])\n      \
    \                 (cond\n                         [(> count max) (find_max (rest\
    \ words))]\n                         [(< count max) (find_max (list max (first\
    \ words) (first words)))]\n                         [else (find_max (list max\
    \ (first words) (first words)))])])])]))]))\n", "  (cond\n    [(empty? words)\
    \ empty]\n    [(equal? (length words) 1) (first words)]\n    [else (let ([max\
    \ (length words)])\n            (let ([count 0])\n              (for ([word (sort\
    \ words (< #:key (lambda (x) (length x)) #:reverse #:stable)])\n             \
    \     (cond\n                    [(empty? word) empty]\n                    [else\
    \ (cond\n                          [(equal? (count word) max) (first word)]\n\
    \                          [else (cons (first word) (find_max (rest words)))]))]))]))]))\n",
  "  (cond\n    [(empty? words) empty]\n    [(equal? (length (first words)) 1) (first\
    \ words)]\n    [else (find_max (rest words))]))\n", "  (define (helper word count)\n\
    \    (cond\n      [(empty? words) (cons word count)]\n      [(equal? (length word)\
    \ count) (cons word count)]\n      [else (helper (cdr word) (+ count 1))]))\n\
    \  (helper words 0))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
