name: HumanEval_56_correct_bracketing
language: rkt
prompt: "#lang racket\n\n;; brackets is a string of \"<\" and \">\".\n;; return True\
  \ if every opening bracket has a corresponding closing bracket.\n;; >>> (correct_bracketing\
  \ \"<\")\n;; #f\n;; >>> (correct_bracketing \"<>\")\n;; #t\n;; >>> (correct_bracketing\
  \ \"<<><>>\")\n;; #t\n;; >>> (correct_bracketing \"><<>\")\n;; #f\n(define (correct_bracketing\
  \ brackets)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate correct_bracketing))\n\
  \    (check-equal? (candidate \"<>\") #t)\n    (check-equal? (candidate \"<<><>>\"\
  ) #t)\n    (check-equal? (candidate \"<><><<><>><>\") #t)\n    (check-equal? (candidate\
  \ \"<><><<<><><>><>><<><><<>>>\") #t)\n    (check-equal? (candidate \"<<<><>>>>\"\
  ) #f)\n    (check-equal? (candidate \"><<>\") #f)\n    (check-equal? (candidate\
  \ \"<\") #f)\n    (check-equal? (candidate \"<<<<\") #f)\n    (check-equal? (candidate\
  \ \">\") #f)\n    (check-equal? (candidate \"<<>\") #f)\n    (check-equal? (candidate\
  \ \"<><><<><>><>><<>\") #f)\n    (check-equal? (candidate \"<><><<><>><>>><>\")\
  \ #f)\n))\n\n(test-humaneval)"
completions: ["  (let ((open (string->list brackets))\n        (close (substring brackets\
    \ 0 (string->length brackets))))\n    (for/fold ((acc '()) (item close)) (item\
    \ open)\n      (if (equal? item '<)\n          (set! acc (cons item acc))\n  \
    \        acc))\n    (equal? (length acc) (string->length brackets))))\n", "  (let\
    \ loop ((i 0))\n    (if (< i #(0 1 2 3 4 5 6 7 8 9))\n        #f\n        (let\
    \ ((open (char->integer (char-ref brackets i)))\n              (close (char->integer\
    \ (char-ref brackets i+1))))\n          (if (< open close)\n              #t\n\
    \              (loop (+ i 1))))))))\n", "  (let loop ((brackets brackets)\n  \
    \           (opening-brackets '())\n             (closing-brackets '()))\n   \
    \ (cond\n      [(empty? brackets) (= (length opening-brackets) (length closing-brackets))]\n\
    \      [(equal? (first brackets) (first closing-brackets)) (loop (rest brackets)\
    \ (cons (first opening-brackets) opening-brackets) (cons (first closing-brackets)\
    \ closing-brackets))]\n      [else (loop (rest brackets) (cons (first opening-brackets)\
    \ opening-brackets) (cons (first closing-brackets) closing-brackets))]\n    )\n\
    \  )\n)\n", "  (let loop ((brackets brackets)\n             (opening-brackets\
    \ '())\n             (closing-brackets '()))\n    (cond\n      [(empty? brackets)\
    \ (= (length opening-brackets) (length closing-brackets))]\n      [(equal? (first\
    \ brackets) (first closing-brackets)) (loop (rest brackets) (cons (first opening-brackets)\
    \ opening-brackets) (cons (first closing-brackets) closing-brackets))]\n     \
    \ [(equal? (first brackets) (first opening-brackets)) (loop (rest brackets) (cons\
    \ (first opening-brackets) opening-brackets) (cons (first closing-brackets) closing-brackets))]\n\
    \      [(equal? (first brackets) (first closing-brackets)) (loop (rest brackets)\
    \ (cons (first opening-brackets) opening-brackets) (cons (first closing-brackets)\
    \ closing-brackets))]\n      [else (loop (rest brackets) (cons (first opening-brackets)\
    \ opening-brackets) (cons (first closing-brackets) closing-brackets))]\n    )\n\
    \  )\n)\n", "  (let ((stack '())\n        (open (string->list brackets))\n   \
    \     (close (list->string open)))\n    (let loop ((i 0))\n      (cond\n     \
    \   ((null? open) stack)\n        ((equal? (car open) (car close)) (loop (+ i\
    \ 1)))\n        (else (loop (+ i 1)))))))\n", "  (let ((open (string->list brackets))\n\
    \        (close (substring brackets 0 (string->length brackets))))\n    (for/fold\
    \ ((i 0) (j 0))\n              ((open (substring open i j))\n               (close\
    \ (substring close i j)))\n      (if (equal? (string-ref open i) (string-ref close\
    \ j))\n          (return #f))))", "  (cond\n    [(empty? brackets) #f]\n    [(equal?\
    \ (first brackets) (first brackets)) (correct_bracketing (subseq brackets 1 2))]\n\
    \    [else (correct_bracketing (subseq brackets 0 -1))]))\n", "  (let ((open (string->list\
    \ brackets)))\n    (cond ((null? open) #f)\n          ((null? (cdr open)) #t)\n\
    \          ((null? (cdr (cdr open))) #t)\n          (else (and (equal? (car open)\
    \ (cadr open)) (correct_bracketing (cdr open)))))))\n", "  (let ((open (string->list\
    \ brackets))\n        (closed (string->list brackets)))\n    (for/fold ((i 0)\
    \ (j 0))\n              ((open (in-range (length open)))\n               ((close\
    \ (in-range (length closed))))\n               ((if (equal? (char->integer open)\
    \ (char->integer close))\n                      (set! i (add1 i))\n          \
    \            (set! j (add1 j)))\n               ((if (equal? (char->integer open)\
    \ (char->integer close))\n                      (set! i (add1 i))\n          \
    \            (set! j (add1 j)))\n               ((if (equal? (char->integer open)\
    \ (char->integer close))\n                      (set! i (add1 i))\n          \
    \            (set! j (add1 j)))\n               ((if (equal? (char->integer open)\
    \ (char->integer close))\n                      (set! i (add1 i))\n          \
    \            (set! j (add1 j)))\n               ((if (equal? (char->integer open)\
    \ (char->integer close))\n                      (set! i (add1 i))\n          \
    \            (set! j (add1 j)))\n               ((if (equal? (char->integer open)\
    \ (char->integer close))\n                      (set! i (add1 i))\n          \
    \            (set! j (add1 j)))\n               ((if (equal? (char->integer open)\
    \ (char->integer close))\n                      (set! i (add1 i))\n          \
    \            (set! j (add1 j)))\n               ((if (equal? (char->integer open)\
    \ (char->integer close))\n                      (set! i (add1 i))\n          \
    \            (set! j (add1 j)))\n               ((if (equal? (char->integer open)\
    \ (char->integer close))\n                      (set! i (add1 i))\n          \
    \            (set! j (add1 j)))\n               ((if (equal? (char->integer open)\
    \ (char->integer close))\n                      (set! i (add1 i))\n          \
    \            (set! j (add1 j)))\n               ((if (equal? (char->integer open)\
    \ (char->integer close))\n                      (set! i (add1 i))\n          \
    \            (set! j (add1 j)))\n               ((if (equal? (char->integer open)\
    \ (char->integer close))\n                      (set! i (add1 i))\n          \
    \            (set! j (add1 j)))\n               ((if (equal? (char->integer open)\
    \ (char->", "  (let ((brackets-count 0))\n    (lambda ()\n      (cond\n      \
    \  ((string=? brackets \"\") #f)\n        ((string=? brackets \"<>\") #f)\n  \
    \      ((string=? brackets \"<<><>>\") #t)\n        (else (set! brackets-count\
    \ (+ brackets-count 1)))\n        (else (set! brackets-count 0))\n      )\n  \
    \    (cond\n        ((< brackets-count 0) #f)\n        ((> brackets-count 0) #t)\n\
    \      )\n    )\n  )\n)\n", "  (cond [(empty? brackets) #f]\n        [(equal?\
    \ (first brackets) (first brackets)) (correct_bracketing (subseq brackets 1 ))]\n\
    \        [else (correct_bracketing (subseq brackets 1 ))]\n  )\n)\n", "  (cond\n\
    \    [(empty? brackets) #f]\n    [(equal? (first brackets) (first brackets)) #f]\n\
    \    [else (equal? (first brackets) (first brackets)) (correct_bracketing (subseq\
    \ brackets 1))]\n  ))\n", "  (cond\n    [(empty? brackets) #f]\n    [(equal? (first\
    \ brackets) \"<\") (correct_bracketing (substring brackets 1 2))]\n    [(equal?\
    \ (first brackets) \">\") (correct_bracketing (substring brackets 2 3))]\n   \
    \ [else (correct_bracketing (substring brackets 1 2))]))\n", "  (let loop ((i\
    \ 0))\n    (cond\n      [(empty? brackets) (= i 0)]\n      [(equal? (char-ref\
    \ brackets i) '<) (loop (+ i 1))]\n      [(equal? (char-ref brackets i) '>) (loop\
    \ (+ i 1))]\n      [else (return false)])))\n", "  (cond\n    [(empty? brackets)\
    \ #f]\n    [(equal? (first brackets) \"<\") (correct_bracketing (substring brackets\
    \ 1 2))]\n    [(equal? (first brackets) \">\") (correct_bracketing (substring\
    \ brackets 2 3))]\n    [else #f]))\n", "  (cond\n    [(empty? brackets) #f]\n\
    \    [(equal? (first brackets) \">\") (correct_bracketing (substring brackets\
    \ 1 2))]\n    [(equal? (first brackets) \"<\") (correct_bracketing (substring\
    \ brackets 2 3))]\n    [else (correct_bracketing (substring brackets 1 2))]\n\
    \  )\n)\n", "  (let ((opening-brackets '())\n        (closing-brackets '()))\n\
    \    (for ([i (string-length brackets)])\n      (when (char= (char-ref brackets\
    \ i) '<)\n        (set! opening-brackets (cons i opening-brackets))\n        (set!\
    \ closing-brackets (cons i closing-brackets))\n        (set! opening-brackets\
    \ (cons i opening-brackets))\n        (set! closing-brackets (cons i closing-brackets))\n\
    \        (set! opening-brackets (cons i opening-brackets))\n        (set! closing-brackets\
    \ (cons i closing-brackets))\n        (set! opening-brackets (cons i opening-brackets))\n\
    \        (set! closing-brackets (cons i closing-brackets))\n        (set! opening-brackets\
    \ (cons i opening-brackets))\n        (set! closing-brackets (cons i closing-brackets))\n\
    \        (set! opening-brackets (cons i opening-brackets))\n        (set! closing-brackets\
    \ (cons i closing-brackets))\n        (set! opening-brackets (cons i opening-brackets))\n\
    \        (set! closing-brackets (cons i closing-brackets))\n        (set! opening-brackets\
    \ (cons i opening-brackets))\n        (set! closing-brackets (cons i closing-brackets))\n\
    \        (set! opening-brackets (cons i opening-brackets))\n        (set! closing-brackets\
    \ (cons i closing-brackets))\n        (set! opening-brackets (cons i opening-brackets))\n\
    \        (set! closing-brackets (cons i closing-brackets))\n        (set! opening-brackets\
    \ (cons i opening-brackets))\n        (set! closing-brackets (cons i closing-brackets))\n\
    \        (set! opening-brackets (cons i opening-brackets))\n        (set! closing-brackets\
    \ (cons i closing-brackets))\n        (set! opening-brackets (cons i opening-brackets))\n\
    \        (set! closing-brackets (cons i closing-brackets))\n        (set! opening-brackets\
    \ (cons i opening-brackets))\n        (set! closing-brackets (cons i closing-brackets))\n\
    \        (set! opening-brackets (cons i opening-brackets))\n        (set! closing-brackets\
    \ (", "  (cond\n    [(empty? brackets) #f]\n    [(equal? (first brackets) \"<\"\
    ) (correct_bracketing (substring brackets 1 2))]\n    [(equal? (first brackets)\
    \ \">\") (correct_bracketing (substring brackets 2 3))]\n    [else (correct_bracketing\
    \ (substring brackets 1 2))]))\n", "  (let ((opening-brackets '())\n        (closing-brackets\
    \ '()))\n    (cond\n      [(empty? brackets) #f]\n      [(equal? (first brackets)\
    \ \"<\") (push (first brackets) opening-brackets)\n       (push (first brackets)\
    \ closing-brackets)\n       #t]\n      [(equal? (first brackets) \">\") (push\
    \ (first brackets) opening-brackets)\n       (push (first brackets) closing-brackets)\n\
    \       #t]\n      [else (push (first brackets) opening-brackets)\n        (push\
    \ (first brackets) closing-brackets)\n        #f]\n      )\n    (cond\n      [(empty?\
    \ opening-brackets) #f]\n      [(empty? closing-brackets) #f]\n      [(equal?\
    \ (first opening-brackets) (first closing-brackets)) #t]\n      [else #f]\n  \
    \    )\n    )\n  )\n", "  (let ([open (string->list brackets)\n        closed\
    \ (string->list '())])\n    (cond [(empty? open) empty]\n          [(empty? closed)\
    \ empty]\n          [(equal? (first open) (first close)) (correct_bracketing (rest\
    \ open))\n           (correct_bracketing (first close))]\n          [else (correct_bracketing\
    \ (first open))\n           (correct_bracketing (first close))]))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
