name: HumanEval_99_closest_integer
language: rkt
prompt: "#lang racket\n\n;; Create a function that takes a value (string) representing\
  \ a number\n;; and returns the closest integer to it. If the number is equidistant\n\
  ;; from two integers, round it away from zero.\n;; Examples\n;; >>> (closest_integer\
  \ \"10\")\n;; 10\n;; >>> (closest_integer \"15.3\")\n;; 15\n;; Note:\n;; Rounding\
  \ away from zero means that if the given number is equidistant\n;; from two integers,\
  \ the one you should return is the one that is the\n;; farthest from zero. For example\
  \ closest_integer(\"14.5\") should\n;; return 15 and closest_integer(\"-14.5\")\
  \ should return -15.\n(define (closest_integer value)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate closest_integer))\n\
  \    (check-equal? (candidate \"10\") 10)\n    (check-equal? (candidate \"14.5\"\
  ) 15)\n    (check-equal? (candidate \"-15.5\") -16)\n    (check-equal? (candidate\
  \ \"15.3\") 15)\n    (check-equal? (candidate \"0\") 0)\n))\n\n(test-humaneval)"
completions: ["  (let ((closest (min (floor (/ value 10)) (floor (/ value 10))))\n\
    \        (closest-to (floor (/ value 10))))\n    (cond\n      [(< value closest)\n\
    \       (min (floor (/ value 10)) (floor (/ value 10)))]\n      [(< value closest-to)\n\
    \       (min (floor (/ value 10)) (floor (/ value 10)))]\n      [else\n      \
    \ closest])))\n", "  (define (closest-to-zero x y)\n    (if (= x y)\n        x\n\
    \        (if (< (abs (- x y)) (abs x))\n            (- x y)\n            (- y\
    \ x))))\n  (define (closest-to-one x y)\n    (if (= x y)\n        x\n        (if\
    \ (< (abs (- x y)) (abs x))\n            (- x y)\n            (- y x))))\n  (define\
    \ (closest-to-two x y)\n    (if (= x y)\n        x\n        (if (< (abs (- x y))\
    \ (abs x))\n            (- x y)\n            (- y x))))\n  (define (closest-to-three\
    \ x y)\n    (if (= x y)\n        x\n        (if (< (abs (- x y)) (abs x))\n  \
    \          (- x y)\n            (- y x))))\n  (define (closest-to-four x y)\n\
    \    (if (= x y)\n        x\n        (if (< (abs (- x y)) (abs x))\n         \
    \   (- x y)\n            (- y x))))\n  (define (closest-to-five x y)\n    (if\
    \ (= x y)\n        x\n        (if (< (abs (- x y)) (abs x))\n            (- x\
    \ y)\n            (- y x))))\n  (define (closest-to-six x y)\n    (if (= x y)\n\
    \        x\n        (if (< (abs (- x y)) (abs x))\n            (- x y)\n     \
    \       (- y x))))\n  (define (closest-to-seven x y)\n    (if (= x y)\n      \
    \  x\n        (if (< (abs (- x y)) (abs x))\n            (- x y)\n           \
    \ (- y x))))\n  (define (closest-to-eight x y)\n    (if (= x y)\n        x\n \
    \       (if (< (abs (- x y)) (abs x))\n            (- x y)\n            (- y x))))\n\
    \  (define (closest-to-nine x y)\n    (if (= x y)\n        x\n        (if (< (abs\
    \ (- x y)) (abs x))\n            (- x y)\n            (- y x))))\n  (define (closest-to-tens\
    \ x y)\n    (if (= x y)\n        x\n        (if (< (abs (- x y)) (abs x))\n  \
    \          (- x y)\n            (- y x))))\n  (define (closest-to-twenty x y)\n\
    \    (if (= x y)\n        x\n        (if (< (abs (- x y)) (abs x))\n         \
    \   (- x y)\n            (- y x))))\n  (", "  (let ([x (string->number (car value))])\n\
    \    (let ([y (string->number (cadr value))])\n      (if (= x y)\n          x\n\
    \          (if (< x y)\n              (ceiling x)\n              (floor x))))))\n",
  "  (let ([x (parse-integer (string->symbol (symbol->string value)))])\n    (cond\n\
    \      [(< x 0) (error \"Not a number\")]\n      [(< x 1) x]\n      [(< x 10)\
    \ (+ x 10)]\n      [(< x 100) (+ x 100)]\n      [(< x 1000) (+ x 1000)]\n    \
    \  [(< x 10000) (+ x 10000)]\n      [(< x 100000) (+ x 100000)]\n      [(< x 1000000)\
    \ (+ x 1000000)]\n      [(< x 10000000) (+ x 10000000)]\n      [(< x 100000000)\
    \ (+ x 100000000)]\n      [(< x 1000000000) (+ x 1000000000)]\n      [(< x 10000000000)\
    \ (+ x 10000000000)]\n      [(< x 100000000000) (+ x 100000000000)]\n      [(<\
    \ x 1000000000000) (+ x 1000000000000)]\n      [(< x 10000000000000) (+ x 10000000000000)]\n\
    \      [(< x 100000000000000) (+ x 100000000000000)]\n      [(< x 1000000000000000)\
    \ (+ x 1000000000000000)]\n      [(< x 10000000000000000) (+ x 10000000000000000)]\n\
    \      [(< x 100000000000000000) (+ x 100000000000000000)]\n      [(< x 1000000000000000000)\
    \ (+ x 1000000000000000000)]\n      [(< x 10000000000000000000) (+ x 10000000000000000000)]\n\
    \      [(< x 100000000000000000000) (+ x 100000000000000000000)]\n      [(< x\
    \ 1000000000000000000000) (+ x 1000000000000000000000)]\n      [(< x 10000000000000000000000)\
    \ (+ x 10000000000000000000000)]\n      [(< x 100000000000000000000000) (+ x 100000000000000000000000)]\n\
    \      [(< x 1000000000000000000000000) (+ x 1000000000000000000000000)]\n   \
    \   [(< x 10000000000000000000000000) (+ x 10000000000000000000000000)]\n    \
    \  [(< x 100000000000000000000000000) (+ x 100000000000000000000000000)]\n   \
    \   [(< x 1000000000000000000000000000) (+ x 1000000000000000000000000000)]\n\
    \      [(< x 10000000000000000000000000000) (+ x 10000000000000000000000000000)]\n\
    \      [(< x 100000000000000000000000000000) (+ x 100000000000000000000000000000)]\n\
    \      [(< x 1000000000000000000000000000000) (+ x 1000000000000000000000000000000)]\n\
    \      [(< x 10000000000000000000000000000000) (+ x 10000000000000000000000000000000)]\n\
    \      [(< x 100000000000000000000000000000000) (+ x 100000000000000000000000000",
  "  (let ([x (number->string value)]\n        [y (number->string value)])\n    (if\
    \ (or (= x y)\n            (string-equal? x y))\n        (number->integer value)\n\
    \        (let ([x (number->string value)]\n              [y (number->string value)])\n\
    \          (if (or (= x y)\n                  (string-equal? x y))\n         \
    \     (number->integer value)\n              (let ([x (number->string value)]\n\
    \                    [(+ (number->integer x) 1)\n                     (+ (number->integer\
    \ y) 1)])\n                (if (< (number->integer x) y)\n                   \
    \ (number->integer x)\n                    (number->integer y))))))))\n", "  (let\
    \ ([x (parse-integer (string->symbol (symbol->string value)))])\n    (cond [(<\
    \ x 0) (error \"Not a number\")]\n          [(< x 1) x]\n          [(< x 10) (round\
    \ (/ x 10))]\n          [(< x 100) (round (/ x 10))]\n          [(< x 1000) (round\
    \ (/ x 10))]\n          [(< x 10000) (round (/ x 10))]\n          [(< x 100000)\
    \ (round (/ x 10))]\n          [(< x 1000000) (round (/ x 10))]\n          [(<\
    \ x 100000000) (round (/ x 10))]\n          [(< x 1000000000) (round (/ x 10))]\n\
    \          [(< x 10000000000) (round (/ x 10))]\n          [(< x 100000000000)\
    \ (round (/ x 10))]\n          [(< x 1000000000000) (round (/ x 10))]\n      \
    \    [(< x 10000000000000) (round (/ x 10))]\n          [(< x 100000000000000)\
    \ (round (/ x 10))]\n          [(< x 1000000000000000) (round (/ x 10))]\n   \
    \       [(< x 10000000000000000) (round (/ x 10))]\n          [(< x 100000000000000000)\
    \ (round (/ x 10))]\n          [(< x 1000000000000000000) (round (/ x 10))]\n\
    \          [(< x 10000000000000000000) (round (/ x 10))]\n          [(< x 100000000000000000000)\
    \ (round (/ x 10))]\n          [(< x 1000000000000000000000) (round (/ x 10))]\n\
    \          [(< x 10000000000000000000000) (round (/ x 10))]\n          [(< x 100000000000000000000000)\
    \ (round (/ x 10))]\n          [(< x 1000000000000000000000000) (round (/ x 10))]\n\
    \          [(< x 10000000000000000000000000) (round (/ x 10))]\n          [(<\
    \ x 100000000000000000000000000) (round (/ x 10))]\n          [(< x 1000000000000000000000000000)\
    \ (round (/ x 10))]\n          [(< x 10000000000000000000000000000) (round (/\
    \ x 10))]\n          [(< x 100000000000000000000000000000) (round (/ x 10))]\n\
    \          [(< x 1000000000000000000000000000000) (round (/ x 10))]\n        \
    \  [(< x 10000000000000000000000000000000) (round (/ x 10))]\n          [(< x\
    \ 100000000000000000000000000000000) (round (/ x 10))]\n          [(< x 1000000000000000000000000000000000)\
    \ (round (/ x 10))", "  (let ([x (number->string value)]\n        [y (number->string\
    \ value)])\n    (cond\n      [(equal? x y) value]\n      [(equal? (number->string\
    \ x) \"-\") (- 0 (number->string value))]\n      [(equal? (number->string x) \"\
    +\") (+ 0 (number->string value))]\n      [else (+ 0 (number->string value))]))))\n",
  "  (let ([x (number->string value)]\n        [y (number->string value)])\n    (cond\
    \ [(number->integer x) (number->integer y)]\n          [(number->integer x) (number->integer\
    \ x)]\n          [(number->integer y) (number->integer y)]\n          [(number->integer\
    \ x) (number->integer y)]\n          [(number->integer y) (number->integer x)]\n\
    \          [(number->integer x) (number->integer x)]\n          [(number->integer\
    \ y) (number->integer y)]\n          [(number->integer x) (number->integer x)]\n\
    \          [(number->integer y) (number->integer y)]\n          [(number->integer\
    \ x) (number->integer x)]\n          [(number->integer y) (number->integer y)]\n\
    \          [(number->integer x) (number->integer x)]\n          [(number->integer\
    \ y) (number->integer y)]\n          [(number->integer x) (number->integer x)]\n\
    \          [(number->integer y) (number->integer y)]\n          [(number->integer\
    \ x) (number->integer x)]\n          [(number->integer y) (number->integer y)]))))\n",
  "  (define (closest-integer-helper value low-bound high-bound)\n    (cond ((< value\
    \ low-bound)\n           (if (< (- value high-bound) low-bound)\n            \
    \   (- low-bound)\n               (- high-bound)))\n          ((< value high-bound)\n\
    \           (if (< (- value low-bound) high-bound)\n               (- high-bound)\n\
    \               (- low-bound)))\n          ((< value low-bound)\n           (-\
    \ low-bound))\n          ((< value high-bound)\n           (- high-bound))\n \
    \         (else\n           (- low-bound)))))\n  (closest-integer-helper value\
    \ 0 (string-length value)))\n", "  (let ([x (number->string value)]\n        [y\
    \ (number->string value)])\n    (if (< (length x) 1)\n        (if (< (length y)\
    \ 1)\n            (string-append x y)\n            (string-append y x))\n    \
    \    (string-append x \"0\"))))\n", "  (let ((x (string->number (string->symbol\
    \ value))))\n    (cond\n      [(< x 0) (error \"Closest integer not possible:\
    \ negative number\")\n       (floor (+ x 1))]\n      [(< x 1) x]\n      [else\
    \ (error \"Closest integer not possible: equidistant numbers\")])))\n", "  (let\
    \ ([x (string->number (car value))])\n    (let ([y (string->number (cadr value))])\n\
    \      (if (= x y)\n          x\n          (if (< x y)\n              (ceiling\
    \ x)\n              (floor x))))))\n", "  (let ([int-value (string->number (string->symbol\
    \ value))])\n    (cond [(< int-value 0)\n           0]\n          [(< int-value\
    \ 10)\n           (floor (/ int-value 10))]\n          [(< int-value 100)\n  \
    \         (floor (/ int-value 10))]\n          [(< int-value 1000)\n         \
    \  (floor (/ int-value 10))]\n          [(< int-value 10000)\n           (floor\
    \ (/ int-value 10))]\n          [(< int-value 100000)\n           (floor (/ int-value\
    \ 10))]\n          [(< int-value 1000000)\n           (floor (/ int-value 10))]\n\
    \          [(< int-value 10000000)\n           (floor (/ int-value 10))]\n   \
    \       [(< int-value 100000000)\n           (floor (/ int-value 10))]\n     \
    \     [(< int-value 1000000000)\n           (floor (/ int-value 10))]\n      \
    \    [(< int-value 10000000000)\n           (floor (/ int-value 10))]\n      \
    \    [(< int-value 100000000000)\n           (floor (/ int-value 10))]\n     \
    \     [(< int-value 1000000000000)\n           (floor (/ int-value 10))]\n   \
    \       [(< int-value 10000000000000)\n           (floor (/ int-value 10))]\n\
    \          [(< int-value 100000000000000)\n           (floor (/ int-value 10))]\n\
    \          [(< int-value 1000000000000000)\n           (floor (/ int-value 10))]\n\
    \          [(< int-value 10000000000000000)\n           (floor (/ int-value 10))]\n\
    \          [(< int-value 100000000000000000)\n           (floor (/ int-value 10))]\n\
    \          [(< int-value 100000000000000001)\n           (floor (/ int-value 10))]\n\
    \          [(< int-value 1000000000000000010)\n           (floor (/ int-value\
    \ 10))]\n          [(< int-value 1000000000000000011)\n           (floor (/ int-value\
    \ 10))]\n          [(< int-value 1000000000000000012)\n           (floor (/ int-value\
    \ 10))]\n          [(< int-value 1000000000000000013)\n           (floor (/ int-value\
    \ 10))]\n          [(< int-value 1000000000000000014)\n           (floor (/ int-value\
    \ 10))]\n          [(< int-value 1000000000000000015)\n           (floor (/ int-value\
    \ 10))]\n          [(< ", "  (define (closest-integer-helper value)\n    (cond\n\
    \      [(number? value) (+ value 1)]\n      [(number? (- value))\n       (if (<\
    \ (- value) 0)\n           (- value)\n           (- value 1))]\n      [else (closest-integer-helper\
    \ (- value))]))\n  (closest-integer-helper value))\n", "  (let ([num (parse-integer\
    \ value)]\n        [nums (list num)]\n        [min (min nums)]\n        [max (max\
    \ nums)])\n    (if (= num 0)\n        min\n        (if (< (abs (- num max)) (abs\
    \ (- num min)))\n            (min (+ num 1))\n            (max (+ num -1))))))\n",
  "  (let ([x (parse-integer (string->symbol (string->symbol value)))])\n    (cond\n\
    \      [(< x 0) (error \"Closest integer not possible: value is negative.\")]\n\
    \      [(< x 1) x]\n      [(< x 100) x]\n      [(< x 1000) (round (/ x 100))]\n\
    \      [(< x 10000) (round (/ x 1000))]\n      [(< x 100000) (round (/ x 10000))]\n\
    \      [(< x 1000000) (round (/ x 100000))]\n      [(< x 10000000) (round (/ x\
    \ 1000000))]\n      [(< x 100000000) (round (/ x 10000000))]\n      [(< x 1000000000)\
    \ (round (/ x 100000000))]\n      [(< x 10000000000) (round (/ x 1000000000))]\n\
    \      [(< x 100000000000) (round (/ x 10000000000))]\n      [(< x 1000000000000)\
    \ (round (/ x 100000000000))]\n      [(< x 10000000000000) (round (/ x 1000000000000))]\n\
    \      [(< x 100000000000000) (round (/ x 10000000000000))]\n      [(< x 1000000000000000)\
    \ (round (/ x 100000000000000))]\n      [(< x 10000000000000000) (round (/ x 1000000000000000))]\n\
    \      [(< x 100000000000000000) (round (/ x 10000000000000000))]\n      [(< x\
    \ 1000000000000000000) (round (/ x 100000000000000000))]\n      [else (round (/\
    \ x 1000000000000000000))])))\n", "  (let ([num (string->number (car value))])\n\
    \    (cond\n      [(< num 0) (- num)]\n      [(< num 1) (- num)]\n      [(< num\
    \ 2) (- num)]\n      [(< num 3) (- num)]\n      [(< num 4) (- num)]\n      [(<\
    \ num 5) (- num)]\n      [(< num 6) (- num)]\n      [(< num 7) (- num)]\n    \
    \  [(< num 8) (- num)]\n      [(< num 9) (- num)]\n      [(< num 10) (- num)]\n\
    \      [(< num 11) (- num)]\n      [(< num 12) (- num)]\n      [(< num 13) (-\
    \ num)]\n      [(< num 14) (- num)]\n      [(< num 15) (- num)]\n      [(< num\
    \ 16) (- num)]\n      [(< num 17) (- num)]\n      [(< num 18) (- num)]\n     \
    \ [(< num 19) (- num)]\n      [(< num 20) (- num)]\n      [(< num 21) (- num)]\n\
    \      [(< num 22) (- num)]\n      [(< num 23) (- num)]\n      [(< num 24) (-\
    \ num)]\n      [(< num 25) (- num)]\n      [(< num 26) (- num)]\n      [(< num\
    \ 27) (- num)]\n      [(< num 28) (- num)]\n      [(< num 29) (- num)]\n     \
    \ [(< num 30) (- num)]\n      [(< num 31) (- num)]\n      [(< num 32) (- num)]\n\
    \      [(< num 33) (- num)]\n      [(< num 34) (- num)]\n      [(< num 35) (-\
    \ num)]\n      [(< num 36) (- num)]\n      [(< num 37) (- num)]\n      [(< num\
    \ 38) (- num)]\n      [(< num 39) (- num)]\n      [(< num 40) (- num)]\n     \
    \ [(< num 41) (- num)]\n      [(< num 42) (- num)]\n      [(< num 43) (- num)]\n\
    \      [(< num 44) (- num)]\n      [(< num 45) (- num)]\n      [(< num 46) (-\
    \ num)]\n      [(< num 47) (- num)]\n      [(< num 48) (- num)]\n      [(< num ",
  "  (let ([integer (parse-integer (string->symbol (string->symbol value)))])\n  \
    \  (cond [(integer? integer) (round integer)]\n          [(< (abs (- integer integer))\
    \ (abs (- integer integer)))\n           (round (- integer integer))]\n      \
    \    [else integer])))\n", "  (let ([integers (map number->integer [1 2 3 4 5\
    \ 6 7 8 9])])\n    (let ([closest (first integers)])\n      (if (< (abs (- value\
    \ closest)) (abs (- value integers)))\n          closest\n          integers))))\n",
  "  (let ([x (string->number (car value))])\n    (let ([y (string->number (cadr value))])\n\
    \      (cond\n        ((< (abs (- x y)) (abs (- y x))) (ceiling x))\n        ((<\
    \ (abs (- x y)) (abs (- y x))) (floor x))\n        (else (round x))))))\n", " \
    \ (let ([integer (parse-integer (string->symbol (symbol->string value)))])\n \
    \   (cond [(< integer 0)\n           (error \"Closest integer not possible for\
    \ negative numbers\")]\n          [(< integer 10)\n           (+ integer (/ 10\
    \ 1))]\n          [(< integer 100)\n           (+ integer (/ 100 1))]\n      \
    \    [(< integer 1000)\n           (+ integer (/ 1000 1))]\n          [(< integer\
    \ 10000)\n           (+ integer (/ 10000 1))]\n          [(< integer 100000)\n\
    \           (+ integer (/ 100000 1))]\n          [(< integer 1000000)\n      \
    \     (+ integer (/ 1000000 1))]\n          [(< integer 10000000)\n          \
    \ (+ integer (/ 10000000 1))]\n          [(< integer 100000000)\n           (+\
    \ integer (/ 100000000 1))]\n          [(< integer 1000000000)\n           (+\
    \ integer (/ 1000000000 1))]\n          [(< integer 10000000000)\n           (+\
    \ integer (/ 10000000000 1))]\n          [(< integer 100000000000)\n         \
    \  (+ integer (/ 100000000000 1))]\n          [(< integer 1000000000000)\n   \
    \        (+ integer (/ 1000000000000 1))]\n          [(< integer 10000000000000)\n\
    \           (+ integer (/ 10000000000000 1))]\n          [(< integer 100000000000000)\n\
    \           (+ integer (/ 100000000000000 1))]\n          [(< integer 1000000000000000)\n\
    \           (+ integer (/ 1000000000000000 1))]\n          [(< integer 10000000000000000)\n\
    \           (+ integer (/ 10000000000000000 1))]\n          [(< integer 100000000000000000)\n\
    \           (+ integer (/ 100000000000000000 1))]\n          [(< integer 1000000000000000000)\n\
    \           (+ integer (/ 1000000000000000000 1))]\n          [(< integer 10000000000000000000)\n\
    \           (+ integer (/ 10000000000000000000 1))]\n          [(< integer 100000000000000000000)\n\
    \           (+ integer (/ 100000000000000000000 1))]\n          [(< integer 1000000000000000000000)\n\
    \           (+ integer (/ 1000000000000000000000 1))]\n          [(< integer 10000000000000000000000)\n\
    \           (+ integer (/ 10000000000000000000000 1))]\n          [(< integer\
    \ 100000000000000000000000)\n           (+ integer (/ 100000000000000000000000\
    \ 1))]\n          [(< integer 1000000000000000000)\n           (+ integer (/ 1000000000000000000\
    \ 1))]\n          [(< integer 10000000000000000000)\n           (+ integer (",
  "  (let ([x (number->string value)]\n        [y (number->string value)])\n    (if\
    \ (< (length x) 1)\n        (if (< (length y) 1)\n            (if (equal? (char-after\
    \ (first x) '-) '-)\n                (if (equal? (char-after (first y) '-) '-)\n\
    \                    (if (equal? (char-after (first x) '-) '-)\n             \
    \           (if (equal? (char-after (first y) '-) '-)\n                      \
    \      (if (equal? (char-after (first x) '-) '-)\n                           \
    \     (if (equal? (char-after (first y) '-) '-)\n                            \
    \        (if (equal? (char-after (first x) '-) '-)\n                         \
    \               (if (equal? (char-after (first y) '-) '-)\n                  \
    \                          (if (equal? (char-after (first x) '-) '-)\n       \
    \                                         (if (equal? (char-after (first y) '-)\
    \ '-)\n                                                    (if (equal? (char-after\
    \ (first x) '-) '-)\n                                                        (if\
    \ (equal? (char-after (first y) '-) '-)\n                                    \
    \                        (if (equal? (char-after (first x) '-) '-)\n         \
    \                                                       (if (equal? (char-after\
    \ (first y) '-) '-)\n                                                        \
    \            (if (equal? (char-after (first x) '-) '-)\n                     \
    \                                                   (if (equal? (char-after (first\
    \ y) '-) '-)\n                                                               \
    \             (if (equal? (char-after (first x) '-) '-)\n                    \
    \                                                            (if (equal? (char-after\
    \ (first y) '-) '-)\n                                                        \
    \                            (if (equal? (char-after (first x) '-) '-)\n     \
    \                                                                            \
    \       (if (equal? (char-after (first y) '-) '-)\n                          \
    \                                                                  (if (equal?\
    \ (char-after (first x) '-) '-)\n                                            \
    \                                                    (if (equal? (char-after (first\
    \ y) '-) '-)\n                                                               \
    \                                     (if (equal? (char-after (first x) '-) '-)\n\
    \                                                                            \
    \                            (if (equal? (char-after (first y) '-) '-)\n     \
    \                                                                            \
    \                           (if (equal? (char-after (first x) '-) '-)\n      \
    \                                                                            \
    \                              (if (equal? (char-after (first y) '-) '-)\n   \
    \                                                                            \
    \                                     (if (equal? (char-after (first x) '-) '-)\n\
    \                                                                            \
    \                                            (if (equal? (char-after (first y)\
    \ '-) ", "  (let ([x (parse-integer value)]\n        [y (parse-integer value)])\n\
    \    (cond [(< x y) x]\n          [(< y x) y]\n          [else (round (abs (-\
    \ x y)))])))\n", "  (define (closest-to-zero x y)\n    (if (= x y)\n        x\n\
    \        (if (< x y)\n            (- x)\n            (- y))))\n  (define (closest-to-one\
    \ x y)\n    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n \
    \           (- y))))\n  (define (closest-to-two x y)\n    (if (= x y)\n      \
    \  x\n        (if (< x y)\n            (- x)\n            (- y))))\n  (define\
    \ (closest-to-three x y)\n    (if (= x y)\n        x\n        (if (< x y)\n  \
    \          (- x)\n            (- y))))\n  (define (closest-to-four x y)\n    (if\
    \ (= x y)\n        x\n        (if (< x y)\n            (- x)\n            (- y))))\n\
    \  (define (closest-to-five x y)\n    (if (= x y)\n        x\n        (if (< x\
    \ y)\n            (- x)\n            (- y))))\n  (define (closest-to-six x y)\n\
    \    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n        \
    \    (- y))))\n  (define (closest-to-seven x y)\n    (if (= x y)\n        x\n\
    \        (if (< x y)\n            (- x)\n            (- y))))\n  (define (closest-to-eight\
    \ x y)\n    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n \
    \           (- y))))\n  (define (closest-to-nine x y)\n    (if (= x y)\n     \
    \   x\n        (if (< x y)\n            (- x)\n            (- y))))\n  (define\
    \ (closest-to-tens x y)\n    (if (= x y)\n        x\n        (if (< x y)\n   \
    \         (- x)\n            (- y))))\n  (define (closest-to-tens x y)\n    (if\
    \ (= x y)\n        x\n        (if (< x y)\n            (- x)\n            (- y))))\n\
    \  (define (closest-to-tens x y)\n    (if (= x y)\n        x\n        (if (< x\
    \ y)\n            (- x)\n            (- y))))\n  (define (closest-to-tens x y)\n\
    \    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n        \
    \    (- y))))\n  (define (closest-to-tens x y)\n    (if (= x y)\n        x\n \
    \       (if (< x y)\n            (- x)\n            (- y))))\n  (define (closest-to-tens\
    \ x y)\n    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n",
  "  (let ([num (string->number (car value))])\n    (cond\n      [(< num 0) (ceiling\
    \ num)]\n      [(> num 0) (floor num)]\n      [(= num 0) 0]\n      [else (round\
    \ num)])))\n", "  (let ([num (parse-integer (string->symbol value))]\n       \
    \ [nums (list num)])\n    (if (< (abs (- num nums)) 1)\n        num\n        (closest_integer\
    \ (- num nums)))))\n", "  (let ([integer (number->integer value)]\n        [integers\
    \ (number->list integer)]\n        [min (min integers)]\n        [max (max integers)])\n\
    \    (if (= (length integers) 1)\n        (number->string integer)\n        (let\
    \ ([closest (min integers)])\n          (if (< (abs (- value closest)) min)\n\
    \              (number->string closest)\n              (let ([closest (min (cons\
    \ closest max))])\n                (if (< (abs (- value closest)) min)\n     \
    \               (number->string closest)\n                    (let ([closest (min\
    \ (cons closest max))])\n                      (if (< (abs (- value closest))\
    \ min)\n                          (number->string closest)\n                 \
    \         (number->string closest)))))\n            (number->string closest)))))\n",
  "  (let ([x (string->number (car value))\n        y (+ (string->number (cadr value))\
    \ (* 10 10))])\n    (cond\n      [(< x y) x]\n      [(> x y) y]\n      [else (round\
    \ x)])))\n", "  (let ([x (number->string value)]\n        [y (number->string value)])\n\
    \    (cond\n      [(equal? x y) value]\n      [(equal? x \"-\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"-\") (- 0 (number->integer value))]\n      [else\
    \ (- 0 (number->integer value))]))))\n", "  (let ([x (number->string value)]\n\
    \        [y (number->string value)])\n    (cond\n      [(equal? x y) value]\n\
    \      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))]\n      [(equal? (string->number x) (string->number y)) (round (number->string\
    \ value))", "  (define (closest-integer value)\n    (cond ((= (abs (- value 1))\
    \ 0)\n           (floor (/ value 1)))\n          ((= (abs (- value 1)) 0)\n  \
    \         (floor (/ value 2)))\n          ((= (abs (- value 2)) 0)\n         \
    \  (floor (/ value 3)))\n          ((= (abs (- value 3)) 0)\n           (floor\
    \ (/ value 4)))\n          ((= (abs (- value 4)) 0)\n           (floor (/ value\
    \ 5)))\n          ((= (abs (- value 5)) 0)\n           (floor (/ value 6)))\n\
    \          ((= (abs (- value 6)) 0)\n           (floor (/ value 7)))\n       \
    \   ((= (abs (- value 7)) 0)\n           (floor (/ value 8)))\n          ((= (abs\
    \ (- value 8)) 0)\n           (floor (/ value 9)))\n          ((= (abs (- value\
    \ 9)) 0)\n           (floor (/ value 10)))\n          ((= (abs (- value 10)) 0)\n\
    \           (floor (/ value 11)))\n          ((= (abs (- value 11)) 0)\n     \
    \      (floor (/ value 12)))\n          ((= (abs (- value 12)) 0)\n          \
    \ (floor (/ value 13)))\n          ((= (abs (- value 13)) 0)\n           (floor\
    \ (/ value 14)))\n          ((= (abs (- value 14)) 0)\n           (floor (/ value\
    \ 15)))\n          ((= (abs (- value 15)) 0)\n           (floor (/ value 16)))\n\
    \          ((= (abs (- value 16)) 0)\n           (floor (/ value 17)))\n     \
    \     ((= (abs (- value 17)) 0)\n           (floor (/ value 18)))\n          ((=\
    \ (abs (- value 18)) 0)\n           (floor (/ value 19)))\n          ((= (abs\
    \ (- value 19)) 0)\n           (floor (/ value 20)))\n          ((= (abs (- value\
    \ 20)) 0)\n           (floor (/ value 21))\n          ((= (abs (- value 21)) 0)\n\
    \           (floor (/ value 22)))\n          ((= (abs (- value 22)) 0)\n     \
    \      (floor (/ value 23)))\n          ((= (abs (- value 23)) 0)\n          \
    \ (floor (/ value 24)))\n          ((= (abs (- value 24)) 0)\n           (floor\
    \ (/ value 25)))\n          ((= (abs (- ", "  (let ([integers (map integer->real\
    \ '(1 2 3 4 5 6 7 8 9 10))])\n    (let ([closest-integer (min (map abs (- value\
    \ integers))\n                                 (map abs (- value integers))\n\
    \                                 (map abs (- value integers))\n             \
    \                    (map abs (- value integers))\n                          \
    \       (map abs (- value integers))\n                                 (map abs\
    \ (- value integers))\n                                 (map abs (- value integers))\n\
    \                                 (map abs (- value integers))\n             \
    \                    (map abs (- value integers))\n                          \
    \       (map abs (- value integers))\n                                 (map abs\
    \ (- value integers))\n                                 (map abs (- value integers))\n\
    \                                 (map abs (- value integers))\n             \
    \                    (map abs (- value integers))\n                          \
    \       (map abs (- value integers))\n                                 (map abs\
    \ (- value integers))\n                                 (map abs (- value integers))\n\
    \                                 (map abs (- value integers))\n             \
    \                    (map abs (- value integers))\n                          \
    \       (map abs (- value integers))\n                                 (map abs\
    \ (- value integers))\n                                 (map abs (- value integers))\n\
    \                                 (map abs (- value integers))\n             \
    \                    (map abs (- value integers))\n                          \
    \       (map abs (- value integers))\n                                 (map abs\
    \ (- value integers))\n                                 (map abs (- value integers))\n\
    \                                 (map abs (- value integers))\n             \
    \                    (map abs (- value integers))\n                          \
    \       (map abs (- value integers))\n                                 (map abs\
    \ (- value integers))\n                                 (map abs (- value integers))\n\
    \                                 (map abs (- value integers))\n             \
    \                    (map abs (- value integers))\n                          \
    \       (map abs (- value integers))\n                                 (map abs\
    \ (- value integers))\n                                 (map abs (- value integers))\n\
    \                                 (map abs (- value integers))\n             \
    \                    (map abs (- value integers))\n                          \
    \       (map abs (- value integers))\n                                 (map abs\
    \ (- value integers))\n                                 (map abs (- value integers))\n\
    \                                 (map abs (- value integers))\n             \
    \                    (map abs (- value integers))\n                          \
    \       (map abs (- value integers))\n                                 (map abs\
    \ (- value integers))\n                                 (map abs (- value integers))\n\
    \                                 (map abs (- value integers))\n             \
    \                    (", "  (let ([integer (string->number (car value))])\n  \
    \  (let ([integers (string->list (cadr value))])\n      (let ([min (min integers\
    \ integer)]\n            [max (max integers integer)])\n        (if (< min max)\n\
    \            (ceil integer)\n            (floor integer)))))\n  value)\n", " \
    \ (define (closest-integer-helper value candidate)\n    (if (= candidate 0)\n\
    \        value\n        (if (< (abs (- candidate value)) (abs (- value candidate)))\n\
    \            (closest-integer-helper (- candidate value) candidate)\n        \
    \    (closest-integer-helper (- value candidate) candidate))))\n  (closest-integer-helper\
    \ value 0))\n", "  (define (closest-integer-helper value)\n    (cond ((< value\
    \ 0) 0)\n          ((< value 1) value)\n          ((< value 2) (+ value 1))\n\
    \          ((< value 3) (+ value 2))\n          ((< value 4) (+ value 3))\n  \
    \        ((< value 5) (+ value 4))\n          ((< value 6) (+ value 5))\n    \
    \      ((< value 7) (+ value 6))\n          ((< value 8) (+ value 7))\n      \
    \    ((< value 9) (+ value 8))\n          ((< value 10) (+ value 9))\n       \
    \   ((< value 11) (+ value 10))\n          ((< value 12) (+ value 11))\n     \
    \     ((< value 13) (+ value 12))\n          ((< value 14) (+ value 13))\n   \
    \       ((< value 15) (+ value 14))\n          ((< value 16) (+ value 15))\n \
    \         ((< value 17) (+ value 16))\n          ((< value 18) (+ value 17))\n\
    \          ((< value 19) (+ value 18))\n          ((< value 20) (+ value 19))\n\
    \          ((< value 21) (+ value 20))\n          ((< value 22) (+ value 21))\n\
    \          ((< value 23) (+ value 22))\n          ((< value 24) (+ value 23))\n\
    \          ((< value 25) (+ value 24))\n          ((< value 26) (+ value 25))\n\
    \          ((< value 27) (+ value 26))\n          ((< value 28) (+ value 27))\n\
    \          ((< value 29) (+ value 28))\n          ((< value 30) (+ value 29))\n\
    \          ((< value 31) (+ value 30))\n          ((< value 32) (+ value 31))\n\
    \          ((< value 33) (+ value 32))\n          ((< value 34) (+ value 33))\n\
    \          ((< value 35) (+ value 34))\n          ((< value 36) (+ value 35))\n\
    \          ((< value 37) (+ value 36))\n          ((< value 38) (+ value 37))\n\
    \          ((< value 39) (+ value 38))\n          ((< value 40) (+ value 39))\n\
    \          ((< value 41) (+ value 40))\n          ((< value 42) (+ value 41))\n\
    \          ((< value 43) (+ value 42))\n          ((< value 44) (+ value 43))\n\
    \          ((< value 45) (+ value 44))\n          ((< value 46) (+ value 45))\n",
  "  (let ((x (string->number (string->symbol value))))\n    (let ((y (/ x 10)))\n\
    \      (if (< x y)\n          (ceiling x)\n          (floor x))))))\n", "  (let\
    \ ([x (string->number (car value))])\n    (let ([y (string->number (cadr value))])\n\
    \      (if (and (number? x) (number? y))\n          (if (= x y)\n            \
    \  (round x)\n              (round (- x y)))\n          (round (- x y))))))\n",
  "  (let ([integers (map number->integer [1 2 3 4 5 6 7 8 9])])\n    (let ([closest\
    \ (first integers)])\n      (if (> (abs (- value closest)) (abs (- value integers)))\n\
    \          closest\n          (closest_integer value))))))\n", "  (define (closest-integer-helper\
    \ value min-value max-value)\n    (cond ((< value max-value) (+ value 1))\n  \
    \        ((< value min-value) (- value 1))\n          (else value)))\n  (closest-integer-helper\
    \ value 0 99))\n", "  (let ([num (number->string value)]\n        [nums (number->list\
    \ value)]\n        [min (min nums)]\n        [max (max nums)])\n    (cond\n  \
    \    [(empty? nums) value]\n      [(equal? num min) (closest_integer max)]\n \
    \     [(equal? num max) (closest_integer min)]\n      [else (if (< (length nums)\
    \ 2)\n              (closest_integer max)\n              (closest_integer min))]))))\n",
  "  (let ([integers (map number->integer [1 2 3 4 5 6 7 8 9])])\n    (let ([closest\
    \ (first integers)])\n      (if (< (abs (- value closest)) (abs (- value integers)))\n\
    \          closest\n          (closest_integer value))))))\n", "  (define (closest-integer\
    \ value low-bound high-bound)\n    (cond [(< value low-bound)\n           (if\
    \ (< (- value high-bound) low-bound)\n               (- low-bound)\n         \
    \      (- high-bound))]\n          [(< value high-bound)\n           (if (< (-\
    \ value low-bound) high-bound)\n               (- high-bound)\n              \
    \ (- low-bound))]\n          [else\n           (if (< (- value low-bound) high-bound)\n\
    \               (- low-bound)\n               (- high-bound))]\n          ))\n\
    \  (closest-integer value 0 (string->number value)))\n", "  (let ([integers (map\
    \ integer->real '(1 2 3 4 5 6 7 8 9 10))])\n    (let ([closest (first integers)])\n\
    \      (if (< (abs (- value closest)) (abs (- value integers)))\n          closest\n\
    \          integer))))\n", "  (let ([x (number->string value)]\n        [y (number->string\
    \ value)])\n    (cond\n      [(empty? x) (number->string 0)]\n      [(empty? y)\
    \ (number->string 0)]\n      [(equal? x y) (number->string 0)]\n      [else (let\
    \ ([x (number->string x)]\n                 [y (number->string y)])\n        \
    \      (cond\n                [(empty? x) (number->string 0)]\n              \
    \  [(empty? y) (number->string 0)]\n                [(equal? x y) (number->string\
    \ 0)]\n                [else (let ([x (number->string x)]\n                  \
    \         [y (number->string y)])\n                        (cond\n           \
    \               [(empty? x) (number->string 0)]\n                          [(empty?\
    \ y) (number->string 0)]\n                          [(equal? x y) (number->string\
    \ 0)]\n                          [else (let ([x (number->string x)]\n        \
    \                               [y (number->string y)])\n                    \
    \                (cond\n                                      [(empty? x) (number->string\
    \ 0)]\n                                      [(empty? y) (number->string 0)]\n\
    \                                      [(equal? x y) (number->string 0)]\n   \
    \                                   [(< (string->number x) (string->number y))\
    \ (number->string 0)]\n                                      [(< (string->number\
    \ x) (number->string y)) (string->number x)]\n                               \
    \       [(< (number->string x) (number->string y)) (string->number x)]\n     \
    \                                 [(< (number->string x) (number->string y)) (number->string\
    \ y)]\n                                      [(< (string->number x) (number->string\
    \ y)) (string->number y)]\n                                      [(< (string->number\
    \ x) (number->string y)) (number->string y)]\n                               \
    \       [(< (number->string x) (number->string y)) (string->number y)]\n     \
    \                                 [(< (number->string x) (number->string y)) (number->string\
    \ y)]\n                                      [(< (string->number x) (number->string\
    \ y)) (string->number y)]\n                                      [(< (string->number\
    \ x) (number->string y)) (number->string y)]\n                               \
    \       [(< (number->string x) (number->string y)) (string->number y)]\n     \
    \                                 [(< (number->string x) (number->string y)) (number->string\
    \ y)]))]))]))]))))\n", "  (define (closest-to-zero x)\n    (if (< x 0)\n     \
    \   0\n        (ceiling x)))\n  (define (closest-to-one x)\n    (if (< x 0)\n\
    \        0\n        (floor (ceiling x))))\n  (define (closest-to-two x)\n    (if\
    \ (< x 0)\n        0\n        (floor (ceiling (ceiling x))))\n  (define (closest-to-three\
    \ x)\n    (if (< x 0)\n        0\n        (floor (ceiling (ceiling (ceiling x))))))\n\
    \  (define (closest-to-four x)\n    (if (< x 0)\n        0\n        (floor (ceiling\
    \ (ceiling (ceiling (ceiling x)))))))\n  (define (closest-to-five x)\n    (if\
    \ (< x 0)\n        0\n        (floor (ceiling (ceiling (ceiling (ceiling (ceiling\
    \ x))))))))\n  (define (closest-to-six x)\n    (if (< x 0)\n        0\n      \
    \  (floor (ceiling (ceiling (ceiling (ceiling (ceiling (ceiling x))))))))\n  (define\
    \ (closest-to-seven x)\n    (if (< x 0)\n        0\n        (floor (ceiling (ceiling\
    \ (ceiling (ceiling (ceiling (ceiling x))))))))\n  (define (closest-to-eight x)\n\
    \    (if (< x 0)\n        0\n        (floor (ceiling (ceiling (ceiling (ceiling\
    \ (ceiling (ceiling x))))))))\n  (define (closest-to-nine x)\n    (if (< x 0)\n\
    \        0\n        (floor (ceiling (ceiling (ceiling (ceiling (ceiling (ceiling\
    \ (ceiling x))))))))\n  (define (closest-to-ten x)\n    (if (< x 0)\n        0\n\
    \        (floor (ceiling (ceiling (ceiling (ceiling (ceiling (ceiling (ceiling\
    \ x))))))))\n  (define (closest-to-eleven x)\n    (if (< x 0)\n        0\n   \
    \     (floor (ceiling (ceiling (ceiling (ceiling (ceiling (ceiling (ceiling x))))))))\n\
    \  (define (closest-to-twelve x)\n    (if (< x 0)\n        0\n        (floor (ceiling\
    \ (ceiling (ceiling (ceiling (ceiling (ceiling (ceiling x))))))))\n  (define (closest-to-thirteen\
    \ x)\n    (if (< x 0)\n        0\n        (floor (ceiling (ceiling (ceiling (ceiling\
    \ (ceiling (ceiling (ceiling x))))))))\n  (define (closest-to-fourteen x)\n  \
    \  (if (< x 0)\n        0\n        (floor (ceiling (ceiling (ceiling (ceiling\
    \ (ceiling (", "  (let ([integer (parse-integer value)]\n        [integers (list\
    \ integer)]\n        [closest (car integers)])\n    (if (null? integers)\n   \
    \     integer\n        (let ([new (+ closest (car integers))])\n          (if\
    \ (< (car integers) new)\n              (closest_integer value)\n            \
    \  (closest_integer new)))))\n  ;; Return the closest integer\n  closest)\n",
  "  (let ([x (string->number (car value))])\n    (let ([y (string->number (cadr value))])\n\
    \      (cond\n        ((= x y) value)\n        (else (round (sqrt (+ (* x x) (*\
    \ y y)))\n                   (/ x y)))))\n  ))\n", "  (define (closest-integer-helper\
    \ x y)\n    (if (= x y)\n        x\n        (if (< (abs (- x y)) (/ x y))\n  \
    \          (- x y)\n            (+ x y))))\n  (closest-integer-helper (parse-integer\
    \ value) value))\n", "  (define (closest-integer-helper value min max)\n    (cond\
    \ ((< value max) (+ min 1))\n          ((< value min) (- min 1))\n          (else\
    \ (+ min (floor (/ value max))))))\n  (closest-integer-helper value 0 10))\n",
  "  (let ([int-value (string->number (value))]\n        [int-min (string->number\
    \ ((min value))))]\n        [int-max (string->number ((max value))))]\n    (cond\n\
    \      [(= int-value int-min) (min int-max)]\n      [(= int-value int-max) (max\
    \ int-min)]\n      [else (round int-value (incf (- int-value int-min) (incf (-\
    \ int-value int-max) 1)))])))\n", "  (let ([x (string->number (car value))\n \
    \       y (+ x (/ (- x) 10 (floor x)))]\n        (cond [(< x y) x]\n         \
    \     [(< y x) y]\n              [else (+ y (/ (- y) 10 (floor y)))])))\n", " \
    \ (let ([x (number->string value)]\n        [y (number->string value)])\n    (cond\n\
    \      [(number-eq? x y) value]\n      [else (let ([x (number->string value)]\n\
    \                  [y (number->string value)])\n              (cond\n        \
    \        [(number-eq? x y) value]\n                [else (let ([x (number->string\
    \ value)]\n                            [y (number->string value)])\n         \
    \               (cond\n                          [(number-eq? x y) value]\n  \
    \                        [else (let ([x (number->string value)]\n            \
    \                          [y (number->string value)])\n                     \
    \             (cond\n                                    [(number-eq? x y) value]\n\
    \                                    [(number-eq? y x) value]\n              \
    \                      [else (let ([x (number->string value)]\n              \
    \                                [y (number->string value)])\n               \
    \                           (cond\n                                          \
    \  [(number-eq? x y) value]\n                                            [(number-eq?\
    \ y x) value]\n                                            [(number-eq? (string->number\
    \ x) (string->number y)) (round (/ (+ (string->number x) (string->number y)) 2))]\n\
    \                                            [else (let ([x (number->string value)]\n\
    \                                                      [y (number->string value)])\n\
    \                                                    (cond\n                 \
    \                                     [(number-eq? x y) value]\n             \
    \                                         [(number-eq? y x) value]\n         \
    \                                             [(number-eq? (string->number x)\
    \ (string->number y)) (round (/ (- (string->number x) (string->number y)) 2))]\n\
    \                                                      [else (let ([x (number->string\
    \ value)]\n                                                                  \
    \  [y (number->string value)])\n                                             \
    \                   (cond\n                                                  \
    \                [(number-eq? x y) value]\n                                  \
    \                                [(number-eq? y x) value]\n                  \
    \                                                [(number-eq? (string->number\
    \ x) (string->number y)) (round (/ (- (string->number x) (string->number y)) 2))]\n\
    \                                                                  [else (let\
    \ ([x (number->string value)]\n                                              \
    \                            [y (number->string value)])\n                   \
    \                                                 (cond\n                    \
    \                                                  [(number-eq? x y) value]\n\
    \                                                                      [(number-eq?\
    \ y x) value]\n                                                              \
    \        [(number-eq? (string->number x) (string->number y)) (round (/ (+ (string->number\
    \ x) (string->number y)) 2))]\n                                              \
    \                        [else (let ([x (number->string value)]\n            \
    \                                                                    [y (number->string\
    \ value)])\n                                                                 \
    \             (cond\n                                                        \
    \                        [(x-eq? x ", "  (let ([integer (string->number (car value))])\n\
    \    (let ([integers (string->list (cadr value))])\n      (let ([closest (car\
    \ integers)])\n        (let ([closests (cdr integers)])\n          (let ([closest-distance\
    \ (abs (- integer closest))])\n            (cond\n              [(empty? closests)\n\
    \               (if (= closest-distance 0)\n                   (car integers)\n\
    \                   (car integers))]\n              [(< closest-distance (abs\
    \ (- integer closests)))\n               (car integers)]\n              [else\
    \ (closest_integer closests)]))))))))\n", "  (let ([x (number->string value)]\n\
    \        [y (number->string value)])\n    (cond\n      [(equal? x y) value]\n\
    \      [(equal? x \"-\") (- 0 (number->integer value))]\n      [(equal? y \"-\"\
    ) (- 0 (number->integer value))]\n      [(equal? x \"0\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"0\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"1\") (- 0 (number->integer value))]\n      [(equal? y \"1\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"2\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"2\") (- 0 (number->integer value))]\n      [(equal? x \"3\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"3\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"4\") (- 0 (number->integer value))]\n      [(equal? y \"4\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"5\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"5\") (- 0 (number->integer value))]\n      [(equal? x \"6\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"6\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"7\") (- 0 (number->integer value))]\n      [(equal? y \"7\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"8\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"8\") (- 0 (number->integer value))]\n      [(equal? x \"9\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"9\") (- 0 (number->integer value))]\n      [else\
    \ (- 0 (number->integer value))]))))\n", "  (let ([integer (parse-integer value)]\n\
    \        [integers (list integer)]\n        [closest (car integers)])\n    (cond\n\
    \      [(empty? integers) value]\n      [(< (abs (- value closest)) (abs (- value\
    \ (car integers))))\n       (closest_integer (car integers))]\n      [else (closest_integer\
    \ (cdr integers))])))\n", "  (let ([int-value (string->number (string->symbol\
    \ value))]\n        [int-min (floor (abs int-value))]\n        [int-max (ceiling\
    \ (abs int-value))]\n        [int-diff (abs int-min)]\n        [int-sum (+ int-min\
    \ int-max)]\n        [int-diff (- int-sum int-value)])\n    (cond\n      [(< int-diff\
    \ int-max) int-max]\n      [(< int-diff int-min) int-min]\n      [else int-value])))\n",
  "  (let ([num (number->string value)])\n    (let ([nums (number->list value)])\n\
    \      (let ([min (min nums)])\n        (let ([max (max nums)])\n          (let\
    \ ([diff (- max min)])\n            (if (= diff 0)\n                num\n    \
    \            (if (= (abs diff) 1)\n                    (round (/ diff 2))\n  \
    \                  (round (/ diff 2))))))))))\n", "  (let ([int-value (string->number\
    \ (value))]\n        [int-min (string->number ((number->string (- (number->string\
    \ int-value) int-value))))]\n        [int-max (string->number ((number->string\
    \ int-value)))])\n    (cond\n      [(< int-value int-min) (number->string int-min)]\n\
    \      [(< int-value int-max) (number->string int-max)]\n      [(> int-value int-min)\
    \ (number->string (- (number->string int-min) int-min))]\n      [(> int-value\
    \ int-max) (number->string (- (number->string int-max) int-max))]\n      [else\
    \ (number->string int-value)])))\n", "  (let ([x (number->string value)]\n   \
    \     [y (number->string value)])\n    (cond\n      [(empty? x) 0]\n      [(empty?\
    \ y) x]\n      [(equal? (car x) (car y)) (closest_integer (cdr x) (closest_integer\
    \ (cdr y)))]\n      [else (let ([x (number->string (car x))\n                \
    \  y (number->string (car y))]\n               [z (number->string (cdr x))\n \
    \                 w (number->string (cdr y))]\n               [result (if (< (<\
    \ (number->string (car x)) (number->string (car y)))\n                       \
    \   (number->string (cdr x)))\n                         (if (< (< (number->string\
    \ (car y)) (number->string (cdr y)))\n                                (number->string\
    \ (cdr x)))\n                         (if (< (< (number->string (cdr x)) (number->string\
    \ (cdr y)))\n                                (number->string (cdr x)))\n     \
    \                    (if (< (< (number->string (cdr y)) (number->string (cdr x)))\n\
    \                                (number->string (cdr x)))\n                 \
    \        (if (< (< (number->string (car x)) (number->string (cdr y)))\n      \
    \                          (number->string (cdr x)))\n                       \
    \  (if (< (< (number->string (cdr y)) (number->string (cdr x)))\n            \
    \                    (number->string (cdr x)))\n                         (if (<\
    \ (< (number->string (car x)) (number->string (cdr y)))\n                    \
    \            (number->string (cdr x)))\n                         (if (< (< (number->string\
    \ (cdr y)) (number->string (cdr x)))\n                                (number->string\
    \ (cdr x)))\n                         (if (< (< (number->string (car x)) (number->string\
    \ (cdr y)))\n                                (number->string (cdr x)))\n     \
    \                    (if (< (< (number->string (cdr y)) (number->string (cdr x)))\n\
    \                                (number->string (cdr x)))\n                 \
    \        (if (< (< (number->string (car x)) (number->string (cdr y)))\n      \
    \                          (number->string (cdr x)))\n                       \
    \  (if (< (< (number->string (cdr y)) (number->string (cdr x)))\n            \
    \                    (number->string (cdr ", "  (let ([num (string->number (car\
    \ value))])\n    (cond\n      [(< num 0) (error \"Closest integer not possible.\"\
    )]\n      [(< num 1) (error \"Closest integer not possible.\")]\n      [else (floor\
    \ (+ (* num num) (/ num 2)))]\n    )\n  )\n)\n", "  (let ([int-value (string->number\
    \ (string->symbol value))]\n        [int-diff (- int-value int-value)]\n     \
    \   [int-diff (ceiling int-diff)]\n        [int-diff (floor int-diff)]\n     \
    \   [int-diff (round int-diff)])\n    (if (< int-diff 0)\n        (- int-diff\
    \ (- int-diff 1)))))\n", "  (let ([integers (map number->integer [1 2 3 4 5 6\
    \ 7 8 9])])\n    (let ([closest (car integers)])\n      (let ([closest-distance\
    \ (abs (- value closest))])\n        (let ([closest-integer (caddr integers)])\n\
    \          (let ([closest-integer-distance (abs (- value closest-integer))])\n\
    \            (if (< closest-distance closest-integer-distance)\n             \
    \   (cons closest-integer integers)\n                (cons closest integers))))))))\n",
  "  (define (closest-integer value)\n    (cond [(number? value) (number->string value)]\n\
    \          [(number? (string->number value)) (string->number value)]\n       \
    \   [(number? (string->number value)) (closest-integer (string->number value))]))\n\
    \  (closest-integer value))\n", "  (let ([integers (map number->integer [1 2 3\
    \ 4 5 6 7 8 9 10])])\n    (let ([closest (first integers)])\n      (if (< (abs\
    \ (- value closest)) (abs (- value integers)))\n          closest\n          (closest_integer\
    \ value))))))\n", "  (let ([x (parse-integer (string->symbol (symbol->string value)))])\n\
    \    (cond [(< x 0) (- 0)]\n          [(< x 1) x]\n          [(< x 2) (- x)]\n\
    \          [(< x 3) (- x)]\n          [(< x 4) (- x)]\n          [(< x 5) (- x)]\n\
    \          [(< x 6) (- x)]\n          [(< x 7) (- x)]\n          [(< x 8) (- x)]\n\
    \          [(< x 9) (- x)]\n          [(< x 10) (- x)]\n          [(< x 11) (-\
    \ x)]\n          [(< x 12) (- x)]\n          [(< x 13) (- x)]\n          [(< x\
    \ 14) (- x)]\n          [(< x 15) (- x)]\n          [(< x 16) (- x)]\n       \
    \   [(< x 17) (- x)]\n          [(< x 18) (- x)]\n          [(< x 19) (- x)]\n\
    \          [(< x 20) (- x)]\n          [(< x 21) (- x)]\n          [(< x 22) (-\
    \ x)]\n          [(< x 23) (- x)]\n          [(< x 24) (- x)]\n          [(< x\
    \ 25) (- x)]\n          [(< x 26) (- x)]\n          [(< x 27) (- x)]\n       \
    \   [(< x 28) (- x)]\n          [(< x 29) (- x)]\n          [(< x 30) (- x)]\n\
    \          [(< x 31) (- x)]\n          [(< x 32) (- x)]\n          [(< x 33) (-\
    \ x)]\n          [(< x 34) (- x)]\n          [(< x 35) (- x)]\n          [(< x\
    \ 36) (- x)]\n          [(< x 37) (- x)]\n          [(< x 38) (- x)]\n       \
    \   [(< x 39) (- x)]\n          [(< x 40) (- x)]\n          [(< x 41) (- x)]\n\
    \          [(< x 42) (- x)]\n          [(< x 43) (- x)]\n          [(< x 44) (-\
    \ x)]\n          [(< x 45) (- x)]\n          [(< x 46) (- x)]\n          [(< x\
    \ 47) (- x)]\n          [(< x 48) (- x)]\n          ", "  (define (closest-integer-helper\
    \ value candidates)\n    (cond [(empty? candidates) value]\n          [(< (abs\
    \ (- (car candidates) value)) (abs (- (car candidates) (cadr candidates)))) (car\
    \ candidates)]\n          [else (closest-integer-helper (car candidates) (cdr\
    \ candidates))]))\n  (closest-integer-helper value '(0 1)))\n", "  (let ([x (string->number\
    \ (car value))])\n    (let ([y (string->number (cadr value))])\n      (if (= x\
    \ y)\n          x\n          (if (< x y)\n              (ceiling x)\n        \
    \      (floor x)))))\n</code>\n<|/ a tags=racket,scheme |>\n<| a |>\n<code>",
  "  (let ([x (parse-integer (string->symbol (symbol->string value)))])\n    (cond\n\
    \      [(< x 0) (error \"Closest integer not possible for negative numbers\")]\n\
    \      [(< x 1) x]\n      [else (round (/ x 2))]))))\n", "  (let ([num (parse-integer\
    \ value)]\n        [min (parse-integer \"0\")])\n    (cond [(= num min) (parse-integer\
    \ \"0\")]\n          [(< num min) (parse-integer \"0\")]\n          [(< num num)\
    \ (parse-integer \"0\")]\n          [else (parse-integer \"0\")]))\n  )\n", " \
    \ (let ([num (number->string value)]\n        [nums (number->list value)])\n \
    \   (let ([closest (number->string 0)])\n      (for [num (in-range nums)]\n  \
    \      (let ([diff (number->string (num - closest))])\n          (if (< (string->number\
    \ diff) (string->number closest))\n              (set! closest num)\n        \
    \      (set! diff (string->number closest)))))\n      (number->number closest))))\n",
  "  (define (closest-integer-helper value min-value max-value)\n    (cond\n     \
    \ [(< value min-value) (+ min-value 1)]\n      [(< value max-value) (+ max-value\
    \ 1)]\n      [else (+ value 1)]))\n  (closest-integer-helper value 0 100))\n",
  "  (let ([num (number->string value)]\n        [nums (number->list value)]\n   \
    \     [min (number->string 0)])\n    (if (null? nums)\n        min\n        (let\
    \ ([num (string->number num)]\n              [nums (string->list num)]\n     \
    \         [min (string->number min)])\n          (if (< (number->string min) num)\n\
    \              (if (< (number->string num) min)\n                  (if (< (number->string\
    \ nums) min)\n                      (if (< (number->string nums) num)\n      \
    \                    (if (< (number->string nums) (number->string min))\n    \
    \                          (if (< (number->string nums) (number->string num))\n\
    \                                  (if (< (number->string nums) (number->string\
    \ min))\n                                      (if (< (number->string nums) (number->string\
    \ num))\n                                          (if (< (number->string nums)\
    \ (number->string min))\n                                              (if (<\
    \ (number->string nums) (number->string num))\n                              \
    \                    (if (< (number->string nums) (number->string min))\n    \
    \                                                  (if (< (number->string nums)\
    \ (number->string num))\n                                                    \
    \      (if (< (number->string nums) (number->string min))\n                  \
    \                                            (if (< (number->string nums) (number->string\
    \ num))\n                                                                  (if\
    \ (< (number->string nums) (number->string min))\n                           \
    \                                           (if (< (number->string nums) (number->string\
    \ num))\n                                                                    \
    \      (if (< (number->string nums) (number->string min))\n                  \
    \                                                            (if (< (number->string\
    \ nums) (number->string num))\n                                              \
    \                                    (if (< (number->string nums) (number->string\
    \ min))\n                                                                    \
    \                  (if (< (number->string nums) (number->string num))\n      \
    \                                                                            \
    \        (if (< (number->string nums) (number->string min))\n                \
    \                                                                            \
    \  (if (< (number->string nums) (number->string num))\n                      \
    \                                                                            (if\
    \ (< (number->string nums) (number->string min))\n                           \
    \                                                                           (if\
    \ (< (number->string nums) (number->string num))\n                           \
    \                                                                            \
    \   (if (< (number->string nums) (number->string min))\n                     \
    \                                                                            \
    \             (if (< (number->string nums) (number->string num))\n           \
    \                                                                            \
    \                           (if (< (number->string nums) (number->string min))\n\
    \                                                                            \
    \                                          (if (< (number->string nums) (number->string\
    \ num))\n                                                                    \
    \                                                      (if (", "  (let ([int-value\
    \ (string->number value)])\n    (cond\n      [(< int-value 0) (error \"Closest\
    \ integer not possible.\")]\n      [else (ceiling int-value)])))\n", "  (let ([x\
    \ (parse-integer (string->symbol (symbol->string value)))])\n    (let ([y (parse-integer\
    \ (string->symbol (symbol->string value)))])\n      (let ([dist (abs (- x y))]\n\
    \            [mindist (min x y)]\n            [maxdist (max x y)]\n          \
    \  [mindist2 (min x y)])\n        (if (= dist 0)\n            (if (= x y)\n  \
    \              mindist\n                (if (< mindist maxdist)\n            \
    \        mindist\n                    maxdist)))))))\n", "  (let ([int-value (parse-integer\
    \ value)]\n        [int-min (parse-integer '-inf)]\n        [int-max (parse-integer\
    \ '+inf)])\n    (cond\n      [(< int-value int-min)\n       (parse-integer '-inf)]\n\
    \      [(> int-value int-max)\n       (parse-integer '+inf)]\n      [else\n  \
    \     (add1 (closest_integer (- int-value int-min)))])))\n", "  (let ([integers\
    \ (map integer->real '(1 2 3 4 5 6 7 8 9))])\n    (let ([closest (car integers)])\n\
    \      (let ([diff (- value closest)])\n        (if (< diff 0)\n            (ceiling\
    \ closest)\n            (floor closest)))))\n", "  (let ([x (number->string value)]\n\
    \        [y (number->string value)])\n    (cond\n      [(equal? x y) value]\n\
    \      [(equal? x \"-\") (- 0 (number->integer value))]\n      [(equal? y \"-\"\
    ) (- 0 (number->integer value))]\n      [(equal? x \"0\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"0\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"1\") (- 0 (number->integer value))]\n      [(equal? y \"1\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"10\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"10\") (- 0 (number->integer value))]\n      [(equal? x \"11\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"11\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"12\") (- 0 (number->integer value))]\n      [(equal? y \"12\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"13\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"13\") (- 0 (number->integer value))]\n      [(equal? x \"14\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"14\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"15\") (- 0 (number->integer value))]\n      [(equal? y \"15\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"16\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"16\") (- 0 (number->integer value))]\n      [(equal? x \"17\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"17\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"18\") (- 0 (number->integer value))]\n      [(equal? y \"18\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"19\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"19\") (- 0 (number->integer value))]\n      [(equal? x \"20\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"20\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"", "  (let ([num (string->number (car value))])\n    (cond\n      [(< num\
    \ 0) (error \"Not a number\")]\n      [(< num 1) (error \"Not a number\")]\n \
    \     [(< num 2) (error \"Not a number\")]\n      [(< num 3) (error \"Not a number\"\
    )]\n      [(< num 4) (error \"Not a number\")]\n      [(< num 5) (error \"Not\
    \ a number\")]\n      [(< num 6) (error \"Not a number\")]\n      [(< num 7) (error\
    \ \"Not a number\")]\n      [(< num 8) (error \"Not a number\")]\n      [(< num\
    \ 9) (error \"Not a number\")]\n      [else (ceiling (/ num 10))]))))\n", "  (let\
    \ ([num (number->string value)])\n    (cond\n      [(number->int? num) (value->int\
    \ num)]\n      [(number->float? num) (value->float num)]\n      [else (error \"\
    Not a number\")]\n      )\n    )\n  )\n", "  (let ([integers (map integer->real\
    \ '(1 2 3 4 5 6 7 8 9 10))])\n    (let ([closest-integer (first integers)])\n\
    \      (if (< (abs (- value closest-integer)) (abs (- value integer)))\n     \
    \     closest-integer\n          (let ([closest-integer (first integers)])\n \
    \           (if (< (abs (- value closest-integer)) (abs (- value integer)))\n\
    \                closest-integer\n                (let ([closest-integer (first\
    \ integers)])\n                  (if (< (abs (- value closest-integer)) (abs (-\
    \ value integer)))\n                      closest-integer\n                  \
    \    (let ([closest-integer (first integers)])\n                        (if (<\
    \ (abs (- value closest-integer)) (abs (- value integer)))\n                 \
    \           closest-integer\n                            (let ([closest-integer\
    \ (first integers)])\n                              (if (< (abs (- value closest-integer))\
    \ (abs (- value integer)))\n                                  closest-integer\n\
    \                                  (let ([closest-integer (first integers)])\n\
    \                                    (if (< (abs (- value closest-integer)) (abs\
    \ (- value integer)))\n                                        closest-integer\n\
    \                                        (let ([closest-integer (first integers)])\n\
    \                                          (if (< (abs (- value closest-integer))\
    \ (abs (- value integer)))\n                                              closest-integer\n\
    \                                              (let ([closest-integer (first integers)])\n\
    \                                                (if (< (abs (- value closest-integer))\
    \ (abs (- value integer)))\n                                                 \
    \   closest-integer\n                                                    (let\
    \ ([closest-integer (first integers)])\n                                     \
    \                 (if (< (abs (- value closest-integer)) (abs (- value integer)))\n\
    \                                                          closest-integer\n \
    \                                                         (let ([closest-integer\
    \ (first integers)])\n                                                       \
    \     (if (< (abs (- value closest-integer)) (abs (- value integer)))\n      \
    \                                                          closest-integer\n \
    \                                                               (let ([closest-integer\
    \ (first integers)])\n                                                       \
    \           (if (< (abs (- value closest-integer)) (abs (- value integer)))\n\
    \                                                                      closest-integer\n\
    \                                                                      (let ([closest-integer\
    \ (first integers)])\n                                                       \
    \                 (if (< (abs (- value closest-integer)) (abs (- value integer)))\n\
    \                                                                            closest-integer\n\
    \                                                                            (let\
    \ ([closest-integer (first integers)])\n                                     \
    \                                         (if (< (abs (- value closest-integer))\
    \ (abs (- value integer)))\n                                                 \
    \                                 closest-integer\n                          \
    \                                                        (let ([closest-integer",
  "  (let ([num (parse-integer value)]\n        [min (parse-integer \"0\")]\n    \
    \    [max (parse-integer \"0\")]\n        [diff (- num min)]\n        [diff (-\
    \ num max)]\n        [diff (- min max)])\n    (if (< diff 0)\n        (parse-integer\
    \ \"0\")\n        (if (< diff 1)\n            (parse-integer \"1\")\n        \
    \    (if (< diff 2)\n                (parse-integer \"2\")\n                (if\
    \ (< diff 3)\n                    (parse-integer \"3\")\n                    (if\
    \ (< diff 4)\n                        (parse-integer \"4\")\n                \
    \        (if (< diff 5)\n                            (parse-integer \"5\")\n \
    \                           (if (< diff 6)\n                                (parse-integer\
    \ \"6\")\n                                (if (< diff 7)\n                   \
    \                 (parse-integer \"7\")\n                                    (if\
    \ (< diff 8)\n                                        (parse-integer \"8\")\n\
    \                                        (if (< diff 9)\n                    \
    \                        (parse-integer \"9\")\n                             \
    \               (parse-integer \"10\"))))))))))))\n", "  (let ([integers (map\
    \ integer->real '(1 2 3 4 5 6 7 8 9 10))])\n    (let ([closest (first integers)])\n\
    \      (if (< (abs (- value closest)) (abs (- value integers)))\n          closest\n\
    \          (closest_integer value))))))\n", "  (let ([integers (map number->integer\
    \ [1 2 3 4 5 6 7 8 9])])\n    (let ([closest (first integers)])\n      (if (<\
    \ (abs (- value closest)) (abs (- value integers)))\n          closest\n     \
    \     (closest_integer value))))))\n", "  (let ([x (number->string value)]\n \
    \       [y (number->string value)])\n    (cond\n      [(empty? x) 0]\n      [(empty?\
    \ y) x]\n      [(equal? (string->number x) (string->number y)) (number->integer\
    \ x)]\n      [else (number->integer x)]))))\n", "  (let ([integers (map number->integer\
    \ (split-string (number->string value) \".\"))])\n    (if (null? integers)\n \
    \       0\n        (let ([closest (car integers)])\n          (if (< (abs (- closest\
    \ value)) (abs (- value closest)))\n              closest\n              (closest_integer\
    \ value))))))\n", "  (let ((x (string->number (string->symbol value))))\n    (cond\n\
    \      [(< x 0) (error \"Closest integer not possible for negative numbers\")]\n\
    \      [(< x 1) x]\n      [(< x 10) (+ x 10)]\n      [(< x 100) (+ x 100)]\n \
    \     [(< x 1000) (+ x 1000)]\n      [(< x 10000) (+ x 10000)]\n      [(< x 100000)\
    \ (+ x 100000)]\n      [(< x 1000000) (+ x 1000000)]\n      [(< x 10000000) (+\
    \ x 10000000)]\n      [(< x 100000000) (+ x 10000000)]\n      [(< x 1000000000)\
    \ (+ x 10000000)]\n      [(< x 10000000000) (+ x 10000000)]\n      [(< x 100000000000)\
    \ (+ x 10000000)]\n      [(< x 1000000000000) (+ x 10000000)]\n      [(< x 10000000000000)\
    \ (+ x 10000000)]\n      [(< x 100000000000000) (+ x 10000000)]\n      [(< x 1000000000000000)\
    \ (+ x 10000000)]\n      [(< x 10000000000000000) (+ x 10000000)]\n      [(< x\
    \ 100000000000000000) (+ x 10000000)]\n      [(< x 1000000000000000000) (+ x 10000000)]\n\
    \      [(< x 10000000000000000000) (+ x 10000000)]\n      [(< x 100000000000000000000)\
    \ (+ x 10000000)]\n      [(< x 1000000000000000000000) (+ x 10000000)]\n     \
    \ [(< x 10000000000000000000000) (+ x 10000000)]\n      [(< x 100000000000000000000000)\
    \ (+ x 10000000)]\n      [(< x 1000000000000000000000000) (+ x 10000000)]\n  \
    \    [(< x 10000000000000000000000000) (+ x 10000000)]\n      [(< x 100000000000000000000000000)\
    \ (+ x 10000000)]\n      [(< x 1000000000000000000000000000) (+ x 10000000)]\n\
    \      [(< x 10000000000000000000000000000) (+ x 10000000)]\n      [(< x 100000000000000000000000000000)\
    \ (+ x 10000000)]\n      [(< x 1000000000000000000000000000000) (+ x 10000000)]\n\
    \      [(< x 10000000000000000000000000000000) (+ x 10000000)]\n      [(< x 100000000000000000000000000000000)\
    \ (+ x 10000000)]\n      [(< x 1000000000000000000000000000000000) (+ x 10000000)]\n\
    \      [(< x 10000000000000000000000000000000000) (+ x 10000000)]\n      [(< x\
    \ 1000000000000000000", "  (let ([x (string->number (car value))\n        y (number->string\
    \ (cdr value))])\n    (cond\n      [(< x y) x]\n      [(< y x) y]\n      [(< (abs\
    \ (- x y)) (abs (- y x)))\n       (+ (floor (/ x y)) (floor (/ y x)))]\n     \
    \ [else (- x y)]))))\n", "  (let ([integers (number->list value)])\n    (let ([closest\
    \ (first integers)])\n      (if (null? integers)\n          closest\n        \
    \  (let ([next (second integers)])\n            (if (> (abs (- closest next))\
    \ (abs (- closest closest)))\n                (closest_integer value)\n      \
    \          (if (< next closest)\n                    (closest_integer value)\n\
    \                    (closest_integer next))))))))\n", "  (let ([x (number->string\
    \ value)]\n        [y (number->string value)])\n    (cond\n      [(equal? x y)\
    \ value]\n      [(equal? x \"-\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"-\") (- 0 (number->integer value))]\n      [(equal? x \"0\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"0\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"1\") (- 0 (number->integer value))]\n      [(equal? y \"1\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"2\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"2\") (- 0 (number->integer value))]\n      [(equal? x \"3\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"3\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"4\") (- 0 (number->integer value))]\n      [(equal? y \"4\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"5\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"5\") (- 0 (number->integer value))]\n      [(equal? x \"6\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"6\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"7\") (- 0 (number->integer value))]\n      [(equal? y \"7\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"8\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"8\") (- 0 (number->integer value))]\n      [(equal? x \"9\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"9\") (- 0 (number->integer value))]\n      [else\
    \ (- 0 (number->integer value))]))))\n", "  (let ([int-value (string->number (value))]\n\
    \        [int-min (string->number ((number->string (- (number->string int-value)\
    \ 1))))]\n        [int-max (string->number ((number->string int-value)))])\n \
    \   (cond\n      [(< int-value int-min) (number->string int-min)]\n      [(< int-value\
    \ int-max) (number->string int-max)]\n      [(> int-value int-min) (number->string\
    \ int-min)]\n      [(> int-value int-max) (number->string int-max)]\n      [else\
    \ (number->string int-value)]))))\n", "  (let ([int-val (string->number value)]\n\
    \        [int-val-diff (- int-val int-val)]\n        [int-val-diff (if (< int-val-diff\
    \ 0) (- int-val-diff) int-val-diff)])\n    (if (< int-val-diff 0)\n        int-val\n\
    \        (ceiling int-val))))\n", "  (let ((x (number->string value)))\n    (if\
    \ (number->string? x)\n        (let ((x (number->string value)))\n          (if\
    \ (number->string? x)\n              (let ((x (number->string value)))\n     \
    \           (if (number->string? x)\n                    (let ((x (number->string\
    \ value)))\n                      (if (number->string? x)\n                  \
    \        (let ((x (number->string value)))\n                            (if (number->string?\
    \ x)\n                                (let ((x (number->string value)))\n    \
    \                              (if (number->string? x)\n                     \
    \                 (let ((x (number->string value)))\n                        \
    \                (if (number->string? x)\n                                   \
    \         (let ((x (number->string value)))\n                                \
    \              (if (number->string? x)\n                                     \
    \             (let ((x (number->string value)))\n                            \
    \                        (if (number->string? x)\n                           \
    \                             (let ((x (number->string value)))\n            \
    \                                              (if (number->string? x)\n     \
    \                                                         (let ((x (number->string\
    \ value)))\n                                                                (if\
    \ (number->string? x)\n                                                      \
    \              (let ((x (number->string value)))\n                           \
    \                                           (if (number->string? x)\n        \
    \                                                                  (let ((x (number->string\
    \ value)))\n                                                                 \
    \           (if (number->string? x)\n                                        \
    \                                        (let ((x (number->string value)))\n \
    \                                                                            \
    \     (if (number->string? x)\n                                              \
    \                                        (let ((x (number->string value)))\n \
    \                                                                            \
    \           (if (number->string? x)\n                                        \
    \                                                    (let ((x (number->string\
    \ value)))\n                                                                 \
    \                             (if (number->string? x)\n                      \
    \                                                                            (let\
    \ ((x (number->string value)))\n                                             \
    \                                                       (if (number->string? x)\n\
    \                                                                            \
    \                            (let ((x (number->string value)))\n             \
    \                                                                            \
    \                 (if (number->string? x)\n                                  \
    \                                                                            (let\
    \ ((x (number->string value)))\n                                             \
    \                                                                   (if (number->string?\
    \ x)\n                                                                       \
    \                                             (let ((x (number->string value)))\n\
    \                                                                            \
    \                                          (if (number->string? x)\n         \
    \                                                                            \
    \                                     (let ((x (number->string value)))\n    \
    \                                                                            \
    \                                            (if (number->string? x)\n       \
    \                                                                            \
    \                                               (let ((x (number->string value)))\n\
    \                                                                            \
    \                                                      (if (number->string? x)\n\
    \                                                                            \
    \                                                                        (let\
    \ ((x (number->string value)))\n                                             \
    \                                                                            \
    \                             (if (number->string? x)\n                      \
    \                                                                            \
    \                                                        (let ((x (number->string\
    \ value)))", "  (let ([num (string->number (car value))])\n    (cond\n      [(<\
    \ num 0) (ceiling num)]\n      [(< num 1) (floor (- num))]\n      [(< num 2) (ceiling\
    \ num)]\n      [(< num 3) (floor (- num))]\n      [(< num 4) (ceiling num)]\n\
    \      [(< num 5) (floor (- num))]\n      [(< num 6) (ceiling num)]\n      [(<\
    \ num 7) (floor (- num))]\n      [(< num 8) (ceiling num)]\n      [(< num 9) (floor\
    \ (- num))]\n      [else (ceiling num)])))\n", "  (let ([integers (map integer?\
    \ #(substring value 0 (string-length value)))])\n    (if (null? integers)\n  \
    \      0\n        (let ([closest (car integers)])\n          (if (< (abs (- value\
    \ closest)) (abs (- value integer)))\n              closest\n              integers)))))\n",
  "  (let ([integers (map number->integer [0 1 2 3 4 5 6 7 8 9])])\n    (let ([closest\
    \ (first integers)])\n      (if (< (abs (- value closest)) (abs (- value integers)))\n\
    \          closest\n          (closest_integer value))))))\n", "  (let ([x (string->number\
    \ (car value))])\n    (cond\n      [(< x 0) (ceiling x)]\n      [(> x 0) (floor\
    \ x)]\n      [else x])))\n", "  (let ([int-value (parse-integer value)]\n    \
    \    [int-diff (- int-value int-value)])\n    (if (= int-diff 0)\n        int-value\n\
    \        (ceiling int-diff))))\n", "  (let ([num (number->string value)]\n   \
    \     [nums (number->list value)]\n        [min (number->string 0)]\n        [max\
    \ (number->string 0)])\n    (if (null? nums)\n        (number->string 0)\n   \
    \     (let ([num (first nums)])\n          (if (< (number->string num) min)\n\
    \              (number->string 0)\n              (let ([num (first nums)])\n \
    \               (if (> (number->string num) max)\n                    (number->string\
    \ 0)\n                    (let ([num (first nums)])\n                      (if\
    \ (< (number->string num) num)\n                          (number->string 0)\n\
    \                          (let ([num (first nums)])\n                       \
    \     (if (> (number->string num) num)\n                                (number->string\
    \ 0)\n                                (let ([num (first nums)])\n            \
    \                      (if (< (number->string num) num)\n                    \
    \                  (number->string 0)\n                                      (let\
    \ ([num (first nums)])\n                                        (if (> (number->string\
    \ num) num)\n                                            (number->string 0)\n\
    \                                            (let ([num (first nums)])\n     \
    \                                         (if (< (number->string num) num)\n \
    \                                                 (number->string 0)\n       \
    \                                           (let ([num (first nums)])\n      \
    \                                              (if (> (number->string num) num)\n\
    \                                                        (number->string 0)\n\
    \                                                        (let ([num (first nums)])\n\
    \                                                          (if (< (number->string\
    \ num) num)\n                                                              (number->string\
    \ 0)\n                                                              (let ([num\
    \ (first nums)])\n                                                           \
    \     (if (> (number->string num) num)\n                                     \
    \                               (number->string 0)\n                         \
    \                                           (let ([num (first nums)])\n      \
    \                                                                (if (< (number->string\
    \ num) num)\n                                                                \
    \          (number->string 0)\n                                              \
    \                            (let ([num (first nums)])\n                     \
    \                                                       (if (> (number->string\
    \ num) num)\n                                                                \
    \                (number->string 0)\n                                        \
    \                                        (let ([num (first nums)])\n         \
    \                                                                         (if\
    \ (< (number->string num) num)\n                                             \
    \                                         (number->string 0)\n               \
    \                                                                       (let ([num\
    \ (first nums)])\n                                                           \
    \                             (if (> (number->string num) num)\n             \
    \                                                                            \
    \   (number->string 0)\n                                                     \
    \                                       (let ([num (first nums)])\n          \
    \                                                                            \
    \        (if (< (number->string num) num)\n                                  \
    \                                                                (number->string\
    \ 0)\n                                                                       \
    \                           (let ([num (first nums)])\n                      \
    \                                                                            \
    \  (if (> (number->string num) num)\n                                        \
    \                                                                (number->string\
    \ 0)\n                                                                       \
    \                                 (", "  (let ([x (string->number (car value))])\n\
    \    (let ([y (string->number (cadr value))])\n      (if (= x y)\n          x\n\
    \          (if (< x y)\n              (ceiling x)\n              (floor x))))))\n",
  "  (let ([integers (map number->integer (string->list value))])\n    (let ([closest\
    \ (first integers)])\n      (if (null? integers)\n          closest\n        \
    \  (let ([diff (- closest first)])\n            (if (< diff (abs (- diff integers)))\n\
    \                (+ closest diff)\n                closest))))))\n", "  (let ([number-str\
    \ (string->number (string->symbol value))])\n    (cond\n      [(< number-str 0)\
    \ (error \"Given value is not a number\")]\n      [(< number-str 1) (error \"\
    Given value is not a number\")]\n      [else (floor (/ number-str 1))]))))\n",
  "  (let ([x (parse-integer (string->symbol (symbol->string value)))])\n    (cond\
    \ [(< x 0) x]\n          [(< x 1) x]\n          [(< x 2) x]\n          [(< x 3)\
    \ x]\n          [(< x 4) x]\n          [(< x 5) x]\n          [(< x 6) x]\n  \
    \        [(< x 7) x]\n          [(< x 8) x]\n          [(< x 9) x]\n         \
    \ [(< x 10) x]\n          [(< x 11) x]\n          [(< x 12) x]\n          [(<\
    \ x 13) x]\n          [(< x 14) x]\n          [(< x 15) x]\n          [(< x 16)\
    \ x]\n          [(< x 17) x]\n          [(< x 18) x]\n          [(< x 19) x]\n\
    \          [(< x 20) x]\n          [(< x 21) x]\n          [(< x 22) x]\n    \
    \      [(< x 23) x]\n          [(< x 24) x]\n          [(< x 25) x]\n        \
    \  [(< x 26) x]\n          [(< x 27) x]\n          [(< x 28) x]\n          [(<\
    \ x 29) x]\n          [(< x 30) x]\n          [(< x 31) x]\n          [(< x 32)\
    \ x]\n          [(< x 33) x]\n          [(< x 34) x]\n          [(< x 35) x]\n\
    \          [(< x 36) x]\n          [(< x 37) x]\n          [(< x 38) x]\n    \
    \      [(< x 39) x]\n          [(< x 40) x]\n          [(< x 41) x]\n        \
    \  [(< x 42) x]\n          [(< x 43) x]\n          [(< x 44) x]\n          [(<\
    \ x 45) x]\n          [(< x 46) x]\n          [(< x 47) x]\n          [(< x 48)\
    \ x]\n          [(< x 49) x]\n          [(< x 50) x]\n          [(< x 51) x]\n\
    \          [(< x 52) x]\n          [(< x 53) x]\n          [(< x 54) x]\n    \
    \      [(< x 55) x]\n          [(< x 56) x]\n          [(< x 57) x]\n        \
    \  [(< x 58) x]\n          [(< x 59) x]\n          [(< x 60) x]\n          [(<\
    \ x 61) x]\n          [(< x ", "  (let ([x (string->number (car value))\n    \
    \    y (number->string (cdr value))])\n    (cond\n      [(< x y) x]\n      [(<\
    \ y x) y]\n      [else (round (/ (- x y) 2))])))\n", "  (let ([num (string->number\
    \ (car value))])\n    (cond\n      [(< num 0) (- 0 (floor (- num)))]\n      [(<\
    \ num 1) (- 0 (floor (- num)))]\n      [else (- 0 (floor (- num)))]\n      )))\n",
  "  (let ([integers (map integer? value)]\n        [min (min integers)]\n       \
    \ [max (max integers)])\n    (if (null? integers)\n        min\n        (let ([closest\
    \ (min (map abs (map - integers [min max]))\n                             (map\
    \ abs (map - integers [max min]))\n                             integers)])\n\
    \          (if (< (abs closest) min)\n              (if (< (abs closest) max)\n\
    \                  closest\n                  (if (< (abs closest) 0)\n      \
    \                (abs closest)\n                      (abs closest)))))\n    \
    \    min)))\n", "  (let ([int-value (string->number (string->symbol value))])\n\
    \    (cond\n      [(< int-value 0) (error \"Given value is not a number\")]\n\
    \      [(< int-value 1) (error \"Given value is not a number\")]\n      [(< int-value\
    \ 2) (error \"Given value is not a number\")]\n      [(< int-value 3) (error \"\
    Given value is not a number\")]\n      [(< int-value 4) (error \"Given value is\
    \ not a number\")]\n      [(< int-value 5) (error \"Given value is not a number\"\
    )]\n      [(< int-value 6) (error \"Given value is not a number\")]\n      [(<\
    \ int-value 7) (error \"Given value is not a number\")]\n      [(< int-value 8)\
    \ (error \"Given value is not a number\")]\n      [(< int-value 9) (error \"Given\
    \ value is not a number\")]\n      [else (round (abs (- int-value 9)))])))\n",
  "  (let ([integers (map number->integer [1 2 3 4 5 6 7 8 9 10])])\n    (let ([closest\
    \ (first integers)])\n      (if (< (abs (- value closest)) (abs (- value integers)))\n\
    \          closest\n          integers))))\n", "  (let ([x (string->number (car\
    \ value))\n        y (+ (string->number (cadr value)) (- x))])\n    (if (< x y)\n\
    \        x\n        y)))\n", "  (let ([x (string->number (car value))])\n    (let\
    \ ([y (string->number (cadr value))])\n      (cond\n        ((< x y) (value->string\
    \ x))\n        ((< y x) (value->string y))\n        (else (value->string (value->number\
    \ ((- x y))))))))\n", "  (let ([integers (map integer->real '(1 2 3 4 5 6 7 8\
    \ 9 10))])\n    (let ([closest (car integers)])\n      (let ([diff (- value closest)])\n\
    \        (cond\n          [(< diff 0) (- closest)]\n          [(< diff 1) (+ closest)]\n\
    \          [(< diff 2) (+ closest)]\n          [(< diff 3) (+ closest)]\n    \
    \      [(< diff 4) (+ closest)]\n          [(< diff 5) (+ closest)]\n        \
    \  [(< diff 6) (+ closest)]\n          [(< diff 7) (+ closest)]\n          [(<\
    \ diff 8) (+ closest)]\n          [(< diff 9) (+ closest)]\n          [(< diff\
    \ 10) (+ closest)]\n          [(< diff 11) (+ closest)]\n          [(< diff 12)\
    \ (+ closest)]\n          [(< diff 13) (+ closest)]\n          [(< diff 14) (+\
    \ closest)]\n          [(< diff 15) (+ closest)]\n          [(< diff 16) (+ closest)]\n\
    \          [(< diff 17) (+ closest)]\n          [(< diff 18) (+ closest)]\n  \
    \        [(< diff 19) (+ closest)]\n          [(< diff 20) (+ closest)]\n    \
    \      [(< diff 21) (+ closest)]\n          [(< diff 22) (+ closest)]\n      \
    \    [(< diff 23) (+ closest)]\n          [(< diff 24) (+ closest)]\n        \
    \  [(< diff 25) (+ closest)]\n          [(< diff 26) (+ closest)]\n          [(<\
    \ diff 27) (+ closest)]\n          [(< diff 28) (+ closest)]\n          [(< diff\
    \ 29) (+ closest)]\n          [(< diff 30) (+ closest)]\n          [(< diff 31)\
    \ (+ closest)]\n          [(< diff 32) (+ closest)]\n          [(< diff 33) (+\
    \ closest)]\n          [(< diff 34) (+ closest)]\n          [(< diff 35) (+ closest)]\n\
    \          [(< diff 36) (+ closest)]\n          [(< diff 37) (+ closest)]\n  \
    \        [(< diff 38) (+ closest)]\n          [(< diff 39) (+ closest)]\n    \
    \      [(< diff 40) (+ closest)]\n          [(< diff 41) (+ closest)]\n      \
    \    [(< diff 42) (+ closest)]\n          [(< diff 43) (+ closest)]\n        \
    \  [(< diff 44) (+ closest)]\n          [(< diff 45) (+ closest)]\n          [(<\
    \ diff ", "  (define (closest-integer-helper value)\n    (cond ((number? value)\
    \ (number->integer value))\n          ((< value 0) (error \"value must be positive\"\
    ))\n          ((< value 1) (error \"value must be positive\"))\n          ((<\
    \ value 2) (error \"value must be positive\"))\n          ((< value 3) (error\
    \ \"value must be positive\"))\n          ((< value 4) (error \"value must be\
    \ positive\"))\n          ((< value 5) (error \"value must be positive\"))\n \
    \         ((< value 6) (error \"value must be positive\"))\n          ((< value\
    \ 7) (error \"value must be positive\"))\n          ((< value 8) (error \"value\
    \ must be positive\"))\n          ((< value 9) (error \"value must be positive\"\
    ))\n          ((< value 10) (error \"value must be positive\"))\n          ((<\
    \ value 11) (error \"value must be positive\"))\n          ((< value 12) (error\
    \ \"value must be positive\"))\n          ((< value 13) (error \"value must be\
    \ positive\"))\n          ((< value 14) (error \"value must be positive\"))\n\
    \          ((< value 15) (error \"value must be positive\"))\n          ((< value\
    \ 16) (error \"value must be positive\"))\n          ((< value 17) (error \"value\
    \ must be positive\"))\n          ((< value 18) (error \"value must be positive\"\
    ))\n          ((< value 19) (error \"value must be positive\"))\n          ((<\
    \ value 20) (error \"value must be positive\"))\n          ((< value 21) (error\
    \ \"value must be positive\"))\n          ((< value 22) (error \"value must be\
    \ positive\"))\n          ((< value 23) (error \"value must be positive\"))\n\
    \          ((< value 24) (error \"value must be positive\"))\n          ((< value\
    \ 25) (error \"value must be positive\"))\n          ((< value 26) (error \"value\
    \ must be positive\"))\n          ((< value 27) (error \"value must be positive\"\
    ))\n          ((< value 28) (error \"value must be positive\"))\n          ((<\
    \ value 29) (error \"value must be positive\"))\n          ((< value 30) (error\
    \ \"value must be positive\"))\n          ((< value 31) (error \"value must be\
    \ positive\"))\n          ((< value 32) (error \"value must be positive\"))\n\
    \          ((< value 33) (error \"value must be positive\"))\n          ((< value\
    \ 34) (error \"value must be positive\"))\n          ((< value 35) (error \"value\
    \ must be positive\"))\n          ((< value 36) (error \"value must be positive\"\
    ))\n          ((< value 37) (error ", "  (let ([integers (number->list value)])\n\
    \    (if (null? integers)\n        0\n        (let ([closest (car integers)])\n\
    \          (if (< (abs (- closest value)) (abs (- value closest)))\n         \
    \     (- closest)\n              closest)))))\n", "  (let ([num (number->string\
    \ value)]\n        [nums (number->list value)]\n        [min (number->string 0)])\n\
    \    (cond\n      [(empty? nums) (number->string 0)]\n      [(number->string=?\
    \ num (first nums)) (number->string (+ (first nums) 1))]\n      [else (number->string\
    \ (min (number->string (first nums)) (number->string (+ (first nums) 1)))]))))\n",
  "  (define (closest-to-zero x y)\n    (if (= x y)\n        x\n        (if (< x y)\n\
    \            (- x)\n            (- y))))\n  (define (closest-to-one x y)\n   \
    \ (if (= x y)\n        x\n        (if (< x y)\n            (+ x)\n           \
    \ (+ y))))\n  (define (closest-to-two x y)\n    (if (= x y)\n        x\n     \
    \   (if (< x y)\n            (- x)\n            (- y))))\n  (define (closest-to-three\
    \ x y)\n    (if (= x y)\n        x\n        (if (< x y)\n            (+ x)\n \
    \           (+ y))))\n  (define (closest-to-four x y)\n    (if (= x y)\n     \
    \   x\n        (if (< x y)\n            (- x)\n            (- y))))\n  (define\
    \ (closest-to-five x y)\n    (if (= x y)\n        x\n        (if (< x y)\n   \
    \         (+ x)\n            (+ y))))\n  (define (closest-to-six x y)\n    (if\
    \ (= x y)\n        x\n        (if (< x y)\n            (- x)\n            (- y))))\n\
    \  (define (closest-to-seven x y)\n    (if (= x y)\n        x\n        (if (<\
    \ x y)\n            (+ x)\n            (+ y))))\n  (define (closest-to-eight x\
    \ y)\n    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n   \
    \         (- y))))\n  (define (closest-to-nine x y)\n    (if (= x y)\n       \
    \ x\n        (if (< x y)\n            (+ x)\n            (+ y))))\n  (define (closest-to-tens\
    \ x y)\n    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n \
    \           (- y))))\n  (define (closest-to-twenty x y)\n    (if (= x y)\n   \
    \     x\n        (if (< x y)\n            (+ x)\n            (+ y))))\n  (define\
    \ (closest-to-thirtys x y)\n    (if (= x y)\n        x\n        (if (< x y)\n\
    \            (- x)\n            (- y))))\n  (define (closest-to-fortys x y)\n\
    \    (if (= x y)\n        x\n        (if (< x y)\n            (+ x)\n        \
    \    (+ y))))\n  (define (closest-to-fiftys x y)\n    (if (= x y)\n        x\n\
    \        (if (< x y)\n            (- x)\n            (- y))))\n  (define (closest-to-sixtys\
    \ x y)\n    (if (= x y)\n        x\n        (if (< x ", "  (let ([num (number->string\
    \ value)]\n        [nums (number->list value)]\n        [min (number->string 0)])\n\
    \    (cond\n      [(empty? nums) (number->string 0)]\n      [(number->string=?\
    \ num (first nums)) (number->string (first nums))]\n      [(number->string=? num\
    \ (second nums)) (number->string (second nums))]\n      [(number->string=? num\
    \ (third nums)) (number->string (third nums))]\n      [(number->string=? num (fourth\
    \ nums)) (number->string (fourth nums))]\n      [(number->string=? num (fifth\
    \ nums)) (number->string (fifth nums))]\n      [(number->string=? num (sixth nums))\
    \ (number->string (sixth nums))]\n      [(number->string=? num (seventh nums))\
    \ (number->string (seventh nums))]\n      [(number->string=? num (eighth nums))\
    \ (number->string (eighth nums))]\n      [(number->string=? num (ninth nums))\
    \ (number->string (ninth nums))]\n      [(number->string=? num (tenth nums)) (number->string\
    \ (tenth nums))]\n      [(number->string=? num (eleventh nums)) (number->string\
    \ (eleventh nums))]\n      [(number->string=? num (twelfth nums)) (number->string\
    \ (twelfth nums))]\n      [(number->string=? num (thirteenth nums)) (number->string\
    \ (thirteenth nums))]\n      [(number->string=? num (fourteenth nums)) (number->string\
    \ (fourteenth nums))]\n      [(number->string=? num (fifteenth nums)) (number->string\
    \ (fifteenth nums))]\n      [(number->string=? num (sixteenth nums)) (number->string\
    \ (sixteenth nums))]\n      [(number->string=? num (seventeenth nums)) (number->string\
    \ (seventeenth nums))]\n      [(number->string=? num (eighteenth nums)) (number->string\
    \ (eighteenth nums))]\n      [(number->string=? num (nineteenth nums)) (number->string\
    \ (nineteenth nums))]\n      [(number->", "  (define (closest-integer-helper value\
    \ min max)\n    (cond ((< value min) (min value))\n          ((> value max) (max\
    \ value))\n          ((= value min) (min value))\n          ((= value max) (max\
    \ value))\n          ((< min value) (min value))\n          ((> max value) (max\
    \ value))\n          (else (closest-integer-helper (- value min) (min value) (max\
    \ value))))\n  (closest-integer-helper value 0 1))\n", "  (let ([x (string->number\
    \ (car value))])\n    (let ([y (string->number (cadr value))])\n      (if (= x\
    \ y)\n          x\n          (if (< x y)\n              (ceiling x)\n        \
    \      (floor x))))))\n", "  (define (closest-integer x y)\n    (cond ((= x y)\
    \ x)\n          ((= (abs (- x y)) (/ x y)) (+ x y))\n          (else (closest-integer\
    \ (+ x 1) y))))\n  (closest-integer 0 value))\n", "  (let ([x (string->number\
    \ (car value))])\n    (let ([y (string->number (cadr value))])\n      (if (and\
    \ (number? x) (number? y))\n          (if (= x y)\n              x\n         \
    \     (if (< (abs (- x y)) (abs x))\n                  (- x)\n               \
    \   (- y)))))\n      (if (< (abs (- x y)) (abs x))\n          (- x)\n        \
    \  (- y))))))\n", "  (let ([x (string->number (car value))])\n    (let ([y (string->number\
    \ (cadr value))])\n      (if (and (number? x) (number? y))\n          (if (< (abs\
    \ (- x y)) 1)\n              (ceiling x)\n              (floor x))\n         \
    \ (if (< (abs (- x y)) 1)\n              (ceiling y)\n              (floor y)))))))\n",
  "  (define (closest-to-zero x y)\n    (if (= x y)\n        x\n        (if (< (abs\
    \ (- x y)) 1.5)\n            (- x)\n            (- y))))\n  (define (closest-to-one\
    \ x y)\n    (if (= x y)\n        x\n        (if (< (abs (- x y)) 1.5)\n      \
    \      (- x)\n            (- y))))\n  (define (closest-to-two x y)\n    (if (=\
    \ x y)\n        x\n        (if (< (abs (- x y)) 1.5)\n            (- x)\n    \
    \        (- y))))\n  (define (closest-to-three x y)\n    (if (= x y)\n       \
    \ x\n        (if (< (abs (- x y)) 1.5)\n            (- x)\n            (- y))))\n\
    \  (define (closest-to-four x y)\n    (if (= x y)\n        x\n        (if (< (abs\
    \ (- x y)) 1.5)\n            (- x)\n            (- y))))\n  (define (closest-to-five\
    \ x y)\n    (if (= x y)\n        x\n        (if (< (abs (- x y)) 1.5)\n      \
    \      (- x)\n            (- y))))\n  (define (closest-to-six x y)\n    (if (=\
    \ x y)\n        x\n        (if (< (abs (- x y)) 1.5)\n            (- x)\n    \
    \        (- y))))\n  (define (closest-to-seven x y)\n    (if (= x y)\n       \
    \ x\n        (if (< (abs (- x y)) 1.5)\n            (- x)\n            (- y))))\n\
    \  (define (closest-to-eight x y)\n    (if (= x y)\n        x\n        (if (<\
    \ (abs (- x y)) 1.5)\n            (- x)\n            (- y))))\n  (define (closest-to-nine\
    \ x y)\n    (if (= x y)\n        x\n        (if (< (abs (- x y)) 1.5)\n      \
    \      (- x)\n            (- y))))\n  (define (closest-to-tens x y)\n    (if (=\
    \ x y)\n        x\n        (if (< (abs (- x y)) 1.5)\n            (- x)\n    \
    \        (- y))))\n  (define (closest-to-tens x y)\n    (if (= x y)\n        x\n\
    \        (if (< (abs (- x y)) 1.5)\n            (- x)\n            (- y))))\n\
    \  (define (closest-to-tens x y)\n    (if (= x y)\n        x\n        (if (< (abs\
    \ (- x y)) 1.5)\n            (- x)\n            (- y))))\n  (define (closest-to-tens\
    \ x y)\n    (if (= x ", "  (let ([integers (map integer->real '(1 2 3 4 5 6 7\
    \ 8 9 10))])\n    (let ([closest-integer (first integers)])\n      (if (< (abs\
    \ (- value closest-integer)) (abs (- value integer)))\n          closest-integer\n\
    \          (first integers)))))\n", "  (let ([integers (number->list value)]\n\
    \        [integer (first integers)])\n    (if (null? integers)\n        0\n  \
    \      (let ([closest (first integers)])\n          (if (< (abs (- value closest))\
    \ (abs (- value integer)))\n              closest\n              integer))))))\n",
  "  (let ([integers (map number->integer [1 2 3 4 5 6 7 8 9 10])])\n    (let ([closest\
    \ (first integers)])\n      (if (< (abs (- value closest)) (abs (- value integers)))\n\
    \          closest\n          (closest_integer value))))))\n", "  (let ([integer\
    \ (parse-integer value)]\n        [integers (list integer)]\n        [closest\
    \ (first integers)])\n    (if (null? integers)\n        integer\n        (let\
    \ ([closest ((min integers) (max integers))])\n          (if (= (abs (- value\
    \ closest)) (abs (- value integer)))\n              (closest_integer value)\n\
    \              closest))))))\n", "  (define (closest-to-zero x y)\n    (if (=\
    \ x y)\n        x\n        (if (< x y)\n            (- x)\n            (+ x))))\n\
    \  (define (closest-to-one x y)\n    (if (= x y)\n        x\n        (if (< x\
    \ y)\n            (- x)\n            (+ x))))\n  (define (closest-to-two x y)\n\
    \    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n        \
    \    (+ x))))\n  (define (closest-to-three x y)\n    (if (= x y)\n        x\n\
    \        (if (< x y)\n            (- x)\n            (+ x))))\n  (define (closest-to-four\
    \ x y)\n    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n \
    \           (+ x))))\n  (define (closest-to-five x y)\n    (if (= x y)\n     \
    \   x\n        (if (< x y)\n            (- x)\n            (+ x))))\n  (define\
    \ (closest-to-six x y)\n    (if (= x y)\n        x\n        (if (< x y)\n    \
    \        (- x)\n            (+ x))))\n  (define (closest-to-seven x y)\n    (if\
    \ (= x y)\n        x\n        (if (< x y)\n            (- x)\n            (+ x))))\n\
    \  (define (closest-to-eight x y)\n    (if (= x y)\n        x\n        (if (<\
    \ x y)\n            (- x)\n            (+ x))))\n  (define (closest-to-nine x\
    \ y)\n    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n   \
    \         (+ x))))\n  (define (closest-to-tens x y)\n    (if (= x y)\n       \
    \ x\n        (if (< x y)\n            (- x)\n            (+ x))))\n  (define (closest-to-tens\
    \ x y)\n    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n \
    \           (+ x))))\n  (define (closest-to-tens x y)\n    (if (= x y)\n     \
    \   x\n        (if (< x y)\n            (- x)\n            (+ x))))\n  (define\
    \ (closest-to-tens x y)\n    (if (= x y)\n        x\n        (if (< x y)\n   \
    \         (- x)\n            (+ x))))\n  (define (closest-to-tens x y)\n    (if\
    \ (= x y)\n        x\n        (if (< x y)\n            (- x)\n            (+ x))))\n\
    \  (define (closest-to-tens x y)\n    (if (= x y)\n        x\n        (if (< x\
    \ y)\n            (- x)\n", "  (let ([number-as-string (number->string value)])\n\
    \    (if (number-as-string \"0\")\n        (number->string 0)\n        (let ([number-as-string\
    \ (number->string value)])\n          (if (number-as-string \"-\")\n         \
    \     (number->string 0)\n              (let ([number-as-string (number->string\
    \ value)])\n                (if (number-as-string \".\")\n                   \
    \ (number->string 0)\n                    (let ([number-as-string (number->string\
    \ value)])\n                      (if (number-as-string \"-\")\n             \
    \             (number->string 0)\n                          (let ([number-as-string\
    \ (number->string value)])\n                            (if (number-as-string\
    \ \"0\")\n                                (number->string 0)\n               \
    \                 (let ([number-as-string (number->string value)])\n         \
    \                         (if (number-as-string \"\")\n                      \
    \                (number->string 0)\n                                      (let\
    \ ([number-as-string (number->string value)])\n                              \
    \          (if (number-as-string \"\")\n                                     \
    \       (number->string 0)\n                                            (let ([number-as-string\
    \ (number->string value)])\n                                              (if\
    \ (number-as-string \"\")\n                                                  (number->string\
    \ 0)\n                                                  (let ([number-as-string\
    \ (number->string value)])\n                                                 \
    \   (if (number-as-string \"\")\n                                            \
    \            (number->string 0)\n                                            \
    \            (let ([number-as-string (number->string value)])\n              \
    \                                            (if (number-as-string \"\")\n   \
    \                                                           (number->string 0)\n\
    \                                                              (let ([number-as-string\
    \ (number->string value)])\n                                                 \
    \               (if (number-as-string \"\")\n                                \
    \                                    (number->string 0)\n                    \
    \                                                (let ([number-as-string (number->string\
    \ value)])\n                                                                 \
    \     (if (number-as-string \"\")\n                                          \
    \                                (number->string 0)\n                        \
    \                                                  (let ([number-as-string (number->string\
    \ value)])\n                                                                 \
    \           (if (number-as-string \"\")\n                                    \
    \                                            (number->string 0)\n            \
    \                                                                    (let ([number-as-string\
    \ (number->string value)])\n                                                 \
    \                                 (if (number-as-string \"\")\n              \
    \                                                                        (number->string\
    \ 0)\n                                                                       \
    \               (let ([number-as-string (number->string value)])\n           \
    \                                                                            \
    \ (if (number-as-string \"\")\n                                              \
    \                                              (number->string 0)\n          \
    \                                                                            \
    \      (let ([number-as-string (number->string value)])\n                    \
    \                                                                          (if\
    \ (number-as-string \"\")\n                                                  \
    \                                                (number->string 0)\n        \
    \                                                                            \
    \              (let ([number-as-string (number->string value)])\n            \
    \                                                                            \
    \            (if (number-as-string \"\")\n", "  (let ([num (parse-integer value)]\n\
    \        [min (parse-integer \"0\")]\n        [max (parse-integer \"9\")])\n \
    \   (cond\n      [(< num max) (parse-integer \"0\")]\n      [(< num min) (parse-integer\
    \ \"9\")]\n      [(= num min) (parse-integer \"0\")]\n      [(= num max) (parse-integer\
    \ \"9\")]\n      [else (+ num 1)]))))\n", "  (let ([num (string->number (car value))])\n\
    \    (cond\n      [(< num 0) (error \"Invalid input: number must be positive.\"\
    )]\n      [(< num 1) (error \"Invalid input: number must be positive.\")]\n  \
    \    [(< num 2) (error \"Invalid input: number must be positive.\")]\n      [(<\
    \ num 3) (error \"Invalid input: number must be positive.\")]\n      [(< num 4)\
    \ (error \"Invalid input: number must be positive.\")]\n      [(< num 5) (error\
    \ \"Invalid input: number must be positive.\")]\n      [(< num 6) (error \"Invalid\
    \ input: number must be positive.\")]\n      [(< num 7) (error \"Invalid input:\
    \ number must be positive.\")]\n      [(< num 8) (error \"Invalid input: number\
    \ must be positive.\")]\n      [(< num 9) (error \"Invalid input: number must\
    \ be positive.\")]\n      [(< num 10) (error \"Invalid input: number must be positive.\"\
    )]\n      [(< num 11) (error \"Invalid input: number must be positive.\")]\n \
    \     [(< num 12) (error \"Invalid input: number must be positive.\")]\n     \
    \ [(< num 13) (error \"Invalid input: number must be positive.\")]\n      [(<\
    \ num 14) (error \"Invalid input: number must be positive.\")]\n      [(< num\
    \ 15) (error \"Invalid input: number must be positive.\")]\n      [(< num 16)\
    \ (error \"Invalid input: number must be positive.\")]\n      [(< num 17) (error\
    \ \"Invalid input: number must be positive.\")]\n      [(< num 18) (error \"Invalid\
    \ input: number must be positive.\")]\n      [(< num 19) (error \"Invalid input:\
    \ number must be positive.\")]\n      [(< num 20) (error \"Invalid input: number\
    \ must be positive.\")]\n      [(< num 21) (error \"Invalid input: number must\
    \ be positive.\")]\n      [(< num 22) (error \"Invalid input: number must be positive.\"\
    )]\n      [(< num 23) (error \"Invalid input: number must be positive.\")]\n \
    \     [(< num 24) (error \"Invalid input: number must be positive.\")]\n     \
    \ [(< num 25) (error \"Invalid input: number must be positive.\")]\n      [(<\
    \ num 26) (error \"Invalid input: number must be positive.\")]\n      [(< num\
    \ 27) (error \"Invalid input: number must be positive.\")]\n      [(< num 28)\
    \ (error \"Invalid input: number must be positive.\")]\n      [(", "  (let ([x\
    \ (number->string value)]\n        [y (number->string value)])\n    (if (equal?\
    \ x y)\n        value\n        (let ([x (number->string value)]\n            \
    \  [y (number->string value)])\n          (if (equal? x y)\n              value\n\
    \              (let ([x (number->string value)]\n                    [(+ (string->number\
    \ x) (string->number y)) (string->number value)])))))))\n", "  (let ([x (number->string\
    \ value)]\n        [y (number->string value)])\n    (cond\n      [(equal? x y)\
    \ value]\n      [(equal? x \"-\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"-\") (- 0 (number->integer value))]\n      [else (- 0 (number->integer value))]))))\n",
  "  (let ([integers (map integer->real '(1 2 3 4 5 6 7 8 9 10))])\n    (let ([closest\
    \ (min (map abs (- value integers))\n                         (map abs (- integers\
    \ value)))])\n      (if (< closest 0)\n          (ceiling value)\n          (floor\
    \ value))))\n", "  (let ([x (number->string value)]\n        [y (number->string\
    \ value)])\n    (cond\n      [(empty? x) 0]\n      [(empty? y) x]\n      [(< (string->number\
    \ x) (string->number y)) (string->number x)]\n      [(< (string->number y) (string->number\
    \ x)) (string->number y)]\n      [else (closest_integer (string->number x))])))\n",
  "  (define (closest-integer-helper value low-bound high-bound)\n    (cond ((< value\
    \ low-bound)\n           (if (< (- value high-bound) low-bound)\n            \
    \   (- low-bound)\n               (- high-bound)))\n          ((< value high-bound)\n\
    \           (if (< (- value low-bound) high-bound)\n               (- low-bound)\n\
    \               (- high-bound)))\n          (else\n           (if (< (- value\
    \ low-bound) high-bound)\n               (- low-bound)\n               (- high-bound))))\n\
    \    (closest-integer-helper value low-bound (- high-bound))))\n", "  (let ([x\
    \ (string->number (car value))])\n    (let ([y (string->number (car value))])\n\
    \      (if (= x y)\n          x\n          (if (< (abs (- x y)) (abs (- y x)))\n\
    \              (ceil (/ x y))\n              (floor (/ y x))))))))\n", "  (define\
    \ (closest-to-zero x y)\n    (if (= x y)\n        x\n        (if (< x y)\n   \
    \         (- x)\n            (+ x))))\n  (define (closest-to-one x y)\n    (if\
    \ (= x y)\n        x\n        (if (< x y)\n            (- x)\n            (+ x))))\n\
    \  (define (closest-to-two x y)\n    (if (= x y)\n        x\n        (if (< x\
    \ y)\n            (- x)\n            (+ x))))\n  (define (closest-to-three x y)\n\
    \    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n        \
    \    (+ x))))\n  (define (closest-to-four x y)\n    (if (= x y)\n        x\n \
    \       (if (< x y)\n            (- x)\n            (+ x))))\n  (define (closest-to-five\
    \ x y)\n    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n \
    \           (+ x))))\n  (define (closest-to-six x y)\n    (if (= x y)\n      \
    \  x\n        (if (< x y)\n            (- x)\n            (+ x))))\n  (define\
    \ (closest-to-seven x y)\n    (if (= x y)\n        x\n        (if (< x y)\n  \
    \          (- x)\n            (+ x))))\n  (define (closest-to-eight x y)\n   \
    \ (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n           \
    \ (+ x))))\n  (define (closest-to-nine x y)\n    (if (= x y)\n        x\n    \
    \    (if (< x y)\n            (- x)\n            (+ x))))\n  (define (closest-to-tens\
    \ x y)\n    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n \
    \           (+ x))))\n  (define (closest-to-tens x y)\n    (if (= x y)\n     \
    \   x\n        (if (< x y)\n            (- x)\n            (+ x))))\n  (define\
    \ (closest-to-tens x y)\n    (if (= x y)\n        x\n        (if (< x y)\n   \
    \         (- x)\n            (+ x))))\n  (define (closest-to-tens x y)\n    (if\
    \ (= x y)\n        x\n        (if (< x y)\n            (- x)\n            (+ x))))\n\
    \  (define (closest-to-tens x y)\n    (if (= x y)\n        x\n        (if (< x\
    \ y)\n            (- x)\n            (+ x))))\n  (define (closest-to-tens x y)\n\
    \    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n", "  (let\
    \ ((integer (parse-integer value)))\n    (let ((diff (- integer (floor (/ integer\
    \ 10))))\n          (closest (floor (/ integer 10))))\n      (if (< diff 0)\n\
    \          (- closest)\n          closest))))\n", "  (let ([numbers (number->string\
    \ value)]\n        [integers (number->string 0)])\n    (cond\n      [(empty? numbers)\
    \ 0]\n      [(empty? integers) 0]\n      [(equal? (first integers) (first numbers))\
    \ (second integers)]\n      [else (let ([closest (first integers)])\n        \
    \      (cond\n               [(equal? (first integers) (first numbers)) (second\
    \ integers)]\n               [(equal? (first integers) (second numbers)) (second\
    \ integers)]\n               [(equal? (first integers) (third numbers)) (second\
    \ integers)]\n               [(equal? (first integers) (fourth numbers)) (second\
    \ integers)]\n               [(equal? (first integers) (fifth numbers)) (second\
    \ integers)]\n               [(equal? (first integers) (sixth numbers)) (second\
    \ integers)]\n               [(equal? (first integers) (seventh numbers)) (second\
    \ integers)]\n               [(equal? (first integers) (eighth numbers)) (second\
    \ integers)]\n               [(equal? (first integers) (ninth numbers)) (second\
    \ integers)]\n               [(equal? (first integers) (tenth numbers)) (second\
    \ integers)]\n               [(equal? (first integers) (eleventh numbers)) (second\
    \ integers)]\n               [(equal? (first integers) (twelfth numbers)) (second\
    \ integers)]\n               [(equal? (first integers) (thirteenth numbers)) (second\
    \ integers)]\n               [(equal? (first integers) (fourteenth numbers)) (second\
    \ integers)]\n               [(equal? (first integers) (fifteenth numbers)) (second\
    \ integers)]\n               [(equal? (first integers) (sixteenth numbers)) (second\
    \ integers)]\n               [(equal? (first integers) (seventeenth numbers))\
    \ (second integers)]\n               [(equal? (first integers) (eighteenth numbers))\
    \ (second integers)]\n               [(equal? (first integers) (nineteenth numbers))\
    \ (second integers)]\n               [(equal? (first integers) (twentieth numbers))\
    \ (second integers)]\n               [(equal? (first integers) (twenty-first numbers))\
    \ (second integers)]\n               [(equal? (first integers) (thirty-first numbers))\
    \ (second integers)]\n               [(equal? (first integers) (forty-first numbers))\
    \ (second integers)]\n               [(equal? (first integers) (fifty-first numbers))\
    \ (second integers)]\n               [(equal? (first integers) (sixty-first numbers))\
    \ (", "  (let ([num (number->string value)])\n    (cond [(number->string->number\
    \ num) value]\n          [(number->string->number num) (number->string->number\
    \ (string->number num))]\n          [else (number->string->number (string->number\
    \ (string->number num)))])))\n", "  (let ([number-str (string->number (string->symbol\
    \ value))])\n    (cond\n      [(number-str (< number-str (- number-str 1))) (-\
    \ number-str 1)]\n      [(number-str (< number-str (- number-str 1))) (- number-str\
    \ 1)]\n      [else number-str])))\n", "  (let ([integers (map number->integer\
    \ (string->list value))])\n    (let ([min (first integers)])\n      (let ([max\
    \ (second integers)])\n        (if (< min max)\n            (ceiling min)\n  \
    \          (floor min)))))\n", "  (let ([x (string->number (car value))])\n  \
    \  (let ([y (string->number (cadr value))])\n      (cond\n        ((< x y) x)\n\
    \        ((< y x) y)\n        (else (round (/ (- x y) 2))))))))\n", "  (let ([x\
    \ (number->string value)]\n        [y (number->string value)])\n    (cond\n  \
    \    [(equal? x y) value]\n      [(equal? x \"-\") (- 0 (number->integer value))]\n\
    \      [(equal? y \"-\") (- 0 (number->integer value))]\n      [else (- 0 (number->integer\
    \ value))]))))\n", "  (define (closest-integer x y)\n    (if (= x y)\n       \
    \ x\n        (if (< (abs (- x y)) (abs (- y x)))\n            (- x y)\n      \
    \      (- y x))))\n  (closest-integer (string->number (value)) (string->number\
    \ (value))))\n", "  (let ([numbers (number->list value)]\n        [min (first\
    \ numbers)]\n        [max (rest numbers)])\n    (cond\n      [(empty? numbers)\
    \ value]\n      [(< (first numbers) min) min]\n      [(> (first numbers) max)\
    \ max]\n      [else (let ([closest (+ (first numbers) (/ (first numbers) (first\
    \ numbers)))])\n              (cond\n                [(< closest min) min]\n \
    \               [(> closest max) max]\n                [else closest])]\n    \
    \  )))\n", "  (let ([num (number->string value)]\n        [nums (number->list\
    \ value)]\n        [min (number->string 0)]\n        [max (number->string 0)])\n\
    \    (if (null? nums)\n        (number->string 0)\n        (let ([num (first nums)])\n\
    \          (if (< (number->string num) min)\n              (number->string 0)\n\
    \              (let ([num (first nums)])\n                (if (> (number->string\
    \ num) max)\n                    (number->string 0)\n                    (let\
    \ ([num (first nums)])\n                      (if (< (number->string num) num)\n\
    \                          (number->string 0)\n                          (let\
    \ ([num (first nums)])\n                            (if (> (number->string num)\
    \ num)\n                                (number->string 0)\n                 \
    \               (let ([num (first nums)])\n                                  (if\
    \ (< (number->string num) num)\n                                      (number->string\
    \ 0)\n                                      (let ([num (first nums)])\n      \
    \                                  (if (> (number->string num) num)\n        \
    \                                    (number->string 0)\n                    \
    \                        (let ([num (first nums)])\n                         \
    \                     (if (< (number->string num) num)\n                     \
    \                             (number->string 0)\n                           \
    \                       (let ([num (first nums)])\n                          \
    \                          (if (> (number->string num) num)\n                \
    \                                        (number->string 0)\n                \
    \                                        (let ([num (first nums)])\n         \
    \                                                 (if (< (number->string num)\
    \ num)\n                                                              (number->string\
    \ 0)\n                                                              (let ([num\
    \ (first nums)])\n                                                           \
    \     (if (> (number->string num) num)\n                                     \
    \                               (number->string 0)\n                         \
    \                                           (let ([num (first nums)])\n      \
    \                                                                (if (< (number->string\
    \ num) num)\n                                                                \
    \          (number->string 0)\n                                              \
    \                            (let ([num (first nums)])\n                     \
    \                                                       (if (> (number->string\
    \ num) num)\n                                                                \
    \                (number->string 0)\n                                        \
    \                                        (let ([num (first nums)])\n         \
    \                                                                         (if\
    \ (< (number->string num) num)\n                                             \
    \                                         (number->string 0)\n               \
    \                                                                       (let ([num\
    \ (first nums)])\n                                                           \
    \                             (if (> (number->string num) num)\n             \
    \                                                                            \
    \   (number->string 0)\n                                                     \
    \                                       (let ([num (first nums)])\n          \
    \                                                                            \
    \        (if (< (number->string num) num)\n                                  \
    \                                                                (number->string\
    \ 0)\n                                                                       \
    \                           (let ([num (first nums)])\n                      \
    \                                                                            \
    \  (if (> (number->string num) num)\n                                        \
    \                                                                (number->string\
    \ 0)\n                                                                       \
    \                                 (", "  (let ([int-value (string->number (string->symbol\
    \ value))])\n    (cond [(< int-value 0)\n           (error \"The given value is\
    \ not a number\")\n           (error \"The given value is not a number\")\n  \
    \         (error \"The given value is not a number\")\n           (error \"The\
    \ given value is not a number\")\n           (error \"The given value is not a\
    \ number\")\n           (error \"The given value is not a number\")\n        \
    \   (error \"The given value is not a number\")\n           (error \"The given\
    \ value is not a number\")\n           (error \"The given value is not a number\"\
    )\n           (error \"The given value is not a number\")\n           (error \"\
    The given value is not a number\")\n           (error \"The given value is not\
    \ a number\")\n           (error \"The given value is not a number\")\n      \
    \     (error \"The given value is not a number\")\n           (error \"The given\
    \ value is not a number\")\n           (error \"The given value is not a number\"\
    )\n           (error \"The given value is not a number\")\n           (error \"\
    The given value is not a number\")\n           (error \"The given value is not\
    \ a number\")\n           (error \"The given value is not a number\")\n      \
    \     (error \"The given value is not a number\")\n           (error \"The given\
    \ value is not a number\")\n           (error \"The given value is not a number\"\
    )\n           (error \"The given value is not a number\")\n           (error \"\
    The given value is not a number\")\n           (error \"The given value is not\
    \ a number\")\n           (error \"The given value is not a number\")\n      \
    \     (error \"The given value is not a number\")\n           (error \"The given\
    \ value is not a number\")\n           (error \"The given value is not a number\"\
    )\n           (error \"The given value is not a number\")\n           (error \"\
    The given value is not a number\")\n           (error \"The given value is not\
    \ a number\")\n           (error \"The given value is not a number\")\n      \
    \     (error \"The given value is not a number\")\n           (error \"The given\
    \ value is not a number\")\n           (error \"The given value is not a number\"\
    )\n           (error \"The given value is not a number\")\n           (error \"\
    The given value is not a number\")\n           (error \"The given value is not\
    \ a number\")\n           (error \"The given value is not a number\")\n      \
    \     (error \"The given value is not a number\")\n           (error \"The given\
    \ value is not a number\")\n           (error \"The given value is not a number\"\
    )\n           (error \"The given value is not a number\")\n           (error \"\
    The given value is not a number\")\n           (error \"The given value is not\
    \ a number\")\n           (error \"The given value is not a number\")\n      \
    \     (error \"The given value is not a ", "  (let ([integers (map number->integer\
    \ [1 2 3 4 5 6 7 8 9 10])])\n    (let ([closest (first integers)])\n      (let\
    \ ([closest-distance (abs (- value closest))])\n        (if (< closest-distance\
    \ (first integers))\n            (first integers)\n            (if (< closest-distance\
    \ (second integers))\n                (second integers)\n                (if (<\
    \ closest-distance (third integers))\n                    (third integers)\n \
    \                   (if (< closest-distance (fourth integers))\n             \
    \           (fourth integers)\n                        (if (< closest-distance\
    \ (fifth integers))\n                            (fifth integers)\n          \
    \                  (if (< closest-distance (sixth integers))\n               \
    \                 (sixth integers)\n                                (if (< closest-distance\
    \ (seventh integers))\n                                    (seventh integers)\n\
    \                                    (if (< closest-distance (eighth integers))\n\
    \                                        (eighth integers)\n                 \
    \                       (if (< closest-distance (ninth integers))\n          \
    \                                  (ninth integers)\n                        \
    \                    closest))))))))))))))\n", "  (let ([integers (string->list\
    \ value)])\n    (let ([min (first integers)])\n      (let ([max (rest integers)])\n\
    \        (if (< min max)\n            (ceiling value)\n            (floor value))))))\n",
  "  (let ([int-value (string->number (value))]\n        [int-min (floor (abs (- int-value\
    \ int-value))) ]\n        [int-max (ceiling (abs (- int-value int-value))) ]\n\
    \        [int-diff (- int-min int-max) ]\n        [int-diff (- int-min int-max)\
    \ ]\n        [int-diff (- int-min int-max) ]\n        [int-diff (- int-min int-max)\
    \ ]\n        [int-diff (- int-min int-max) ]\n        [int-diff (- int-min int-max)\
    \ ]\n        [int-diff (- int-min int-max) ]\n        [int-diff (- int-min int-max)\
    \ ]\n        [int-diff (- int-min int-max) ]\n        [int-diff (- int-min int-max)\
    \ ]\n        [int-diff (- int-min int-max) ]\n        [int-diff (- int-min int-max)\
    \ ]\n        [int-diff (- int-min int-max) ]\n        [int-diff (- int-min int-max)\
    \ ]\n        [int-diff (- int-min int-max) ]\n        [int-diff (- int-min int-max)\
    \ ]\n        [int-diff (- int-min int-max) ]\n        [int-diff (- int-min int-max)\
    \ ]\n        [int-diff (- int-min int-max) ]\n        [int-diff (- int-min int-max)\
    \ ]\n        [int-diff (- int-min int-max) ]\n        [int-diff (- int-min int-max)\
    \ ]\n        [int-diff (- int-min int-max) ]\n        [int-diff (- int-min int-max)\
    \ ]\n        [int-diff (- int-min int-max) ]\n        [int-diff (- int-min int-max)\
    \ ]\n        [int-diff (- int-min int-max) ]\n        [int-diff (- int-min int-max)\
    \ ]\n        [int-diff (- int-min int-max) ]\n        [int-diff (- int-min int-max)\
    \ ]\n        [int-diff (- int-min int-max", "  (define (closest-integer-helper\
    \ value min max)\n    (cond ((< value max) (+ min 1))\n          ((< value min)\
    \ (+ max 1))\n          ((= value min) (+ min 1))\n          ((= value max) (+\
    \ max 1))\n          (else (closest-integer-helper value (+ min 1) (+ max 1)))))\n\
    \  (closest-integer-helper value 0 1))\n", "  (let ([integers (map integer->real\
    \ '(1 2 3 4 5 6 7 8 9 10))])\n    (let ([closest (first integers)])\n      (if\
    \ (< (abs (- value closest)) (abs (- value (car integers))))\n          (first\
    \ integers)\n          (first integers)))))\n", "  (let ([num (parse-integer (string->symbol\
    \ value))]\n        [min (parse-integer (string->symbol value))])\n    (cond [(<\
    \ num min) (parse-integer (string->symbol value))]\n          [(= num min) (parse-integer\
    \ (string->symbol value))]\n          [(< num 0) (parse-integer (string->symbol\
    \ value))]\n          [(> num 0) (parse-integer (string->symbol value))]\n   \
    \       [(< num max) (parse-integer (string->symbol value))]\n          [(> num\
    \ max) (parse-integer (string->symbol value))]\n          [else (parse-integer\
    \ (string->symbol value))]))))\n", "  (define (closest-to-zero x y)\n    (if (=\
    \ x y)\n        x\n        (if (< x y)\n            (- x)\n            (+ x))))\n\
    \  (define (closest-to-one x y)\n    (if (= x y)\n        x\n        (if (< x\
    \ y)\n            (- x)\n            (+ x))))\n  (define (closest-to-two x y)\n\
    \    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n        \
    \    (+ x))))\n  (define (closest-to-three x y)\n    (if (= x y)\n        x\n\
    \        (if (< x y)\n            (- x)\n            (+ x))))\n  (define (closest-to-four\
    \ x y)\n    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n \
    \           (+ x))))\n  (define (closest-to-five x y)\n    (if (= x y)\n     \
    \   x\n        (if (< x y)\n            (- x)\n            (+ x))))\n  (define\
    \ (closest-to-six x y)\n    (if (= x y)\n        x\n        (if (< x y)\n    \
    \        (- x)\n            (+ x))))\n  (define (closest-to-seven x y)\n    (if\
    \ (= x y)\n        x\n        (if (< x y)\n            (- x)\n            (+ x))))\n\
    \  (define (closest-to-eight x y)\n    (if (= x y)\n        x\n        (if (<\
    \ x y)\n            (- x)\n            (+ x))))\n  (define (closest-to-nine x\
    \ y)\n    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n   \
    \         (+ x))))\n  (define (closest-to-tens x y)\n    (if (= x y)\n       \
    \ x\n        (if (< x y)\n            (- x)\n            (+ x))))\n  (define (closest-to-tens\
    \ x y)\n    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n \
    \           (+ x))))\n  (define (closest-to-tens x y)\n    (if (= x y)\n     \
    \   x\n        (if (< x y)\n            (- x)\n            (+ x))))\n  (define\
    \ (closest-to-tens x y)\n    (if (= x y)\n        x\n        (if (< x y)\n   \
    \         (- x)\n            (+ x))))\n  (define (closest-to-tens x y)\n    (if\
    \ (= x y)\n        x\n        (if (< x y)\n            (- x)\n            (+ x))))\n\
    \  (define (closest-to-tens x y)\n    (if (= x y)\n        x\n        (if (< x\
    \ y)\n            (- x)\n", "  (let ([int-value (string->number (string->symbol\
    \ value))])\n    (cond\n      [(< int-value 0) (error \"Closest integer not possible\
    \ for negative numbers\")]\n      [(< int-value 1) (error \"Closest integer not\
    \ possible for single digit\")]\n      [(< int-value 10) (error \"Closest integer\
    \ not possible for tens\")]\n      [else (round (abs (- int-value 10))\n     \
    \             (ceiling (/ int-value 10))\n                  (floor int-value)\n\
    \                  (round (abs (- int-value 10))\n                         (ceiling\
    \ (/ int-value 10))\n                         (floor int-value)\n            \
    \             (round (abs (- int-value 10))\n                                \
    \ (ceiling (/ int-value 10))\n                                 (floor int-value)\n\
    \                                 (round (abs (- int-value 10))\n            \
    \                             (ceiling (/ int-value 10))\n                   \
    \                      (floor int-value)\n                                   \
    \      (round (abs (- int-value 10))\n                                       \
    \          (ceiling (/ int-value 10))\n                                      \
    \           (floor int-value)\n                                              \
    \   (round (abs (- int-value 10))\n                                          \
    \               (ceiling (/ int-value 10))\n                                 \
    \                        (floor int-value)\n                                 \
    \                        (round (abs (- int-value 10))\n                     \
    \                                            (ceiling (/ int-value 10))\n    \
    \                                                             (floor int-value)\n\
    \                                                                 (round (abs\
    \ (- int-value 10))\n                                                        \
    \                 (ceiling (/ int-value 10))\n                               \
    \                                          (floor int-value)\n               \
    \                                                          (round (abs (- int-value\
    \ 10))\n                                                                     \
    \        (ceiling (/ int-value 10))\n                                        \
    \                                     (floor int-value)\n                    \
    \                                                         (round (abs (- int-value\
    \ 10))\n                                                                     \
    \                  (ceiling (/ int-value 10))\n                              \
    \                                                         (floor int-value)\n\
    \                                                                            \
    \           (round (abs (- int-value 10))\n                                  \
    \                                                            (ceiling (/ int-value\
    \ 10))\n                                                                     \
    \                         (floor int-value)\n                                \
    \                                                              (round (abs (-\
    \ int-value 10))\n                                                           \
    \                                            (ceiling (/ int-value 10))\n    \
    \                                                                            \
    \                       (floor int-value)\n                                  \
    \                                                                     (round (abs\
    \ (- int-value 10))\n                                                        \
    \                                                      (ceiling (/ int-value 10))\n\
    \                                                                            \
    \                                  (floor int-value)\n                       \
    \                                                                            \
    \           (round (abs (- int-value 10))\n                                  \
    \                                                                            \
    \      (ceiling (/ int-value 10))\n                                          \
    \                                                                          (flo",
  "  (let ([integer (parse-integer value)]\n        [integers (list integer)]\n  \
    \      [integer-distance (distance integer integers)])\n    (if (null? integer-distance)\n\
    \        integer\n        (let ([closest (car integer-distance)])\n          (if\
    \ (< (distance integer closest) integer-distance)\n              (closest_integer\
    \ value)\n              closest)))))\n", "  (let ([x (string->number (car value))])\n\
    \    (let ([y (string->number (cadr value))])\n      (if (and (< x y) \n     \
    \          (< y x))\n          (ceiling x)\n          (ceiling y)))))\n", "  (let\
    \ ([x (parse-integer (string->symbol (symbol->string value)))])\n    (cond [(<\
    \ x 0) (error \"Not a number\")]\n          [(< x 1) x]\n          [(< x 10) (round\
    \ (/ x 10))]\n          [(< x 100) (round (/ x 10))]\n          [(< x 1000) (round\
    \ (/ x 10))]\n          [(< x 10000) (round (/ x 10))]\n          [(< x 100000)\
    \ (round (/ x 10))]\n          [(< x 1000000) (round (/ x 10))]\n          [(<\
    \ x 10000000) (round (/ x 10))]\n          [(< x 100000000) (round (/ x 10))]\n\
    \          [(< x 1000000000) (round (/ x 10))]\n          [(< x 10000000000) (round\
    \ (/ x 10))]\n          [(< x 100000000000) (round (/ x 10))]\n          [(< x\
    \ 1000000000000) (round (/ x 10))]\n          [(< x 10000000000000) (round (/\
    \ x 10))]\n          [(< x 100000000000000) (round (/ x 10))]\n          [(< x\
    \ 1000000000000000) (round (/ x 10))]\n          [(< x 10000000000000000) (round\
    \ (/ x 10))]\n          [(< x 100000000000000000) (round (/ x 10))]\n        \
    \  [(< x 1000000000000000000) (round (/ x 10))]\n          [(< x 10000000000000000000)\
    \ (round (/ x 10))]\n          [(< x 100000000000000000000) (round (/ x 10))]\n\
    \          [(< x 1000000000000000000000) (round (/ x 10))]\n          [(< x 10000000000000000000000)\
    \ (round (/ x 10))]\n          [(< x 100000000000000000000000) (round (/ x 10))]\n\
    \          [(< x 1000000000000000000000000) (round (/ x 10))]\n          [(< x\
    \ 10000000000000000000000000) (round (/ x 10))]\n          [(< x 100000000000000000000000000)\
    \ (round (/ x 10))]\n          [(< x 1000000000000000000000000000) (round (/ x\
    \ 10))]\n          [(< x 10000000000000000000000000000) (round (/ x 10))]\n  \
    \        [(< x 100000000000000000000000000000) (round (/ x 10))]\n          [(<\
    \ x 1000000000000000000000000000000) (round (/ x 10))]\n          [(< x 10000000000000000000000000000000)\
    \ (round (/ x 10))]\n          [(< x 100000000000000000000000000000000) (round\
    \ (/ x ", "  (let ([int-val (string->number value)]\n        [int-diff (- int-val\
    \ (floor (/ int-val 10)))])\n    (if (< int-diff 0)\n        (ceiling int-val)\n\
    \        (floor int-val))))\n", "  (let ([x (number->string value)]\n        [y\
    \ (number->string value)])\n    (cond\n      [(equal? x y) value]\n      [(equal?\
    \ x \"-\") (- 0 (string->number y))]\n      [(equal? y \"-\") (- 0 (string->number\
    \ x))]\n      [(equal? x \"0\") (- 0 (string->number y))]\n      [(equal? y \"\
    0\") (- 0 (string->number x))]\n      [(equal? x \"1\") (+ 0 (string->number y))]\n\
    \      [(equal? y \"1\") (+ 0 (string->number x))]\n      [else (- 0 (string->number\
    \ x))])))\n", "  (define (closest-to-zero x y)\n    (if (= x y)\n        x\n \
    \       (if (< x y)\n            (- x)\n            (+ x))))\n  (define (closest-to-two\
    \ x y)\n    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n \
    \           (+ x))))\n  (define (closest-to-one x y)\n    (if (= x y)\n      \
    \  x\n        (if (< x y)\n            (- x)\n            (+ x))))\n  (define\
    \ (closest-to-three x y)\n    (if (= x y)\n        x\n        (if (< x y)\n  \
    \          (- x)\n            (+ x))))\n  (define (closest-to-five x y)\n    (if\
    \ (= x y)\n        x\n        (if (< x y)\n            (- x)\n            (+ x))))\n\
    \  (define (closest-to-six x y)\n    (if (= x y)\n        x\n        (if (< x\
    \ y)\n            (- x)\n            (+ x))))\n  (define (closest-to-seven x y)\n\
    \    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n        \
    \    (+ x))))\n  (define (closest-to-eight x y)\n    (if (= x y)\n        x\n\
    \        (if (< x y)\n            (- x)\n            (+ x))))\n  (define (closest-to-nine\
    \ x y)\n    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n \
    \           (+ x))))\n  (define (closest-to-tens x y)\n    (if (= x y)\n     \
    \   x\n        (if (< x y)\n            (- x)\n            (+ x))))\n  (define\
    \ (closest-to-twenty x y)\n    (if (= x y)\n        x\n        (if (< x y)\n \
    \           (- x)\n            (+ x))))\n  (define (closest-to-thirtys x y)\n\
    \    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n        \
    \    (+ x))))\n  (define (closest-to-fortys x y)\n    (if (= x y)\n        x\n\
    \        (if (< x y)\n            (- x)\n            (+ x))))\n  (define (closest-to-fiftys\
    \ x y)\n    (if (= x y)\n        x\n        (if (< x y)\n            (- x)\n \
    \           (+ x))))\n  (define (closest-to-sixtys x y)\n    (if (= x y)\n   \
    \     x\n        (if (< x y)\n            (- x)\n            (+ x))))\n  (define\
    \ (closest-to-seventys x y)\n    (if (= x y)\n        x\n        (if (", "  (let\
    \ ((integer (parse-integer value)))\n    (cond ((< integer 0)\n           (error\
    \ \"Closest integer cannot be negative\"))\n          ((< integer 10)\n      \
    \     (integer))\n          ((< integer 15)\n           (ceiling (- integer)))\n\
    \          ((< integer 20)\n           (floor (- integer)))\n          ((< integer\
    \ 25)\n           (ceiling (- integer)))\n          ((< integer 30)\n        \
    \   (floor (- integer)))\n          ((< integer 35)\n           (ceiling (- integer)))\n\
    \          ((< integer 40)\n           (floor (- integer)))\n          ((< integer\
    \ 45)\n           (ceiling (- integer)))\n          ((< integer 50)\n        \
    \   (floor (- integer)))\n          ((< integer 55)\n           (ceiling (- integer)))\n\
    \          ((< integer 60)\n           (floor (- integer)))\n          ((< integer\
    \ 65)\n           (ceiling (- integer)))\n          ((< integer 70)\n        \
    \   (floor (- integer)))\n          ((< integer 75)\n           (ceiling (- integer)))\n\
    \          ((< integer 80)\n           (floor (- integer)))\n          ((< integer\
    \ 85)\n           (ceiling (- integer)))\n          ((< integer 90)\n        \
    \   (floor (- integer)))\n          ((< integer 95)\n           (ceiling (- integer)))\n\
    \          ((< integer 100)\n           (floor (- integer)))\n          ((< integer\
    \ 105)\n           (ceiling (- integer)))\n          ((< integer 110)\n      \
    \     (floor (- integer)))\n          ((< integer 115)\n           (ceiling (-\
    \ integer)))\n          ((< integer 120)\n           (floor (- integer)))\n  \
    \        ((< integer 125)\n           (ceiling (- integer)))\n          ((< integer\
    \ 130)\n           (floor (- integer)))\n          ((< integer 135)\n        \
    \   (ceiling (- integer)))\n          ((< integer 140)\n           (floor (- integer)))\n\
    \          ((< integer 145)\n           (ceiling (- integer)))\n          ((<\
    \ integer 150)\n           (floor (- integer)))\n          ((< integer 155)\n\
    \           (ceiling (- integer)))\n          ((< integer 160)\n           (floor\
    \ (- integer)))\n          ((< integer 165)\n           (ceiling (- integer)))\n\
    \          ((< integer 170)\n           (floor (- integer)))\n          ((< integer\
    \ 175)\n           (ceiling (- integer)))\n          ((< integer 180)\n      \
    \     (floor (- integer)))\n          ((< integer 185)\n           (", "  (let\
    \ ([num (number->string value)])\n    (if (number->string->number num)\n     \
    \   (number->string->number (string-append \"0\" num))\n        (number->string->number\
    \ (string-append \"1\" num)))))\n", "  (let ([num (number->string value)]\n  \
    \      [nums (number->list value)])\n    (if (= (length nums) 1)\n        (number->integer\
    \ num)\n        (let ([num (number->string num)]\n              [nums (number->list\
    \ num)])\n          (let ([min (min nums)])\n            (if (= (length nums)\
    \ 1)\n                (number->integer num)\n                (let ([num (number->string\
    \ num)]\n                      [nums (number->list num)])\n                  (let\
    \ ([diff (- num (first nums))])\n                    (if (< diff min)\n      \
    \                  (number->integer num)\n                        (closest_integer\
    \ num))))))))))\n", "  (define (closest-integer-helper value)\n    (cond ((< value\
    \ 0) 0)\n          ((< value 1) 1)\n          ((< value 2) 2)\n          ((< value\
    \ 3) 3)\n          ((< value 4) 4)\n          ((< value 5) 5)\n          ((< value\
    \ 6) 6)\n          ((< value 7) 7)\n          ((< value 8) 8)\n          ((< value\
    \ 9) 9)\n          ((< value 10) 10)\n          ((< value 11) 11)\n          ((<\
    \ value 12) 12)\n          ((< value 13) 13)\n          ((< value 14) 14)\n  \
    \        ((< value 15) 15)\n          ((< value 16) 16)\n          ((< value 17)\
    \ 17)\n          ((< value 18) 18)\n          ((< value 19) 19)\n          ((<\
    \ value 20) 20)\n          ((< value 21) 21)\n          ((< value 22) 22)\n  \
    \        ((< value 23) 23)\n          ((< value 24) 24)\n          ((< value 25)\
    \ 25)\n          ((< value 26) 26)\n          ((< value 27) 27)\n          ((<\
    \ value 28) 28)\n          ((< value 29) 29)\n          ((< value 30) 30)\n  \
    \        ((< value 31) 31)\n          ((< value 32) 32)\n          ((< value 33)\
    \ 33)\n          ((< value 34) 34)\n          ((< value 35) 35)\n          ((<\
    \ value 36) 36)\n          ((< value 37) 37)\n          ((< value 38) 38)\n  \
    \        ((< value 39) 39)\n          ((< value 40) 40)\n          ((< value 41)\
    \ 41)\n          ((< value 42) 42)\n          ((< value 43) 43)\n          ((<\
    \ value 44) 44)\n          ((< value 45) 45)\n          ((< value 46) 46)\n  \
    \        ((< value 47) 47)\n          ((< value 48) 48)\n          ((< value 49)\
    \ 49)\n          ((< value 50) 50)\n          ((< value 51) 51)\n          ((<\
    \ value 52) 52)\n          ((< value 53) 53)\n          ((< value 54) 54)\n  \
    \        ((< value 55) 55)\n          ((< value 56) 56)\n          ((< value 57)\
    \ 57)\n          ((< value 58) 58)\n          ((< value 59) 59)", "  (let ([x\
    \ (parse-integer (string->symbol (symbol->string value)))])\n    (let ([y (parse-integer\
    \ (symbol->string x))])\n      (if (= x y)\n          x\n          (let ([diff\
    \ (- x y)])\n            (if (< diff 0)\n                (+ x 1)\n           \
    \     (- x 1))))))))\n", "  (let ([x (string->number (car value))])\n    (let\
    \ ([y (string->number (cadr value))])\n      (if (= x y)\n          x\n      \
    \    (if (< x y)\n              (ceiling x)\n              (floor x))))))\n",
  "  (let ([int-value (string->number (string->symbol value))])\n    (cond\n     \
    \ [(< int-value 0) (error \"Given value is not a number\")]\n      [(< int-value\
    \ 1) (int-value)]\n      [(< int-value 2) (int-value + 1)]\n      [(< int-value\
    \ 3) (int-value + 2)]\n      [(< int-value 4) (int-value + 3)]\n      [(< int-value\
    \ 5) (int-value + 4)]\n      [(< int-value 6) (int-value + 5)]\n      [(< int-value\
    \ 7) (int-value + 6)]\n      [(< int-value 8) (int-value + 7)]\n      [(< int-value\
    \ 9) (int-value + 8)]\n      [(< int-value 10) (int-value + 9)]\n      [(< int-value\
    \ 11) (int-value + 10)]\n      [(< int-value 12) (int-value + 11)]\n      [(<\
    \ int-value 13) (int-value + 12)]\n      [(< int-value 14) (int-value + 13)]\n\
    \      [(< int-value 15) (int-value + 14)]\n      [(< int-value 16) (int-value\
    \ + 15)]\n      [(< int-value 17) (int-value + 16)]\n      [(< int-value 18) (int-value\
    \ + 17)]\n      [(< int-value 19) (int-value + 18)]\n      [(< int-value 20) (int-value\
    \ + 19)]\n      [(< int-value 21) (int-value + 20)]\n      [(< int-value 22) (int-value\
    \ + 21)]\n      [(< int-value 23) (int-value + 22)]\n      [(< int-value 24) (int-value\
    \ + 23)]\n      [(< int-value 25) (int-value + 24)]\n      [(< int-value 26) (int-value\
    \ + 25)]\n      [(< int-value 27) (int-value + 26)]\n      [(< int-value 28) (int-value\
    \ + 27)]\n      [(< int-value 29) (int-value + 28)]\n      [(< int-value 30) (int-value\
    \ + 29)]\n      [(< int-value 31) (int-value + 30)]\n      [(< int-value 32) (int-value\
    \ + 31)]\n      [(< int-value 33) (int-value + 32", "  (let ([x (string->number\
    \ (car value))])\n    (let ([y (string->number (cadr value))])\n      (if (= x\
    \ y)\n          x\n          (if (< x y)\n              (ceiling x)\n        \
    \      (floor x))))))\n", "  (let ([x (string->number (car value))])\n    (let\
    \ ([y (string->number (cadr value))])\n      (if (and (number? x) (number? y))\n\
    \          (if (< (abs (- x y)) (abs x))\n              (if (< (abs (- x y)) (abs\
    \ y))\n                  (round (- x y))\n                  (round (- y x))\n\
    \                  (round (- x y))\n                  (round (- y x))\n      \
    \            (round (- x y))\n                  (round (- y x))\n            \
    \      (round (- x y))\n                  (round (- y x))\n                  (round\
    \ (- x y))\n                  (round (- y x))\n                  (round (- x y))\n\
    \                  (round (- y x))\n                  (round (- x y))\n      \
    \            (round (- y x))\n                  (round (- x y))\n            \
    \      (round (- y x))\n                  (round (- x y))\n                  (round\
    \ (- y x))\n                  (round (- x y))\n                  (round (- y x))\n\
    \                  (round (- x y))\n                  (round (- y x))\n      \
    \            (round (- x y))\n                  (round (- y x))\n            \
    \      (round (- x y))\n                  (round (- y x))\n                  (round\
    \ (- x y))\n                  (round (- y x))\n                  (round (- x y))\n\
    \                  (round (- y x))\n                  (round (- x y))\n      \
    \            (round (- y x))\n                  (round (- x y))\n            \
    \      (round (- y x))\n                  (round (- x y))\n                  (round\
    \ (- y x))\n                  (round (- x y))\n                  (round (- y x))\n\
    \                  (round (- x y))\n                  (round (- y x))\n      \
    \            (round (- x y))\n                  (round (- y x))\n            \
    \      (round (- x y))\n                  (round (- y x))\n                  (round\
    \ (- x y))\n                  (round (- y x))\n                  (round (- x y))\n\
    \                  (round (- y x))\n                  (round (- x y))\n      \
    \            (round (- y x))\n                  (round (- x y))\n            \
    \      (round (- y x))\n                  (round (- x y))\n                  (round\
    \ (- y x))\n                  (round (- x y))\n                  (round (- y ",
  "  (let ([num (parse-integer value)]\n        [min (parse-integer \"0\")])\n   \
    \ (cond\n      [(< num min) (parse-integer \"0\")]\n      [(< min num) (parse-integer\
    \ \"0\")]\n      [(= num min) (parse-integer \"0\")]\n      [(= min num) (parse-integer\
    \ \"0\")]\n      [(> num min) (parse-integer \"0\")]\n      [(> min num) (parse-integer\
    \ \"0\")]\n      [(= (abs (- num min)) (abs (- num num))) (parse-integer \"0\"\
    )]\n      [(< (abs (- num min)) (abs (- num num))) (parse-integer \"0\")]\n  \
    \    [(> (abs (- num min)) (abs (- num num))) (parse-integer \"0\")]\n      [(<\
    \ (abs (- num min)) (abs (- num num))) (parse-integer \"0\")]\n      [(> (abs\
    \ (- num min)) (abs (- num num))) (parse-integer \"0\")]\n      [(< (abs (- num\
    \ min)) (abs (- num num))) (parse-integer \"0\")]\n      [(> (abs (- num min))\
    \ (abs (- num num))) (parse-integer \"0\")]\n      [(< (abs (- num min)) (abs\
    \ (- num num))) (parse-integer \"0\")]\n      [(> (abs (- num min)) (abs (- num\
    \ num))) (parse-integer \"0\")]\n      [(< (abs (- num min)) (abs (- num num)))\
    \ (parse-integer \"0\")]\n      [(> (abs (- num min)) (abs (- num num))) (parse-integer\
    \ \"0\")]\n      [(< (abs (- num min)) (abs (- num num))) (parse-integer \"0\"\
    )]\n      [(> (abs (- num min)) (abs (- num num))) (parse-integer \"0\")]\n  \
    \    [(< (abs (- num min)) (abs (- num num))) (parse-integer \"0\")]\n      [(>\
    \ (abs (- num min)) (abs (- num num))) (parse-integer \"0\")]\n      [(< (abs\
    \ (- num min)) (abs (- num num))) (parse-integer \"0\")]\n      [(> (abs (- num\
    \ min)) (abs (- num num))) (parse-integer \"0\")]\n      ", "  (let ([num (parse-integer\
    \ value)])\n    (cond [(< num 0)\n           0]\n          [(< num 10)\n     \
    \      (+ num 1)]\n          [(< num 100)\n           (+ num 10)]\n          [(<\
    \ num 1000)\n           (+ num 100)]\n          [(< num 10000)\n           (+\
    \ num 1000)]\n          [(< num 100000)\n           (+ num 10000)]\n         \
    \ [(< num 1000000)\n           (+ num 100000)]\n          [(< num 10000000)\n\
    \           (+ num 1000000)]\n          [(< num 100000000)\n           (+ num\
    \ 10000000)]\n          [(< num 1000000000)\n           (+ num 100000000)]\n \
    \         [(< num 10000000000)\n           (+ num 1000000000)]\n          [(<\
    \ num 100000000000)\n           (+ num 10000000000)]\n          [(< num 1000000000000)\n\
    \           (+ num 100000000000)]\n          [(< num 10000000000000)\n       \
    \    (+ num 1000000000000)]\n          [(< num 100000000000000)\n           (+\
    \ num 10000000000000)]\n          [(< num 1000000000000000)\n           (+ num\
    \ 100000000000000)]\n          [(< num 10000000000000000)\n           (+ num 1000000000000000)]\n\
    \          [(< num 100000000000000000)\n           (+ num 10000000000000000)]\n\
    \          [(< num 1000000000000000000)\n           (+ num 100000000000000000)]\n\
    \          [(< num 10000000000000000000)\n           (+ num 100000000000000000)]\n\
    \          [(< num 100000000000000000000)\n           (+ num 100000000000000000)]\n\
    \          [(< num 1000000000000000000000)\n           (+ num 100000000000000000)]\n\
    \          [(< num 10000000000000000000000)\n           (+ num 100000000000000000)]\n\
    \          [(< num 100000000000000000000000)\n           (+ num 100000000000000000)]\n\
    \          [(< num 1000000000000000000000000)\n           (+ num 100000000000000000)]\n\
    \          [(< num 10000000000000000000000000)\n           (+ num 100000000000000000)]\n\
    \          [(< num 100000000000000000000000000)\n           (+ num 100000000000000000)]\n\
    \          [(< num 1000000000000000000000000000)\n           (+ num 100000000000000000)]\n\
    \          [(< num 10000000000000000000000000000)\n           (+ num 100000000000000000)]\n\
    \          [(< num 100000000000000000000000000000)\n           (+ num 100000000000000000)]\n\
    \          [(< num 1000000000000000000000000000000)\n           (+ num 100000000000000000)]\n\
    \          [(< num 1000000000000000000000000000000", "  (let ([int-value (string->number\
    \ value)])\n    (cond\n      [(< int-value 0) (error \"Closest integer not possible.\"\
    )]\n      [(< int-value 1) (error \"Closest integer not possible.\")]\n      [else\
    \ (round (abs (- int-value 1)))])))\n", "  (let ([integers (map integer? (string->list\
    \ value))])\n    (if (null? integers)\n        0\n        (let ([closest (car\
    \ integers)])\n          (if (null? integers)\n              closest\n       \
    \       (let ([diff (abs (- closest value)))\n                    (newdiff (if\
    \ (< diff 0) (- diff) diff))\n                    (newclosest (if (< diff 0) (-\
    \ closest) closest))])\n                (if (< newdiff 0) (newdiff) newdiff)\n\
    \                (if (< newclosest 0) (newclosest) newclosest)))))\n", "  (let\
    \ ([integer (parse-integer value)]\n        [integers (list integer)]\n      \
    \  [integer-distance (- integer (first integers))])\n    (cond\n      [(empty?\
    \ integers) integer]\n      [(< (first integers) integer) integer]\n      [else\
    \ (let ([new-integer (+ integer (first integers))])\n              (cond\n   \
    \             [(empty? integers) new-integer]\n                [(< (first integers)\
    \ new-integer) new-integer]\n                [else (let ([new-integers (cons new-integer\
    \ (rest integers))])\n                        (cond\n                        \
    \  [(empty? new-integers) new-integer]\n                          [(< (first new-integers)\
    \ new-integer) new-integer]\n                          [else (let ([new-integer-distance\
    \ (- new-integer (first new-integers))])\n                                  (cond\n\
    \                                    [(empty? new-integers) new-integer]\n   \
    \                                 [(< (first new-integers) new-integer) new-integer]\n\
    \                                    [else (let ([new-integer-distance (+ new-integer-distance\
    \ (first new-integers))])\n                                              (cond\n\
    \                                                [(empty? new-integers) new-integer]\n\
    \                                                [(< (first new-integers) new-integer)\
    \ new-integer]\n                                                [else (let ([new-integer-distance\
    \ (- new-integer-distance (first new-integers))])\n                          \
    \                              (cond\n                                       \
    \                   [(empty? new-integers) new-integer]\n                    \
    \                                      [(< (first new-integers) new-integer) new-integer]\n\
    \                                                          [else (let ([new-integer-distance\
    \ (+ new-integer-distance (first new-integers))])\n                          \
    \                                          (cond\n                           \
    \                                           [(empty? new-integers) new-integer]\n\
    \                                                                      [(< (first\
    \ new-integers) new-integer) new-integer]\n                                  \
    \                                    [else (let ([new-integer-distance (- new-integer-distance\
    \ (first new-integers))])\n                                                  \
    \                        (cond\n                                             \
    \                               [(empty? new-integers) new-integer]\n        \
    \                                                                    [(< (first\
    \ new-integers) new-integer) new-integer]\n                                  \
    \                                          [else (let ([new-integer-distance (+\
    \ new-integer-distance (first new-integers))])\n                             \
    \                                                         (cond\n            \
    \                                                                            [(empty?\
    \ new-integers) new-integer]\n                                               \
    \                                         [(< (first new-integers) new-integer)\
    \ new-integer]\n                                                             \
    \                           [else (let ([new-integer-distance (- new-integer-distance\
    \ (first new-integers))])\n                                                  \
    \                                              (cond\n                       \
    \                                                                           [(empty?\
    \ new-integers) new-integer]\n                                               \
    \                                                   [(< (first new-integers) new-integer",
  "  (let ([x (number->string value)]\n        [y (number->string value)])\n    (cond\n\
    \      [(number->string? value) (number->string value)]\n      [(number->number?\
    \ value) (number->number value)]\n      [else (error \"Invalid argument: ~a\"\
    \ value)]\n      )\n    (cond\n      [(equal? x y) (number->number value)]\n \
    \     [else (let ([x (number->string x)]\n                 [y (number->string\
    \ y)])\n             (cond\n               [(equal? x y) (number->number value)]\n\
    \               [else (let ([x (number->string x)]\n                         \
    \  [y (number->string y)])\n                        (cond\n                  \
    \        [(equal? x y) (number->number value)]\n                          [else\
    \ (let ([x (number->string x)]\n                                       [y (number->string\
    \ y)])\n                                    (cond\n                          \
    \            [(equal? x y) (number->number value)]\n                         \
    \             [else (let ([x (number->string x)]\n                           \
    \                        [y (number->string y)])\n                           \
    \                 (cond\n                                              [(equal?\
    \ x y) (number->number value)]\n                                             \
    \ [else (error \"Invalid argument: ~a\" value)]\n                            \
    \                  )\n                                            )\n        \
    \                                  )\n                                       \
    \ )\n                                      )\n                               \
    \     )\n                                  )\n                               \
    \ )\n                              )\n                            )\n        \
    \                  )\n                        )\n                    )\n     \
    \           )\n            )\n        )\n    )\n  )\n)\n", "  (let ([num (number->string\
    \ value)]\n        [nums (number->list value)]\n        [min (number->string 0)]\n\
    \        [max (number->string 0)])\n    (cond\n      [(empty? nums) value]\n \
    \     [(number->string? (first nums)) (closest_integer (first nums))]\n      [(number->string?\
    \ (last nums)) (closest_integer (last nums))]\n      [(number->string? (first\
    \ num)) (closest_integer (first num))]\n      [(number->string? (last num)) (closest_integer\
    \ (last num))]\n      [(number->string? (first nums)) (closest_integer (first\
    \ nums))]\n      [(number->string? (last nums)) (closest_integer (last nums))]\n\
    \      [(number->string? (first num)) (closest_integer (first num))]\n      [(number->string?\
    \ (last num)) (closest_integer (last num))]\n      [(number->string? (first nums))\
    \ (closest_integer (first nums))]\n      [(number->string? (last nums)) (closest_integer\
    \ (last nums))]\n      [(number->string? (first num)) (closest_integer (first\
    \ num))]\n      [(number->string? (last num)) (closest_integer (last num))]\n\
    \      [(number->string? (first nums)) (closest_integer (first nums))]\n     \
    \ [(number->string? (last nums)) (closest_integer (last nums))]\n      [(number->string?\
    \ (first num)) (closest_integer (first num))]\n      [(number->string? (last num))\
    \ (closest_integer (last num))]\n      [(number->string? (first nums)) (closest_integer\
    \ (first nums))]\n      [(number->string? (last nums)) (closest_integer (last\
    \ nums))]\n      [(number->string? (first num)) (closest_integer (first num))]\n\
    \      [(number->string? (last num)) (closest_integer (last num))]\n      [(number->string?\
    \ (first nums)) (closest_integer (first nums))]\n      [(number->string? (last\
    \ nums)) (closest_integer (last nums))]\n      [(number->string? (first num))\
    \ (closest_integer (first num))]\n      [(number->string? (last num)) (closest_integer\
    \ (last num))]\n      [(number->string? (first nums)) (closest_integer (first\
    \ nums))]\n      [(number->string? (last nums)) (closest_integer (last nums))]\n\
    \      [(number->string? (first ", "  (let ([x (number->string value)]\n     \
    \   [y (number->string value)])\n    (cond\n      [(equal? x y) value]\n     \
    \ [(number->number (string-append x \"0\"))\n       (if (< (number->number (string-append\
    \ x \"0\")) 0)\n           (number->number (string-append x \"1\"))\n        \
    \   (number->number (string-append x \"0\")))]\n      [(number->number (string-append\
    \ y \"0\"))\n       (if (< (number->number (string-append y \"0\")) 0)\n     \
    \      (number->number (string-append y \"1\"))\n           (number->number (string-append\
    \ y \"0\")))]\n      [else (number->number (string-append x \"0\"))])))\n", " \
    \ (let ([int-value (string->number (string->symbol value))])\n    (cond\n    \
    \  [(< int-value 0) (error \"Given value is not a number\")]\n      [(< int-value\
    \ 1) (error \"Given value is not a number\")]\n      [(< int-value 2) (error \"\
    Given value is not a number\")]\n      [(< int-value 3) (error \"Given value is\
    \ not a number\")]\n      [(< int-value 4) (error \"Given value is not a number\"\
    )]\n      [(< int-value 5) (error \"Given value is not a number\")]\n      [(<\
    \ int-value 6) (error \"Given value is not a number\")]\n      [(< int-value 7)\
    \ (error \"Given value is not a number\")]\n      [(< int-value 8) (error \"Given\
    \ value is not a number\")]\n      [(< int-value 9) (error \"Given value is not\
    \ a number\")]\n      [(< int-value 10) (error \"Given value is not a number\"\
    )]\n      [(< int-value 11) (error \"Given value is not a number\")]\n      [(<\
    \ int-value 12) (error \"Given value is not a number\")]\n      [(< int-value\
    \ 13) (error \"Given value is not a number\")]\n      [(< int-value 14) (error\
    \ \"Given value is not a number\")]\n      [(< int-value 15) (error \"Given value\
    \ is not a number\")]\n      [(< int-value 16) (error \"Given value is not a number\"\
    )]\n      [(< int-value 17) (error \"Given value is not a number\")]\n      [(<\
    \ int-value 18) (error \"Given value is not a number\")]\n      [(< int-value\
    \ 19) (error \"Given value is not a number\")]\n      [(< int-value 20) (error\
    \ \"Given value is not a number\")]\n      [(< int-value 21) (error \"Given value\
    \ is not a number\")]\n      [(< int-value 22) (error \"Given value is not a number\"\
    )]\n      [(< int-value 23) (error \"Given value is not a number\")]\n      [(<\
    \ int-value 24) (error \"Given value is not a number\")]\n      [(< int-value\
    \ 25) (error \"Given value is not a number\")]\n      [(< int-value 26) (error\
    \ \"Given value is not a number\")]\n      [(< int-value 27) (error \"Given value\
    \ is not a number\")]\n      [(< int-value 28) (error \"Given value is not a number\"\
    )]\n      [(< int-value 29) (error \"Given value is not a number\")]\n      [(<\
    \ int-value 30) (error \"Given value is not a ", "  (let ([x (string->number (car\
    \ value))])\n    (let ([y (string->number (cadr value))])\n      (cond\n     \
    \   ((< x y) x)\n        ((< y x) y)\n        (else (round (sqrt (+ (square (-\
    \ x y)) (square (- x y)))) 0))))))\n", "  (let ([int-value (string->number (car\
    \ value))])\n    (cond\n      [(< int-value 0)\n       (error \"The given value\
    \ is not a number\")\n       (car value)]\n      [(< int-value (car int-value))\n\
    \       (car value)]\n      [else\n       (let ([int-value (car int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (cdr int-value)]\n             [int-value (cdr int-value)]\n\
    \             [int-value (c", "  (let ([integers (map number->integer [1 2 3 4\
    \ 5 6 7 8 9])])\n    (let ([closest (first integers)])\n      (if (< (abs (- value\
    \ closest)) (abs (- value integers)))\n          closest\n          integers))))\n",
  "  (define (closest-to-zero x y)\n    (if (= x y)\n        x\n        (if (< (abs\
    \ (- x y)) 1)\n            (- x y)\n            (- y x))))\n  (define (closest-to-value\
    \ x y)\n    (if (= x y)\n        x\n        (if (< (abs (- x y)) 1)\n        \
    \    (- x y)\n            (- y x))))\n  (define (closest-to-value x y)\n    (if\
    \ (= x y)\n        x\n        (if (< (abs (- x y)) 1)\n            (- x y)\n \
    \           (- y x))))\n  (define (closest-to-value x y)\n    (if (= x y)\n  \
    \      x\n        (if (< (abs (- x y)) 1)\n            (- x y)\n            (-\
    \ y x))))\n  (define (closest-to-value x y)\n    (if (= x y)\n        x\n    \
    \    (if (< (abs (- x y)) 1)\n            (- x y)\n            (- y x))))\n  (define\
    \ (closest-to-value x y)\n    (if (= x y)\n        x\n        (if (< (abs (- x\
    \ y)) 1)\n            (- x y)\n            (- y x))))\n  (define (closest-to-value\
    \ x y)\n    (if (= x y)\n        x\n        (if (< (abs (- x y)) 1)\n        \
    \    (- x y)\n            (- y x))))\n  (define (closest-to-value x y)\n    (if\
    \ (= x y)\n        x\n        (if (< (abs (- x y)) 1)\n            (- x y)\n \
    \           (- y x))))\n  (define (closest-to-value x y)\n    (if (= x y)\n  \
    \      x\n        (if (< (abs (- x y)) 1)\n            (- x y)\n            (-\
    \ y x))))\n  (define (closest-to-value x y)\n    (if (= x y)\n        x\n    \
    \    (if (< (abs (- x y)) 1)\n            (- x y)\n            (- y x))))\n  (define\
    \ (closest-to-value x y)\n    (if (= x y)\n        x\n        (if (< (abs (- x\
    \ y)) 1)\n            (- x y)\n            (- y x))))\n  (define (closest-to-value\
    \ x y)\n    (if (= x y)\n        x\n        (if (< (abs (- x y)) 1)\n        \
    \    (- x y)\n            (- y x))))\n  (define (closest-to-value x y)\n    (if\
    \ (= x y)\n        x\n        (if (< (abs (- x y)) 1)\n            (- x y)\n \
    \           (- y x))))\n  (define (closest-to-", "  (let ([x (number->string value)]\n\
    \        [y (number->string value)])\n    (if (and (number? x)\n             (number?\
    \ y))\n        (let ([x (number->string x)]\n              [y (number->string\
    \ y)])\n          (if (and (number? x)\n                   (number? y))\n    \
    \          (let ([x (number->string x)]\n                    [(- x y) (- y x)]\n\
    \                    [y (number->string y)])\n                (if (< (- x y) 0)\n\
    \                    (number->string x)\n                    (number->string y))))\n\
    \          (number->string x))))))\n", "  (let ([num (number->string value)])\n\
    \    (if (number->string->number num)\n        (number->string->number (string-append\
    \ \"0\" num))\n        (number->string->number (string-append \"1\" num)))))\n",
  "  (let ([x (string->number (car value))])\n    (let ([y (string->number (cadr value))])\n\
    \      (if (= x y)\n          x\n          (if (< x y)\n              (ceiling\
    \ x)\n              (floor x))))))\n", "  (let ([number-str (string->number (string->symbol\
    \ value))])\n    (cond\n      [(number? number-str)\n       (if (number-str <\
    \ 0)\n           (ceiling (- (number-str)))\n           (floor (- (number-str))))]\n\
    \      [(number-str < 0)\n       (ceiling (- (number-str)))]\n      [else\n  \
    \     (floor (- (number-str)))])))\n", "  (let ([integers (number->list value)])\n\
    \    (let ([closest (first integers)])\n      (if (null? integers)\n         \
    \ closest\n          (let ([next (second integers)])\n            (if (> (abs\
    \ (- next closest)) (abs (- closest next)))\n                (+ closest next)\n\
    \                closest))))))\n", "  (define (closest-integer-helper value)\n\
    \    (cond [(number? value) (number->integer value)]\n          [(< value 0) (-\
    \ 0 (floor (/ value 10)))]\n          [(< value 1) (- 0 (floor (/ value 10)))]\n\
    \          [(< value 10) (- 0 (floor (/ value 10)))]\n          [(< value 100)\
    \ (- 0 (floor (/ value 10)))]\n          [(< value 1000) (- 0 (floor (/ value\
    \ 10)))]\n          [(< value 10000) (- 0 (floor (/ value 10)))]\n          [(<\
    \ value 100000) (- 0 (floor (/ value 10)))]\n          [(< value 1000000) (- 0\
    \ (floor (/ value 10)))]\n          [(< value 10000000) (- 0 (floor (/ value 10)))]\n\
    \          [(< value 100000000) (- 0 (floor (/ value 10)))]\n          [(< value\
    \ 1000000000) (- 0 (floor (/ value 10)))]\n          [(< value 10000000000) (-\
    \ 0 (floor (/ value 10)))]\n          [(< value 100000000000) (- 0 (floor (/ value\
    \ 10)))]\n          [(< value 1000000000000) (- 0 (floor (/ value 10)))]\n   \
    \       [(< value 10000000000000) (- 0 (floor (/ value 10)))]\n          [(< value\
    \ 100000000000000) (- 0 (floor (/ value 10)))]\n          [(< value 1000000000000000)\
    \ (- 0 (floor (/ value 10)))]\n          [(< value 10000000000000000) (- 0 (floor\
    \ (/ value 10)))]\n          [(< value 100000000000000000) (- 0 (floor (/ value\
    \ 10)))]\n          [(< value 1000000000000000000) (- 0 (floor (/ value 10)))]\n\
    \          [(< value 10000000000000000000) (- 0 (floor (/ value 10)))]\n     \
    \     [(< value 100000000000000000000) (- 0 (floor (/ value 10)))]\n         \
    \ [(< value 1000000000000000000000) (- 0 (floor (/ value 10)))]\n          [(<\
    \ value 10000000000000000000000) (- 0 (floor (/ value 10)))]\n          [(< value\
    \ 100000000000000000000000) (- 0 (floor (/ value 10)))]\n          [(< value 1000000000000000000000000)\
    \ (- 0 (floor (/ value 10)))]\n          [(< value 10000000000000000000000000)\
    \ (- 0 (floor (/ value 10)))]\n          [(< value 100000000000000000000000000)\
    \ (- 0 (floor (/ value 10)))]\n          [(", "  (let ([x (parse-integer (string->symbol\
    \ (symbol->string value)))])\n    (cond\n      [(< x 0) (error \"Closest integer\
    \ not possible for negative numbers\")]\n      [(< x 1) x]\n      [(< x 2) (-\
    \ x)]\n      [else (- x)]))\n  )\n", "  (let ([integers (map number->integer [1\
    \ 2 3 4 5 6 7 8 9])])\n    (let ([closest (car integers)])\n      (let ([diff\
    \ (- value closest)])\n        (if (< diff 0)\n          (closest_integer value)\n\
    \          (if (= diff 0)\n            closest\n            (min closest diff)))))\n\
    \    (if (< value 0)\n      (- value)\n      value)))\n", "  (let ([x (number->string\
    \ value)]\n        [y (number->string value)])\n    (cond\n      [(equal? x y)\
    \ value]\n      [(equal? x \"-\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"-\") (- 0 (number->integer value))]\n      [(equal? x \"0\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"0\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"1\") (- 0 (number->integer value))]\n      [(equal? y \"1\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"10\") (- 0 (number->integer value))]\n      [(equal?\
    \ y \"10\") (- 0 (number->integer value))]\n      [(equal? x \"100\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"100\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"1000\") (- 0 (number->integer value))]\n      [(equal? y \"1000\") (- 0\
    \ (number->integer value))]\n      [(equal? x \"10000\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"10000\") (- 0 (number->integer value))]\n     \
    \ [(equal? x \"100000\") (- 0 (number->integer value))]\n      [(equal? y \"100000\"\
    ) (- 0 (number->integer value))]\n      [(equal? x \"1000000\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"1000000\") (- 0 (number->integer value))]\n   \
    \   [(equal? x \"10000000\") (- 0 (number->integer value))]\n      [(equal? y\
    \ \"10000000\") (- 0 (number->integer value))]\n      [(equal? x \"100000000\"\
    ) (- 0 (number->integer value))]\n      [(equal? y \"100000000\") (- 0 (number->integer\
    \ value))]\n      [(equal? x \"1000000000\") (- 0 (number->integer value))]\n\
    \      [(equal? y \"1000000000\") (- 0 (number->integer value))]\n      [(equal?\
    \ x \"10000000000\") (- 0 (number->integer value))]\n      [(equal? y \"10000000000\"\
    ) (- 0 (number->integer value))]\n      [(equal? x \"100000000000\") (- 0 (number->integer\
    \ value))]\n      [(equal? y \"100000000000\") (- 0 (", "  (let ([int-value (string->number\
    \ (car value))])\n    (let ([int-min (string->number (car value))])\n      (let\
    \ ([int-max (string->number (cadr value))])\n        (cond\n          [(< int-value\
    \ int-min) (+ int-min 1)]\n          [(< int-value int-max) (+ int-max 1)]\n \
    \         [else (+ int-value 1)])))\n    (cond\n      [(< int-value int-min) (+\
    \ int-min 1)]\n      [(< int-value int-max) (+ int-max 1)]\n      [else (+ int-value\
    \ 1))]))\n", "  (let ([x (number->string value)]\n        [y (number->string value)])\n\
    \    (cond\n      [(empty? x) 0]\n      [(empty? y) 0]\n      [(equal? x y) 0]\n\
    \      [(equal? (first x) '-) (- 0 (string->number (rest y)))]\n      [(equal?\
    \ (first x) '+) (+ 0 (string->number (rest y)))]\n      [else (let ([x (string->number\
    \ (first x))\n                  y (number->string (rest y))])\n              (cond\n\
    \                [(equal? x y) 0]\n                [(equal? (first x) '-) (- 0\
    \ (string->number (rest y)))]\n                [(equal? (first x) '+) (+ 0 (string->number\
    \ (rest y)))]\n                [else (let ([x (string->number (first x))\n   \
    \                         y (number->string (rest y))])\n                    \
    \     (cond\n                          [(equal? x y) 0]\n                    \
    \      [(equal? (first x) '-) (- 0 (string->number (rest y)))]\n             \
    \             [(equal? (first x) '+) (+ 0 (string->number (rest y)))]\n      \
    \                    [else (let ([x (string->number (first x))\n             \
    \                           y (number->string (rest y))])\n                  \
    \                   (cond\n                                       [(equal? x y)\
    \ 0]\n                                       [(equal? (first x) '-) (- 0 (string->number\
    \ (rest y)))]\n                                       [(equal? (first x) '+) (+\
    \ 0 (string->number (rest y)))]\n                                       [else\
    \ (let ([x (string->number (first x))\n                                      \
    \              y (number->string (rest y))])\n                               \
    \                  (cond\n                                                   [(equal?\
    \ x y) 0]\n                                                   [(equal? (first\
    \ x) '-) (- 0 (string->number (rest y)))]\n                                  \
    \                 [(equal? (first x) '+) (+ 0 (string->number (rest y)))]\n  \
    \                                                 [else (let ([x (string->number\
    \ (first x))\n                                                               \
    \ y (number->string (rest y))])\n                                            \
    \               (cond\n                                                      \
    \       [(equal? x y) 0]\n                                                   \
    \          [(equal? (first x) '-) (- 0 (string->number (rest y)))]\n         \
    \                                                    [(equal? (first x) '+) (+\
    \ 0 (string->number (rest y)))]\n                                            \
    \                 [else (let ([x (string->number (first x))\n                \
    \                                                        y (number->string (rest\
    \ y))])\n                                                                    \
    \ (cond\n                                                                    \
    \   [(equal? x y) 0]\n                                                       \
    \                [(equal? (first x) '-) (- 0 (string->number (rest y)))]\n   \
    \                                                                    [(equal?\
    \ (first x) '+) (", "  (let ([number-string (read-string value)])\n    (if (number-string\
    \ empty?)\n        0\n        (let ([number-integer (parse-integer number-string)])\n\
    \          (if (number-integer < 0)\n              (- number-integer 1)\n    \
    \          number-integer)))))\n", "  (let ([integers (map integer->real '(1 2\
    \ 3 4 5 6 7 8 9))])\n    (let ([closest (first integers)])\n      (let ([diff\
    \ (- value closest)])\n        (if (< diff 0)\n            (ceiling closest)\n\
    \            (floor closest)))))\n", "  (let ([num (parse-integer value)]\n  \
    \      [nums (list num)]\n        [num-diff (- num nums)])\n    (if (null? num-diff)\n\
    \        num\n        (let ([closest (car num-diff)])\n          (if (< num closest)\n\
    \              (closest_integer value)\n              (closest_integer closest)))))\n",
  "  (let ([num (parse-integer value)]\n        [min (parse-integer \"0\")]\n    \
    \    [max (parse-integer \"10\")])\n    (cond\n      [(< num min) (parse-integer\
    \ \"0\")]\n      [(< num max) (parse-integer \"10\")]\n      [(= num max) (parse-integer\
    \ \"10\")]\n      [(< num max) (parse-integer \"0\")]\n      [else (parse-integer\
    \ \"10\")]))))\n", "  (let ([int-value (string->number (car value))])\n    (cond\n\
    \      [(< int-value 0) (error \"Closest integer not possible: value is negative.\"\
    )]\n      [(< int-value 1) (error \"Closest integer not possible: value is zero.\"\
    )]\n      [(< int-value 2) (error \"Closest integer not possible: value is one.\"\
    )]\n      [(< int-value 3) (error \"Closest integer not possible: value is two.\"\
    )]\n      [(< int-value 4) (error \"Closest integer not possible: value is three.\"\
    )]\n      [(< int-value 5) (error \"Closest integer not possible: value is four.\"\
    )]\n      [(< int-value 6) (error \"Closest integer not possible: value is five.\"\
    )]\n      [(< int-value 7) (error \"Closest integer not possible: value is six.\"\
    )]\n      [(< int-value 8) (error \"Closest integer not possible: value is seven.\"\
    )]\n      [(< int-value 9) (error \"Closest integer not possible: value is eight.\"\
    )]\n      [(< int-value 10) (error \"Closest integer not possible: value is nine.\"\
    )]\n      [else (round (/ int-value 10))]))))\n", "  (let ([int-value (string->number\
    \ (string->symbol value))])\n    (cond\n      [(< int-value 0) (error \"Given\
    \ value is not a number\")]\n      [(< int-value 1) (error \"Given value is not\
    \ a number\")]\n      [else (round (* int-value 10))]))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
