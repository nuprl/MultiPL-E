name: HumanEval_80_is_happy
language: rkt
prompt: "#lang racket\n\n;; You are given a string s.\n;; Your task is to check if\
  \ the string is happy or not.\n;; A string is happy if its length is at least 3\
  \ and every 3 consecutive letters are distinct\n;; For example:\n;; >>> (is_happy\
  \ a)\n;; #f\n;; >>> (is_happy aa)\n;; #f\n;; >>> (is_happy abcd)\n;; #t\n;; >>>\
  \ (is_happy aabb)\n;; #f\n;; >>> (is_happy adb)\n;; #t\n;; >>> (is_happy xyy)\n\
  ;; #f\n(define (is_happy s)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate is_happy))\n\
  \    (check-equal? (candidate \"a\") #f)\n    (check-equal? (candidate \"aa\") #f)\n\
  \    (check-equal? (candidate \"abcd\") #t)\n    (check-equal? (candidate \"aabb\"\
  ) #f)\n    (check-equal? (candidate \"adb\") #t)\n    (check-equal? (candidate \"\
  xyy\") #f)\n    (check-equal? (candidate \"iopaxpoi\") #t)\n    (check-equal? (candidate\
  \ \"iopaxioi\") #f)\n))\n\n(test-humaneval)"
completions: ["  (and (>= (length s) 3)\n       (every (lambda (x) (distinct (substring\
    \ s 0 x) (substring s x 3))) \n               (range (length s)))))\n", "  (and\
    \ (>= (length s) 3)\n       (every (lambda (x) (distinct (substring s 0 x) (substring\
    \ s x 3))) s)))\n", "  (or (= (length s) 3)\n      (and (= (length s) 3)\n   \
    \        (distinct-letters s))))\n", "  (and (>= (length s) 3)\n       (every\
    \ (lambda (x) (distinct (substring s 0 x) (substring s x 3))) \n             \
    \  (range (length s)))))\n", "  (and (>= (length s) 3)\n       (for/fold ((acc\
    \ #t) (c (in-string s #\\)))\n                  ((acc #f) (i 0))\n           \
    \       (if (= i 3)\n                      (set! acc (not (distinct c acc)))\n\
    \                      (set! acc (distinct c acc))))))\n", "  (or (>= (length\
    \ s) 3)\n      (and (distinct (subseq s 0 2)) (distinct (subseq s 2 4)) (distinct\
    \ (subseq s 4 6)))))\n", "  (and (>= (length s) 3)\n       (for/fold ([i 0]) ([j\
    \ 0]) (lambda ([i j])\n                                (if (equal? (substring\
    \ s i j) '#\\#)\n                                    (set! i (+ i 3))\n      \
    \                              (set! j (+ j 3))))\n               (= i j))))\n",
  "  (or (>= (length s) 3)\n      (every (lambda (c) (distinct (car s) c)) (subseq\
    \ s 0 (- 3 s)))))\n", "  (and (>= (length s) 3)\n       (for/fold ((counts #{})\
    \ (letter #\\a)) ((i (length s))\n                          (if (= i 3)\n    \
    \                          (let ((count (length counts)))\n                  \
    \              (if (not (member letter counts))\n                            \
    \        (set! counts (cons letter counts))\n                                \
    \    #f)\n                                  (set! counts (cons count counts))))\n\
    \                      (= i 3))\n       (not (empty? counts))))\n", "  (and (>=\
    \ (length s) 3)\n       (for/fold ((acc #f) (c (in-string s #\\Space)))\n    \
    \               ((i 0) (j 0))\n                   ((or (= i j) (= i 3) (= j 3))\n\
    \                    (set! acc (not (= (char c #\\Space) acc)))\n            \
    \        (set! i (+ i 1))\n                    (set! j (+ j 1))\n            \
    \        (set! acc (not (= (char c #\\Space) acc))))\n               acc))\n",
  "  (and (>= (length s) 3)\n       (every (lambda (x) (distinct (substring s 0 x)\
    \ (substring s x 3))) \n               (range (length s)))))\n", "  (and (>= (length\
    \ s) 3)\n       (for/fold ([i 0]) ([j 0]) (lambda ([x y])\n                  \
    \              (if (equal? (char-code x) (char-code y))\n                    \
    \                (set! i (add1 i))\n                                    (set!\
    \ j (add1 j))\n                                    (if (= i j)\n             \
    \                           (return #f))))\n       (= i j)))\n", "  (and (>= (length\
    \ s) 3)\n       (every (lambda (x) (distinct (substring s 0 x)))\n           \
    \    (range (length s) 3))))\n", "  (and (>= (length s) 3)\n       (for/fold ((count\
    \ 0) (letter #\\a)) ((i (in-range (length s))) (if (equal? (substring s i i) letter)\
    \ (add1 count) count))\n       (= count 3)))\n", "  (and (>= (length s) 3)\n \
    \      (every (lambda (x) (distinct (substring s 0 x) (substring s x (length s))))\n\
    \               (range 3 (length s)))))\n", "  (and (>= (length s) 3)\n      \
    \ (every3 (string=? s #\\a) (string=? s #\\b) (string=? s #\\c) (string=? s #\\\
    d) (string=? s #\\e) (string=? s #\\f) (string=? s #\\g) (string=? s #\\h) (string=?\
    \ s #\\i) (string=? s #\\j) (string=? s #\\k) (string=? s #\\l) (string=? s #\\\
    m) (string=? s #\\n) (string=? s #\\o) (string=? s #\\p) (string=? s #\\q) (string=?\
    \ s #\\r) (string=? s #\\s)\n               (string=? s #\\t) (string=? s #\\\
    v) (string=? s #\\w) (string=? s #\\x) (string=? s #\\y) (string=? s #\\z))))\n",
  "  (and (>= (length s) 3)\n       (every (lambda (x) (distinct (substring s 0 x)\
    \ (substring s x (length s))))\n               (range (length s)))))\n", "  (and\
    \ (>= (length s) 3)\n       (for/fold ([i 0]) ([j 0])\n         (if (equal? (substring\
    \ s i j) '#\\#)\n             (set! i (+ i 3))\n             (set! j (+ j 3))))\n\
    \       (for/fold ([i 0]) ([j 0])\n         (if (equal? (substring s i j) '#\\\
    #)\n             (set! i (+ i 3))\n             (set! j (+ j 3))))\n       (for/fold\
    \ ([i 0]) ([j 0])\n         (if (equal? (substring s i j) '#\\#)\n           \
    \  (set! i (+ i 3))\n             (set! j (+ j 3))))\n       (for/fold ([i 0])\
    \ ([j 0])\n         (if (equal? (substring s i j) '#\\#)\n             (set! i\
    \ (+ i 3))\n             (set! j (+ j 3))))\n       (for/fold ([i 0]) ([j 0])\n\
    \         (if (equal? (substring s i j) '#\\#)\n             (set! i (+ i 3))\n\
    \             (set! j (+ j 3))))\n       (for/fold ([i 0]) ([j 0])\n         (if\
    \ (equal? (substring s i j) '#\\#)\n             (set! i (+ i 3))\n          \
    \   (set! j (+ j 3))))\n       (for/fold ([i 0]) ([j 0])\n         (if (equal?\
    \ (substring s i j) '#\\#)\n             (set! i (+ i 3))\n             (set!\
    \ j (+ j 3))))\n       (for/fold ([i 0]) ([j 0])\n         (if (equal? (substring\
    \ s i j) '#\\#)\n             (set! i (+ i 3))\n             (set! j (+ j 3))))\n\
    \       (for/fold ([i 0]) ([j 0])\n         (if (equal? (substring s i j) '#\\\
    #)\n             (set! i (+ i 3))\n             (set! j (+ j 3))))\n       (for/fold\
    \ ([i 0]) ([j 0])\n         (if (equal? (substring s i j) '#\\#)\n           \
    \  (set! i (+ i 3))\n             (set! j (+ j 3))))\n       (for/fold ([i 0])\
    \ ([j 0])\n         (if (equal? (substring s i j) '#\\#)\n             (set! i\
    \ (+ i 3))\n             (set! j (+ j 3))", "  (and (>= (length s) 3)\n      \
    \ (every (lambda (x) (not (member x s))) (rest s))))\n", "  (and (>= (length s)\
    \ 3)\n       (every (lambda (x) (distinct (substring s 0 x)))\n              \
    \ (range (length s) 3))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
