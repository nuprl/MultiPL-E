name: HumanEval_72_will_it_fly
language: rkt
prompt: "#lang racket\n\n;; Write a function that returns True if the object q will\
  \ fly, and False otherwise.\n;; The object q will fly if it's balanced (it is a\
  \ palindromic list) and the sum of its elements is less than or equal the maximum\
  \ possible weight w.\n;; Example:\n;; >>> (will_it_fly (list 1 2) 5)\n;; #f\n;;\
  \ # 1+2 is less than the maximum possible weight, but it's unbalanced.\n;; >>> (will_it_fly\
  \ (list 3 2 3) 1)\n;; #f\n;; # it's balanced, but 3+2+3 is more than the maximum\
  \ possible weight.\n;; >>> (will_it_fly (list 3 2 3) 9)\n;; #t\n;; # 3+2+3 is less\
  \ than the maximum possible weight, and it's balanced.\n;; >>> (will_it_fly (list\
  \ 3) 5)\n;; #t\n;; # 3 is less than the maximum possible weight, and it's balanced.\n\
  (define (will_it_fly q w)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate will_it_fly))\n\
  \    (check-equal? (candidate (list 3 2 3) 9) #t)\n    (check-equal? (candidate\
  \ (list 1 2) 5) #f)\n    (check-equal? (candidate (list 3) 5) #t)\n    (check-equal?\
  \ (candidate (list 3 2 3) 1) #f)\n    (check-equal? (candidate (list 1 2 3) 6) #f)\n\
  \    (check-equal? (candidate (list 5) 5) #t)\n))\n\n(test-humaneval)"
completions: ["  (cond [(empty? q) #f]\n        [(equal? (first q) (reverse (first\
    \ q))) #t]\n        [(< (sum (rest q)) w) #f]\n        [else #f]))\n", "  (and\
    \ (list? q)\n       (palindrome? q)\n       (< (length q) w)\n       (<= (apply\
    \ + q) w)))\n", "  (cond\n    [(empty? q) #f]\n    [(equal? (first q) (reverse\
    \ (first q))) #t]\n    [else (will_it_fly (rest q) (+ w (first q)))]))\n", " \
    \ (cond [(empty? q) #f]\n        [(equal? (first q) (reverse (first q))) #t]\n\
    \        [else (and (< (+ (first q) (first q)) w)\n                   (will_it_fly\
    \ (rest q) w))]))\n", "  (cond\n    [(empty? q) #f]\n    [(equal? (first q) (reverse\
    \ (first q))) #t]\n    [else (< (+ (first q) (first q)) w) #f]))\n", "  (and (list?\
    \ q)\n       (palindrome? q)\n       (<= (sum (reverse q)) w)))\n", "  (and (list?\
    \ q)\n       (palindromic? q)\n       (<= (sum (reverse q)) w)))\n", "  (cond\n\
    \    [(empty? q) #f]\n    [(equal? (first q) (reverse (first q))) #t]\n    [else\
    \ (and (will_it_fly (rest q) w) (< (sum (rest q)) w))]))\n", "  (cond\n    [(empty?\
    \ q) #f]\n    [(equal? (first q) (reverse (first q))) #t]\n    [else (and (equal?\
    \ (first q) (reverse (first q))) (<= (+ (first q) (second q)) w))]))\n", "  (and\
    \ (list? q)\n       (palindromic? q)\n       (<= (sum (reverse q)) w)))\n", " \
    \ (cond\n    [(empty? q) #f]\n    [(equal? (first q) (reverse (first q))) #t]\n\
    \    [else (and (< (+ (first q) (second q)) w)\n               (will_it_fly (rest\
    \ q) w))]))\n", "  (cond [(empty? q) #f]\n        [(equal? (first q) (reverse\
    \ (first q))) #t]\n        [else (< (+ (first q) (first q)) w) (will_it_fly (rest\
    \ q) w)]))\n", "  (and (list? q)\n       (palindrome? q)\n       (<= (sum (reverse\
    \ q)) w)))\n", "  (cond\n    [(empty? q) #f]\n    [(equal? (first q) (reverse\
    \ (first q))) #t]\n    [else (and (equal? (first q) (reverse (first q))) (<= (+\
    \ (first q) (second q)) w))]))\n", "  (and (list? q)\n       (palindromic? q)\n\
    \       (<= (sum (reverse q)) w)))\n", "  (cond ((null? q) #f)\n        ((palindrome\
    \ q) (<= (sum (reverse q)) w))\n        (else #f)))\n", "  (cond [(empty? q) #f]\n\
    \        [(equal? (first q) (reverse (first q))) #f]\n        [(< (sum (rest q))\
    \ w) #f]\n        [else #t]))\n", "  (and (list? q)\n       (palindrome? q)\n\
    \       (< (length q) (- w 1))))\n", "  (cond\n    [(empty? q) #f]\n    [(equal?\
    \ (first q) (reverse (first q))) #t]\n    [else (or (will_it_fly (rest q) (+ w\
    \ w))\n               (will_it_fly (rest q) w))]))\n", "  (and (list? q)\n   \
    \    (palindrome? q)\n       (<= (sum (reverse q)) w)))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
