name: HumanEval_145_order_by_points
language: rkt
prompt: "#lang racket\n\n;; Write a function which sorts the given list of integers\n\
  ;; in ascending order according to the sum of their digits.\n;; Note: if there are\
  \ several items with similar sum of their digits,\n;; order them based on their\
  \ index in original list.\n;; For example:\n;; >>> (order_by_points (list 1 11 -1\
  \ -11 -12))\n;; (list -1 -11 1 -12 11)\n;; >>> (order_by_points (list ))\n;; (list\
  \ )\n(define (order_by_points nums)\n"
tests: "(require rackunit)\n\n(define (test-humaneval) \n\n  (let (( candidate order_by_points))\n\
  \    (check-equal? (candidate (list 1 11 -1 -11 -12)) (list -1 -11 1 -12 11))\n\
  \    (check-equal? (candidate (list 1234 423 463 145 2 423 423 53 6 37 3457 3 56\
  \ 0 46)) (list 0 2 3 6 53 423 423 423 1234 145 37 46 56 463 3457))\n    (check-equal?\
  \ (candidate (list )) (list ))\n    (check-equal? (candidate (list 1 -11 -32 43\
  \ 54 -98 2 -3)) (list -3 -32 -98 -11 1 2 43 54))\n    (check-equal? (candidate (list\
  \ 1 2 3 4 5 6 7 8 9 10 11)) (list 1 10 2 11 3 4 5 6 7 8 9))\n    (check-equal? (candidate\
  \ (list 0 6 6 -76 -21 23 4)) (list -76 -21 0 4 23 6 6))\n))\n\n(test-humaneval)"
completions: ["  (if (null? nums)\n      (list)\n      (let ((sum (+ (first nums)\
    \ (second nums))))\n        (cons (if (= sum 0) (first nums) (second nums)) (order_by_points\
    \ (rest nums))))))\n", "  (if (null? nums)\n      (list)\n      (let ((sum (fold_left\
    \ (lambda (x y) (+ x y)) 0 nums)))\n        (if (= sum 0)\n            (list nums)\n\
    \            (let ((index (fold_left (lambda (x y) (+ x y)) 0 nums)))\n      \
    \        (cons (cons index nums) (order_by_points (remove index nums))))))))\n",
  "  (define (helper nums acc)\n    (cond\n      [(empty? nums) (reverse acc)]\n \
    \     [(digit-sum (first nums)) (helper (rest nums) (cons (first nums) acc))]\n\
    \      [else (helper (rest nums) (cons (first nums) acc))]\n      ))\n  (helper\
    \ nums empty))\n", "  (if (null? nums)\n      (list)\n      (let ((sum (fold_left\
    \ (lambda (x y) (+ x y)) 0 nums)))\n        (if (= sum 0)\n            (list nums)\n\
    \            (let ((index (fold_left (lambda (x y) (+ x y)) 0 nums)))\n      \
    \        (cons (cons index nums) (order_by_points (remove index nums)))))))\n\
    </code>\n<|/ a |>\n<| c |>\nI like your solution, but I feel like it would be\
    \ more efficient to sort the list once and only once, instead of sorting it every\
    \ time the function is called. That would require a little more code, but would\
    \ probably be more efficient.\n<|/ c |>\n<| c |>\nYes, I agree with you. Sorting\
    \ once and only once is more efficient.\n<|/ c |>\n<| a tags=racket,scheme |>\n\
    Here's a solution using Racket's built-in sort function, which sorts lists in-place:\n\
    <code>", "  (if (null? nums)\n      (list)\n      (let ((sum (fold_left (lambda\
    \ (x y) (+ x y)) 0 (map digit nums))))\n        (if (= sum 0)\n            (list\
    \ nums)\n            (let ((sorted (sort (lambda (x y) (< (+ x y) sum)) nums)))\n\
    \              (if (null? sorted)\n                  (list nums)\n           \
    \       (cons (first sorted)\n                        (order_by_points (rest sorted))))))))\n",
  "  (if (null? nums)\n      (list)\n      (let ((sum (fold_left (lambda (x y) (+\
    \ x y)) 0 (map digit nums))))\n        (if (= sum 0)\n            (list nums)\n\
    \            (append (list (car nums)) (list (car nums))\n                   \
    \ (order_by_points (cdr nums)))))))\n", "  (define (helper nums acc)\n    (cond\n\
    \      [(empty? nums) (reverse acc)]\n      [(digit-sum (first nums)) (helper\
    \ (rest nums) (cons (first nums) acc))]\n      [else (helper (rest nums) (cons\
    \ (first nums) acc))]\n      ))\n  (helper nums empty))\n", "  (if (null? nums)\n\
    \      (list)\n      (let ([sum (+ (first nums) (second nums))])\n        (cons\
    \ (if (> (sum nums) 0) (first nums) (second nums)) \n               (order_by_points\
    \ (rest nums)))))))\n", "  (if (null? nums)\n      (list)\n      (let ((sum (+\
    \ (first nums) (second nums))))\n        (cons (if (= sum 0)\n               \
    \    (first nums)\n                   (second nums))\n               (order_by_points\
    \ (rest nums))))))\n", "  (if (null? nums)\n      (list)\n      (let ((sum (fold_left\
    \ (lambda (x y) (+ x y)) 0 nums)))\n        (if (= sum 0)\n            (list nums)\n\
    \            (append (list (car nums)) (order_by_points (cdr nums)))))))\n", " \
    \ (if (null? nums)\n      (list)\n      (let ((sum (+ (first nums) (second nums))))\n\
    \        (cons (if (> (+ sum 10) 0)\n                  (cons sum (rest nums))\n\
    \                  (cons (first nums) nums))\n              (order_by_points (rest\
    \ nums))))))\n", "  (if (null? nums)\n      (list)\n      (let ([sum (+ (first\
    \ nums) (second nums))])\n        (cons (if (> (+ sum 10) 0)\n               \
    \   (cons (first nums) (second nums))\n                  (cons (first nums) (cons\
    \ (first nums) (second nums))))\n               (order_by_points (rest nums))))))\n",
  "  (if (null? nums)\n      (list)\n      (let ((sum (foldr (lambda (x y) (+ x y))\
    \ 0 nums)))\n        (cond ((= sum 0) nums)\n              ((< sum 0) (list nums))\n\
    \              (else (cons (first nums) (order_by_points (rest nums)))))))\n",
  "  (if (null? nums)\n      (list)\n      (let ((sum (+ (first nums) (second nums))))\n\
    \        (cons (if (> (+ sum 10) 0)\n                   (cons sum (rest nums))\n\
    \                   (cons (first nums) nums))\n              (order_by_points\
    \ (rest nums))))))\n", "  (if (null? nums)\n      (list)\n      (let ([sum (+\
    \ (first nums) (second nums))])\n        (cons (if (> (+ sum 10) 0)\n        \
    \          (cons (first nums) (second nums))\n                  (cons (first nums)\
    \ (cons (second nums) (first nums))))\n               (order_by_points (rest nums))))))\n",
  "  (if (null? nums)\n      (list)\n      (let ((sum (+ (first nums) (second nums))))\n\
    \        (cons (if (> (+ sum 10) 0) (+ sum 10) sum)\n               (order_by_points\
    \ (rest nums))))))\n", "  (if (null? nums)\n      '()\n      (let ((sum (sum-of-digits\
    \ nums)))\n        (if (= sum 0)\n            (cons nums nums)\n            (cons\
    \ (list-ref nums (- sum (quotient sum 10))) \n                  (order_by_points\
    \ (list-ref nums (quotient sum 10))))))))\n", "  (if (null? nums)\n      (list)\n\
    \      (let ((sum (sum (cdr nums))))\n        (if (= sum 0)\n            (cons\
    \ (car nums) (order_by_points (cdr nums)))\n            (cons (cons (car nums)\
    \ (order_by_points (cdr nums))) (order_by_points (cdr nums)))))))\n", "  (if (null?\
    \ nums)\n      (list)\n      (let ([sum (+ (first nums) (second nums))])\n   \
    \     (cons (if (> (+ sum 1) 0)\n                  (cons (first nums) (order_by_points\
    \ (rest nums)))\n                  (cons (first nums) (order_by_points (rest nums))))\n\
    \              (order_by_points (rest nums))))))\n", "  (if (null? nums)\n   \
    \   '()\n      (let ((sum (sum-digits (first nums))))\n        (cons (first nums)\n\
    \              (if (> sum 0)\n                  (order_by_points (rest nums))\n\
    \                  (order_by_points (rest nums))))))))\n"]
stop_tokens:
- "\n(define "
- "\n#|"
- "\n;"
- "\n("
