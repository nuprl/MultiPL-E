name: HumanEval_115_max_fill
language: rb
prompt: "# You are given a rectangular grid of wells. Each row represents a single\
  \ well,\n# and each 1 in a row represents a single unit of water.\n# Each well has\
  \ a corresponding bucket that can be used to extract water from it, \n# and all\
  \ buckets have the same capacity.\n# Your task is to use the buckets to empty the\
  \ wells.\n# Output the number of times you need to lower the buckets.\n# Example\
  \ 1:\n# Example 2:\n# Example 3:\n# Constraints:\n# * all wells have the same length\n\
  # * 1 <= grid.length <= 10^2\n# * 1 <= grid[:,1].length <= 10^2\n# * grid[i][j]\
  \ -> 0 | 1\n# * 1 <= capacity <= 10\ndef max_fill(grid, capacity)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_max_fill\n\
  \    candidate = method(:max_fill)\n    assert_equal(6, candidate.call([[0, 0, 1,\
  \ 0], [0, 1, 0, 0], [1, 1, 1, 1]], 1))\n    assert_equal(5, candidate.call([[0,\
  \ 0, 1, 1], [0, 0, 0, 0], [1, 1, 1, 1], [0, 1, 1, 1]], 2))\n    assert_equal(0,\
  \ candidate.call([[0, 0, 0], [0, 0, 0]], 5))\n    assert_equal(4, candidate.call([[1,\
  \ 1, 1, 1], [1, 1, 1, 1]], 2))\n    assert_equal(2, candidate.call([[1, 1, 1, 1],\
  \ [1, 1, 1, 1]], 9))\n  end\nend\n"
completions: ["  max = 0\n  grid.each do |row|\n    max = row.max if row.max > max\n\
    \  end\n  max / capacity\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  max = 0\n  grid.each\
    \ do |row|\n    max = row.max if row.max > max\n  end\n  max\nend", "  return\
    \ 0 if grid.empty?\n  return 0 if grid.first.empty?\n  return 0 if capacity <=\
    \ 0\n  max_fill_helper(grid, capacity, 0, 0)\nend", "  return 0 if grid.empty?\n\
    \  return 0 if grid.first.empty?\n  return 0 if capacity <= 0\n  return 0 if grid.first.first\
    \ > capacity\n  return 1 if grid.first.first == capacity\n  return 1 + max_fill(grid.first[1..-1],\
    \ capacity - grid.first.first)\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = [max_fill, row.sum].max\n  end\n  max_fill / capacity\nend", " \
    \ return 0 if grid.empty?\n  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill / capacity\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  # fill the buckets\n  # lower the buckets\n  # repeat\
    \ until all wells are empty\n  # return the number of times you lowered the buckets\n\
    end", "  return 0 if grid.empty?\n  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill / capacity + (max_fill % capacity\
    \ > 0 ? 1 : 0)\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill,\
    \ row.count(1)].max\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do\
    \ |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend",
  "  # fill each well to capacity\n  # count the number of times you fill\n  # return\
    \ the count\n  count = 0\n  grid.each do |row|\n    row.each do |well|\n     \
    \ count += 1 if well == 1\n    end\n  end\n  count / capacity\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill\nend", "  # fill each well to capacity\n  # return the number\
    \ of times you need to lower the buckets\n  #\n  # 1) iterate through each row\n\
    \  # 2) iterate through each column\n  # 3) if the value is 1, fill it to capacity\n\
    \  # 4) return the number of times you need to lower the buckets\n  #\n  # 1)\
    \ iterate through each row\n  # 2) iterate through each column\n  # 3) if the\
    \ value is 1, fill it to capacity\n  # 4) return the number of times you need\
    \ to lower the buckets\n  #\n  # 1) iterate through each row\n  # 2) iterate through\
    \ each column\n  # 3) if the value is 1, fill it to capacity\n  # 4) return the\
    \ number of times you need to lower the buckets\n  #\n  # 1) iterate through each\
    \ row\n  # 2) iterate through each column\n  # 3) if the value is 1, fill it to\
    \ capacity\n  # 4) return the number of times you need to lower the buckets\n\
    \  #\n  # 1) iterate through each row\n  # 2) iterate through each column\n  #\
    \ 3) if the value is 1, fill it to capacity\n  # 4) return the number of times\
    \ you need to lower the buckets\n  #\n  # 1) iterate through each row\n  # 2)\
    \ iterate through each column\n  # 3) if the value is 1, fill it to capacity\n\
    \  # 4) return the number of times you need to lower the buckets\n  #\n  # 1)\
    \ iterate through each row\n  # 2) iterate through each column\n  # 3) if the\
    \ value is 1, fill it to capacity\n  # 4) return the number of times you need\
    \ to lower the buckets\n  #\n  # 1) iterate through each row\n  # 2) iterate through\
    \ each column\n  # 3) if the value is 1, fill it to capacity\n  # 4) return the\
    \ number of times you need to lower the buckets\n  #\n  # 1) iterate through each\
    \ row\n  # 2) iterate through each column\n  # 3) if the value is 1, fill it to\
    \ capacity\n  # 4) return the number of times you need to lower the buckets\n\
    \  #\n", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if\
    \ row.count(1) > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\n\
    end", "  # fill buckets\n  # lower buckets\n  # repeat until all wells are empty\n\
    \  # return number of times buckets were lowered\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.sum if row.sum\
    \ > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\nend",
  "  # find the max height of the grid\n  max_height = 0\n  grid.each do |row|\n \
    \   max_height = row.max if row.max > max_height\n  end\n  # for each height,\
    \ fill the wells\n  max_height.times do |height|\n    grid.each do |row|\n   \
    \   row.each_with_index do |well, index|\n        if well > 0\n          row[index]\
    \ -= 1\n        end\n      end\n    end\n  end\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill\nend", "  # find the max in each row\n  # fill\
    \ each row to the max\n  # repeat until all rows are filled\n  # return the number\
    \ of times we filled\n  #\n  # [1, 1, 1]\n  # [1, 1, 1]\n  # [1, 1, 1]\n  #\n\
    \  # [1, 1, 1]\n  # [1, 1, 1]\n  # [1, 1, 1]\n  #\n  # [1, 1, 1]\n  # [1, 1, 1]\n\
    \  # [1, 1, 1]\n  #\n  # [1, 1, 1]\n  # [1, 1, 1]\n  # [1, 1, 1]\n  #\n  # [1,\
    \ 1, 1]\n  # [1, 1, 1]\n  # [1, 1, 1]\n  #\n  # [1, 1, 1]\n  # [1, 1, 1]\n  #\
    \ [1, 1, 1]\n  #\n  # [1, 1, 1]\n  # [1, 1, 1]\n  # [1, 1, 1]\n  #\n  # [1, 1,\
    \ 1]\n  # [1, 1, 1]\n  # [1, 1, 1]\n  #\n  # [1, 1, 1]\n  # [1, 1, 1]\n  # [1,\
    \ 1, 1]\n  #\n  # [1, 1, 1]\n  # [1, 1, 1]\n  # [1, 1, 1]\n  #\n  # [1, 1, 1]\n\
    \  # [1, 1, 1]\n  # [1, 1, 1]\n  #\n  # [1, 1, 1]\n  # [1, 1, 1]\n  # [1, 1, 1]\n\
    \  #\n  # [1, 1, 1]\n  # [1, 1, 1]\n  # [1, 1, 1]\n  #\n  # [1, 1, 1]\n  # [1,\
    \ 1, 1]\n  # [1, 1, 1]\n  #\n  # [1, 1, 1]", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  # fill\
    \ buckets\n  # empty buckets\n  # repeat until empty\n  # return number of times\
    \ buckets were filled\n  #\n  # fill buckets\n  #   for each row\n  #     for\
    \ each column\n  #       add to bucket\n  #       break if bucket is full\n  #\n\
    \  # empty buckets\n  #   for each row\n  #     for each column\n  #       remove\
    \ from bucket\n  #       break if bucket is empty\n  #\n  # repeat until empty\n\
    \  #   return number of times buckets were filled\n  #\n  # return number of times\
    \ buckets were filled\n  #\n  # fill buckets\n  #   for each row\n  #     for\
    \ each column\n  #       add to bucket\n  #       break if bucket is full\n  #\n\
    \  # empty buckets\n  #   for each row\n  #     for each column\n  #       remove\
    \ from bucket\n  #       break if bucket is empty\n  #\n  # repeat until empty\n\
    \  #   return number of times buckets were filled\n  #\n  # return number of times\
    \ buckets were filled\n  #\n  # fill buckets\n  #   for each row\n  #     for\
    \ each column\n  #       add to bucket\n  #       break if bucket is full\n  #\n\
    \  # empty buckets\n  #   for each row\n  #     for each column\n  #       remove\
    \ from bucket\n  #       break if bucket is empty\n  #\n  # repeat until empty\n\
    \  #   return number of times buckets were filled\n  #\n  # return number of times\
    \ buckets were filled\n  #\n  # fill buckets\n  #   for each row\n  #     for\
    \ each column\n  #       add to bucket\n  #       break if bucket is full\n  #\n\
    \  # empty buckets\n  #   for each row\n  #     for each column\n  #       remove\
    \ from bucket\n  #       break if bucket is empty\n  #\n  # repeat until empty\n\
    \  #   return number of times buckets were filled\n  #\n  # return number of times\
    \ buckets were filled\n  #\n  # fill buckets\n  #   for each row\n  #     for\
    \ each column\n  #       add to bucket\n  #       break if bucket is full\n  #\n\
    \  # empty buckets\n  #  ", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = row.sum if row.sum > max_fill\n  end\n\
    \  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.sum\
    \ if row.sum > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill\nend", "  return 0 if grid.empty?\n  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill / capacity\nend", "  # max_fill = 0\n  # grid.each do |row|\n  # \
    \  row_fill = row.count(1)\n  #   max_fill = row_fill if row_fill > max_fill\n\
    \  # end\n  # max_fill\n  grid.map { |row| row.count(1) }.max\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  # find the max value in the grid\n  max = 0\n  grid.each\
    \ do |row|\n    max = row.max if row.max > max\n  end\n  # fill the grid with\
    \ the max value\n  grid.each do |row|\n    row.map! { |e| e = max }\n  end\n \
    \ # fill the grid with the max value - capacity\n  grid.each do |row|\n    row.map!\
    \ { |e| e = e - capacity }\n  end\n  # count the number of times you need to lower\
    \ the buckets\n  count = 0\n  grid.each do |row|\n    row.each do |e|\n      count\
    \ += 1 if e > 0\n    end\n  end\n  count\nend", "  max_fill = 0\n  grid.each do\
    \ |row|\n    max_fill = row.count('1') if row.count('1') > max_fill\n  end\n \
    \ max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill,\
    \ row.count(1)].max\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do\
    \ |row|\n    max_fill = row.sum if row.sum > max_fill\n  end\n  max_fill\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\nend", "  return\
    \ 0 if grid.empty?\n  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill,\
    \ row.count(1)].max\n  end\n  max_fill / capacity\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\n\
    end", "  # find the max value in the grid\n  max = grid.flatten.max\n  # create\
    \ a new grid with the max value\n  new_grid = Array.new(grid.length) { Array.new(grid[0].length,\
    \ max) }\n  # iterate over the grid\n  grid.each_with_index do |row, i|\n    row.each_with_index\
    \ do |col, j|\n      # if the value is 0, set the new grid value to 0\n      if\
    \ col == 0\n        new_grid[i][j] = 0\n      # otherwise, set the new grid value\
    \ to the max value - the capacity\n      else\n        new_grid[i][j] = max -\
    \ capacity\n      end\n    end\n  end\n  # return the new grid\n  new_grid\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.sum].max\n\
    \  end\n  max_fill / capacity\nend", "  # grid.map { |row| row.sum }.max\n  grid.map\
    \ { |row| row.sum }.max(capacity).sum\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    row.each do |cell|\n      max_fill = cell if cell > max_fill\n    end\n \
    \ end\n  max_fill\nend", "  # fill each well to capacity\n  # return number of\
    \ times we filled the bucket\n  # if we can't fill the bucket, return -1\n  #\
    \ if we can't fill the bucket, return -1\n  # if we can't fill the bucket, return\
    \ -1\n  # if we can't fill the bucket, return -1\n  # if we can't fill the bucket,\
    \ return -1\n  # if we can't fill the bucket, return -1\n  # if we can't fill\
    \ the bucket, return -1\n  # if we can't fill the bucket, return -1\n  # if we\
    \ can't fill the bucket, return -1\n  # if we can't fill the bucket, return -1\n\
    \  # if we can't fill the bucket, return -1\n  # if we can't fill the bucket,\
    \ return -1\n  # if we can't fill the bucket, return -1\n  # if we can't fill\
    \ the bucket, return -1\n  # if we can't fill the bucket, return -1\n  # if we\
    \ can't fill the bucket, return -1\n  # if we can't fill the bucket, return -1\n\
    \  # if we can't fill the bucket, return -1\n  # if we can't fill the bucket,\
    \ return -1\n  # if we can't fill the bucket, return -1\n  # if we can't fill\
    \ the bucket, return -1\n  # if we can't fill the bucket, return -1\n  # if we\
    \ can't fill the bucket, return -1\n  # if we can't fill the bucket, return -1\n\
    \  # if we can't fill the bucket, return -1\n  # if we can't fill the bucket,\
    \ return -1\n  # if we can't fill the bucket, return -1\n  # if we can't fill\
    \ the bucket, return -1\n  # if we can't fill the bucket, return -1\n  # if we\
    \ can't fill the bucket, return -1\n  # if we can't fill the bucket, return -1\n\
    \  # if we can't fill the bucket, return -1\n  # if we can't fill the bucket,\
    \ return -1\n  # if we can't fill the bucket, return -1\n  # if we can't fill\
    \ the bucket, return -1\n  #", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = row.sum if row.sum > max_fill\n  end\n  max_fill\nend", "  return 0 if grid.empty?\n\
    \  return 0 if grid.first.empty?\n  return 0 if capacity < 1\n  return 0 if capacity\
    \ > 10", "  max = 0\n  grid.each do |row|\n    max = row.count(1) if row.count(1)\
    \ > max\n  end\n  max\nend", "  # find the max value in the grid\n  max = 0\n\
    \  grid.each do |row|\n    max = row.max if row.max > max\n  end\n  # fill the\
    \ grid with the max value\n  grid.each_with_index do |row, i|\n    row.each_with_index\
    \ do |val, j|\n      grid[i][j] = max\n    end\n  end\n  # fill the grid with\
    \ the max value\n  grid.each_with_index do |row, i|\n    row.each_with_index do\
    \ |val, j|\n      grid[i][j] = max\n    end\n  end\n  # fill the grid with the\
    \ max value\n  grid.each_with_index do |row, i|\n    row.each_with_index do |val,\
    \ j|\n      grid[i][j] = max\n    end\n  end\n  # fill the grid with the max value\n\
    \  grid.each_with_index do |row, i|\n    row.each_with_index do |val, j|\n   \
    \   grid[i][j] = max\n    end\n  end\n  # fill the grid with the max value\n \
    \ grid.each_with_index do |row, i|\n    row.each_with_index do |val, j|\n    \
    \  grid[i][j] = max\n    end\n  end\n  # fill the grid with the max value\n  grid.each_with_index\
    \ do |row, i|\n    row.each_with_index do |val, j|\n      grid[i][j] = max\n \
    \   end\n  end\n  # fill the grid with the max value\n  grid.each_with_index do\
    \ |row, i|\n    row.each_with_index do |val, j|\n      grid[i][j] = max\n    end\n\
    \  end\n  # fill the grid with the max value\n  grid.each_with_index do |row,\
    \ i|\n    row.each_with_index do |val, j|\n      grid[i][j] = max\n    end\n \
    \ end\n  # fill the grid with the max value\n  grid.each_with_index do |row, i",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  # max_fill\
    \ = 0\n  # grid.each do |row|\n  #   max_fill = row.sum if row.sum > max_fill\n\
    \  # end\n  # max_fill\n  grid.map { |row| row.sum }.max\nend", "  # 1. find the\
    \ max height of the grid\n  # 2. fill the grid with the max height\n  # 3. find\
    \ the max height of the grid\n  # 4. fill the grid with the max height\n  # 5.\
    \ repeat until the grid is empty\n  # 6. return the number of times the grid was\
    \ filled\n  # 7. if the grid is empty, return 0\n  # 8. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 9. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 10. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 11. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 12. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 13. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 14. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 15. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 16. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 17. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 18. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 19. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 20. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 21. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 22. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 23. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 24. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 25. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 26. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 27. if the grid is not empty,\
    \ return the number of times the grid was filled\n  # 28. if", "  max_fill = 0\n\
    \  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  max_fill = 0\n \
    \ grid.each do |row|\n    max_fill = row.max if row.max > max_fill\n  end\n  max_fill\n\
    end", "  # fill the buckets\n  # lower the buckets\n  # repeat\n  # return the\
    \ number of times the buckets were lowered\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill\nend", "  # fill the buckets\n  # lower the buckets\n\
    \  # repeat until all wells are empty\n  # return the number of times the buckets\
    \ were lowered\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1)\
    \ if row.count(1) > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  # fill the buckets\n  # lower the buckets\n  # repeat\
    \ until all wells are empty\n  # return the number of times the buckets were lowered\n\
    \  #\n  # fill the buckets\n  #   for each row\n  #     fill the buckets with\
    \ water\n  #     if the bucket is full\n  #       lower the bucket\n  #      \
    \ empty the bucket\n  #       fill the bucket\n  #   return the number of times\
    \ the buckets were lowered\n  #\n  # fill the buckets\n  #   for each row\n  #\
    \     fill the buckets with water\n  #     if the bucket is full\n  #       lower\
    \ the bucket\n  #       empty the bucket\n  #       fill the bucket\n  #   return\
    \ the number of times the buckets were lowered\n  #\n  # fill the buckets\n  #\
    \   for each row\n  #     fill the buckets with water\n  #     if the bucket is\
    \ full\n  #       lower the bucket\n  #       empty the bucket\n  #       fill\
    \ the bucket\n  #   return the number of times the buckets were lowered\n  #\n\
    \  # fill the buckets\n  #   for each row\n  #     fill the buckets with water\n\
    \  #     if the bucket is full\n  #       lower the bucket\n  #       empty the\
    \ bucket\n  #       fill the bucket\n  #   return the number of times the buckets\
    \ were lowered\n  #\n  # fill the buckets\n  #   for each row\n  #     fill the\
    \ buckets with water\n  #     if the bucket is full\n  #       lower the bucket\n\
    \  #       empty the bucket\n  #       fill the bucket\n  #   return the number\
    \ of times the buckets were lowered\n  #\n  # fill the buckets\n  #   for each\
    \ row\n  #     fill the buckets with water\n  #     if the bucket is full\n  #\
    \       lower the bucket\n  #       empty the bucket\n  #       fill the bucket\n\
    \  #   return the number of times the buckets were lowered\n  #\n  # fill the\
    \ buckets\n  #   for each row\n  #     fill the buckets with water\n  #     if\
    \ the bucket is full\n  #       lower the bucket\n  #       empty the bucket\n\
    \  #       fill the bucket\n  #   return the number of times the buckets were\
    \ lowered\n  #", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1)\
    \ if row.count(1) > max_fill\n  end\n  max_fill\nend", "  return 0 if grid.empty?\n\
    \  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill / capacity\nend", "  max_fill = 0\n  grid.each do |row|\n \
    \   max_fill = [max_fill, row.sum].max\n  end\n  max_fill\nend", "  max_fill =\
    \ 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1)\
    \ if row.count(1) > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\n\
    end", "  grid.map { |row| row.sum / capacity }.max\nend", "  return 0 if grid.empty?\n\
    \  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill / capacity\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\n\
    end", "  # Fill the buckets with the water from the wells\n  # Return the number\
    \ of times the buckets were lowered\n  #\n  # Fill the buckets with the water\
    \ from the wells\n  # Return the number of times the buckets were lowered\n  #\n\
    \  # Fill the buckets with the water from the wells\n  # Return the number of\
    \ times the buckets were lowered\n  #\n  # Fill the buckets with the water from\
    \ the wells\n  # Return the number of times the buckets were lowered\n  #\n  #\
    \ Fill the buckets with the water from the wells\n  # Return the number of times\
    \ the buckets were lowered\n  #\n  # Fill the buckets with the water from the\
    \ wells\n  # Return the number of times the buckets were lowered\n  #\n  # Fill\
    \ the buckets with the water from the wells\n  # Return the number of times the\
    \ buckets were lowered\n  #\n  # Fill the buckets with the water from the wells\n\
    \  # Return the number of times the buckets were lowered\n  #\n  # Fill the buckets\
    \ with the water from the wells\n  # Return the number of times the buckets were\
    \ lowered\n  #\n  # Fill the buckets with the water from the wells\n  # Return\
    \ the number of times the buckets were lowered\n  #\n  # Fill the buckets with\
    \ the water from the wells\n  # Return the number of times the buckets were lowered\n\
    \  #\n  # Fill the buckets with the water from the wells\n  # Return the number\
    \ of times the buckets were lowered\n  #\n  # Fill the buckets with the water\
    \ from the wells\n  # Return the number of times the buckets were lowered\n  #\n\
    \  # Fill the buckets with the water from the wells\n  # Return the number of\
    \ times the buckets were lowered\n  #\n  # Fill the buckets with the water from\
    \ the wells\n  # Return the number of times the buckets were lowered\n  #\n  #\
    \ Fill the buckets with the water from the wells\n  # Return the number of times\
    \ the buckets were lowered\n  #\n  # Fill the buckets with the water from the\
    \ wells\n  # Return the number of times the buckets were lowered\n  #\n  # Fill\
    \ the buckets with the water from the wells\n  # Return the number of times the\
    \ buckets were lowered\n  #\n  # Fill the buckets with the water from the wells\n\
    \  # Return the number of times the buckets were lowered\n ", "  # fill the buckets\n\
    \  # if there is water left over, fill the next bucket\n  # if there is no water\
    \ left over, return the number of buckets filled\n  # if there is no water left\
    \ over, return the number of buckets filled\n  # if there is no water left over,\
    \ return the number of buckets filled\n  # if there is no water left over, return\
    \ the number of buckets filled\n  # if there is no water left over, return the\
    \ number of buckets filled\n  # if there is no water left over, return the number\
    \ of buckets filled\n  # if there is no water left over, return the number of\
    \ buckets filled\n  # if there is no water left over, return the number of buckets\
    \ filled\n  # if there is no water left over, return the number of buckets filled\n\
    \  # if there is no water left over, return the number of buckets filled\n  #\
    \ if there is no water left over, return the number of buckets filled\n  # if\
    \ there is no water left over, return the number of buckets filled\n  # if there\
    \ is no water left over, return the number of buckets filled\n  # if there is\
    \ no water left over, return the number of buckets filled\n  # if there is no\
    \ water left over, return the number of buckets filled\n  # if there is no water\
    \ left over, return the number of buckets filled\n  # if there is no water left\
    \ over, return the number of buckets filled\n  # if there is no water left over,\
    \ return the number of buckets filled\n  # if there is no water left over, return\
    \ the number of buckets filled\n  # if there is no water left over, return the\
    \ number of buckets filled\n  # if there is no water left over, return the number\
    \ of buckets filled\n  # if there is no water left over, return the number of\
    \ buckets filled\n  # if there is no water left over, return the number of buckets\
    \ filled\n  # if there is no water left over, return the number of buckets filled\n\
    \  # if there is no water left over, return the number of buckets filled\n  #\
    \ if there is no water left over, return the number of buckets filled\n  # if\
    \ there is no water left over, return the number of buckets filled\n  # if there\
    \ is no water left over, return the number of buckets filled\n  # if there is\
    \ no water left over, return the number of buckets", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  # fill each well to capacity\n  # return number of times\
    \ we had to fill\n  #\n  # fill_count = 0\n  # grid.each do |row|\n  #   row.each\
    \ do |well|\n  #     if well < capacity\n  #       fill_count += 1\n  #     end\n\
    \  #   end\n  # end\n  # fill_count\n  grid.map { |row| row.reduce(0) { |sum,\
    \ well| sum + capacity - well } }.reduce(:+)\nend", "  return 0 if grid.empty?\n\
    \  max_fill_helper(grid, capacity, 0, 0)\nend", "  # fill buckets\n  # lower buckets\n\
    \  # repeat until all wells are empty\n  # return number of times buckets were\
    \ lowered\n  #\n  # fill buckets\n  #   for each row\n  #     fill buckets until\
    \ full\n  #     if bucket is full\n  #       move to next row\n  # lower buckets\n\
    \  #   for each row\n  #     lower bucket\n  #     if bucket is empty\n  #   \
    \    move to next row\n  # repeat until all wells are empty\n  #   for each row\n\
    \  #     if row is not empty\n  #       return false\n  # return number of times\
    \ buckets were lowered\n  #\n  # fill buckets\n  #   for each row\n  #     fill\
    \ buckets until full\n  #     if bucket is full\n  #       move to next row\n\
    \  # lower buckets\n  #   for each row\n  #     lower bucket\n  #     if bucket\
    \ is empty\n  #       move to next row\n  # repeat until all wells are empty\n\
    \  #   for each row\n  #     if row is not empty\n  #       return false\n  #\
    \ return number of times buckets were lowered\n  #\n  # fill buckets\n  #   for\
    \ each row\n  #     fill buckets until full\n  #     if bucket is full\n  #  \
    \     move to next row\n  # lower buckets\n  #   for each row\n  #     lower bucket\n\
    \  #     if bucket is empty\n  #       move to next row\n  # repeat until all\
    \ wells are empty\n  #   for each row\n  #     if row is not empty\n  #      \
    \ return false\n  # return number of times buckets were lowered\n  #\n  # fill\
    \ buckets\n  #   for each row\n  #     fill buckets until full\n  #     if bucket\
    \ is full\n  #       move to next row\n  # lower buckets\n  #   for each row\n\
    \  #     lower bucket\n  #     if bucket is empty\n  #       move to next row\n\
    \  # repeat until all wells are empty\n  #   for each row\n  #     if row is not\
    \ empty\n  #       return false\n  # return number of times buckets were lowered\n\
    \  #\n  # fill buckets\n  #   for each row\n  #     fill buckets until full\n\
    \  #    ", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  max_fill = 0\n \
    \ grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  # fill each well\
    \ to capacity\n  # return the number of times we had to fill\n  #\n  # fill each\
    \ well to capacity\n  # return the number of times we had to fill\n  #\n  # fill\
    \ each well to capacity\n  # return the number of times we had to fill\n  #\n\
    \  # fill each well to capacity\n  # return the number of times we had to fill\n\
    \  #\n  # fill each well to capacity\n  # return the number of times we had to\
    \ fill\n  #\n  # fill each well to capacity\n  # return the number of times we\
    \ had to fill\n  #\n  # fill each well to capacity\n  # return the number of times\
    \ we had to fill\n  #\n  # fill each well to capacity\n  # return the number of\
    \ times we had to fill\n  #\n  # fill each well to capacity\n  # return the number\
    \ of times we had to fill\n  #\n  # fill each well to capacity\n  # return the\
    \ number of times we had to fill\n  #\n  # fill each well to capacity\n  # return\
    \ the number of times we had to fill\n  #\n  # fill each well to capacity\n  #\
    \ return the number of times we had to fill\n  #\n  # fill each well to capacity\n\
    \  # return the number of times we had to fill\n  #\n  # fill each well to capacity\n\
    \  # return the number of times we had to fill\n  #\n  # fill each well to capacity\n\
    \  # return the number of times we had to fill\n  #\n  # fill each well to capacity\n\
    \  # return the number of times we had to fill\n  #\n  # fill each well to capacity\n\
    \  # return the number of times we had to fill\n  #\n  # fill each well to capacity\n\
    \  # return the number of times we had to fill\n  #\n  # fill each well to capacity\n\
    \  # return the number of times we had to fill\n  #\n  # fill each well to capacity\n\
    \  # return the number of times we had to fill\n  #\n  # fill each well to capacity\n\
    \  # return the number of times we had to fill\n  #\n  # fill each well to capacity\n\
    \  # return the number of times we had to fill\n  #\n  # fill each well", "  #\
    \ find max value in grid\n  max = 0\n  grid.each do |row|\n    row.each do |col|\n\
    \      max = col if col > max\n    end\n  end\n  # fill each well to max\n  grid.each\
    \ do |row|\n    row.each do |col|\n      col = max if col < max\n    end\n  end\n\
    \  # count the number of times we fill the buckets\n  count = 0\n  grid.each do\
    \ |row|\n    row.each do |col|\n      count += col / capacity\n    end\n  end\n\
    \  count\nend", "  # find the max height of the grid\n  max_height = grid.map\
    \ { |row| row.count(1) }.max\n  # fill the buckets\n  buckets = Array.new(grid.length,\
    \ capacity)\n  # lower the buckets\n  lowers = 0\n  # fill the buckets\n  (0...max_height).each\
    \ do |height|\n    # fill the buckets\n    grid.each_with_index do |row, i|\n\
    \      buckets[i] -= 1 if row[height] == 1\n    end\n    # lower the buckets\n\
    \    lowers += 1 if buckets.any? { |b| b == 0 }\n  end\n  lowers\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill\nend", "  return 0 if grid.empty?\n  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill / capacity\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill\nend", "  max = 0\n  grid.each do |row|\n    max\
    \ = row.max if row.max > max\n  end\n  max / capacity\nend", "  max_fill = 0\n\
    \  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  return 0 if grid.empty?\n\
    \  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill / capacity\nend", "  max_fill = 0\n  grid.each do |row|\n \
    \   max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = row.reduce(:+) if row.reduce(:+) > max_fill\n  end\n  max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count('1') if\
    \ row.count('1') > max_fill\n  end\n  max_fill\nend", "  return 0 if grid.empty?\n\
    \  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill / capacity\nend", "  # fill the first row\n  grid[0].map! {\
    \ capacity }\n  # fill the rest of the rows\n  (1...grid.length).each do |row|\n\
    \    (0...grid[row].length).each do |col|\n      if grid[row][col] == 1\n    \
    \    grid[row][col] = [grid[row - 1][col], grid[row][col - 1]].min\n      end\n\
    \    end\n  end\n  grid[-1].max\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  # find\
    \ the max value in the grid\n  max = 0\n  grid.each do |row|\n    max = row.max\
    \ if row.max > max\n  end\n  # fill the grid with the max value\n  grid.each_with_index\
    \ do |row, i|\n    row.each_with_index do |col, j|\n      grid[i][j] = max\n \
    \   end\n  end\n  # fill the grid with the capacity value\n  grid.each_with_index\
    \ do |row, i|\n    row.each_with_index do |col, j|\n      grid[i][j] = capacity\
    \ if grid[i][j] == 0\n    end\n  end\n  # find the max value in the grid\n  max\
    \ = 0\n  grid.each do |row|\n    max = row.max if row.max > max\n  end\n  # fill\
    \ the grid with the max value\n  grid.each_with_index do |row, i|\n    row.each_with_index\
    \ do |col, j|\n      grid[i][j] = max\n    end\n  end\n  # fill the grid with\
    \ the capacity value\n  grid.each_with_index do |row, i|\n    row.each_with_index\
    \ do |col, j|\n      grid[i][j] = capacity if grid[i][j] == 0\n    end\n  end\n\
    \  # find the max value in the grid\n  max = 0\n  grid.each do |row|\n    max\
    \ = row.max if row.max > max\n  end\n  # fill the grid with the max value\n  grid.each_with_index\
    \ do |row, i|\n    row.each_with_index do |col, j|\n      grid[i][j] = max\n \
    \   end\n  end\n  # fill the grid with the capacity value\n  grid.each_with_index\
    \ do |row, i|\n    row.each_with_index do |col, j|\n      grid[i][j] = capacity\
    \ if grid[i][j] == 0\n    end\n  end\n  # find the max value in the grid\n  max\
    \ = 0\n  grid.each do |row|\n    max = row", "  # fill each well to capacity\n\
    \  # return the number of times we had to fill\n  # grid.map { |row| row.map {\
    \ |cell| cell == 1 ? capacity : 0 } }\n  # grid.map { |row| row.map { |cell| cell\
    \ == 1 ? capacity : 0 } }\n  # grid.map { |row| row.map { |cell| cell == 1 ? capacity\
    \ : 0 } }\n  # grid.map { |row| row.map { |cell| cell == 1 ? capacity : 0 } }\n\
    \  # grid.map { |row| row.map { |cell| cell == 1 ? capacity : 0 } }\n  # grid.map\
    \ { |row| row.map { |cell| cell == 1 ? capacity : 0 } }\n  # grid.map { |row|\
    \ row.map { |cell| cell == 1 ? capacity : 0 } }\n  # grid.map { |row| row.map\
    \ { |cell| cell == 1 ? capacity : 0 } }\n  # grid.map { |row| row.map { |cell|\
    \ cell == 1 ? capacity : 0 } }\n  # grid.map { |row| row.map { |cell| cell ==\
    \ 1 ? capacity : 0 } }\n  # grid.map { |row| row.map { |cell| cell == 1 ? capacity\
    \ : 0 } }\n  # grid.map { |row| row.map { |cell| cell == 1 ? capacity : 0 } }\n\
    \  # grid.map { |row| row.map { |cell| cell == 1 ? capacity : 0 } }\n  # grid.map\
    \ { |row| row.map { |cell| cell == 1 ? capacity : 0 } }\n  # grid.map { |row|\
    \ row.map { |cell| cell == 1 ? capacity : 0 } }\n  # grid.map { |row| row.map\
    \ { |cell| cell == 1 ? capacity : 0 } }\n  # grid.map { |row| row.map { |cell|\
    \ cell == 1 ? capacity : 0 } }\n  # grid.map { |row| row.map { |cell| cell ==\
    \ 1 ? capacity : 0 } }\n  # grid.map { |row| row.map { |cell| cell == 1 ? capacity\
    \ : 0", "  max_fill = 0\n  grid.each do |row|\n    row.each do |col|\n      max_fill\
    \ = col if col > max_fill\n    end\n  end\n  max_fill\nend", "  max_fill = 0\n\
    \  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  max_fill = 0\n \
    \ grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  # find\
    \ the max height of the grid\n  max_height = grid.map { |row| row.count(1) }.max\n\
    \  # for each height, find the number of buckets needed\n  (1..max_height).map\
    \ do |height|\n    # find the number of rows that have at least height 1s\n  \
    \  rows_with_height = grid.count { |row| row.count(1) >= height }\n    # find\
    \ the number of buckets needed for each row\n    buckets_needed = grid.map { |row|\
    \ row.count(1) / height }\n    # find the max number of buckets needed for all\
    \ rows\n    buckets_needed.max * rows_with_height\n  end.max\nend", "  return\
    \ 0 if grid.empty?\n  return 0 if grid.first.empty?\n  return 0 if capacity <\
    \ 1\n  return 0 if capacity > 10", "  max_fill = 0\n  grid.each do |row|\n   \
    \ max_fill = [max_fill, row.reduce(:+)].max\n  end\n  max_fill\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.sum].max\n  end\n  max_fill\nend", "  max = 0\n  grid.each\
    \ do |row|\n    max = row.max if row.max > max\n  end\n  max\nend", "  # fill\
    \ the buckets\n  # lower the buckets\n  # repeat until all wells are empty\n \
    \ # return the number of times the buckets were lowered\nend", "  max_fill = 0\n\
    \  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.sum\
    \ if row.sum > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\n\
    end", "  max = 0\n  grid.each do |row|\n    max = row.max if row.max > max\n \
    \ end\n  max\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1)\
    \ if row.count(1) > max_fill\n  end\n  max_fill\nend", "  max = 0\n  grid.each\
    \ do |row|\n    max = row.max if row.max > max\n  end\n  max\nend", "  # fill\
    \ the buckets\n  # lower the buckets\n  # repeat until all wells are empty\n \
    \ # return the number of times the buckets were lowered\n  #\n  # fill the buckets\n\
    \  # lower the buckets\n  # repeat until all wells are empty\n  # return the number\
    \ of times the buckets were lowered\n  #\n  # fill the buckets\n  # lower the\
    \ buckets\n  # repeat until all wells are empty\n  # return the number of times\
    \ the buckets were lowered\n  #\n  # fill the buckets\n  # lower the buckets\n\
    \  # repeat until all wells are empty\n  # return the number of times the buckets\
    \ were lowered\n  #\n  # fill the buckets\n  # lower the buckets\n  # repeat until\
    \ all wells are empty\n  # return the number of times the buckets were lowered\n\
    \  #\n  # fill the buckets\n  # lower the buckets\n  # repeat until all wells\
    \ are empty\n  # return the number of times the buckets were lowered\n  #\n  #\
    \ fill the buckets\n  # lower the buckets\n  # repeat until all wells are empty\n\
    \  # return the number of times the buckets were lowered\n  #\n  # fill the buckets\n\
    \  # lower the buckets\n  # repeat until all wells are empty\n  # return the number\
    \ of times the buckets were lowered\n  #\n  # fill the buckets\n  # lower the\
    \ buckets\n  # repeat until all wells are empty\n  # return the number of times\
    \ the buckets were lowered\n  #\n  # fill the buckets\n  # lower the buckets\n\
    \  # repeat until all wells are empty\n  # return the number of times the buckets\
    \ were lowered\n  #\n  # fill the buckets\n  # lower the buckets\n  # repeat until\
    \ all wells are empty\n  # return the number of times the buckets were lowered\n\
    \  #\n  # fill the buckets\n  # lower the buckets\n  # repeat until all wells\
    \ are empty\n  # return the number of times the buckets were lowered\n  #\n  #\
    \ fill the buckets\n  # lower the buckets\n  # repeat until all wells are empty\n\
    \  # return the number of times the buckets were lowered\n  #\n  # fill the buckets\n\
    \  # lower the buckets\n  # repeat until all wells are empty\n  # return the number\
    \ of times the buckets were lowered\n  #\n  # fill the buckets\n ", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  # fill the buckets\n  # lower the buckets\n  # repeat until\
    \ all wells are empty\n  # return the number of times the buckets were lowered\n\
    end", "  # find the max height\n  max_height = grid.map { |row| row.count(1) }.max\n\
    \  # fill each bucket to capacity\n  # count the number of times you fill the\
    \ bucket\n  # return the count\n  count = 0\n  max_height.times do |i|\n    grid.each\
    \ do |row|\n      if row[i] == 1\n        count += 1\n      end\n    end\n  end\n\
    \  count\nend", "  # find the max height of the grid\n  max_height = grid.max_by\
    \ { |row| row.count(1) }.count(1)\n  # initialize a new grid with the max height\n\
    \  new_grid = Array.new(grid.length) { Array.new(max_height, 0) }\n  # fill the\
    \ new grid with the wells\n  grid.each_with_index do |row, i|\n    row.each_with_index\
    \ do |cell, j|\n      new_grid[i][j] = cell\n    end\n  end\n  # fill the new\
    \ grid with the buckets\n  new_grid.each_with_index do |row, i|\n    row.each_with_index\
    \ do |cell, j|\n      if cell == 1\n        new_grid[i][j] = capacity\n      end\n\
    \    end\n  end\n  # initialize a counter for the number of times the buckets\
    \ are lowered\n  counter = 0\n  # loop through the new grid\n  new_grid.each_with_index\
    \ do |row, i|\n    row.each_with_index do |cell, j|\n      # if the cell is empty\n\
    \      if cell == 0\n        # check if the cell above is full\n        if new_grid[i\
    \ - 1][j] == capacity\n          # if so, empty it\n          new_grid[i - 1][j]\
    \ = 0\n          # increment the counter\n          counter += 1\n        end\n\
    \      end\n    end\n  end\n  # return the counter\n  counter\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  # fill the buckets with the max amount of water\n  # return\
    \ the number of buckets filled\n  #\n  # fill the buckets with the max amount\
    \ of water\n  # return the number of buckets filled\n  #\n  # fill the buckets\
    \ with the max amount of water\n  # return the number of buckets filled\n  #\n\
    \  # fill the buckets with the max amount of water\n  # return the number of buckets\
    \ filled\n  #\n  # fill the buckets with the max amount of water\n  # return the\
    \ number of buckets filled\n  #\n  # fill the buckets with the max amount of water\n\
    \  # return the number of buckets filled\n  #\n  # fill the buckets with the max\
    \ amount of water\n  # return the number of buckets filled\n  #\n  # fill the\
    \ buckets with the max amount of water\n  # return the number of buckets filled\n\
    \  #\n  # fill the buckets with the max amount of water\n  # return the number\
    \ of buckets filled\n  #\n  # fill the buckets with the max amount of water\n\
    \  # return the number of buckets filled\n  #\n  # fill the buckets with the max\
    \ amount of water\n  # return the number of buckets filled\n  #\n  # fill the\
    \ buckets with the max amount of water\n  # return the number of buckets filled\n\
    \  #\n  # fill the buckets with the max amount of water\n  # return the number\
    \ of buckets filled\n  #\n  # fill the buckets with the max amount of water\n\
    \  # return the number of buckets filled\n  #\n  # fill the buckets with the max\
    \ amount of water\n  # return the number of buckets filled\n  #\n  # fill the\
    \ buckets with the max amount of water\n  # return the number of buckets filled\n\
    \  #\n  # fill the buckets with the max amount of water\n  # return the number\
    \ of buckets filled\n  #\n  # fill the buckets with the max amount of water\n\
    \  # return the number of buckets filled\n  #\n  # fill the buckets with the max\
    \ amount of water\n  # return the number of buckets filled\n  #\n  # fill the\
    \ buckets with the max amount of water\n  # return the number of buckets filled\n\
    \  #\n  # fill the buckets with the max amount of water\n  # return the number\
    \ of buckets filled\n  #\n  # fill the buckets with the", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  # 1. find the max height of the grid\n  # 2. for\
    \ each height, find the number of wells that need to be filled\n  # 3. return\
    \ the sum of the number of wells that need to be filled\n  # 4. return the number\
    \ of times you need to lower the buckets\n  max_height = grid.max_by(&:length).length\n\
    \  max_height.times.reduce(0) do |sum, height|\n    sum + grid.count { |row| row.length\
    \ > height }\n  end\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  max_fill = 0\n \
    \ grid.each do |row|\n    max_fill = [max_fill, row.sum].max\n  end\n  max_fill\
    \ / capacity\nend", "  # find the max fill\n  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = row.sum if row.sum > max_fill\n  end\n  # return the number of\
    \ times we need to fill the buckets\n  max_fill / capacity\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill,\
    \ row.count(1)].max\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do\
    \ |row|\n    max_fill = row.sum if row.sum > max_fill\n  end\n  max_fill\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  return 0 if grid.empty?\n  max_fill = grid.max\n\
    \  return 0 if max_fill <= capacity\n  (max_fill / capacity) + (max_fill % capacity\
    \ > 0 ? 1 : 0)\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1)\
    \ if row.count(1) > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.sum if row.sum > max_fill\n  end\n  max_fill\n\
    end", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill\nend", "  # fill each well to capacity\n  # return\
    \ number of times we filled a well\n  # if we can't fill a well, return -1\n \
    \ #\n  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n\
    \  #\n  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n  #\
    \ [1,0,1,0,1]\n  #\n  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n\
    \  # [1,0,1,0,1]\n  #\n  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n  #\
    \ [1,0,1,0,1]\n  # [1,0,1,0,1]\n  #\n  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n\
    \  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n  #\n  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n  #\
    \ [1,0,1,0,1]\n  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n  #\n  # [1,0,1,0,1]\n  # [1,0,1,0,1]\n\
    \  # [1,0,1,", "  max = 0\n  grid.each do |row|\n    max = row.max if row.max\
    \ > max\n  end\n  max\nend", "  grid.map { |row| row.sum / capacity }.max\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  # grid.map { |row| row.reduce(:+) }.max\n  grid.map\
    \ { |row| row.sum }.max\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  max_fill = 0\n \
    \ grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill\nend", "  # fill the buckets\n  # find the max\n  # subtract\
    \ the max from each bucket\n  # repeat until all buckets are empty\n  # return\
    \ the number of times the buckets were filled\n  count = 0\n  while grid.flatten.any?\
    \ { |x| x > 0 }\n    count += 1\n    grid.each { |row| row.map! { |x| x - capacity\
    \ } }\n  end\n  count\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  max_fill = 0\n \
    \ grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\n\
    end", "  # fill the buckets\n  # lower the buckets\n  # repeat until all wells\
    \ are empty\n  # return the number of times the buckets were lowered\n  #\n  #\
    \ fill the buckets\n  #   for each well\n  #     fill the bucket with the number\
    \ of 1s in the well\n  #     set the well to 0\n  #\n  # lower the buckets\n \
    \ #   for each well\n  #     if the bucket is not empty\n  #       fill the well\
    \ with the bucket\n  #       empty the bucket\n  #\n  # repeat until all wells\
    \ are empty\n  #   for each well\n  #     if the well is not empty\n  #      \
    \ return false\n  #   return true\n  #\n  # return the number of times the buckets\
    \ were lowered\n  #   initialize a counter to 0\n  #   while the wells are not\
    \ empty\n  #     fill the buckets\n  #     lower the buckets\n  #     increment\
    \ the counter\n  #   return the counter\n  counter = 0\n  loop do\n    break if\
    \ fill_buckets(grid, capacity)\n    lower_buckets(grid, capacity)\n    counter\
    \ += 1\n  end\n  counter\nend", "  # fill each bucket to capacity\n  # then empty\
    \ each bucket into the next well\n  # repeat until all wells are empty\n  # return\
    \ the number of times a bucket was filled\n  #\n  # grid = [\n  #   [1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1],\n  #   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  #   [1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1],\n  #   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  #   [1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1],\n  #   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  #   [1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1],\n  #   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1],\n  #   [1, 1, 1,\
    \ 1, 1, 1, 1, 1, 1, 1],\n  #   [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]\n  # ]\n  # capacity\
    \ = 3\n  #\n  # bucket = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n  #\n  # bucket = [3,\
    \ 3, 3, 3, 3, 3, 3, 3, 3, 3]\n  #\n  # bucket = [3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n\
    \  # grid = [\n  #   [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n  #   [3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3],\n  #   [3, 3, 3, 3, 3, 3, 3, 3, 3, 3],\n  #   [3, 3, 3, 3, 3, 3,\
    \ 3, 3, 3, 3],\n  #   [3, 3, 3", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\nend", "  # fill\
    \ each well to capacity\n  # return the number of times you need to lower the\
    \ buckets\n  # if a well is already full, do not fill it\n  # if a well is already\
    \ empty, do not fill it\n  # if a well is partially full, fill it to capacity\n\
    \  # if a well is partially empty, fill it to capacity\n  # if a well is partially\
    \ full and partially empty, fill it to capacity\n  # if a well is partially full\
    \ and partially empty and the capacity is 1, fill it to capacity\n  # if a well\
    \ is partially full and partially empty and the capacity is 2, fill it to capacity\n\
    \  # if a well is partially full and partially empty and the capacity is 3, fill\
    \ it to capacity\n  # if a well is partially full and partially empty and the\
    \ capacity is 4, fill it to capacity\n  # if a well is partially full and partially\
    \ empty and the capacity is 5, fill it to capacity\n  # if a well is partially\
    \ full and partially empty and the capacity is 6, fill it to capacity\n  # if\
    \ a well is partially full and partially empty and the capacity is 7, fill it\
    \ to capacity\n  # if a well is partially full and partially empty and the capacity\
    \ is 8, fill it to capacity\n  # if a well is partially full and partially empty\
    \ and the capacity is 9, fill it to capacity\n  # if a well is partially full\
    \ and partially empty and the capacity is 10, fill it to capacity\n  # if a well\
    \ is partially full and partially empty and the capacity is 11, fill it to capacity\n\
    \  # if a well is partially full and partially empty and the capacity is 12, fill\
    \ it to capacity\n  # if a well is partially full and partially empty and the\
    \ capacity is 13, fill it to capacity\n  # if a well is partially full and partially\
    \ empty and the capacity is 14, fill it to capacity\n  # if a well is partially\
    \ full and partially empty and the capacity is 15, fill it to capacity\n  # if\
    \ a well is partially full and partially empty and the capacity is 16, fill it\
    \ to capacity\n  # if a well is partially full and partially empty and the capacity\
    \ is 17, fill it to capacity\n  # if a well is partially full and partially empty\
    \ and the capacity is 18, fill it to capacity\n  # if a well is partially full\
    \ and partially empty and the capacity is 19, fill it to", "  # find the max in\
    \ the row\n  # fill the bucket with the max\n  # subtract the max from the row\n\
    \  # repeat until all rows are empty\n  # return the number of times the bucket\
    \ was filled\n  count = 0\n  while grid.any? { |row| row.any? { |well| well >\
    \ 0 } }\n    grid.each do |row|\n      max = row.max\n      if max > 0\n     \
    \   row.map! { |well| well - max }\n        count += 1\n      end\n    end\n \
    \ end\n  count\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.sum\
    \ if row.sum > max_fill\n  end\n  max_fill\nend", "  # fill each well to capacity\n\
    \  # return the number of times you need to lower the buckets\n  # return the\
    \ number of times you need to lower the buckets\n  # return the number of times\
    \ you need to lower the buckets\n  # return the number of times you need to lower\
    \ the buckets\n  # return the number of times you need to lower the buckets\n\
    \  # return the number of times you need to lower the buckets\n  # return the\
    \ number of times you need to lower the buckets\n  # return the number of times\
    \ you need to lower the buckets\n  # return the number of times you need to lower\
    \ the buckets\n  # return the number of times you need to lower the buckets\n\
    \  # return the number of times you need to lower the buckets\n  # return the\
    \ number of times you need to lower the buckets\n  # return the number of times\
    \ you need to lower the buckets\n  # return the number of times you need to lower\
    \ the buckets\n  # return the number of times you need to lower the buckets\n\
    \  # return the number of times you need to lower the buckets\n  # return the\
    \ number of times you need to lower the buckets\n  # return the number of times\
    \ you need to lower the buckets\n  # return the number of times you need to lower\
    \ the buckets\n  # return the number of times you need to lower the buckets\n\
    \  # return the number of times you need to lower the buckets\n  # return the\
    \ number of times you need to lower the buckets\n  # return the number of times\
    \ you need to lower the buckets\n  # return the number of times you need to lower\
    \ the buckets\n  # return the number of times you need to lower the buckets\n\
    \  # return the number of times you need to lower the buckets\n  # return the\
    \ number of times you need to lower the buckets\n  # return the number of times\
    \ you need to lower the buckets\n  # return the number of times you need to lower\
    \ the buckets\n  # return the number of times you need to lower the buckets\n\
    \  # return the number of times you need to lower the buckets\n  # return the\
    \ number of times you need to lower the buckets\n  # return the number of times\
    \ you need to lower the buckets\n  # return the number of times you need to lower\
    \ the buckets\n  # return the number of times you need to lower the buckets\n\
    \  # return the number of times you need to lower the buckets", "  max_fill =\
    \ 0\n  grid.each do |row|\n    max_fill = row.sum if row.sum > max_fill\n  end\n\
    \  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1)\
    \ if row.count(1) > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend",
  "  # find the max value in the grid\n  # fill the buckets with the max value\n \
    \ # return the number of times you need to fill the buckets\n  max = grid.flatten.max\n\
    \  max_fill = capacity / max\n  max_fill\nend", "  max_fill = 0\n  grid.each do\
    \ |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend",
  "  return 0 if grid.empty?\n  grid.map! { |row| row.map { |cell| cell * capacity\
    \ } }\n  max_fill_helper(grid, capacity)\nend", "  # find the max height of the\
    \ wells\n  max_height = grid.max_by(&:length).length\n  # initialize the number\
    \ of times the bucket is lowered\n  lowers = 0\n  # iterate through the wells\n\
    \  (0...max_height).each do |height|\n    # iterate through the wells\n    grid.each\
    \ do |well|\n      # if the well is not empty\n      if well[height] == 1\n  \
    \      # lower the bucket\n        lowers += 1\n      end\n    end\n  end\n  #\
    \ return the number of times the bucket was lowered\n  lowers\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1)\
    \ if row.count(1) > max_fill\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.sum if row.sum > max_fill\n  end\n  max_fill\n\
    end", "  # find the max height of the wells\n  max_height = grid.max_by(&:length).length\n\
    \  # fill the wells\n  (0...max_height).each do |height|\n    # fill the wells\
    \ at this height\n    grid.each do |well|\n      # fill the well\n      well.fill(0,\
    \ height, capacity)\n    end\n  end\n  # return the number of times we filled\
    \ the wells\n  max_height\nend", "  # fill each well to capacity\n  # return the\
    \ number of times we filled the bucket\n  # fill the bucket\n  # lower the bucket\n\
    \  # fill the bucket\n  # lower the bucket\n  # fill the bucket\n  # lower the\
    \ bucket\n  # fill the bucket\n  # lower the bucket\n  # fill the bucket\n  #\
    \ lower the bucket\n  # fill the bucket\n  # lower the bucket\n  # fill the bucket\n\
    \  # lower the bucket\n  # fill the bucket\n  # lower the bucket\n  # fill the\
    \ bucket\n  # lower the bucket\n  # fill the bucket\n  # lower the bucket\n  #\
    \ fill the bucket\n  # lower the bucket\n  # fill the bucket\n  # lower the bucket\n\
    \  # fill the bucket\n  # lower the bucket\n  # fill the bucket\n  # lower the\
    \ bucket\n  # fill the bucket\n  # lower the bucket\n  # fill the bucket\n  #\
    \ lower the bucket\n  # fill the bucket\n  # lower the bucket\n  # fill the bucket\n\
    \  # lower the bucket\n  # fill the bucket\n  # lower the bucket\n  # fill the\
    \ bucket\n  # lower the bucket\n  # fill the bucket\n  # lower the bucket\n  #\
    \ fill the bucket\n  # lower the bucket\n  # fill the bucket\n  # lower the bucket\n\
    \  # fill the bucket\n  # lower the bucket\n  # fill the bucket\n  # lower the\
    \ bucket\n  # fill the bucket\n  # lower the bucket\n  # fill the bucket\n  #\
    \ lower the bucket\n  # fill the bucket\n  # lower the bucket\n  # fill the bucket\n\
    \  # lower the bucket\n  # fill the bucket\n  # lower the bucket\n  # fill the\
    \ bucket\n  # lower the bucket\n  # fill the bucket\n  # lower the bucket\n  #\
    \ fill the bucket\n  # lower the bucket\n  # fill the bucket\n  # lower the bucket\n\
    \  # fill the bucket\n  # lower the bucket\n  # fill the bucket\n  # lower the\
    \ bucket\n  # fill the bucket\n  # lower the bucket\n  # fill the bucket\n  #\
    \ lower the bucket\n  # fill the bucket\n  # lower the bucket\n  # fill the bucket\n\
    \  # lower the bucket\n  # fill the bucket\n  # lower the bucket", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n\
    \  max_fill\nend", "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill,\
    \ row.count(1)].max\n  end\n  max_fill\nend", "  max_fill = 0\n  grid.each do\
    \ |row|\n    max_fill = [max_fill, row.count(1)].max\n  end\n  max_fill\nend",
  "  max_fill = 0\n  grid.each do |row|\n    max_fill = [max_fill, row.count(1)].max\n\
    \  end\n  max_fill\nend", "  max = 0\n  grid.each do |row|\n    max = row.max\
    \ if row.max > max\n  end\n  max\nend", "  max_fill = 0\n  grid.each do |row|\n\
    \    max_fill = row.sum if row.sum > max_fill\n  end\n  max_fill\nend", "  max_fill\
    \ = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n\
    \  end\n  max_fill\nend", "  return 0 if grid.empty?\n  max_fill = 0\n  grid.each\
    \ do |row|\n    max_fill = row.count(1) if row.count(1) > max_fill\n  end\n  max_fill\
    \ / capacity\nend", "  return 0 if grid.empty?\n  return 0 if grid.first.empty?\n\
    \  return 0 if capacity < 1", "  max_fill = 0\n  grid.each do |row|\n    max_fill\
    \ = [max_fill, row.count(1)].max\n  end\n  max_fill\nend", "  return 0 if grid.empty?\n\
    \  max_fill = 0\n  grid.each do |row|\n    max_fill = row.count(1) if row.count(1)\
    \ > max_fill\n  end\n  max_fill\nend", "  # Fill each well to capacity\n  grid.map!\
    \ { |row| row.map { |well| well == 1 ? capacity : 0 } }\n  # Fill each row to\
    \ capacity\n  grid.map! { |row| row.reduce(:+) > capacity ? row.map { capacity\
    \ } : row }\n  # Fill each column to capacity\n  grid.transpose.map! { |col| col.reduce(:+)\
    \ > capacity ? col.map { capacity } : col }\n  grid.transpose\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
