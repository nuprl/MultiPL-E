name: HumanEval_127_intersection
language: rb
prompt: "# You are given two intervals,\n# where each interval is a pair of integers.\
  \ For example, interval = (start, end) = (1, 2).\n# The given intervals are closed\
  \ which means that the interval (start, end)\n# includes both start and end.\n#\
  \ For each given interval, it is assumed that its start is less or equal its end.\n\
  # Your task is to determine whether the length of intersection of these two \n#\
  \ intervals is a prime number.\n# Example, the intersection of the intervals (1,\
  \ 3), (2, 4) is (2, 3)\n# which its length is 1, which not a prime number.\n# If\
  \ the length of the intersection is a prime number, return \"YES\",\n# otherwise,\
  \ return \"NO\".\n# If the two intervals don't intersect, return \"NO\".\n# [input/output]\
  \ samples:\ndef intersection(interval1, interval2)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_intersection\n\
  \    candidate = method(:intersection)\n    assert_equal(\"NO\", candidate.call([1,\
  \ 2], [2, 3]))\n    assert_equal(\"NO\", candidate.call([-1, 1], [0, 4]))\n    assert_equal(\"\
  YES\", candidate.call([-3, -1], [-5, 5]))\n    assert_equal(\"YES\", candidate.call([-2,\
  \ 2], [-4, 0]))\n    assert_equal(\"NO\", candidate.call([-11, 2], [-1, -1]))\n\
  \    assert_equal(\"NO\", candidate.call([1, 2], [3, 5]))\n    assert_equal(\"NO\"\
  , candidate.call([1, 2], [1, 2]))\n    assert_equal(\"NO\", candidate.call([-2,\
  \ -2], [-3, -2]))\n  end\nend\n"
completions: ["  return \"NO\" if interval1[1] < interval2[0] || interval2[1] < interval1[0]\n\
    \  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  (start..finish).to_a.length\nend", "  # check if the intervals intersect\n\
    \  if interval1[1] < interval2[0] || interval2[1] < interval1[0]\n    return \"\
    NO\"\n  end\n  # find the intersection\n  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  # check if the length of the intersection\
    \ is prime\n  if (start..finish).count.prime?\n    return \"YES\"\n  else\n  \
    \  return \"NO\"\n  end\nend", "  if interval1[0] > interval2[1] || interval2[0]\
    \ > interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  if start == finish\n    return\
    \ \"NO\"\n  end\n  if start > finish\n    return \"NO\"\n  end\n  if is_prime(finish\
    \ - start + 1)\n    return \"YES\"\n  else\n    return \"NO\"\n  end\nend", " \
    \ start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  return nil if start > finish\n  [start, finish]\nend", "  if interval1[0] >\
    \ interval2[1] || interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  if\
    \ interval1[0] > interval2[0]\n    start = interval1[0]\n  else\n    start = interval2[0]\n\
    \  end\n  if interval1[1] < interval2[1]\n    finish = interval1[1]\n  else\n\
    \    finish = interval2[1]\n  end\n  if start == finish\n    return \"YES\"\n\
    \  end\n  if start == finish - 1\n    return \"NO\"\n  end\n  if start == finish\
    \ - 2\n    return \"YES\"\n  end\n  if start == finish - 3\n    return \"NO\"\n\
    \  end\n  if start == finish - 4\n    return \"YES\"\n  end\n  if start == finish\
    \ - 5\n    return \"NO\"\n  end\n  if start == finish - 6\n    return \"YES\"\n\
    \  end\n  if start == finish - 7\n    return \"NO\"\n  end\n  if start == finish\
    \ - 8\n    return \"YES\"\n  end\n  if start == finish - 9\n    return \"NO\"\n\
    \  end\n  if start == finish - 10\n    return \"YES\"\n  end\n  if start == finish\
    \ - 11\n    return \"NO\"\n  end\n  if start == finish - 12\n    return \"YES\"\
    \n  end\n  if start == finish - 13\n    return \"NO\"\n  end\n  if start == finish\
    \ - 14\n    return \"YES\"\n  end\n  if start == finish - 15\n    return \"NO\"\
    \n  end\n  if start == finish - 16\n    return \"YES\"\n  end\n  if start == finish\
    \ - 17\n    return \"NO\"\n  end\n  if start == finish - 18\n    return \"YES\"\
    \n  end\n  if start == finish - 19\n    return \"NO\"\n  end\n  if start == finish\
    \ - 20\n    return \"YES\"\n  end\n  if start == finish - 21\n    return \"NO\"\
    \n  end\n  if start == finish - 22\n    return \"YES\"\n  end\n  if start == finish\
    \ - 23\n    return \"", "  start = [interval1[0], interval2[0]].max\n  finish\
    \ = [interval1[1], interval2[1]].min\n  return [start, finish] if start <= finish\n\
    \  nil\nend", "  # your code here\nend", "  if interval1[0] <= interval2[0]\n\
    \    start = interval2[0]\n  else\n    start = interval1[0]\n  end\n  if interval1[1]\
    \ <= interval2[1]\n    finish = interval1[1]\n  else\n    finish = interval2[1]\n\
    \  end\n  if start > finish\n    return \"NO\"\n  end\n  return (start..finish).to_a.length\n\
    end", "  start = [interval1[0], interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n\
    \  (start..ending).to_a\nend", "  if interval1[0] > interval2[1] || interval2[0]\
    \ > interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n\
    \  ending = [interval1[1], interval2[1]].min\n  length = ending - start + 1\n\
    \  if length == 1\n    return \"NO\"\n  end\n  if length == 2\n    return \"YES\"\
    \n  end\n  if length % 2 == 0\n    return \"NO\"\n  end\n  (3..Math.sqrt(length)).each\
    \ do |i|\n    if length % i == 0\n      return \"NO\"\n    end\n  end\n  return\
    \ \"YES\"\nend", "  start = [interval1[0], interval2[0]].max\n  ending = [interval1[1],\
    \ interval2[1]].min\n  (start..ending).to_a\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  return nil if start > finish\n\
    \  [start, finish]\nend", "  start = [interval1[0], interval2[0]].max\n  finish\
    \ = [interval1[1], interval2[1]].min\n  [start, finish]\nend", "  # your code\
    \ here\nend", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  (start..finish).to_a\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  return nil if start > finish\n\
    \  [start, finish]\nend", "  start = [interval1[0], interval2[0]].max\n  finish\
    \ = [interval1[1], interval2[1]].min\n  return \"NO\" if start > finish\n  (start..finish).count\n\
    end", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  (start..finish).to_a\nend", "  # your code here\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  return \"\
    NO\" if start > finish\n  (start..finish).count\nend", "  if interval1[0] > interval2[1]\
    \ || interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0],\
    \ interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n  if start ==\
    \ ending\n    return \"NO\"\n  end\n  if (start..ending).to_a.length.prime?\n\
    \    return \"YES\"\n  else\n    return \"NO\"\n  end\nend", "  # your code here\n\
    \  if interval1[0] > interval2[1] || interval2[0] > interval1[1]\n    return \"\
    NO\"\n  end\n  if interval1[0] < interval2[0]\n    start = interval2[0]\n  else\n\
    \    start = interval1[0]\n  end\n  if interval1[1] < interval2[1]\n    finish\
    \ = interval1[1]\n  else\n    finish = interval2[1]\n  end\n  if start == finish\n\
    \    return \"NO\"\n  end\n  if start == finish - 1\n    return \"YES\"\n  end\n\
    \  if start == finish - 2\n    return \"NO\"\n  end\n  if start == finish - 3\n\
    \    return \"YES\"\n  end\n  if start == finish - 4\n    return \"NO\"\n  end\n\
    \  if start == finish - 5\n    return \"YES\"\n  end\n  if start == finish - 6\n\
    \    return \"NO\"\n  end\n  if start == finish - 7\n    return \"YES\"\n  end\n\
    \  if start == finish - 8\n    return \"NO\"\n  end\n  if start == finish - 9\n\
    \    return \"YES\"\n  end\n  if start == finish - 10\n    return \"NO\"\n  end\n\
    \  if start == finish - 11\n    return \"YES\"\n  end\n  if start == finish -\
    \ 12\n    return \"NO\"\n  end\n  if start == finish - 13\n    return \"YES\"\n\
    \  end\n  if start == finish - 14\n    return \"NO\"\n  end\n  if start == finish\
    \ - 15\n    return \"YES\"\n  end\n  if start == finish - 16\n    return \"NO\"\
    \n  end\n  if start == finish - 17\n    return \"YES\"\n  end\n  if start == finish\
    \ - 18\n    return \"NO\"\n  end\n  if start == finish - 19\n    return \"YES\"\
    \n  end\n  if start == finish - 20\n    return \"NO\"\n  end\n  if start == finish\
    \ - 21\n    return \"YES\"\n  end\n  if start == finish - 22\n    return \"NO\"\
    \n  end\n  if start == finish", "  # your code here\nend", "  # your code here\n\
    end", "    if interval1[0] > interval2[1] || interval2[0] > interval1[1]\n   \
    \     return \"NO\"\n    else\n        start = [interval1[0], interval2[0]].max\n\
    \        finish = [interval1[1], interval2[1]].min\n        if start == finish\n\
    \            return \"YES\"\n        else\n            return \"NO\"\n       \
    \ end\n    end\nend", "  # your code here\nend", "  if interval1[0] > interval2[1]\
    \ || interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  length = finish\
    \ - start + 1\n  if length == 1\n    return \"NO\"\n  end\n  if length == 2\n\
    \    return \"YES\"\n  end\n  (2..Math.sqrt(length)).each do |i|\n    if length\
    \ % i == 0\n      return \"NO\"\n    end\n  end\n  return \"YES\"\nend", "  start\
    \ = [interval1[0], interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n\
    \  return [start, ending]\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  return [start, finish] if start\
    \ <= finish\n  nil\nend", "  return \"NO\" if interval1[1] < interval2[0] || interval2[1]\
    \ < interval1[0]\n  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  (start..finish).to_a\nend", "  [interval1, interval2].sort_by!\
    \ { |interval| interval[0] }\n  return \"NO\" if interval1[1] < interval2[0]\n\
    \  return \"NO\" if interval2[1] < interval1[0]\n  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  length = finish - start + 1\n\
    \  return \"YES\" if length == 1\n  (2..length / 2).each do |i|\n    return \"\
    NO\" if length % i == 0\n  end\n  \"YES\"\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  return [start, finish] if start\
    \ <= finish\n  nil\nend", "  start = [interval1[0], interval2[0]].max\n  ending\
    \ = [interval1[1], interval2[1]].min\n  (start..ending).to_a\nend", "  if interval1[0]\
    \ > interval2[1] || interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  start\
    \ = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  length = finish - start + 1\n  if length < 2\n    return \"NO\"\n  end\n  if\
    \ length == 2\n    return \"YES\"\n  end\n  if length % 2 == 0\n    return \"\
    NO\"\n  end\n  for i in 3..(length/2)\n    if length % i == 0\n      return \"\
    NO\"\n    end\n  end\n  return \"YES\"\nend", "  return \"NO\" if interval1[1]\
    \ < interval2[0] || interval2[1] < interval1[0]\n  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  (start..finish).to_a\nend", " \
    \ if interval1[0] > interval2[1] || interval2[0] > interval1[1]\n    return \"\
    NO\"\n  end\n  if interval1[0] < interval2[0]\n    start = interval2[0]\n  else\n\
    \    start = interval1[0]\n  end\n  if interval1[1] < interval2[1]\n    finish\
    \ = interval1[1]\n  else\n    finish = interval2[1]\n  end\n  if start == finish\n\
    \    return \"NO\"\n  end\n  if start == finish - 1\n    return \"YES\"\n  end\n\
    \  if start == finish - 2\n    return \"NO\"\n  end\n  if start == finish - 3\n\
    \    return \"YES\"\n  end\n  if start == finish - 4\n    return \"NO\"\n  end\n\
    \  if start == finish - 5\n    return \"YES\"\n  end\n  if start == finish - 6\n\
    \    return \"NO\"\n  end\n  if start == finish - 7\n    return \"YES\"\n  end\n\
    \  if start == finish - 8\n    return \"NO\"\n  end\n  if start == finish - 9\n\
    \    return \"NO\"\n  end\n  if start == finish - 10\n    return \"NO\"\n  end\n\
    \  if start == finish - 11\n    return \"YES\"\n  end\n  if start == finish -\
    \ 12\n    return \"NO\"\n  end\n  if start == finish - 13\n    return \"YES\"\n\
    \  end\n  if start == finish - 14\n    return \"NO\"\n  end\n  if start == finish\
    \ - 15\n    return \"NO\"\n  end\n  if start == finish - 16\n    return \"NO\"\
    \n  end\n  if start == finish - 17\n    return \"YES\"\n  end\n  if start == finish\
    \ - 18\n    return \"NO\"\n  end\n  if start == finish - 19\n    return \"YES\"\
    \n  end\n  if start == finish - 20\n    return \"NO\"\n  end\n  if start == finish\
    \ - 21\n    return \"NO\"\n  end\n  if start == finish - 22\n    return \"NO\"\
    \n  end\n  if start == finish - 23\n    return \"", "  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  return \"\
    NO\" if start > finish\n  (start..finish).count\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n  (start..ending).to_a\n\
    end", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  return [start, finish] if start <= finish\n  nil\nend", "  # your code here\n\
    end", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  return nil if start > finish\n  [start, finish]\nend", "  # your code here\n\
    end", "  arr = []\n  arr << interval1[0] if interval1[0] >= interval2[0] && interval1[0]\
    \ <= interval2[1]\n  arr << interval1[1] if interval1[1] >= interval2[0] && interval1[1]\
    \ <= interval2[1]\n  arr << interval2[0] if interval2[0] >= interval1[0] && interval2[0]\
    \ <= interval1[1]\n  arr << interval2[1] if interval2[1] >= interval1[0] && interval2[1]\
    \ <= interval1[1]\n  arr.sort!\n  arr\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  return nil if start > finish\n\
    \  [start, finish]\nend", "  if interval1[0] > interval2[1] || interval2[0] >\
    \ interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  if start == finish\n    return\
    \ \"NO\"\n  end\n  if is_prime(finish - start)\n    return \"YES\"\n  else\n \
    \   return \"NO\"\n  end\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  ending = [interval1[1], interval2[1]].min\n  return \"NO\" if start > ending\n\
    \  (start..ending).size\nend", "  start = [interval1[0], interval2[0]].max\n \
    \ finish = [interval1[1], interval2[1]].min\n  return [start, finish] if start\
    \ <= finish\n  nil\nend", "  if interval1[0] > interval2[1] || interval2[0] >\
    \ interval1[1]\n    return \"NO\"\n  else\n    start = [interval1[0], interval2[0]].max\n\
    \    finish = [interval1[1], interval2[1]].min\n    length = finish - start +\
    \ 1\n    if length == 1\n      return \"NO\"\n    else\n      return \"YES\" if\
    \ is_prime(length)\n      return \"NO\"\n    end\n  end\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  (start..finish).to_a\n\
    end", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  return [start, finish] if start <= finish\n  nil\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  return [start,\
    \ finish] if start <= finish\n  nil\nend", "  if interval1[0] > interval2[1] ||\
    \ interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  if interval1[0] > interval2[0]\n\
    \    start = interval1[0]\n  else\n    start = interval2[0]\n  end\n  if interval1[1]\
    \ < interval2[1]\n    finish = interval1[1]\n  else\n    finish = interval2[1]\n\
    \  end\n  if start == finish\n    return \"NO\"\n  end\n  if start == 2\n    return\
    \ \"YES\"\n  end\n  if start % 2 == 0\n    start += 1\n  end\n  while start <\
    \ finish\n    if finish % start == 0\n      return \"NO\"\n    end\n    start\
    \ += 2\n  end\n  return \"YES\"\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  return nil if start > finish\n\
    \  [start, finish]\nend", "  # your code here\nend", "  if interval1[0] > interval2[1]\
    \ || interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  length = finish\
    \ - start + 1\n  if length == 1\n    return \"NO\"\n  end\n  if length == 2\n\
    \    return \"YES\"\n  end\n  (2..Math.sqrt(length)).each do |i|\n    if length\
    \ % i == 0\n      return \"NO\"\n    end\n  end\n  return \"YES\"\nend", "  #\
    \ your code here\nend", "  start = [interval1[0], interval2[0]].max\n  ending\
    \ = [interval1[1], interval2[1]].min\n  [start, ending]\nend", "  # your code\
    \ here\nend", "  return \"NO\" if interval1[1] < interval2[0] || interval2[1]\
    \ < interval1[0]\n  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  return \"NO\" if start == finish\n  (start..finish).count.prime?\
    \ ? \"YES\" : \"NO\"\nend", "  if interval1[0] > interval2[1] || interval2[0]\
    \ > interval1[1]\n    return \"NO\"\n  else\n    start = [interval1[0], interval2[0]].max\n\
    \    ending = [interval1[1], interval2[1]].min\n    length = ending - start +\
    \ 1\n    return \"YES\" if is_prime?(length)\n    return \"NO\"\n  end\nend",
  "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  return [start, finish] if start <= finish\n  return false\nend", "  # your\
    \ code here\nend", "  if interval1[0] > interval2[1] || interval2[0] > interval1[1]\n\
    \    return \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n  finish\
    \ = [interval1[1], interval2[1]].min\n  if start == finish\n    return \"NO\"\n\
    \  end\n  if (start..finish).to_a.length.prime?\n    return \"YES\"\n  else\n\
    \    return \"NO\"\n  end\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  return \"NO\" if start > finish\n\
    \  (start..finish).size.prime? ? \"YES\" : \"NO\"\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n  if start >\
    \ ending\n    return \"NO\"\n  else\n    return \"YES\" if (start..ending).count.prime?\n\
    \    return \"NO\"\n  end\nend", "  if interval1[0] > interval2[1] || interval2[0]\
    \ > interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  if start == finish\n    return\
    \ \"NO\"\n  end\n  if is_prime(finish - start)\n    return \"YES\"\n  else\n \
    \   return \"NO\"\n  end\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  return \"NO\" if start > finish\n\
    \  (start..finish).size.prime? ? \"YES\" : \"NO\"\nend", "  if interval1[0] >\
    \ interval2[1] || interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  if\
    \ interval1[0] < interval2[0]\n    start = interval2[0]\n  else\n    start = interval1[0]\n\
    \  end\n  if interval1[1] < interval2[1]\n    finish = interval1[1]\n  else\n\
    \    finish = interval2[1]\n  end\n  if start == finish\n    return \"NO\"\n \
    \ end\n  if is_prime(finish - start)\n    return \"YES\"\n  else\n    return \"\
    NO\"\n  end\nend", "  if interval1[0] > interval2[1] || interval2[0] > interval1[1]\n\
    \    return \"NO\"\n  end\n  if interval1[0] > interval2[0]\n    start = interval1[0]\n\
    \  else\n    start = interval2[0]\n  end\n  if interval1[1] < interval2[1]\n \
    \   finish = interval1[1]\n  else\n    finish = interval2[1]\n  end\n  if start\
    \ == finish\n    return \"YES\"\n  end\n  if start == finish - 1\n    return \"\
    NO\"\n  end\n  if start == finish - 2\n    return \"YES\"\n  end\n  if start ==\
    \ finish - 3\n    return \"NO\"\n  end\n  if start == finish - 4\n    return \"\
    YES\"\n  end\n  if start == finish - 5\n    return \"NO\"\n  end\n  if start ==\
    \ finish - 6\n    return \"YES\"\n  end\n  if start == finish - 7\n    return\
    \ \"NO\"\n  end\n  if start == finish - 8\n    return \"YES\"\n  end\n  if start\
    \ == finish - 9\n    return \"NO\"\n  end\n  if start == finish - 10\n    return\
    \ \"YES\"\n  end\n  if start == finish - 11\n    return \"NO\"\n  end\n  if start\
    \ == finish - 12\n    return \"YES\"\n  end\n  if start == finish - 13\n    return\
    \ \"NO\"\n  end\n  if start == finish - 14\n    return \"YES\"\n  end\n  if start\
    \ == finish - 15\n    return \"NO\"\n  end\n  if start == finish - 16\n    return\
    \ \"YES\"\n  end\n  if start == finish - 17\n    return \"NO\"\n  end\n  if start\
    \ == finish - 18\n    return \"YES\"\n  end\n  if start == finish - 19\n    return\
    \ \"NO\"\n  end\n  if start == finish - 20\n    return \"YES\"\n  end\n  if start\
    \ == finish - 21\n    return \"NO\"\n  end\n  if start == finish - 22\n    return\
    \ \"YES\"\n  end\n  if start == finish - 23\n    return \"", "  # your code here\n\
    end", "  return \"NO\" if interval1[1] < interval2[0] || interval2[1] < interval1[0]\n\
    \  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  (start..finish).to_a.length\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  return nil if start > finish\n\
    \  [start, finish]\nend", "  if interval1[0] > interval2[1] || interval2[0] >\
    \ interval1[1]\n    return \"NO\"\n  end\n  if interval1[0] > interval2[0]\n \
    \   start = interval1[0]\n  else\n    start = interval2[0]\n  end\n  if interval1[1]\
    \ < interval2[1]\n    finish = interval1[1]\n  else\n    finish = interval2[1]\n\
    \  end\n  if start == finish\n    return \"YES\"\n  end\n  if start == finish\
    \ - 1\n    return \"NO\"\n  end\n  if start == finish - 2\n    return \"YES\"\n\
    \  end\n  if start == finish - 3\n    return \"NO\"\n  end\n  if start == finish\
    \ - 4\n    return \"YES\"\n  end\n  if start == finish - 5\n    return \"NO\"\n\
    \  end\n  if start == finish - 6\n    return \"YES\"\n  end\n  if start == finish\
    \ - 7\n    return \"NO\"\n  end\n  if start == finish - 8\n    return \"YES\"\n\
    \  end\n  if start == finish - 9\n    return \"NO\"\n  end\n  if start == finish\
    \ - 10\n    return \"YES\"\n  end\n  if start == finish - 11\n    return \"NO\"\
    \n  end\n  if start == finish - 12\n    return \"YES\"\n  end\n  if start == finish\
    \ - 13\n    return \"NO\"\n  end\n  if start == finish - 14\n    return \"YES\"\
    \n  end\n  if start == finish - 15\n    return \"NO\"\n  end\n  if start == finish\
    \ - 16\n    return \"YES\"\n  end\n  if start == finish - 17\n    return \"NO\"\
    \n  end\n  if start == finish - 18\n    return \"YES\"\n  end\n  if start == finish\
    \ - 19\n    return \"NO\"\n  end\n  if start == finish - 20\n    return \"YES\"\
    \n  end\n  if start == finish - 21\n    return \"NO\"\n  end\n  if start == finish\
    \ - 22\n    return \"YES\"\n  end\n  if start == finish - 23\n    return \"",
  "  start = [interval1[0], interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n\
    \  return [start, ending]\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  (start..finish).to_a\nend", " \
    \ return \"NO\" if interval1[1] < interval2[0] || interval2[1] < interval1[0]\n\
    \  start = [interval1[0], interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n\
    \  return \"NO\" if start == ending\n  (start..ending).to_a.length.prime? ? \"\
    YES\" : \"NO\"\nend", "  if interval1[0] > interval2[1] || interval2[0] > interval1[1]\n\
    \    return \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n  finish\
    \ = [interval1[1], interval2[1]].min\n  length = finish - start + 1\n  if length\
    \ == 1\n    return \"NO\"\n  end\n  if length == 2\n    return \"YES\"\n  end\n\
    \  if length % 2 == 0\n    return \"NO\"\n  end\n  (3..Math.sqrt(length)).each\
    \ do |i|\n    if length % i == 0\n      return \"NO\"\n    end\n  end\n  return\
    \ \"YES\"\nend", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  return [start, finish] if start <= finish\n  nil\nend",
  "    start = [interval1[0], interval2[0]].max\n    finish = [interval1[1], interval2[1]].min\n\
    \    return (start..finish).to_a\nend", "  if interval1[0] >= interval2[1] ||\
    \ interval2[0] >= interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  length = finish\
    \ - start\n  if length == 0\n    return \"NO\"\n  end\n  if length == 1\n    return\
    \ \"YES\"\n  end\n  if length == 2\n    return \"NO\"\n  end\n  if length % 2\
    \ == 0\n    return \"NO\"\n  end\n  (3..Math.sqrt(length)).each do |i|\n    if\
    \ length % i == 0\n      return \"NO\"\n    end\n  end\n  return \"YES\"\nend",
  "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  return [start, finish] if start <= finish\n  nil\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n  return \"\
    NO\" if start > ending\n  return \"YES\" if (start..ending).count == 2\n  (start..ending).count.prime?\
    \ ? \"YES\" : \"NO\"\nend", "  (interval1[0]..interval1[1]).to_a & (interval2[0]..interval2[1]).to_a\n\
    end", "  # your code here\nend", "  return \"NO\" if interval1[1] < interval2[0]\
    \ || interval2[1] < interval1[0]\n  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  (start..finish).to_a.length\n\
    end", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  return [start, finish] if start <= finish\n  nil\nend", "  if interval1[0]\
    \ <= interval2[0] && interval2[0] <= interval1[1]\n    return [interval2[0], interval1[1]]\n\
    \  elsif interval2[0] <= interval1[0] && interval1[0] <= interval2[1]\n    return\
    \ [interval1[0], interval2[1]]\n  else\n    return nil\n  end\nend", "  (interval1[0]..interval1[1]).to_a\
    \ & (interval2[0]..interval2[1]).to_a\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  return nil if start > finish\n\
    \  [start, finish]\nend", "  return \"NO\" if interval1[1] < interval2[0] || interval2[1]\
    \ < interval1[0]\n  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  return \"NO\" if start == finish\n  (start..finish).count.prime?\
    \ ? \"YES\" : \"NO\"\nend", "  # your code here\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n  (start..ending).to_a\n\
    end", "  return \"NO\" if interval1[1] < interval2[0] || interval2[1] < interval1[0]\n\
    \  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  (start..finish).to_a.size\nend", "  if interval1[0] > interval2[1] || interval2[0]\
    \ > interval1[1]\n    return \"NO\"\n  end\n  intersection = [interval1[0], interval2[0]].max..[interval1[1],\
    \ interval2[1]].min\n  if intersection.size == 1\n    return \"YES\"\n  end\n\
    \  return \"NO\"\nend", "  if interval1[0] > interval2[1] || interval2[0] > interval1[1]\n\
    \    return \"NO\"\n  else\n    start = [interval1[0], interval2[0]].max\n   \
    \ finish = [interval1[1], interval2[1]].min\n    length = finish - start + 1\n\
    \    return \"YES\" if is_prime?(length)\n    return \"NO\"\n  end\nend", "  #\
    \ interval1 = (1, 3)\n  # interval2 = (2, 4)\n  # intersection = (2, 3)\n  # length\
    \ = 1\n  # return \"NO\"\n  # interval1 = (1, 3)\n  # interval2 = (2, 4)\n  #\
    \ intersection = (2, 3)\n  # length = 1\n  # return \"NO\"\n  # interval1 = (1,\
    \ 3)\n  # interval2 = (2, 4)\n  # intersection = (2, 3)\n  # length = 1\n  # return\
    \ \"NO\"\n  # interval1 = (1, 3)\n  # interval2 = (2, 4)\n  # intersection = (2,\
    \ 3)\n  # length = 1\n  # return \"NO\"\n  # interval1 = (1, 3)\n  # interval2\
    \ = (2, 4)\n  # intersection = (2, 3)\n  # length = 1\n  # return \"NO\"\n  #\
    \ interval1 = (1, 3)\n  # interval2 = (2, 4)\n  # intersection = (2, 3)\n  # length\
    \ = 1\n  # return \"NO\"\n  # interval1 = (1, 3)\n  # interval2 = (2, 4)\n  #\
    \ intersection = (2, 3)\n  # length = 1\n  # return \"NO\"\n  # interval1 = (1,\
    \ 3)\n  # interval2 = (2, 4)\n  # intersection = (2, 3)\n  # length = 1\n  # return\
    \ \"NO\"\n  # interval1 = (1, 3)\n  # interval2 = (2, 4)\n  # intersection = (2,\
    \ 3)\n  # length = 1\n  # return \"NO\"\n  # interval1 = (1, 3)\n  # interval2\
    \ = (2, 4)\n  # intersection = (2, 3)\n  # length = 1\n  # return \"NO\"\n  #\
    \ interval1 = (1, 3)\n  # interval2 = (2, 4)\n  # intersection = (2, 3)\n  # length\
    \ = 1\n  # return \"NO\"\n  # interval1 = (1, 3)\n  # interval2 =", "  start =\
    \ [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  return [start, finish] if start <= finish\n  return nil\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  return nil\
    \ if start > finish\n  [start, finish]\nend", "  # your code here\nend", "  return\
    \ \"NO\" if interval1[1] < interval2[0] || interval2[1] < interval1[0]\n  start\
    \ = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  (start..finish).to_a\nend", "  return \"NO\" if interval1[1] < interval2[0]\
    \ || interval2[1] < interval1[0]\n  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  (start..finish).to_a.length\n\
    end", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  (start..finish).to_a\nend", "  start = [interval1[0], interval2[0]].max\n \
    \ finish = [interval1[1], interval2[1]].min\n  [start, finish]\nend", "  if interval1[0]\
    \ > interval2[1] || interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  start\
    \ = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  if start > finish\n    return \"NO\"\n  end\n  if is_prime(finish - start +\
    \ 1)\n    return \"YES\"\n  else\n    return \"NO\"\n  end\nend", "  return \"\
    NO\" if interval1[1] < interval2[0] || interval2[1] < interval1[0]\n  start =\
    \ [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  (start..finish).to_a.length\nend", "  # your code here\nend", "  if interval1[0]\
    \ > interval2[1] || interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  if\
    \ interval1[0] > interval2[0]\n    start = interval1[0]\n  else\n    start = interval2[0]\n\
    \  end\n  if interval1[1] < interval2[1]\n    finish = interval1[1]\n  else\n\
    \    finish = interval2[1]\n  end\n  if start == finish\n    return \"YES\"\n\
    \  end\n  if start == 2\n    return \"YES\"\n  end\n  if start % 2 == 0\n    start\
    \ += 1\n  end\n  while start < finish\n    if finish % start == 0\n      return\
    \ \"NO\"\n    end\n    start += 2\n  end\n  return \"YES\"\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n  (start..ending).to_a\n\
    end", "  if interval1[0] > interval2[1] || interval2[0] > interval1[1]\n    return\
    \ \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n  ending = [interval1[1],\
    \ interval2[1]].min\n  length = ending - start + 1\n  if length == 1\n    return\
    \ \"NO\"\n  end\n  if length == 2\n    return \"YES\"\n  end\n  if length % 2\
    \ == 0\n    return \"NO\"\n  end\n  (3..Math.sqrt(length)).each do |i|\n    if\
    \ length % i == 0\n      return \"NO\"\n    end\n  end\n  return \"YES\"\nend",
  "  start = [interval1[0], interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n\
    \  return [start, ending]\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  (start..finish).to_a\nend", " \
    \ start = [interval1[0], interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n\
    \  (start..ending).to_a\nend", "  # your code here\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  return nil\
    \ if start > finish\n  [start, finish]\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  start > finish ? [] : [start,\
    \ finish]\nend", "  # your code here\nend", "  if interval1[0] > interval2[1]\
    \ || interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  if start ==\
    \ finish\n    return \"NO\"\n  end\n  if is_prime(finish - start)\n    return\
    \ \"YES\"\n  else\n    return \"NO\"\n  end\nend", "  if interval1[0] > interval2[1]\
    \ || interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  length = finish\
    \ - start + 1\n  return \"YES\" if length == 1\n  return \"NO\" if length == 2\n\
    \  (2..Math.sqrt(length)).each do |i|\n    return \"NO\" if length % i == 0\n\
    \  end\n  \"YES\"\nend", "  # your code here\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  return nil\
    \ if start > finish\n  [start, finish]\nend", "  if interval1[0] > interval2[1]\
    \ || interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0],\
    \ interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n  if start ==\
    \ ending\n    return \"NO\"\n  end\n  if (start..ending).to_a.length.prime?\n\
    \    return \"YES\"\n  else\n    return \"NO\"\n  end\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n  (start..ending).to_a\n\
    end", "  # your code here\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  return [start, finish] if start\
    \ <= finish\n  return []\nend", "  if interval1[0] > interval2[1] || interval2[0]\
    \ > interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  length = finish - start + 1\n\
    \  return \"YES\" if length == 1\n  return \"NO\" if length == 2\n  (2..Math.sqrt(length)).each\
    \ do |i|\n    return \"NO\" if length % i == 0\n  end\n  \"YES\"\nend", "  start\
    \ = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  [start, finish]\nend", "  if interval1[0] > interval2[1] || interval2[0] >\
    \ interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  if start == finish\n    return\
    \ \"NO\"\n  end\n  if (start..finish).to_a.length.prime?\n    return \"YES\"\n\
    \  else\n    return \"NO\"\n  end\nend", "  if interval1[0] > interval2[1] ||\
    \ interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  length = finish\
    \ - start + 1\n  return \"YES\" if length == 1\n  return \"NO\" if length == 2\n\
    \  (2..Math.sqrt(length)).each do |n|\n    return \"NO\" if length % n == 0\n\
    \  end\n  \"YES\"\nend", "  start = [interval1[0], interval2[0]].max\n  finish\
    \ = [interval1[1], interval2[1]].min\n  return \"NO\" if start > finish\n  (start..finish).to_a.length.prime?\
    \ ? \"YES\" : \"NO\"\nend", "  if interval1[0] > interval2[1] || interval2[0]\
    \ > interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  length = finish - start + 1\n\
    \  if length == 1\n    return \"NO\"\n  end\n  if length == 2\n    return \"YES\"\
    \n  end\n  (2..length-1).each do |i|\n    if length % i == 0\n      return \"\
    NO\"\n    end\n  end\n  return \"YES\"\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  (start..finish).to_a\nend", " \
    \ start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  return [start, finish] if start <= finish\n  nil\nend", "  intersection = []\n\
    \  if interval1[0] <= interval2[0] && interval2[0] <= interval1[1]\n    intersection\
    \ << interval2[0]\n  elsif interval2[0] <= interval1[0] && interval1[0] <= interval2[1]\n\
    \    intersection << interval1[0]\n  end\n  if interval1[0] <= interval2[1] &&\
    \ interval2[1] <= interval1[1]\n    intersection << interval2[1]\n  elsif interval2[0]\
    \ <= interval1[1] && interval1[1] <= interval2[1]\n    intersection << interval1[1]\n\
    \  end\n  intersection\nend", "  if interval1[0] > interval2[1] || interval2[0]\
    \ > interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  length = finish - start + 1\n\
    \  if length == 1\n    return \"NO\"\n  end\n  if length == 2\n    return \"YES\"\
    \n  end\n  if length % 2 == 0\n    return \"NO\"\n  end\n  (3..Math.sqrt(length)).each\
    \ do |i|\n    if length % i == 0\n      return \"NO\"\n    end\n  end\n  return\
    \ \"YES\"\nend", "  if interval1[0] >= interval2[1] || interval2[0] >= interval1[1]\n\
    \    return \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n  finish\
    \ = [interval1[1], interval2[1]].min\n  length = finish - start + 1\n  if length\
    \ == 1\n    return \"NO\"\n  end\n  if length == 2\n    return \"YES\"\n  end\n\
    \  (2..length/2).each do |i|\n    if length % i == 0\n      return \"NO\"\n  \
    \  end\n  end\n  return \"YES\"\nend", "  # your code here\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  (start..finish).to_a\n\
    end", "  return \"NO\" if interval1[1] < interval2[0] || interval2[1] < interval1[0]\n\
    \  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  (start..finish).to_a.length\nend", "  return \"NO\" if interval1[1] < interval2[0]\
    \ || interval2[1] < interval1[0]\n  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  (start..finish).to_a\nend", " \
    \ start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  return nil if start > finish\n  [start, finish]\nend", "  [interval1[0], interval2[0]].max..[interval1[1],\
    \ interval2[1]].min\nend", "  if interval1[0] <= interval2[0]\n    start = interval2[0]\n\
    \  else\n    start = interval1[0]\n  end\n  if interval1[1] <= interval2[1]\n\
    \    finish = interval1[1]\n  else\n    finish = interval2[1]\n  end\n  if start\
    \ > finish\n    return \"NO\"\n  end\n  if start == finish\n    return \"YES\"\
    \n  end\n  if start + 1 == finish\n    return \"YES\"\n  end\n  if start + 2 ==\
    \ finish\n    return \"YES\"\n  end\n  if start + 3 == finish\n    return \"NO\"\
    \n  end\n  if start + 4 == finish\n    return \"YES\"\n  end\n  if start + 5 ==\
    \ finish\n    return \"NO\"\n  end\n  if start + 6 == finish\n    return \"YES\"\
    \n  end\n  if start + 7 == finish\n    return \"NO\"\n  end\n  if start + 8 ==\
    \ finish\n    return \"NO\"\n  end\n  if start + 9 == finish\n    return \"NO\"\
    \n  end\n  if start + 10 == finish\n    return \"NO\"\n  end\n  if start + 11\
    \ == finish\n    return \"YES\"\n  end\n  if start + 12 == finish\n    return\
    \ \"NO\"\n  end\n  if start + 13 == finish\n    return \"YES\"\n  end\n  if start\
    \ + 14 == finish\n    return \"NO\"\n  end\n  if start + 15 == finish\n    return\
    \ \"NO\"\n  end\n  if start + 16 == finish\n    return \"NO\"\n  end\n  if start\
    \ + 17 == finish\n    return \"YES\"\n  end\n  if start + 18 == finish\n    return\
    \ \"NO\"\n  end\n  if start + 19 == finish\n    return \"YES\"\n  end\n  if start\
    \ + 20 == finish\n    return \"NO\"\n  end\n  if start + 21 == finish\n    return\
    \ \"NO\"\n  end\n  if start + 22 == finish\n    return \"NO\"\n  end\n  if start\
    \ + 23 == finish\n    return \"YES\"\n  end\n  if start + 24 == finish\n    return\
    \ \"NO\"\n", "  if interval1[0] > interval2[1] || interval2[0] > interval1[1]\n\
    \    return \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n  finish\
    \ = [interval1[1], interval2[1]].min\n  if start == finish\n    return \"NO\"\n\
    \  end\n  length = finish - start\n  if length == 1\n    return \"NO\"\n  end\n\
    \  if length == 2\n    return \"YES\"\n  end\n  for i in 2..length-1\n    if length\
    \ % i == 0\n      return \"NO\"\n    end\n  end\n  return \"YES\"\nend", "  start\
    \ = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  return [start, finish] if start <= finish\n  nil\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  return [start,\
    \ finish] if start <= finish\n  return nil\nend", "  if interval1[0] > interval2[1]\
    \ || interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  if start ==\
    \ finish\n    return \"NO\"\n  end\n  if (start..finish).to_a.size.prime?\n  \
    \  return \"YES\"\n  else\n    return \"NO\"\n  end\nend", "    start = [interval1[0],\
    \ interval2[0]].max\n    ending = [interval1[1], interval2[1]].min\n    if start\
    \ > ending\n        return \"NO\"\n    end\n    if start == ending\n        return\
    \ \"YES\"\n    end\n    if (start..ending).to_a.length.prime?\n        return\
    \ \"YES\"\n    else\n        return \"NO\"\n    end\nend", "  # your code here\n\
    end", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  (start..finish).to_a\nend", "  start = [interval1[0], interval2[0]].max\n \
    \ finish = [interval1[1], interval2[1]].min\n  return \"NO\" if start > finish\n\
    \  return \"YES\" if start == finish\n  (start..finish).count.prime? ? \"YES\"\
    \ : \"NO\"\nend", "  if interval1[0] > interval2[1] || interval2[0] > interval1[1]\n\
    \    return \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n  finish\
    \ = [interval1[1], interval2[1]].min\n  (start..finish).to_a.length.prime? ? \"\
    YES\" : \"NO\"\nend", "  start = [interval1[0], interval2[0]].max\n  finish =\
    \ [interval1[1], interval2[1]].min\n  return [start, finish] if start <= finish\n\
    \  nil\nend", "  return \"NO\" if interval1[1] < interval2[0] || interval2[1]\
    \ < interval1[0]\n  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  (start..finish).to_a\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  ending = [interval1[1], interval2[1]].min\n  (start..ending).to_a\nend", " \
    \ # your code here\nend", "  return \"NO\" if interval1[1] < interval2[0] || interval2[1]\
    \ < interval1[0]\n  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  (start..finish).to_a\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  return nil if start > finish\n\
    \  [start, finish]\nend", "  # your code here\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  start > finish\
    \ ? nil : [start, finish]\nend", "  # your code here\n  start = interval1[0] >\
    \ interval2[0] ? interval1[0] : interval2[0]\n  finish = interval1[1] < interval2[1]\
    \ ? interval1[1] : interval2[1]\n  if start > finish\n    return \"NO\"\n  else\n\
    \    return (start..finish).to_a.length.prime? ? \"YES\" : \"NO\"\n  end\nend",
  "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  (start..finish).to_a\nend", "  if interval1[0] > interval2[1] || interval2[0]\
    \ > interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n\
    \  ending = [interval1[1], interval2[1]].min\n  if start == ending\n    return\
    \ \"NO\"\n  end\n  if is_prime(ending - start)\n    return \"YES\"\n  else\n \
    \   return \"NO\"\n  end\nend", "  return \"NO\" if interval1[1] < interval2[0]\
    \ || interval2[1] < interval1[0]\n  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  return \"NO\" if start == finish\n\
    \  return \"YES\" if (start..finish).count.prime?\n  \"NO\"\nend", "  if interval1[0]\
    \ > interval2[1] || interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  if\
    \ interval1[0] > interval2[0]\n    start = interval1[0]\n  else\n    start = interval2[0]\n\
    \  end\n  if interval1[1] < interval2[1]\n    finish = interval1[1]\n  else\n\
    \    finish = interval2[1]\n  end\n  if start == finish\n    return \"NO\"\n \
    \ end\n  if is_prime(finish - start)\n    return \"YES\"\n  else\n    return \"\
    NO\"\n  end\nend", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  start < finish ? (start..finish) : nil\nend", "  # your\
    \ code here\nend", "  # your code here\nend", "  # your code here\nend", "  start\
    \ = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  return [start, finish] if start <= finish\n  return nil\nend", "  return \"\
    NO\" if interval1[1] < interval2[0] || interval2[1] < interval1[0]\n  start =\
    \ [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  (start..finish).to_a\nend", "  # your code here\nend", "  return \"NO\" if\
    \ interval1[1] < interval2[0] || interval2[1] < interval1[0]\n  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  (start..finish).to_a\n\
    end", "  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  (start..finish).to_a\nend", "  # your code here\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n  (start..ending).to_a\n\
    end", "  if interval1[0] > interval2[1] || interval2[0] > interval1[1]\n    return\
    \ \"NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n  ending = [interval1[1],\
    \ interval2[1]].min\n  if (start..ending).count.prime?\n    return \"YES\"\n \
    \ else\n    return \"NO\"\n  end\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  [start, finish]\nend", "  # your\
    \ code here\nend", "  # your code here\nend", "  return \"NO\" if interval1[1]\
    \ < interval2[0] || interval2[1] < interval1[0]\n  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  return \"NO\" if start == finish\n\
    \  (start..finish).count.prime? ? \"YES\" : \"NO\"\nend", "  # if interval1[0]\
    \ > interval2[1] || interval2[0] > interval1[1]\n  #   return \"NO\"\n  # end\n\
    \  # if interval1[0] < interval2[0]\n  #   start = interval2[0]\n  # else\n  #\
    \   start = interval1[0]\n  # end\n  # if interval1[1] < interval2[1]\n  #   finish\
    \ = interval1[1]\n  # else\n  #   finish = interval2[1]\n  # end\n  # if start\
    \ == finish\n  #   return \"NO\"\n  # end\n  # if start == finish - 1\n  #   return\
    \ \"YES\"\n  # end\n  # if start == finish - 2\n  #   return \"NO\"\n  # end\n\
    \  # if start == finish - 3\n  #   return \"YES\"\n  # end\n  # if start == finish\
    \ - 4\n  #   return \"NO\"\n  # end\n  # if start == finish - 5\n  #   return\
    \ \"YES\"\n  # end\n  # if start == finish - 6\n  #   return \"NO\"\n  # end\n\
    \  # if start == finish - 7\n  #   return \"YES\"\n  # end\n  # if start == finish\
    \ - 8\n  #   return \"NO\"\n  # end\n  # if start == finish - 9\n  #   return\
    \ \"YES\"\n  # end\n  # if start == finish - 10\n  #   return \"NO\"\n  # end\n\
    \  # if start == finish - 11\n  #   return \"YES\"\n  # end\n  # if start == finish\
    \ - 12\n  #   return \"NO\"\n  # end\n  # if start == finish - 13\n  #   return\
    \ \"YES\"\n  # end\n  # if start == finish - 14\n  #   return \"NO\"\n  # end\n\
    \  # if start == finish - 15\n  #   return \"YES\"\n  # end\n  # if start == finish\
    \ - 16\n  #   return \"NO\"\n  # end\n  # if start == finish - 17\n  #   return\
    \ \"YES\"\n  # end\n  # if start == finish", "  start = [interval1[0], interval2[0]].max\n\
    \  finish = [interval1[1], interval2[1]].min\n  return [start, finish] if start\
    \ <= finish\n  nil\nend", "  # your code here\nend", "  if interval1[0] > interval2[1]\
    \ || interval2[0] > interval1[1]\n    return \"NO\"\n  else\n    start = [interval1[0],\
    \ interval2[0]].max\n    finish = [interval1[1], interval2[1]].min\n    length\
    \ = finish - start + 1\n    return \"YES\" if is_prime?(length)\n    return \"\
    NO\"\n  end\nend", "  # your code here\nend", "  if interval1[0] > interval2[1]\
    \ || interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  start = [interval1[0],\
    \ interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n  if start ==\
    \ finish\n    return \"NO\"\n  end\n  if (start..finish).to_a.size.prime?\n  \
    \  return \"YES\"\n  else\n    return \"NO\"\n  end\nend", "  start = [interval1[0],\
    \ interval2[0]].max\n  ending = [interval1[1], interval2[1]].min\n  (start..ending).to_a\n\
    end", "  return \"NO\" if interval1[1] < interval2[0] || interval2[1] < interval1[0]\n\
    \  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  (start..finish).to_a.length\nend", "  start = [interval1[0], interval2[0]].max\n\
    \  ending = [interval1[1], interval2[1]].min\n  (start..ending).to_a\nend", " \
    \ start = [interval1[0], interval2[0]].max\n  finish = [interval1[1], interval2[1]].min\n\
    \  [start, finish]\nend", "  # your code here\nend", "  # your code here\nend",
  "  if interval1[0] > interval2[1] || interval2[0] > interval1[1]\n    return \"\
    NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  if start == finish\n    return \"NO\"\n  end\n  if (start..finish).to_a.length.prime?\n\
    \    return \"YES\"\n  else\n    return \"NO\"\n  end\nend", "  # your code here\n\
    \  # interval1 = (1, 3)\n  # interval2 = (2, 4)\n  # intersection = (2, 3)\n \
    \ # length = 1\n  # return \"NO\"\n  # interval1 = (1, 3)\n  # interval2 = (2,\
    \ 4)\n  # intersection = (2, 3)\n  # length = 1\n  # return \"NO\"\n  # interval1\
    \ = (1, 3)\n  # interval2 = (2, 4)\n  # intersection = (2, 3)\n  # length = 1\n\
    \  # return \"NO\"\n  # interval1 = (1, 3)\n  # interval2 = (2, 4)\n  # intersection\
    \ = (2, 3)\n  # length = 1\n  # return \"NO\"\n  # interval1 = (1, 3)\n  # interval2\
    \ = (2, 4)\n  # intersection = (2, 3)\n  # length = 1\n  # return \"NO\"\n  #\
    \ interval1 = (1, 3)\n  # interval2 = (2, 4)\n  # intersection = (2, 3)\n  # length\
    \ = 1\n  # return \"NO\"\n  # interval1 = (1, 3)\n  # interval2 = (2, 4)\n  #\
    \ intersection = (2, 3)\n  # length = 1\n  # return \"NO\"\n  # interval1 = (1,\
    \ 3)\n  # interval2 = (2, 4)\n  # intersection = (2, 3)\n  # length = 1\n  # return\
    \ \"NO\"\n  # interval1 = (1, 3)\n  # interval2 = (2, 4)\n  # intersection = (2,\
    \ 3)\n  # length = 1\n  # return \"NO\"\n  # interval1 = (1, 3)\n  # interval2\
    \ = (2, 4)\n  # intersection = (2, 3)\n  # length = 1\n  # return \"NO\"\n  #\
    \ interval1 = (1, 3)\n  # interval2 = (2, 4)\n  # intersection = (2, 3)\n  # length\
    \ = 1\n  # return \"NO\"\n  # interval1 = (1, 3)", "  start = [interval1[0], interval2[0]].max\n\
    \  ending = [interval1[1], interval2[1]].min\n  return [start, ending]\nend",
  "  if interval1[0] > interval2[1] || interval2[0] > interval1[1]\n    return \"\
    NO\"\n  end\n  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  length = finish - start + 1\n  if length < 2\n    return\
    \ \"NO\"\n  end\n  if length == 2\n    return \"YES\"\n  end\n  (2..Math.sqrt(length)).each\
    \ do |i|\n    if length % i == 0\n      return \"NO\"\n    end\n  end\n  return\
    \ \"YES\"\nend", "  return \"NO\" if interval1[1] < interval2[0] || interval2[1]\
    \ < interval1[0]\n  start = [interval1[0], interval2[0]].max\n  finish = [interval1[1],\
    \ interval2[1]].min\n  return \"NO\" if start == finish\n  return \"YES\" if (start..finish).to_a.size\
    \ == 2\n  return \"NO\"\nend", "  start = [interval1[0], interval2[0]].max\n \
    \ ending = [interval1[1], interval2[1]].min\n  return \"NO\" if start > ending\n\
    \  (start..ending).size.prime? ? \"YES\" : \"NO\"\nend", "  if interval1[0] >\
    \ interval2[1] || interval2[0] > interval1[1]\n    return \"NO\"\n  end\n  if\
    \ interval1[0] > interval2[0]\n    interval1, interval2 = interval2, interval1\n\
    \  end\n  if interval1[1] > interval2[1]\n    interval1[1] = interval2[1]\n  end\n\
    \  if interval1[1] - interval1[0] == 0\n    return \"NO\"\n  end\n  if is_prime(interval1[1]\
    \ - interval1[0])\n    return \"YES\"\n  else\n    return \"NO\"\n  end\nend",
  "  # your code here\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
