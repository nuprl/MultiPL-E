name: HumanEval_11_string_xor
language: rb
prompt: "# Input are two strings a and b consisting only of 1s and 0s.\n# Perform\
  \ binary XOR on these inputs and return result also as a string.\ndef string_xor(a,\
  \ b)\n"
tests: "require 'test/unit'\nclass TestHumanEval < Test::Unit::TestCase\n  def test_string_xor\n\
  \    candidate = method(:string_xor)\n    assert_equal(\"010010\", candidate.call(\"\
  111000\", \"101010\"))\n    assert_equal(\"0\", candidate.call(\"1\", \"1\"))\n\
  \    assert_equal(\"0101\", candidate.call(\"0101\", \"0000\"))\n  end\nend\n"
completions: ["  a.chars.zip(b.chars).map { |a, b| a.to_i ^ b.to_i }.join\nend", " \
    \ a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  # TODO: Implement me!\n  a.length.times.map\
    \ { |i| (a[i].to_i ^ b[i].to_i).to_s }.join\nend", "  # TODO: Implement this function\n\
    \  result = \"\"\n  a.length.times do |i|\n    result += (a[i].to_i ^ b[i].to_i).to_s\n\
    \  end\n  result\nend", "  a.chars.zip(b.chars).map { |a, b| (a.to_i ^ b.to_i).to_s\
    \ }.join\nend", "  # TODO: Implement this method\n  result = \"\"\n  a.length.times\
    \ do |i|\n    if a[i] == b[i]\n      result << \"0\"\n    else\n      result <<\
    \ \"1\"\n    end\n  end\n  result\nend", "  a.chars.zip(b.chars).map { |x, y|\
    \ x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i\
    \ ^ y.to_i).to_s }.join\nend", "  # TODO\nend", "  # TODO: implement me\n  a.chars.zip(b.chars).map{|x,y|\
    \ x==y ? '0' : '1'}.join\nend", "  # TODO: implement this method\n  a.to_i(2)\
    \ ^ b.to_i(2)\nend", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\n\
    end", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\nend", " \
    \ result = \"\"\n  a.length.times do |i|\n    result += (a[i].to_i ^ b[i].to_i).to_s\n\
    \  end\n  result\nend", "  # TODO: implement me\n  a.chars.zip(b.chars).map {\
    \ |a, b| a.to_i ^ b.to_i }.join\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i\
    \ ^ y.to_i).to_s }.join\nend", "  (0..a.length-1).map { |i| (a[i].to_i ^ b[i].to_i).to_s\
    \ }.join\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s }.join\n\
    end", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend",
  "  a.chars.zip(b.chars).map { |a, b| a == b ? '0' : '1' }.join\nend", "  # TODO:\
    \ Your code here\n  a = a.split('')\n  b = b.split('')\n  result = []\n  a.each_with_index\
    \ do |num, index|\n    if num == b[index]\n      result << '0'\n    else\n   \
    \   result << '1'\n    end\n  end\n  result.join\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map {\
    \ |x, y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x, y|\
    \ (x.to_i ^ y.to_i).to_s }.join\nend", "  # TODO: implement me\n  a.to_i(2) ^\
    \ b.to_i(2)\nend", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\n\
    end", "  # TODO: implement me\n  a.to_i(2) ^ b.to_i(2)\nend", "  # TODO: implement\
    \ me\n  # a = a.to_i(2)\n  # b = b.to_i(2)\n  # result = a ^ b\n  # result.to_s(2)\n\
    \  a.to_i(2) ^ b.to_i(2)\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^\
    \ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s\
    \ }.join\nend", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\n\
    end", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend",
  "  result = \"\"\n  a.length.times do |i|\n    result += (a[i].to_i ^ b[i].to_i).to_s\n\
    \  end\n  result\nend", "  result = \"\"\n  a.length.times do |i|\n    result\
    \ << (a[i] == b[i] ? \"0\" : \"1\")\n  end\n  result\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  # Your code here\n  a = a.to_i(2)\n\
    \  b = b.to_i(2)\n  (a ^ b).to_s(2)\nend", "  a.chars.zip(b.chars).map { |x, y|\
    \ x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x, y| x == y\
    \ ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |a, b| a == b ? '0'\
    \ : '1' }.join\nend", "  # TODO: implement this method\n  a.to_i(2) ^ b.to_i(2)\n\
    end", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend",
  "  # TODO: implement this method\n  a_array = a.split('')\n  b_array = b.split('')\n\
    \  result = []\n  a_array.each_with_index do |value, index|\n    if value == b_array[index]\n\
    \      result << '0'\n    else\n      result << '1'\n    end\n  end\n  result.join\n\
    end", "  # TODO\nend", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1'\
    \ }.join\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s }.join\n\
    end", "  # TODO: implement this method\n  result = \"\"\n  a.length.times do |i|\n\
    \    result << ((a[i].to_i ^ b[i].to_i).to_s)\n  end\n  result\nend", "  # TODO\n\
    end", "  # TODO: implement me\n  a_array = a.split('')\n  b_array = b.split('')\n\
    \  result = []\n  a_array.each_with_index do |value, index|\n    if value == b_array[index]\n\
    \      result << '0'\n    else\n      result << '1'\n    end\n  end\n  result.join\n\
    end", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend",
  "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  # TODO: implement this method\n\
    \  a = a.split('')\n  b = b.split('')\n  result = []\n  a.each_with_index do |element,\
    \ index|\n    if element == b[index]\n      result << '0'\n    else\n      result\
    \ << '1'\n    end\n  end\n  result.join\nend", "  # TODO: implement this function\n\
    \  # a = \"10101\"\n  # b = \"11111\"\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2)\
    \ ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2)\
    \ ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2)\
    \ ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2)\
    \ ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2)\
    \ ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2)\
    \ ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2)\
    \ ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2)\
    \ ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.", "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x,\
    \ y| (x.to_i ^ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map { |x, y|\
    \ (x.to_i ^ y.to_i).to_s }.join\nend", "  # TODO: implement this method\n  a.length.times.map\
    \ { |i| a[i] == b[i] ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x,\
    \ y| (x.to_i ^ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map { |x, y|\
    \ (x.to_i ^ y.to_i).to_s }.join\nend", "  # TODO: Implement this method\n  a =\
    \ a.to_i(2)\n  b = b.to_i(2)\n  (a ^ b).to_s(2)\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  # TODO: implement me\n  result\
    \ = []\n  a.chars.each_with_index do |char, index|\n    result << (char.to_i ^\
    \ b[index].to_i).to_s\n  end\n  result.join\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  raise ArgumentError, 'Inputs\
    \ must be strings' unless a.is_a?(String) && b.is_a?(String)\n  raise ArgumentError,\
    \ 'Inputs must be binary strings' unless a.match(/^[01]+$/) && b.match(/^[01]+$/)\n\
    \  raise ArgumentError, 'Inputs must be of equal length' unless a.length == b.length",
  "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  # TODO:\
    \ implement this method\n  a.to_i(2) ^ b.to_i(2)\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map {\
    \ |x, y| x == y ? '0' : '1' }.join\nend", "  result = \"\"\n  a.length.times do\
    \ |i|\n    result += (a[i].to_i ^ b[i].to_i).to_s\n  end\n  result\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  # TODO: your code here\n  a.to_i(2)\
    \ ^ b.to_i(2)\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s\
    \ }.join\nend", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\n\
    end", "  # TODO: implement this method\n  a = a.to_i(2)\n  b = b.to_i(2)\n  (a\
    \ ^ b).to_s(2)\nend", "  # TODO: implement\n  a.to_i(2) ^ b.to_i(2)\nend", " \
    \ a.size.times.map { |i| (a[i].to_i ^ b[i].to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x,\
    \ y| x == y ? '0' : '1' }.join\nend", "  # TODO: implement me\n  # a = \"1010101\"\
    \n  # b = \"0101010\"\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n\
    \  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n\
    \  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n\
    \  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n\
    \  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n\
    \  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n\
    \  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n\
    \  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n\
    \  # a.to_i(2) ^ b.to_i(2)\n  # a", "  # TODO: Your code here\n  a.to_i(2) ^ b.to_i(2)\n\
    end", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\nend", " \
    \ # TODO: implement this method\n  a.to_i(2) ^ b.to_i(2)\nend", "  # TODO: Implement\
    \ this method\n  a_array = a.split('')\n  b_array = b.split('')\n  result = []\n\
    \  a_array.each_with_index do |value, index|\n    if value == b_array[index]\n\
    \      result << '0'\n    else\n      result << '1'\n    end\n  end\n  result.join\n\
    end", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\nend", " \
    \ a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x,\
    \ y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x, y| x ==\
    \ y ? '0' : '1' }.join\nend", "  # TODO: implement me\n  # a = \"10101\"\n  #\
    \ b = \"11100\"\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2)\
    \ ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2)\
    \ ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2)\
    \ ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2)\
    \ ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2)\
    \ ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2)\
    \ ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2)\
    \ ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2)\
    \ ^ b.to_i(2)\n  # a.to", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s\
    \ }.join\nend", "  # TODO: Your code here\n  a = a.to_i(2)\n  b = b.to_i(2)\n\
    \  result = (a ^ b).to_s(2)\n  return result\nend", "  # TODO: implement this\
    \ method\n  result = \"\"\n  a.length.times do |i|\n    if a[i] == b[i]\n    \
    \  result << \"0\"\n    else\n      result << \"1\"\n    end\n  end\n  result\n\
    end", "  result = ''\n  a.length.times do |i|\n    result += (a[i] == b[i]) ?\
    \ '0' : '1'\n  end\n  result\nend", "  a.chars.zip(b.chars).map { |x, y| x ==\
    \ y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s\
    \ }.join\nend", "  result = \"\"\n  a.length.times do |i|\n    result += (a[i].to_i\
    \ ^ b[i].to_i).to_s\n  end\n  result\nend", "  a.length.times.map { |i| (a[i].to_i\
    \ ^ b[i].to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map { |x, y| x == y\
    \ ? '0' : '1' }.join\nend", "  # TODO: Your code here\n  a.to_i(2) ^ b.to_i(2)\n\
    end", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\nend", " \
    \ a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\nend", "  # TODO:\
    \ implement me\n  a.to_i(2) ^ b.to_i(2)\nend", "  a.chars.zip(b.chars).map { |x,\
    \ y| x == y ? '0' : '1' }.join\nend", "  result = ''\n  a.length.times do |i|\n\
    \    result += a[i] == b[i] ? '0' : '1'\n  end\n  result\nend", "  # TODO: Implement\
    \ this method\n  a.to_i(2) ^ b.to_i(2)\nend", "  a.chars.zip(b.chars).map { |x,\
    \ y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i\
    \ ^ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map { |a, b| a.to_i ^ b.to_i\
    \ }.join\nend", "  if a.length != b.length\n    raise ArgumentError, \"Strings\
    \ must be of equal length\"\n  end", "  # TODO: implement this method\n  a.length\
    \ == b.length ? (0...a.length).map { |i| a[i].to_i ^ b[i].to_i }.join : nil\n\
    end", "  result = []\n  a.chars.each_with_index do |char, index|\n    result <<\
    \ (char.to_i ^ b[index].to_i).to_s\n  end\n  result.join\nend", "  # TODO: implement\
    \ this method\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2).to_s(2)\n  # a.to_i(2).to_s(2)\
    \ ^ b.to_i(2).to_s(2)\n  # a.to_i(2).to_s(2) ^ b.to_i(2).to_s(2)\n  # a.to_i(2).to_s(2)\
    \ ^ b.to_i(2).to_s(2)\n  # a.to_i(2).to_s(2) ^ b.to_i(2).to_s(2)\n  # a.to_i(2).to_s(2)\
    \ ^ b.to_i(2).to_s(2)\n  # a.to_i(2).to_s(2) ^ b.to_i(2).to_s(2)\n  # a.to_i(2).to_s(2)\
    \ ^ b.to_i(2).to_s(2)\n  # a.to_i(2).to_s(2) ^ b.to_i(2).to_s(2)\n  # a.to_i(2).to_s(2)\
    \ ^ b.to_i(2).to_s(2)\n  # a.to_i(2).to_s(2) ^ b.to_i(2).to_s(2)\n  # a.to_i(2).to_s(2)\
    \ ^ b.to_i(2).to_s(2)\n  # a.to_i(2).to_s(2) ^ b.to_i(2).to_s(2)\n  # a.to_i(2).to_s(2)\
    \ ^ b.to_i(2).to_s(2)\n  # a.to_i(2).to_s(2) ^ b.to_i(2).to_s(2)\n  # a.to_i(2).to_s(2)\
    \ ^", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend",
  "  a.length.times.map { |i| a[i] == b[i] ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  raise ArgumentError, 'Inputs must\
    \ be strings' unless a.is_a?(String) && b.is_a?(String)\n  raise ArgumentError,\
    \ 'Inputs must be the same length' unless a.length == b.length\n  raise ArgumentError,\
    \ 'Inputs must only contain 1s and 0s' unless a.match(/[^01]/).nil? && b.match(/[^01]/).nil?",
  "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  # TODO: implement me\n  a =\
    \ a.split('')\n  b = b.split('')\n  result = []\n  a.each_with_index do |value,\
    \ index|\n    if value == b[index]\n      result << '0'\n    else\n      result\
    \ << '1'\n    end\n  end\n  result.join\nend", "  a.chars.zip(b.chars).map { |x,\
    \ y| (x.to_i ^ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map { |x, y|\
    \ x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x, y| x == y\
    \ ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0'\
    \ : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s\
    \ }.join\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s }.join\n\
    end", "  # TODO: implement this method\n  result = \"\"\n  a.length.times do |i|\n\
    \    if a[i] == b[i]\n      result << \"0\"\n    else\n      result << \"1\"\n\
    \    end\n  end\n  result\nend", "  # TODO: implement\n  a_array = a.split('')\n\
    \  b_array = b.split('')\n  result = []\n  a_array.each_with_index do |value,\
    \ index|\n    if value == b_array[index]\n      result << '0'\n    else\n    \
    \  result << '1'\n    end\n  end\n  result.join\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x,\
    \ y| x.to_i ^ y.to_i }.join\nend", "  # TODO: implement me\n  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x,\
    \ y| (x.to_i ^ y.to_i).to_s }.join\nend", "  # TODO: implement\n  a_array = a.split('')\n\
    \  b_array = b.split('')\n  result = []\n  a_array.each_with_index do |value,\
    \ index|\n    if value == b_array[index]\n      result << '0'\n    else\n    \
    \  result << '1'\n    end\n  end\n  result.join\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map {\
    \ |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  result = \"\"\n  a.length.times\
    \ do |i|\n    result << (a[i] == b[i] ? \"0\" : \"1\")\n  end\n  result\nend",
  "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\nend", "  # TODO:\
    \ implement me\n  result = ''\n  a.length.times do |i|\n    result << (a[i].to_i\
    \ ^ b[i].to_i).to_s\n  end\n  result\nend", "  a.chars.zip(b.chars).map { |x,\
    \ y| x == y ? '0' : '1' }.join\nend", "  a.to_i(2) ^ b.to_i(2)\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  # TODO: implement me\n  a.to_i(2)\
    \ ^ b.to_i(2)\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s\
    \ }.join\nend", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\n\
    end", "  # TODO: implement this method\n  a = a.split('')\n  b = b.split('')\n\
    \  result = []\n  a.each_with_index do |x, i|\n    if x == b[i]\n      result\
    \ << '0'\n    else\n      result << '1'\n    end\n  end\n  result.join\nend",
  "  a.length.times.map { |i| (a[i].to_i ^ b[i].to_i).to_s }.join\nend", "  # TODO:\
    \ implement me\n  # a.to_i(2) ^ b.to_i(2)\n  # a.to_i(2).to_s(2)\n  a.to_i(2)\
    \ ^ b.to_i(2)\nend", "  raise ArgumentError, 'Inputs must be strings' unless a.is_a?(String)\
    \ && b.is_a?(String)\n  raise ArgumentError, 'Inputs must be of equal length'\
    \ unless a.length == b.length\n  raise ArgumentError, 'Inputs must only contain\
    \ 1s and 0s' unless a.match(/[^01]/).nil? && b.match(/[^01]/).nil?", "  a.chars.zip(b.chars).map\
    \ { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map {\
    \ |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map { |x,\
    \ y| x == y ? '0' : '1' }.join\nend", "  a.to_i(2) ^ b.to_i(2)\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |a,\
    \ b| a.to_i ^ b.to_i }.join\nend", "  a.chars.zip(b.chars).map { |x, y| x == y\
    \ ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s\
    \ }.join\nend", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\n\
    end", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend",
  "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  # TODO:\
    \ implement me\n  a = a.to_i(2)\n  b = b.to_i(2)\n  (a ^ b).to_s(2)\nend", " \
    \ # TODO: implement me\n  a.to_i(2) ^ b.to_i(2)\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map {\
    \ |x, y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x, y|\
    \ x == y ? '0' : '1' }.join\nend", "  result = []\n  a.split('').each_with_index\
    \ do |char, index|\n    result << (char.to_i ^ b[index].to_i).to_s\n  end\n  result.join('')\n\
    end", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\nend", " \
    \ a.length.times.map { |i| a[i] == b[i] ? '0' : '1' }.join\nend", "  raise ArgumentError,\
    \ 'Inputs must be strings' unless a.is_a?(String) && b.is_a?(String)\n  raise\
    \ ArgumentError, 'Inputs must be the same length' unless a.length == b.length\n\
    \  raise ArgumentError, 'Inputs must only contain 1s and 0s' unless a.match(/[^10]/)\
    \ == nil && b.match(/[^10]/) == nil", "  result = \"\"\n  a.length.times do |i|\n\
    \    result << (a[i] == b[i] ? \"0\" : \"1\")\n  end\n  result\nend", "  result\
    \ = ''\n  a.length.times do |i|\n    result << (a[i] == b[i] ? '0' : '1')\n  end\n\
    \  result\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s }.join\n\
    end", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\nend", " \
    \ raise ArgumentError, 'Inputs must be strings' unless a.is_a?(String) && b.is_a?(String)\n\
    \  raise ArgumentError, 'Inputs must be equal length' unless a.length == b.length\n\
    \  raise ArgumentError, 'Inputs must only contain 1s and 0s' unless a.match(/^[01]+$/)\
    \ && b.match(/^[01]+$/)", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' :\
    \ '1' }.join\nend", "  # TODO: implement me\n  a = a.split('')\n  b = b.split('')\n\
    \  result = []\n  a.each_with_index do |x, i|\n    if x == b[i]\n      result\
    \ << '0'\n    else\n      result << '1'\n    end\n  end\n  result.join\nend",
  "  a.size.times.map { |i| (a[i].to_i ^ b[i].to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  result = \"\"\n  a.length.times\
    \ do |i|\n    result << (a[i] == b[i] ? \"0\" : \"1\")\n  end\n  result\nend",
  "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  # TODO:\
    \ Implement this method\n  a = a.to_i(2)\n  b = b.to_i(2)\n  (a ^ b).to_s(2)\n\
    end", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend",
  "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x,\
    \ y| x == y ? '0' : '1' }.join\nend", "  # TODO: your code here\n  result = \"\
    \"\n  a.length.times do |i|\n    result << (a[i].to_i ^ b[i].to_i).to_s\n  end\n\
    \  result\nend", "  a.chars.zip(b.chars).map { |x, y| (x.to_i ^ y.to_i).to_s }.join\n\
    end", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\nend", " \
    \ a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map { |x,\
    \ y| (x.to_i ^ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map { |x, y|\
    \ (x.to_i ^ y.to_i).to_s }.join\nend", "  # TODO: implement\n  a.to_i(2) ^ b.to_i(2)\n\
    end", "  a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\nend", " \
    \ a.chars.zip(b.chars).map { |x, y| x == y ? '0' : '1' }.join\nend", "  a.chars.zip(b.chars).map\
    \ { |a, b| a.to_i ^ b.to_i }.join\nend", "  # TODO\nend", "  # TODO: implement\
    \ me\n  result = []\n  a.split('').each_with_index do |char, index|\n    result\
    \ << (char.to_i ^ b[index].to_i).to_s\n  end\n  result.join\nend", "  a.chars.zip(b.chars).map\
    \ { |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map {\
    \ |x, y| (x.to_i ^ y.to_i).to_s }.join\nend", "  a.chars.zip(b.chars).map { |x,\
    \ y| x == y ? '0' : '1' }.join\nend"]
stop_tokens:
- "\nclass"
- "\ndef"
- "\n#"
- "\n\n"
