{
  "language": "scala",
  "name": "HumanEval_9_rolling_max",
  "results": [
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var current = List.empty[Long]\n        var maximum = numbers.head\n        var tempList = List.empty[Long]\n        numbers.tail.foreach{value =>\n            val current = current :+ value\n            val tempListWithCurrentMax = tempList :+ maximum\n            maximum = Math.max(maximum, value)\n            tempListWithCurrentMax.foreach{max => if (max > maximum) current = current :+ max}\n        }\n        current :+ maximum\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp5_27xhfh.scala:13:26 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mcurrent\u001b[0m = current :+ value\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Recursive \u001b[33mvalue\u001b[0m \u001b[35mcurrent\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp5_27xhfh.scala:16:77 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            tempListWithCurrentMax.foreach{\u001b[36mmax\u001b[0m => \u001b[33mif\u001b[0m (max > maximum) current = current :+ max}\n\u001b[31m\u001b[31m   |\u001b[0m                                                                     ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Reassignment to val current\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010918
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxVals = numbers.takeWhile(_ > 0).reverse\n        val maxCounts = numbers.dropWhile(_ < 0).reverse\n        (maxVals, maxCounts)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_pce2488.scala:11:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        (maxVals, maxCounts)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31m(\u001b[0mList[Long\u001b[1m\u001b[31m]\u001b[0m\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0m\u001b[1m\u001b[31mLong\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010924
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val max_list = ListBuffer[Long]()\n        var rolling_max = 0\n\n        for (number <- numbers) {\n            if (number > rolling_max) {\n                rolling_max = number\n                max_list += rolling_max\n            } else if (number == rolling_max) {\n                max_list += number\n            }\n        }\n        max_list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpq47memtk.scala:14:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                rolling_max = number\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (number : Long)\n\u001b[31m   |\u001b[0m                              Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010925
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var max = 0\n        numbers.reverse foreach { x =>\n            if (x > max) {\n                max = x\n            }\n        }\n        max :: rollingMax(numbers.dropRight(1));\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7pn5kaep.scala:12:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m                max = x\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    (x : Long)\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010925
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var max = 0\n        var maxIndex = 0\n        var currentMax = 0\n        var rollingMax = scala.collection.mutable.ArrayBuffer.empty[Long]()\n        var currentIndex = numbers.head\n\n        var sum = 0\n\n        while(numbers.length > 0) {\n            sum = numbers(currentIndex).asInstanceOf[Long]\n            rollingMax = rollingMax.:+(numbers(currentIndex))\n            currentIndex += 1\n\n            if(sum > currentMax) {\n                currentMax = sum\n                maxIndex = currentIndex\n                rollingMax = rollingMax.:+(numbers(maxIndex))\n            }\n\n            if(currentIndex < numbers.size) {\n                sum = 0\n                currentMax = 0\n                maxIndex = 0\n                currentIndex = numbers.head\n            }\n        }\n\n        rollingMax.subList(0, maxIndex + 1).map((elem) => elem.asInstanceOf[Long]).toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp11m_v4gn.scala:12:73 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrollingMax\u001b[0m = scala.collection.mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter n of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mArrayBuffer\u001b[0m: (n: Int): Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp11m_v4gn.scala:18:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            sum = numbers(currentIndex).asInstanceOf[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (currentIndex : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp11m_v4gn.scala:24:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                maxIndex = currentIndex\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (currentIndex : Long)\n\u001b[31m   |\u001b[0m                           Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010926
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxValues = mutable.Buffer[Long]()\n        val currentMax = numbers.head\n        for(i <- 1 until numbers.size) {\n            val value = numbers.lift(i).max\n            if(value > currentMax) {\n                currentMax = value\n                maxValues += currentMax\n            } else if(value == currentMax) {\n                maxValues += currentMax\n            } else {\n                maxValues += currentMax\n                maxValues += value\n            }\n        }\n        maxValues\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3a62zw4i.scala:9:24 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxValues\u001b[0m = mutable.Buffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                        Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp3a62zw4i.scala:14:27 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                currentMax = value\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val currentMax\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010920
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val rollMax = mutable.ArrayBuffer.empty[Long]\n        numbers.reverse.foreach(rollMax += _)\n        rollMax.reverse.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgklbuhqn.scala:9:22 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollMax\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m  |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                      Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010918
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val max = numbers(0)\n        numbers.reverse.foldLeft(List[Long]()) { (result, num) =>\n            if(num > max)\n                result :+ num\n            else \n                result\n        }.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\tat Problem$.rollingMax(tmpfybvmjk5.scala:9)\n\tat Problem$.main(tmpfybvmjk5.scala:18)\n\tat Problem.main(tmpfybvmjk5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010927
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxList = numbers.foldLeft[List[Long]](List.empty[Long]) { \n            case (acc, x) =>\n                if (acc contains x) \n                    acc else acc :+ x \n        }\n        val tail = numbers.dropRight(1)\n        if (tail.isEmpty) maxList else rollingMax(tail).flatMap { acc =>\n            maxList :+ max(acc)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpqfpfxbcp.scala:16:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            maxList :+ max(acc)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double, y: Double): Double\n\u001b[31m   |\u001b[0m (x: Float, y: Float): Float\n\u001b[31m   |\u001b[0m (x: Long, y: Long): Long\n\u001b[31m   |\u001b[0m (x: Int, y: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments ((acc : Long))\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010919
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var maxes = mutable.Buffer.empty[Long]\n        var max = 0l\n        for (n <- numbers) {\n            if (n > max) {\n                maxes += n\n                max = n\n            } else if (n == max) {\n                maxes += n\n            } else if (n > max) {\n                maxes = maxes ++ List(max)\n                max = n\n            }\n        }\n        maxes += max\n        return maxes.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpahkrledj.scala:9:20 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxes\u001b[0m = mutable.Buffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m  |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                    Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010918
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        // base case\n        if(numbers.isEmpty) return numbers.tail\n        val first = numbers.head\n        if(numbers.size == 1) List(first)\n        else {\n            // recursive case\n            val tail = rollingMax(numbers.tail)\n            val middle = numbers.take(numbers.size / 2).max\n            val maxes = tail filter (_ >= middle)\n            val maxes.reverse.foldLeft(maxes)( (curMax: List[Long], elem: Long) =>\n                curMax :+ elem :+ curMax.last\n            )\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpjp1900c3.scala:18:45 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mval\u001b[0m maxes.reverse.foldLeft(maxes)( (curMax: List[Long], elem: Long) =>\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             '=' expected, but '(' found\n\u001b[31m\u001b[31m-- [E127] Syntax Error: /tmp/tmpjp1900c3.scala:18:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mval\u001b[0m maxes.reverse.foldLeft(maxes)( (curMax: List[Long], elem: Long) =>\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmaxes.reverse.foldLeft cannot be used as an extractor in a pattern because it lacks an unapply or unapplySeq method\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjp1900c3.scala:21:9 ---------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0m         Found:    Unit\n\u001b[31m   |\u001b[0m         Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010925
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        def rollingMaxHelper(numbers: List[Long], maxSoFar: List[Long]) : List[Long] = {\n            if (numbers.isEmpty) return maxSoFar\n            if (numbers.size == 1) return maxSoFar\n            val first = numbers.head\n            val tail = numbers.tail\n            maxSoFar :+ first\n            val nextMax = tail.foldLeft(first)(max(_, number))\n            rollingMaxHelper(tail, nextMax)\n        }\n        rollingMaxHelper(numbers, List[Long]())\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpr6xna8zx.scala:15:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnextMax\u001b[0m = tail.foldLeft(first)(max(_, number))\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr6xna8zx.scala:16:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            rollingMaxHelper(tail, nextMax)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Found:    (nextMax : Long)\n\u001b[31m   |\u001b[0m                                   Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010925
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxNumbers = numbers.map(_.toLong).toList\n        val rollingMaxNumbers = maxNumbers.tail.zip(maxNumbers.tail.dropRight(1)).map(a => a._1 + a._2)\n        rollingMaxNumbers.takeWhile(a => a > maxNumbers.head).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: tail of empty list\n\tat scala.collection.immutable.Nil$.tail(List.scala:664)\n\tat scala.collection.immutable.Nil$.tail(List.scala:661)\n\tat Problem$.rollingMax(tmpibmw9ikc.scala:10)\n\tat Problem$.main(tmpibmw9ikc.scala:14)\n\tat Problem.main(tmpibmw9ikc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010926
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val len = numbers.size\n        var maxList = numbers.tail\n        var maxNumber = numbers.last\n        var rollingMaxList = ListBuffer.empty[Long]\n        val rollingMax = new mutable.Buffer[Long]()\n        for (i <- 0 until len) {\n            rollingMax += numbers(i)\n            rollingMaxList += numbers(i)\n            if (rollingMax.last > maxNumber) {\n                maxNumber = rollingMax.last\n                maxList = rollingMaxList\n            }\n        }\n        rollingMaxList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqbr6l_5e.scala:13:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMax\u001b[0m = \u001b[33mnew\u001b[0m mutable.Buffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqbr6l_5e.scala:19:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                maxList = rollingMaxList\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m  Found:    (rollingMaxList : scala.collection.mutable.ListBuffer[Long])\n\u001b[31m   |\u001b[0m  Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqbr6l_5e.scala:22:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        rollingMaxList\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m  Found:    (rollingMaxList : scala.collection.mutable.ListBuffer[Long])\n\u001b[31m   |\u001b[0m  Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010925
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        // For a rolling max, we just need to maintain a list of maximum elements seen so far\n        // and just append the current element to it when we see it again. The only time we add a\n        // new element is when we reach the end.\n        val maxes = new mutable.ListBuffer[Long]\n        maxes += numbers.head\n        numbers foreach { number =>\n            if (number > maxes.last) {\n                maxes += number\n            }\n        }\n        maxes.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgcsfs35f.scala:12:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxes\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010917
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        require(numbers.nonEmpty, \"numbers cannot be empty\")\n        val listMax = numbers.map(x => x)\n        var max = 0L\n        var current = 1L\n        var listMaxMax = List[Long]()\n        for (i <- numbers) {\n            if (current > x) {\n                listMaxMax = listMax.takeWhile(x => current >= x).toList\n                current = 1L\n                max = x\n            }\n            if (max < i) current = i\n            else max = i\n        }\n        listMaxMax = listMaxMax.map(x => x + 1).toList\n        listMaxMax :: listMax\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphfx1p6al.scala:15:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m (current > x) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphfx1p6al.scala:18:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                max = x\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphfx1p6al.scala:24:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        listMaxMax :: listMax\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (listMaxMax : List[Long])\n\u001b[31m   |\u001b[0m        Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010923
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.foldLeft(List[Long]()) { (sum, current) =>\n            val index = sum.size - 1\n            if (index <= current) sum :+ current\n            else sum.updated(index, current max sum)\n        }.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3710s471.scala:12:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33melse\u001b[0m sum.updated(index, current max sum)\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Found:    (sum : List[Long])\n\u001b[31m   |\u001b[0m                                            Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010925
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.foldLeft(List[Long]()) { (res, x) => {\n            val max = res.max { t => if (t > x) t else x }\n            val res = res.init :+ max\n            res\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmped1jh_i6.scala:23:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmped1jh_i6.scala:22:1 ---------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m ^\u001b[0m\n\u001b[31m   |\u001b[0m Found:    Unit\n\u001b[31m   |\u001b[0m Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- Warning: /tmp/tmped1jh_i6.scala:15:4 ----------------------------------------\u001b[0m\u001b[0m\n\u001b[33m15 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mmain\u001b[0m(\u001b[36margs\u001b[0m: \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m]) = {\n\u001b[33m\u001b[33m   |\u001b[0m    ^\u001b[0m\n\u001b[33m   |\u001b[0m    Line is indented too far to the left, or a `}` is missing\n1 warning found\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010925
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var max = 0\n        var maxElem = numbers(0)\n\n        for (i <- 1 to numbers.length - 1) {\n            max = numbers(i)\n            if (max > maxElem) {\n                maxElem = max\n            }\n        }\n        maxElem :: rollingMax(numbers.drop(1))\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphlvfvhnm.scala:13:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            max = numbers(i)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    Long\n\u001b[31m   |\u001b[0m                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010925
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        if (numbers.isEmpty) return Nil\n        val r = new mutable.ListBuffer[Long]\n        var index = 0\n        var max = 0L\n        val r = new mutable.ListBuffer[Long]\n        for (i <- 1 to numbers.size) {\n            if (numbers(i) > max) {\n                index = i\n                max = numbers(i)\n            }\n            else {\n                val r = numbers.drop(i).filterNot(x => x == numbers(i)).iterator\n                if (r.hasNext) r else null\n            }\n        }\n        r :+ max\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpbhhll8y2.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mr\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mr is already defined as \u001b[33mvalue\u001b[0m \u001b[35mr\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbhhll8y2.scala:10:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mr\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010921
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        // Sort list to make it more interesting\n        val sortedNumbers = numbers.sortWith((x, y) => x < y)\n        \n        // Sum up all elements except the last\n        var cummulativeSum = sortedNumbers(0)\n        var cummulativeSumMax = cummulativeSum\n        for(i <- 1 to sortedNumbers.length-1) {\n            cummulativeSum += sortedNumbers(i)\n            cummulativeSumMax = Math.max(cummulativeSum, cummulativeSumMax)\n        }\n        \n        // Append the last\n        numbers :+ cummulativeSumMax\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.IndexOutOfBoundsException: 0\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\tat Problem$.rollingMax(tmp66ulqntf.scala:13)\n\tat Problem$.main(tmp66ulqntf.scala:24)\n\tat Problem.main(tmp66ulqntf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010927
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.foldLeft(List[Long]()){ \n            (acc: List[Long], number: Long) => {\n                number match {\n                    case x :: xs => x :: acc\n                    case _ => acc :+ number\n                }\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbp3oyutw.scala:12:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m                    \u001b[33mcase\u001b[0m x :: xs => x :: acc\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Found:    (x : Any)\n\u001b[31m   |\u001b[0m                                    Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010925
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val rollingMaxList = mutable.MutableList[Long]()\n        var max = numbers.last\n        numbers.foreach{ n =>\n            if (n > max) {\n                max = n\n            }\n        }\n        var index = numbers.length\n        while (!numbers(index).equals(max)) {\n            rollingMaxList += max\n            index += 1\n        }\n        rollingMaxList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdulaw13f.scala:9:29 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMaxList\u001b[0m = mutable.MutableList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010919
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val rollingMax = mutable.ListBuffer[Long]()\n        var maxNum = numbers(0)\n        for (i<- 1 to numbers.size)\n        {\n            maxNum = numbers(i)\n            for (j<- 0 to i-1)\n            {\n                if (numbers(j) > maxNum)\n                {\n                    maxNum = numbers(j)\n                }\n            }\n            rollingMax += maxNum\n        }\n        rollingMax.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps4_tw556.scala:9:25 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMax\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                         Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010931
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n      val result = ListBuffer[Long]()\n      var rollingMax = numbers.get(0)\n      for (num <- numbers) {\n        if (num > rollingMax) {\n          rollingMax = num\n          result += rollingMax.toLong\n        }\n      }\n      result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptoo663v2.scala:10:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m      \u001b[33mvar\u001b[0m \u001b[36mrollingMax\u001b[0m = numbers.get(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value get is not a member of List[Long] - did you mean numbers.seq?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmptoo663v2.scala:17:6 ---------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m      result\n\u001b[31m\u001b[31m   |\u001b[0m      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      Found:    (result : scala.collection.mutable.ListBuffer[Long])\n\u001b[31m   |\u001b[0m      Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010939
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.foldLeft((List[Long](), 0)){ (x, y) =>\n            // Add new number at the head of list\n            val temp_list = x match {\n                case (acc, 0) => (y :: acc, 0)\n                case (acc, m) => (y :: acc, m)\n            }\n            val max_element = temp_list._2\n            // Append new element to the head of previous list\n            val temp_list = x match {\n                case (acc, 0) => (y :: acc, 0)\n                case (acc, m) => (y :: acc, m)\n            }\n            // Find index of max_element from previous list\n            val index = temp_list._1.indexOfMax(max_element)\n            // Append max_element to last element of list\n            temp_list._1 :+ max_element :: temp_list._2(index).tail\n        }._1\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E041] Syntax Error: /tmp/tmp9xwfvbbp.scala:24:28 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            temp_list._1 :+ max_element :: temp_list._2(index).tail\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m:+ (which is left-associative) and :: (which is right-associative) have same precedence and may not be mixed\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp9xwfvbbp.scala:17:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mtemp_list\u001b[0m = x \u001b[33mmatch\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^\u001b[0m\n\u001b[31m   |\u001b[0mtemp_list is already defined as \u001b[33mvalue\u001b[0m \u001b[35mtemp_list\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m18 |\u001b[0m                \u001b[33mcase\u001b[0m (acc, \u001b[31m0\u001b[0m) => (y :: acc, \u001b[31m0\u001b[0m)\n\u001b[31m19 |\u001b[0m                \u001b[33mcase\u001b[0m (acc, m) => (y :: acc, m)\n\u001b[31m20 |\u001b[0m            }\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp9xwfvbbp.scala:22:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mindex\u001b[0m = temp_list._1.indexOfMax(max_element)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue indexOfMax is not a member of List[Long] - did you mean _1.indexOf?\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp9xwfvbbp.scala:24:53 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            temp_list._1 :+ max_element :: temp_list._2(index).tail\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mgetter\u001b[0m \u001b[35m_2\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mTuple2\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010939
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val max = numbers(0l).max(numbers(numbers.size - 1l))\n        val list = new collection.mutable.ListBuffer[Long]()\n        for (i <- 0 until numbers.size - 1l) {\n            if (numbers(i + 1l) == max) {\n                list += numbers(i).toLong\n            }\n        }\n        list.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbtpfdu44.scala:9:26 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = numbers(\u001b[31m0l\u001b[0m).max(numbers(numbers.size - \u001b[31m1l\u001b[0m))\n\u001b[31m\u001b[31m  |\u001b[0m                          ^^\u001b[0m\n\u001b[31m  |\u001b[0m                          Found:    (\u001b[31m0L\u001b[0m : Long)\n\u001b[31m  |\u001b[0m                          Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbtpfdu44.scala:9:42 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = numbers(\u001b[31m0l\u001b[0m).max(numbers(numbers.size - \u001b[31m1l\u001b[0m))\n\u001b[31m\u001b[31m  |\u001b[0m                                          ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                          Found:    Long\n\u001b[31m  |\u001b[0m                                          Required: Int\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbtpfdu44.scala:11:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until numbers.size - \u001b[31m1l\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    Long\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbtpfdu44.scala:12:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mif\u001b[0m (numbers(i + \u001b[31m1l\u001b[0m) == max) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    Long\n\u001b[31m   |\u001b[0m                        Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010941
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var result = List[Long](numbers(0))\n        val listOfMaxElements = List[Long]()\n        val maxElement = numbers(0)\n        numbers.foreach {\n            number => {\n                if(number > maxElement) {\n                    maxElement = number\n                    listOfMaxElements = ListBuffer(maxElement)\n                } else {\n                    listOfMaxElements = listOfMaxElements :+ number\n                }\n                result = result ++ listOfMaxElements\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp36rxeki9.scala:15:31 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                    maxElement = number\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Reassignment to val maxElement\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp36rxeki9.scala:16:50 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                    listOfMaxElements = ListBuffer(maxElement)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    scala.collection.mutable.ListBuffer[Long]\n\u001b[31m   |\u001b[0m                     Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp36rxeki9.scala:18:38 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                    listOfMaxElements = listOfMaxElements :+ number\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Reassignment to val listOfMaxElements\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010939
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val rollingMaxResult = mutable.List[Long]()\n        var max = 0\n        var maxIndex = 0\n        for ((number, index) <- numbers.zipWithIndex) {\n            if (number > max) {\n                max = number\n                maxIndex = index\n            }\n        }\n        for (i <- 0 until maxIndex) {\n            val currentMax = numbers(maxIndex - i)\n            if (max == currentMax) {\n                rollingMaxResult += currentMax\n            } else {\n                rollingMaxResult += max\n            }\n        }\n        rollingMaxResult\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppjok5gqi.scala:9:31 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMaxResult\u001b[0m = mutable.List[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                               Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppjok5gqi.scala:14:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                max = number\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    (number : Long)\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010940
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val res = numbers.foldLeft(List[Long]()) { case (acc, number) =>\n            number :: acc\n        }\n        res.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpf_yqe3jz.scala:17)\n\tat Problem.main(tmpf_yqe3jz.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010943
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val rollingMax = new mutable.Array[Long]\n        var maximum = 0L\n        var rollingMaxNumber = 0\n        var i = 1\n        var rollingMaxIndex = 0\n        while(i < numbers.length) {\n            rollingMax(rollingMaxNumber) = numbers(i)\n            rollingMaxNumber += 1\n            i += 1\n            maximum = max(maximum, numbers(i))\n        }\n        rollingMaxIndex = 1\n        while(rollingMaxIndex < rollingMaxNumber) {\n            maximum = max(maximum, rollingMax(rollingMaxIndex))\n            i += 1\n            rollingMaxIndex += 1\n        }\n        rollingMax(rollingMaxNumber)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyq1q26cn.scala:9:29 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMax\u001b[0m = \u001b[33mnew\u001b[0m mutable.Array[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010935
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val rollingMax = numbers.foldLeft(List.empty[Long])((acc, x) => acc max x)\n        val rollingMaxList: List[Long] = rollingMax.toList\n        rollingMaxList.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqygxqyzu.scala:9:80 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMax\u001b[0m = numbers.foldLeft(List.empty[\u001b[35mLong\u001b[0m])((\u001b[36macc\u001b[0m, \u001b[36mx\u001b[0m) => acc max x)\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                ^\u001b[0m\n\u001b[31m  |\u001b[0m                                                  Found:    (x : Long)\n\u001b[31m  |\u001b[0m                                                  Required: Ordering[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010942
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        // Using mutable collection to store all rolling maximum elements\n        // The purpose of this mutable collection is to prevent multiple time searching same rolling\n        // max element in the rolling max list\n        val rollingMaxList = mutable.Buffer[Long]()\n        numbers.foreach{number =>\n            if(number > rollingMaxList.last){\n                rollingMaxList += number\n            }\n        }\n        return rollingMaxList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_fskhhrt.scala:12:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMaxList\u001b[0m = mutable.Buffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010936
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        // Use a scala.collection.mutable.Stack to keep track of the current max values seen so far.\n        val stack = new mutable.Stack[Long]()\n        for (i <- numbers) {\n            if (stack.size > 0)\n                stack += max( stack.last , i)\n            else {\n                stack += i\n            }\n        }\n        stack.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpw33rqm3z.scala:10:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstack\u001b[0m = \u001b[33mnew\u001b[0m mutable.Stack[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010937
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        if (numbers.length <= 0) return Nil\n        val max = 0\n        val maxElement = numbers.head\n        val maxList = List(numbers.tail.max) ::: Nil\n        val nextElements = numbers.tail\n        nextElements.tail.foldLeft(List[Long]())((acc, element) => {\n            if (element > max) {\n                max = element\n                maxElement = element\n                maxList = acc\n            }\n            if (element == maxElement) {\n                maxList = maxList :+ element\n            }\n            if (element < maxElement) maxList = maxList :+ element\n            maxList ::: acc\n        })\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpwn9ns5xa.scala:16:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                max = element\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    (element : Long @uncheckedVariance)\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpwn9ns5xa.scala:17:27 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                maxElement = element\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val maxElement\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpwn9ns5xa.scala:18:24 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                maxList = acc\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val maxList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpwn9ns5xa.scala:21:24 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                maxList = maxList :+ element\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val maxList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpwn9ns5xa.scala:23:46 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33mif\u001b[0m (element < maxElement) maxList = maxList :+ element\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Reassignment to val maxList\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660010944
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxElements = mutable.ListBuffer[Long]()\n        for (elem <- numbers) {\n            maxElements += elem\n        }\n        val maxIndex = maxElements.max\n        maxIndex.until(maxIndex.head + 1).foreach { maxIndex =>\n            maxElements.updated(maxIndex, maxElements(maxIndex))\n        }\n        return maxElements.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9ihugi0p.scala:9:26 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxElements\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                          Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010936
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val m = numbers(numbers.size - 1)\n        var i = numbers.size - 1\n        while (i >= 0) {\n            if (numbers(i) > m)\n                m = numbers(i)\n            i--\n        }\n        numbers\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpmsx853gu.scala:14:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            i--\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpmsx853gu.scala:13:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                m = numbers(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010939
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        // Initialize a list to hold rolling maximum\n        val rollingMax = new scala.collection.mutable.ListBuffer[Long]()\n        for (n <- numbers) {\n            // If number is not in the rolling maximum list, add the number to the list\n            if (!rollingMax.contains(n)) {\n                rollingMax.append(n)\n            }\n        }\n        // Return the rolling maximum list\n        rollingMax.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp317spvso.scala:23)\n\tat Problem.main(tmp317spvso.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010945
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxList = numbers.foldLeft(List.empty[Long]){\n            (maxList, elem) =>\n                if (elem > maxList.head) maxList :+ elem\n                else maxList\n        }\n        val list: List[Long] = maxList.drop(maxList.size - 3)\n        list\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.$anonfun$1(tmp752l2ayr.scala:11)\n\tat Problem$.$anonfun$adapted$1(tmp752l2ayr.scala:12)\n\tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\tat scala.collection.immutable.List.foldLeft(List.scala:79)\n\tat Problem$.rollingMax(tmp752l2ayr.scala:12)\n\tat Problem$.main(tmp752l2ayr.scala:19)\n\tat Problem.main(tmp752l2ayr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010946
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxes = scala.collection.mutable.ListBuffer.empty[Long]\n        for (number <- numbers) {\n            val maxIndex = numbers.indexWhere(_ > number)\n            val maxValue = numbers(maxIndex)\n            if (maxes.isEmpty || maxes.last > maxValue)\n                maxes += maxValue\n        }\n        maxes.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.IndexOutOfBoundsException: -1\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:115)\n\tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\tat Problem$.rollingMax$$anonfun$1(tmpv3n3klnt.scala:12)\n\tat scala.runtime.java8.JFunction1$mcVJ$sp.apply(JFunction1$mcVJ$sp.scala:18)\n\tat scala.collection.immutable.List.foreach(List.scala:333)\n\tat Problem$.rollingMax(tmpv3n3klnt.scala:15)\n\tat Problem$.main(tmpv3n3klnt.scala:20)\n\tat Problem.main(tmpv3n3klnt.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010947
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxSeq = new mutable.ListBuffer[Long]()\n        numbers.foreach { x =>\n            val maxIndex = maxSeq.findIndex(_.longValue < x)\n            maxSeq.update(maxIndex + 1, x)\n        }\n        maxSeq.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4i2kkg16.scala:9:25 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxSeq\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                         Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010939
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxList : List[Long] = List.empty[Long]\n        var maxVal : Long = 0\n        var maxIndex = 0\n        numbers.zipWithIndex.foreach {\n            x => {\n                if (x._2 >= maxIndex){\n                    maxVal = x._1\n                    maxIndex = x._2\n                }\n                if (x._2 == maxIndex && x._1 > maxVal) {\n                    maxVal = x._1\n                    maxIndex = x._2\n                }\n            }\n        }\n        maxList.add(maxVal)\n        return maxList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpum80q7e3.scala:24:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        maxList.add(maxVal)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value add is not a member of List[Long]\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010943
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val numList = numbers.toList\n        val numListLen = numList.size\n        val numListMax = numList(0).toLong\n        // generate numListLen rolling max list\n        val numMaxList = new Array[Long](numListLen)\n        var j = 0\n        for(i <- 0 until numListLen){\n            numMaxList(i) = numList(i)\n        }\n        // append rolling max list\n        while(j < numListLen){\n            val maxNum = numMaxList(j)\n            val index = j\n            val k = 1\n            while(k <= numListLen){\n                if(numMaxList(index + k) > maxNum){\n                    numMaxList(index + k) = maxNum\n                }\n                k++\n            }\n            j++\n        }\n        numMaxList.map(_.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpkv2qx71a.scala:27:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                k++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpkv2qx71a.scala:29:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            j++\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpkv2qx71a.scala:31:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        numMaxList.map(_.toLong)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    \u001b[1m\u001b[31mArray\u001b[0m[Long]\n\u001b[31m   |\u001b[0m        Required: \u001b[1m\u001b[32mList\u001b[0m[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010946
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n        numbers.foreach { n =>\n            result += n.toList #:: rollingMax(result.slice)\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqbhvh5ig.scala:9:25 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                         Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010940
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        require(numbers.length >= 1)\n        var max = 0\n        val maxElem = numbers(0)\n        var index = 0\n        var newMax = maxElem\n        for(i <- 1 to numbers.length - 1){\n            val newElem = numbers(i)\n            if (newElem > maxElem){\n                max = newMax\n                index = i\n            }\n            newMax = math.max(newElem, max)\n        }\n        val result = List(maxElem, index)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp38utkz06.scala:17:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                max = newMax\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    (newMax : Long)\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp38utkz06.scala:23:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mreturn\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    (result : List[AnyVal])\n\u001b[31m   |\u001b[0m               Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010947
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val rollingMax = numbers.sortWith(_ < _)\n            .reverse\n            .sliding(numbers.size)\n            .map { n =>\n                val rollingMax = n.sortWith(_ < _)\n                    .reverse\n                    .sliding(numbers.size)\n                    .max\n                rollingMax.max(numbers.last)\n            }\n            .reverse\n            .toList\n        rollingMax\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8gnirj_8.scala:17:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                rollingMax.max(numbers.last)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    Long\n\u001b[31m   |\u001b[0m                               Required: Ordering[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010946
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n      def accumulator(current: Long, accumulator: Long) : Long = if (current > accumulator) current else accumulator\n      numbers.foldLeft(0l.toLong)(accumulator)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxjda6kbb.scala:10:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m      numbers.foldLeft(\u001b[31m0l\u001b[0m.toLong)(accumulator)\n\u001b[31m\u001b[31m   |\u001b[0m      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      Found:    Long\n\u001b[31m   |\u001b[0m      Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010951
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        def computeMax(n: Long, max: List[Long]) : List[Long] = {\n            if (n == 0) max\n            else computeMax(n - 1, max :+ Math.max(n-1, numbers(n-1)))\n        }\n        computeMax(numbers.size, List.empty)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpuqe_w4m2.scala:11:64 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[33melse\u001b[0m computeMax(n - \u001b[31m1\u001b[0m, max :+ Math.max(n-\u001b[31m1\u001b[0m, numbers(n-\u001b[31m1\u001b[0m)))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                          Found:    Long\n\u001b[31m   |\u001b[0m                                                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010953
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        def isMax(x : Long, m : List[Long], s : List[Long]) : Boolean = {\n            if(m.head == x) {\n                true\n            } else {\n                m.head < x && (s = m :: s)\n            }\n        }\n        def maxRolling(n : List[Long], s : List[Long]) : List[Long] = {\n            n match {\n                case Nil => s\n                case x :: Nil => maxRolling(s, List(x.toLong))\n                case x :: xs => maxRolling(isMax(x, xs, s), xs)\n            }\n        }\n        maxRolling(numbers, Nil)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpis8cpy9f.scala:13:33 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                m.head < x && (s = m :: s)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m\u001b[33mmethod\u001b[0m \u001b[35m&&\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mBoolean\u001b[0m: (x: Boolean): Boolean does not have a parameter s\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpis8cpy9f.scala:20:48 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                \u001b[33mcase\u001b[0m x :: xs => maxRolling(isMax(x, xs, s), xs)\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    Boolean\n\u001b[31m   |\u001b[0m                                           Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010954
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        def rolling(list : List[Long], max: Long, current : Long) : List[Long] = {\n            list match {\n                case Nil => List(current)\n                case head :: tail => if(head > current) rolling(tail, max, head) else rolling(tail, max, current)\n            }\n        }\n        rolling(numbers, Int.MaxValue, Int.MaxValue).toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpdd6_bog5.scala:18)\n\tat Problem.main(tmpdd6_bog5.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010957
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val numbersList = numbers.toList\n        val result = new mutable.ListBuffer[Long]()\n        numbersList.iterator\n                .takeWhile(_ <= numbersList(numbersList.size - 1))\n                .foreach(result.add((numbersList(numbersList.length - 1))))\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7kmuqkw1.scala:10:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010949
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        require(numbers.nonEmpty, \"rollingMax requires non-empty list of numbers\")\n        var result = List[Long]()\n        numberIter(numbers, result)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp16bd1brq.scala:11:8 -------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        numberIter(numbers, result)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Not found: numberIter\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010951
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val max = new mutable.ArrayBuffer[Long]()\n        for (n <- numbers) {\n            if (n.toInt > max.toInt) max += n.toLong\n            else n = max\n        }\n        list(a.max(a.last, max.max))\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4jpaswd_.scala:9:22 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                      Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp4jpaswd_.scala:12:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33melse\u001b[0m n = max\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Reassignment to val n\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4jpaswd_.scala:14:8 -------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        list(a.max(a.last, max.max))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Not found: list\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4jpaswd_.scala:14:13 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        list(a.max(a.last, max.max))\n\u001b[31m\u001b[31m   |\u001b[0m             ^\u001b[0m\n\u001b[31m   |\u001b[0m             Not found: a\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010951
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        if (numbers.isEmpty)\n            List()\n        else {\n            val list = numbers.tail\n            val currentMax = list.head\n            val rollingMax = numbers.toList match {\n                case x :: y :: xs => if (x == currentMax) y :: rollingMax\n                     else y :: rollingMax.map(v => if (v > currentMax) v else currentMax)\n                case _ => numbers.toList\n            }\n            rollingMax ++ rollingMax.tail\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpan6oh_vy.scala:15:63 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                \u001b[33mcase\u001b[0m x :: y :: xs => \u001b[33mif\u001b[0m (x == currentMax) y :: rollingMax\n\u001b[31m\u001b[31m   |\u001b[0m                                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Recursive \u001b[33mvalue\u001b[0m \u001b[35mrollingMax\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpan6oh_vy.scala:16:31 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                     \u001b[33melse\u001b[0m y :: rollingMax.map(v => \u001b[33mif\u001b[0m (v > currentMax) v \u001b[33melse\u001b[0m currentMax)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Recursive \u001b[33mvalue\u001b[0m \u001b[35mrollingMax\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010952
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.foldRight[List[Long]](List[Long]())((acc, x) => {\n            if (acc.last >= x) return acc\n            if (acc contains x) acc :+ x\n            else acc :+ acc.last + 1\n        })\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr_jnm_jy.scala:10:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            \u001b[33mif\u001b[0m (acc.last >= x) \u001b[33mreturn\u001b[0m acc\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value last is not a member of Long\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr_jnm_jy.scala:10:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            \u001b[33mif\u001b[0m (acc.last >= x) \u001b[33mreturn\u001b[0m acc\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (acc : Long)\n\u001b[31m   |\u001b[0m                                      Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr_jnm_jy.scala:11:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[33mif\u001b[0m (acc contains x) acc :+ x\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value contains is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr_jnm_jy.scala:11:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[33mif\u001b[0m (acc contains x) acc :+ x\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value :+ is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr_jnm_jy.scala:12:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33melse\u001b[0m acc :+ acc.last + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value :+ is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpr_jnm_jy.scala:12:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33melse\u001b[0m acc :+ acc.last + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value last is not a member of Long\n6 errors found\n",
      "stdout": "",
      "timestamp": 1660010960
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        // For each element in the list, generate the maximum (max or rolling max)\n        // until that moment, then add it to the list and return it.\n        numbers.foldLeft(List[Long]())((accumulator, element) => accumulator :+ math.max(element))\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpocj797hy.scala:11:85 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        numbers.foldLeft(List[\u001b[35mLong\u001b[0m]())((\u001b[36maccumulator\u001b[0m, \u001b[36melement\u001b[0m) => accumulator :+ math.max(element))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double, y: Double): Double\n\u001b[31m   |\u001b[0m (x: Float, y: Float): Float\n\u001b[31m   |\u001b[0m (x: Long, y: Long): Long\n\u001b[31m   |\u001b[0m (x: Int, y: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments ((element : Long))\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010952
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.foldLeft(List[Long]()){\n            (x: mutable.Buffer, n: Long) => {\n                if (x.size < n) x ++= List(n.toLong)\n                else\n                { val maxEle = x.lastOption.getOrElse(x.size)\n                    x ++= List(maxEle - 1, maxEle)}\n            }\n        }.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppydqteer.scala:10:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            (\u001b[36mx\u001b[0m: mutable.Buffer, \u001b[36mn\u001b[0m: \u001b[35mLong\u001b[0m) => {\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010953
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val max = new mutable.PriorityQueue[Long]() //max value found so far\n        numbers.foreach { n =>\n            max.enqueue(math.max(n, max.head))\n        }\n        val result = new mutable.PriorityQueue[Long]()\n        number.foreach { n =>\n            if (max.size > 0) result.enqueue(math.max(n, max.dequeue))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjkjr4609.scala:9:22 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]() \u001b[34m//max value found so far\u001b[0m\n\u001b[31m\u001b[31m  |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                      Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjkjr4609.scala:13:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.PriorityQueue[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjkjr4609.scala:14:8 -------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        number.foreach { \u001b[36mn\u001b[0m =>\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Not found: number\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010953
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val list = numbers.toList\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        val max = list.max\n        \n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpx99dwqjy.scala:11:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = list.max\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmax is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmax\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpx99dwqjy.scala:12:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = list.max\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmax is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmax\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpx99dwqjy.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = list.max\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmax is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmax\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpx99dwqjy.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = list.max\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmax is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmax\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpx99dwqjy.scala:15:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = list.max\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmax is already defined as \u001b[33mvalue\u001b[0m \u001b[35mmax\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpx99dwqjy.scala:16:12 ---------------------------\u001b[0",
      "stdout": "",
      "timestamp": 1660010961
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        if (numbers.isEmpty) {\n            numbers\n        } else {\n            var maxNumbers : List[Long] = List(numbers.head)\n            var currentNumbers = List(numbers.tail)\n            var rollingMaxNumber = numbers.head\n\n            while (currentNumbers.nonEmpty) {\n                var foundRollingMaxNumber = false\n                var rollingMaxIndex = -1\n\n                for (i <- 0 until currentNumbers.size) {\n                    if (maxNumbers.exists(number => number > currentNumbers(i))) {\n                        if (foundRollingMaxNumber) {\n                            maxNumbers = List(currentNumbers(i))\n                            foundRollingMaxNumber = false\n                        } else {\n                            maxNumbers = maxNumbers.head :: List(currentNumbers(i))\n                            rollingMaxIndex = i + 1\n                            foundRollingMaxNumber = true\n                        }\n                    }\n                }\n\n                if (!foundRollingMaxNumber) {\n                    maxNumbers = rollingMaxNumber :: maxNumbers\n                }\n\n                currentNumbers = currentNumbers.tail\n                rollingMaxNumber = maxNumbers(rollingMaxIndex)\n            }\n\n            maxNumbers\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpb9wo43ve.scala:21:59 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                    \u001b[33mif\u001b[0m (maxNumbers.exists(\u001b[36mnumber\u001b[0m => number > currentNumbers(i))) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m>\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Boolean\n\u001b[31m   |\u001b[0m (x: Float): Boolean\n\u001b[31m   |\u001b[0m (x: Long): Boolean\n\u001b[31m   |\u001b[0m (x: Int): Boolean\n\u001b[31m   |\u001b[0m (x: Char): Boolean\n\u001b[31m   |\u001b[0m (x: Short): Boolean\n\u001b[31m   |\u001b[0m (x: Byte): Boolean\n\u001b[31m   |\u001b[0mmatch arguments (List[Long])\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb9wo43ve.scala:23:60 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                            maxNumbers = List(currentNumbers(i))\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Found:    \u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mLong\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m                                              Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb9wo43ve.scala:26:41 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                            maxNumbers = maxNumbers.head :: List(currentNumbers(i))\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    List[Matchable]\n\u001b[31m   |\u001b[0m                                         Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010963
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var currentMax = numbers(0)\n        var currentMaxIndex = -1\n\n        var maxRolling = 0\n        var maxRollingIndex = 0\n        var maxRollingValue = 0\n        var maxRollingIndexValue = 0\n        var rollingValue = 0\n        var rollingIndex = 0\n\n        for (i <- 0 until numbers.length) {\n            rollingIndex = 0\n            currentMaxIndex = i\n\n            for (j <- 0 until numbers.length) {\n                if (i != j) {\n                    rollingValue = numbers(j)\n                    if (rollingValue > currentMax) {\n                        currentMax = rollingValue\n                        currentMaxIndex = j\n                    }\n                    rollingIndex += 1\n                }\n            }\n\n            if (currentMaxIndex != maxRollingIndex) {\n                maxRollingIndex = currentMaxIndex\n                maxRollingValue = currentMax\n                maxRollingIndexValue = currentMaxIndex\n                rollingValue = currentMax\n                rollingIndex = currentMaxIndex\n            } else {\n                rollingIndex += 1\n                rollingValue = currentMax\n                rollingIndexValue = currentMaxIndex\n                if (rollingValue > maxRollingValue) {\n                    maxRollingValue = rollingValue\n                    maxRollingIndexValue = currentMaxIndex\n                }\n            }\n        }\n\n        return numbers(maxRollingIndexValue) ++ rollingValue\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpy_6dfq3_.scala:25:42 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                    rollingValue = numbers(j)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Found:    Long\n\u001b[31m   |\u001b[0m                                   Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpy_6dfq3_.scala:36:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                maxRollingValue = currentMax\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (currentMax : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpy_6dfq3_.scala:38:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m                rollingValue = currentMax\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    (currentMax : Long)\n\u001b[31m   |\u001b[0m                               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpy_6dfq3_.scala:42:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m                rollingValue = currentMax\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    (currentMax : Long)\n\u001b[31m   |\u001b[0m                               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpy_6dfq3_.scala:43:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m43 |\u001b[0m                rollingIndexValue = currentMaxIndex\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: rollingIndexValue\n\u001b[31m",
      "stdout": "",
      "timestamp": 1660010964
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxList = numbers.map(_.toLong).scanLeft(0L)(_ + _).tail\n        val rollingMax = maxList.max\n        maxList.map { max =>\n            if (max > rollingMax) rollingMax else max\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\tat Problem$.rollingMax(tmpgxv02ldo.scala:10)\n\tat Problem$.main(tmpgxv02ldo.scala:16)\n\tat Problem.main(tmpgxv02ldo.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010965
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val m = new mutable.HashMap[Long, Int]\n        var rollingMax = List[Long]()\n        for(i <- numbers ) {\n            val curMax = m.getOrElse(i, -1)\n            if(curMax == -1) { // first time we encounter this element\n                rollingMax:::=i\n                m.put(i, 1)\n            }\n            else { // we have not seen the element before and we need to check its rollingMax\n                val newMax = Math.max(curMax, i)\n                m.put(i, newMax)\n                if(newMax > rollingMax.last) {\n                    rollingMax:::=newMax\n                }\n            }\n        }\n        rollingMax\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx274pqxc.scala:9:20 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mm\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mInt\u001b[0m]\n\u001b[31m\u001b[31m  |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                    Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx274pqxc.scala:14:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                rollingMax:::=i\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m value :::= is not a member of List[Long] - did you mean List[Long].:::?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010962
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val rollingMax = numbers.map(_ => (numbers.reduceLeftOption(_ > _).getOrElse(0L), numbers)).groupBy(x => x(0)).mapValues(x => x.map(y => (y(1), y(2)))).mapValues(x => x.map(_._1).max).toList\n        rollingMax.map(_._2)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphfooddzm.scala:9:68 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMax\u001b[0m = numbers.map(_ => (numbers.reduceLeftOption(_ > _).getOrElse(\u001b[31m0L\u001b[0m), numbers)).groupBy(\u001b[36mx\u001b[0m => x(\u001b[31m0\u001b[0m)).mapValues(\u001b[36mx\u001b[0m => x.map(\u001b[36my\u001b[0m => (y(\u001b[31m1\u001b[0m), y(\u001b[31m2\u001b[0m)))).mapValues(\u001b[36mx\u001b[0m => x.map(_._1).max).toList\n\u001b[31m\u001b[31m  |\u001b[0m                                                                    ^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                                         Found:    Boolean\n\u001b[31m  |\u001b[0m                                                         Required: Long\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmphfooddzm.scala:9:153 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMax\u001b[0m = numbers.map(_ => (numbers.reduceLeftOption(_ > _).getOrElse(\u001b[31m0L\u001b[0m), numbers)).groupBy(\u001b[36mx\u001b[0m => x(\u001b[31m0\u001b[0m)).mapValues(\u001b[36mx\u001b[0m => x.map(\u001b[36my\u001b[0m => (y(\u001b[31m1\u001b[0m), y(\u001b[31m2\u001b[0m)))).mapValues(\u001b[36mx\u001b[0m => x.map(_._1).max).toList\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                                                                                         ^\u001b[0m\n\u001b[31m  |\u001b[0m        Match type reduction failed since selector  EmptyTuple.type\n\u001b[31m  |\u001b[0m        matches none of the cases\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m            case x *: xs => (\u001b[31m0\u001b[0m : Int)\u001b[33m match \u001b[0m{\n\u001b[31m  |\u001b[0m          case (\u001b[31m0\u001b[0m : Int) => x\n\u001b[31m  |\u001b[0m          case scala.compiletime.ops.int.S[n1] => scala.Tuple.Elem[xs, n1]\n\u001b[31m  |\u001b[0m        }\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphfooddzm.scala:10:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        rollingMax.map(_._2)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    \u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mLong\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m  ",
      "stdout": "",
      "timestamp": 1660010968
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        def rollingMaxHelper(numbers: List[Long], max: Long, prev: List[Long], result: List[Long]) : List[Long] = {\n            if (numbers.isEmpty) {\n                result\n            } else {\n                val x = numbers.head\n                if (prev.isEmpty || x > prev) {\n                    rollingMaxHelper(numbers.tail, max, List(numbers(0)), result :+ max)\n                } else {\n                    rollingMaxHelper(numbers.tail, max, List(max), result :+ x)\n                }\n            }\n        }\n        rollingMaxHelper(numbers, numbers(0), numbers.init, List.empty)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpuxnuh2x9.scala:14:38 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                \u001b[33mif\u001b[0m (prev.isEmpty || x > prev) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m>\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Boolean\n\u001b[31m   |\u001b[0m (x: Float): Boolean\n\u001b[31m   |\u001b[0m (x: Long): Boolean\n\u001b[31m   |\u001b[0m (x: Int): Boolean\n\u001b[31m   |\u001b[0m (x: Char): Boolean\n\u001b[31m   |\u001b[0m (x: Short): Boolean\n\u001b[31m   |\u001b[0m (x: Byte): Boolean\n\u001b[31m   |\u001b[0mmatch arguments ((prev : List[Long]))\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010961
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val numbersWithMax = numbers.foldLeft(List[Long]()){case (numbers, i) => if (numbers(numbers.size - 1) < i) numbers :+ i else numbers}\n        val numbersWithMaxSize = numbersWithMax.size\n        val max = numbersWithMax.last\n        val maxSize = numbersWithMaxSize - 1\n        val numbersRolled = new scala.collection.mutable.ListBuffer[Long]()\n        var i = 0\n        while (i < maxSize) {\n            numbersRolled += numbersWithMax(i).abs\n            i += 1\n        }\n        numbersRolled.take(maxSize).toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: last of empty list\n\tat scala.collection.immutable.Nil$.last(List.scala:665)\n\tat scala.collection.immutable.Nil$.last(List.scala:661)\n\tat Problem$.rollingMax(tmpgzx99q9e.scala:11)\n\tat Problem$.main(tmpgzx99q9e.scala:22)\n\tat Problem.main(tmpgzx99q9e.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010970
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        require(numbers contains numbers.length, \"The rolling max number list must contain its length\")\n        require(numbers contains numbers.head, \"The rolling max number list must contain its head\")\n        require(numbers contains numbers.tail, \"The rolling max number list must contain its tail\")\n        var max = 0l\n        numbers.foreach { number =>\n            val currentMax = Math.max(max, number)\n            max = (currentMax + 1).toLong\n        }\n        numbers.reverse.takeWhile(number => max < number).toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.IllegalArgumentException: requirement failed: The rolling max number list must contain its length\n\tat scala.Predef$.require(Predef.scala:337)\n\tat Problem$.rollingMax(tmpd0suueu8.scala:9)\n\tat Problem$.main(tmpd0suueu8.scala:20)\n\tat Problem.main(tmpd0suueu8.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010968
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var maxSoFar = -1L\n        var rollingMaxSoFar = -1L\n        var rollingMax = List[Long]()\n        var rollingMaxIndex = List[Int]()\n        numbers.foreach(x => {\n            rollingMaxSoFar = x\n            if (x > maxSoFar) {\n                maxSoFar = x\n            }\n            rollingMaxIndex += 1 // update max index\n            rollingMax = rollingMax.toList :+ maxSoFar\n        })\n        rollingMaxIndex.toList.map(x => rollingMax(x)) // return list of rolling max\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgmwu9udm.scala:18:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            rollingMaxIndex += \u001b[31m1\u001b[0m \u001b[34m// update max index\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value += is not a member of List[Int] - did you mean List[Int].!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010967
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var max = 0L\n        val ret: List[Long] = numbers.map { n =>\n            if (max <= n) max = n\n            n else 0L\n        }\n        return ret.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp9zzmrfdk.scala:12:14 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            n \u001b[33melse\u001b[0m \u001b[31m0L\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              end of statement expected but 'else' found\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010960
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var max = numbers.head\n        var maxIndex = numbers.lastIndex\n        numbers.tail.foreach {\n            if (_ > max) {\n                max = _\n                maxIndex = _\n            }\n        }\n        if (maxIndex - numbers.lastIndex < maxIndex) {\n            numbers = numbers.init :+ max\n        }\n        numbers :+ max\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpaqjhe_6q.scala:10:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxIndex\u001b[0m = numbers.lastIndex\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue lastIndex is not a member of List[Long] - did you mean numbers.lastIndexOf?\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpaqjhe_6q.scala:12:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mif\u001b[0m (_ > max) {\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$1 of expanded function:\n\u001b[31m   |\u001b[0m   _$1 => _$1 > max.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpaqjhe_6q.scala:13:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                max = _\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$2 of expanded function:\n\u001b[31m   |\u001b[0m   _$2 => max = _$2.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmpaqjhe_6q.scala:14:27 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                maxIndex = _\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$3 of expanded function:\n\u001b[31m   |\u001b[0m   _$3 => maxIndex = _$3.\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpaqjhe_6q.scala:18:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            numbers = numbers.init :+ max\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val numbers\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660010968
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val rollingMaxValues = mutable.ListBuffer.empty[Long]\n        numbers.foreach { x =>\n            rollingMaxValues.append(rollingMaxValues(rollingMaxValues.size-1))\n        }\n        rollingMaxValues.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp64ipwl4l.scala:9:31 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMaxValues\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m  |\u001b[0m                               ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                               Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010965
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        def maxRoll(list: List[Long], acc: Long) : Long = {\n            if (list.isEmpty) acc\n            else {\n                val max = math.max(list._1, acc)\n                list.tail.tail.foreach(x => acc += x)\n                if (max < acc) max else maxRoll(list.tail, acc)\n            }\n        }\n        numbers.tail.init.reverse.map(x => maxRoll(numbers.init, x)).reverse.drop(numbers.size - 1)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpn_uegm04.scala:12:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = math.max(list._1, acc)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value _1 is not a member of List[Long]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpn_uegm04.scala:13:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                list.tail.tail.foreach(\u001b[36mx\u001b[0m => acc += x)\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value += is not a member of Long - did you mean acc.!=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010973
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val result: List[Long] = Nil\n        val map = mutable.HashMap[Long, Long]()\n\n        numbers foreach { n =>\n            if (map.contains(n)) {\n                val previous = map.get(n)\n                map.put(n, previous + 1)\n            } else {\n                map.put(n, 1L)\n            }\n        }\n\n        numbers.foldLeft(map)((acc: Map[Long, Long], n: Long) => {\n            if (acc.contains(n)) {\n                val previous = acc.get(n)\n                acc.put(n, previous + 1)\n            } else {\n                acc.put(n, 1L)\n            }\n        })\n\n        acc flatMap {\n            case (k, v) =>\n                if (k > v) {\n                    v\n                } else {\n                    Nil\n                }\n        } toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp10vfzv9b.scala:37:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m        } toList\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp10vfzv9b.scala:10:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmap\u001b[0m = mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp10vfzv9b.scala:24:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                acc.put(n, previous + \u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of Option[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp10vfzv9b.scala:30:8 -------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m        acc flatMap {\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Not found: acc\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660010972
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var curr = numbers(0)\n        numbers.tail.foreach { n =>\n            if (curr < n) curr = n\n            else numbers = numbers :+ n\n        }\n        numbers :+ curr\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp2mq20j48.scala:12:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33melse\u001b[0m numbers = numbers :+ n\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Reassignment to val numbers\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010966
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxIndex = numbers.lastIndex\n        if (maxIndex == -1) numbers else numbers.drop(maxIndex).map(x => numbers.takeWhile(y => y > x).max)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmprtct7cmx.scala:9:31 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = numbers.lastIndex\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0mvalue lastIndex is not a member of List[Long] - did you mean numbers.lastIndexOf?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010971
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val res = new ListBuffer[Long]()\n        var max = 0\n        for {\n            n <- numbers\n        } max += n\n\n        while (max < numbers.length) {\n            max += numbers.length\n            res += numbers(max)\n        }\n\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpozkpvge5.scala:13:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        } max += n\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpozkpvge5.scala:20:8 ---------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        res\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    (res : scala.collection.mutable.ListBuffer[Long])\n\u001b[31m   |\u001b[0m        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010974
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        if (numbers.isEmpty) List(1l.toLong)\n        else {\n            var max = 0L\n            var rollingMax: Option[Long] = None\n            for (x <- numbers) {\n                if (x > max) max = x\n                else {\n                    if (rollingMax.isEmpty) rollingMax = x\n                    else rollingMax = Some(rollingMax.get + x)\n                }\n            }\n            rollingMax.get\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6_le4rg2.scala:16:57 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                    \u001b[33mif\u001b[0m (rollingMax.isEmpty) rollingMax = x\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Found:    (x : Long)\n\u001b[31m   |\u001b[0m                                                  Required: Option[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6_le4rg2.scala:20:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            rollingMax.get\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    Long\n\u001b[31m   |\u001b[0m            Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010973
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var current = List[Long]()\n        var max = 0l\n        numbers.foreach {n =>\n            var newMax = math.max(max, n)\n            current = current :+ newMax\n            max = newMax\n        }\n        current\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1660010974
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var max = 0L\n        var rollMax = 0L\n        var rollMaxIndex = 0L\n        var rollMaxIndexList = List[Long]()\n        var maxIndex = 0L\n\n        numbers.foreach { number =>\n            if (number > max) {\n                max = number\n                maxIndex = number\n                rollMaxIndexList.clear()\n                rollMaxIndexList.push(number)\n                rollMaxIndex = 0L\n            } else if (number == max) {\n                rollMaxIndexList.push(number)\n                rollMaxIndex += 1\n                rollMaxIndexList.push(number)\n            } else {\n                if (rollMaxIndexList.contains(maxIndex - rollMax)) {\n                    rollMaxIndexList.clear()\n                    rollMaxIndexList.push(maxIndex)\n                    rollMaxIndex += 1\n                    rollMaxIndexList.push(maxIndex)\n                }\n            }\n        }\n        rollMaxIndexList.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8vyvqabd.scala:19:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                rollMaxIndexList.clear()\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue clear is not a member of List[Long] - did you mean List[Long].clone?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8vyvqabd.scala:20:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                rollMaxIndexList.push(number)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue push is not a member of List[Long] - did you mean List[Long].last?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8vyvqabd.scala:23:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                rollMaxIndexList.push(number)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue push is not a member of List[Long] - did you mean List[Long].last?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8vyvqabd.scala:25:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                rollMaxIndexList.push(number)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue push is not a member of List[Long] - did you mean List[Long].last?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8vyvqabd.scala:28:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                    rollMaxIndexList.clear()\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue clear is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.seq AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.collection asJava\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.collection asJava\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8vyvqabd.scala:29:37 ---------",
      "stdout": "",
      "timestamp": 1660010978
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val currentMax = numbers.reduceLeftOption(_ > _).getOrElse(-1L)\n        numbers.reverse.map { n =>\n            if (n < currentMax) {\n                currentMax = n\n                n\n            } else {\n                currentMax\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl8h8ro_k.scala:9:50 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mcurrentMax\u001b[0m = numbers.reduceLeftOption(_ > _).getOrElse(-\u001b[31m1L\u001b[0m)\n\u001b[31m\u001b[31m  |\u001b[0m                                                  ^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                                  Found:    Boolean\n\u001b[31m  |\u001b[0m                                                  Required: Long\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpl8h8ro_k.scala:12:27 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m                currentMax = n\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val currentMax\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010977
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val l = numbers.asInstanceOf[mutable.WrappedArray[Long]]\n        val maxIndexes = mutable.ListBuffer[Int]()\n\n        def rollingMaxHelper(i : Int) : List[Long] = {\n            if (i >= l.length) {\n                maxIndexes += i\n                return l\n            }\n            val current = l(i)\n            val index = i\n            val leftIndexes = maxIndexes ++ List(index - 1)\n\n            val leftMaxs = rollingMaxHelper(index)\n            val rightMaxs = rollingMaxHelper(index + 1)\n            val leftMax = leftMaxs.max\n            val rightMax = rightMaxs.max\n\n            val leftGreaterThanRight = current > rightMax\n            if (leftGreaterThanRight) leftMaxs else rightMaxs\n        }\n\n        rollingMaxHelper(0)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpevocmony.scala:9:37 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ml\u001b[0m = numbers.asInstanceOf[mutable.WrappedArray[\u001b[35mLong\u001b[0m]]\n\u001b[31m\u001b[31m  |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                     Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpevocmony.scala:10:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndexes\u001b[0m = mutable.ListBuffer[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010975
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var max = -math.inf\n        for(i <- numbers) {\n            if (max < i) max = i\n        }\n        numbers.foldLeft(List[Long]())((l, number) => l.head == number ? l :+ number)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbos6cxgl.scala:9:24 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmax\u001b[0m = -math.inf\n\u001b[31m\u001b[31m  |\u001b[0m                   ^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                   value inf is not a member of math\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbos6cxgl.scala:13:71 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        numbers.foldLeft(List[\u001b[35mLong\u001b[0m]())((\u001b[36ml\u001b[0m, \u001b[36mnumber\u001b[0m) => l.head == number ? l :+ number)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         value ? is not a member of Long\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010982
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxs = mutable.ListBuffer.empty[Long]\n        numbers foreach { x =>\n            while (true) {\n                x match {\n                    case 3 => maxs += x.toLong\n                    case 2 => maxs += x.toLong\n                    case 1 => maxs += x.toLong\n                    case 0 => break\n                    case _ => x -= 1\n                }\n            }\n        }\n        maxs.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbcqtwpri.scala:9:19 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxs\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m  |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                   Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbcqtwpri.scala:16:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                    \u001b[33mcase\u001b[0m \u001b[31m0\u001b[0m => break\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbcqtwpri.scala:17:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                    \u001b[33mcase\u001b[0m _ => x -= \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value -= is not a member of Long - did you mean x.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010982
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        if (numbers.length == 0) List(1l.toLong)\n        else {\n            val maxIndex = numbers.length - 1\n            val maxValue = numbers.last\n            var currentMax = maxValue\n            var currentIndex = 0\n            val result = new mutable.ArrayBuffer(maxValue)\n            var i = 0\n            for (i <- numbers.indices){\n                if (i < maxIndex) {\n                    currentMax = numbers(i)\n                    currentIndex = i\n                }\n                if (currentMax < maxValue) {\n                    result.synchronized {\n                        result += currentMax\n                        currentMax = numbers(currentIndex)\n                    }\n                    currentIndex = currentIndex + 1\n                }\n            }\n            result.synchronized {\n                result += currentMax\n            }\n            result.toList\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmppyp61314.scala:15:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayBuffer(maxValue)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010976
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var currentMax = 0\n        var maxIndex = 0\n        var maxRolling = List[Long]()\n        for (i <- 0 until numbers.length) {\n            if (maxIndex < i) {\n                currentMax = numbers(i)\n                maxIndex = 0\n            } else {\n                if (currentMax > numbers(i)) {\n                    maxIndex = i + 1\n                    maxRolling = (numbers(maxIndex) :: maxRolling)\n                    currentMax = numbers(i)\n                } else {\n                    maxIndex = i\n                }\n            }\n        }\n        maxRolling\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsexyoc0q.scala:14:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                currentMax = numbers(i)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    Long\n\u001b[31m   |\u001b[0m                             Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsexyoc0q.scala:20:40 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                    currentMax = numbers(i)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    Long\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010984
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.foldLeft(List[Long]())(\n            (l: List[Long], n: Long) => {\n                if (l.length < 5) {\n                    l.updated(l.length, n)\n                } else {\n                    val l2 = l.drop(l.length - 1).drop(1)\n                    l2.max(n) :: l\n                }\n            })\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpa0w4g6sw.scala:15:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                    l2.max(n) :: l\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (n : Long)\n\u001b[31m   |\u001b[0m                           Required: Ordering[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010983
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var max: Long = numbers(0)\n        var result: List[Long] = List()\n\n        numbers match {\n            case x :: tail =>\n                x.toLong match {\n                    case max: Long =>\n                        result = x :: result\n                    case max =>\n                        max = x\n                }\n\n                rollingMax(tail) match {\n                    case x :: tail =>\n                        max == x.toLong match {\n                            case true =>\n                                result = x :: result\n                            case false =>\n                                rollingMax(tail)\n                        }\n                    case _ =>\n                        result\n                }\n            case Nil =>\n                result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp51fc_0fk.scala:18:28 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                        max = x\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Reassignment to val max\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp51fc_0fk.scala:25:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                                result = x :: result\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    Unit\n\u001b[31m   |\u001b[0m                                Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010983
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.toList.tail.reverse.foldLeft(List[Long]())((max, element) => {\n            val last = max.last\n            val currMax = last match {\n                case None =>\n                    element\n                case _ =>\n                    if (element > last) element else last\n            }\n            val newMax = currMax :: max\n            newMax\n        })\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpvot0h6w9.scala:12:21 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m                \u001b[33mcase\u001b[0m None =>\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    None.type\n\u001b[31m   |\u001b[0m                     Required: Long\n\u001b[31m   |\u001b[0m                     pattern type is incompatible with expected type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010980
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var res = ListBuffer[Long]()\n        var max = 0L\n        numbers.foreach{ n =>\n            if(n <= max) {\n                max = n\n                res = res :+ max\n            }\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqg4onh06.scala:17:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mreturn\u001b[0m res\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    (res : scala.collection.mutable.ListBuffer[Long])\n\u001b[31m   |\u001b[0m             Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010984
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val rollingMaxList = mutable.ListBuffer[Long]()\n        for (i <- 0 until numbers.length) {\n            val current = numbers(i)\n            rollingMaxList += current\n            for (j <- 0 until rollingMaxList.length) {\n                if (current > rollingMaxList(j)) {\n                    rollingMaxList(j) = current\n                }\n            }\n        }\n        rollingMaxList.take(numbers.length)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp790n31za.scala:9:29 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMaxList\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010981
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val max: mutable.Map[Int, Long] = new mutable.HashMap[Int, Long]\n        var maxIndex = -1L\n        numbers.foreach { n =>\n            if (max.containsKey(n)) {\n                max.put(maxIndex, n)\n            } else {\n                if (maxIndex != -1) {\n                    maxIndex += 1\n                    max.put(maxIndex, numbers.last)\n                }\n                maxIndex = -1L\n            }\n        }\n        if (maxIndex != -1L) {\n            maxIndex += 1\n            max.put(maxIndex, numbers.last)\n        }\n        max.toList.sortBy(_._2).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprxzy7tcu.scala:9:17 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m: mutable.Map[\u001b[35mInt\u001b[0m, \u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m  |\u001b[0m                 ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                 Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmprxzy7tcu.scala:9:46 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m: mutable.Map[\u001b[35mInt\u001b[0m, \u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m  |\u001b[0m                                              ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                              Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010982
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val m = numbers.head\n        var current = numbers.tail.max\n        numbers match {\n            case head :: tail => {\n                val max = tail.max\n                if (current < max) head :: rollingMax(tail)\n                else rollingMax(tail)\n            }\n            case _ => List(current)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.rollingMax(tmpv14sbtbf.scala:9)\n\tat Problem$.main(tmpv14sbtbf.scala:21)\n\tat Problem.main(tmpv14sbtbf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660010990
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val result = new mutable.ListBuffer[Long]()\n        numbers.foreach { number =>\n            number match {\n                case x if x >= result.last.max => result.last :+ x\n                case x => result :+ x\n            }\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpak9_1o25.scala:9:25 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                         Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010982
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val max = numbers(0)\n        val max_max_so_far = numbers.tail.foldLeft(0l){ (a,b) => if (a > b) a else b}\n        val max_in_tail = numbers.tail.foldLeft(0l){ (a,b) => if (a > b) a else b}\n        val min_max_so_far = numbers.head.foldLeft(0l){ (a,b) => if (a > b) a else b}\n        val min_max_in_head = numbers.head.foldLeft(0l){ (a,b) => if (a > b) a else b}\n\n        numbers.drop(1).sliding(2).collect {\n            x => if (x == max_max_so_far) max_in_tail else if (x == max_max_so_far - max_in_tail) max else if (x == max_max_so_far - min_max_so_far) max_in_tail else if (x == max_max_so_far - min_max_so_far - max_in_tail) max else min_max_in_head\n        }.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp721_1y3g.scala:12:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmin_max_so_far\u001b[0m = numbers.head.foldLeft(\u001b[31m0l\u001b[0m){ (\u001b[36ma\u001b[0m,\u001b[36mb\u001b[0m) => \u001b[33mif\u001b[0m (a > b) a \u001b[33melse\u001b[0m b}\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value foldLeft is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp721_1y3g.scala:13:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmin_max_in_head\u001b[0m = numbers.head.foldLeft(\u001b[31m0l\u001b[0m){ (\u001b[36ma\u001b[0m,\u001b[36mb\u001b[0m) => \u001b[33mif\u001b[0m (a > b) a \u001b[33melse\u001b[0m b}\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value foldLeft is not a member of Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmp721_1y3g.scala:16:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == max_max_so_far) max_in_tail \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x == max_max_so_far - max_in_tail) max \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x == max_max_so_far - min_max_so_far) max_in_tail \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x == max_max_so_far - min_max_so_far - max_in_tail) max \u001b[33melse\u001b[0m min_max_in_head\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    Values of types List[Long] and Long cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmp721_1y3g.scala:16:63 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == max_max_so_far) max_in_tail \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x == max_max_so_far - max_in_tail) max \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x == max_max_so_far - min_max_so_far) max_in_tail \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (x == max_max_so_far - min_max_so_far - max_in_tail) max \u001b[33melse\u001b[0m min_max_in_head\n\u001b[31m\u001b[31m   |\u001b[0m                                                               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    Values of types List[Long] and Long cannot be comp",
      "stdout": "",
      "timestamp": 1660010991
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val nums = numbers.toList\n        val result = mutable.ArrayBuffer.empty[Long]\n        val window = nums.head\n        nums.reverse.tail.foreach(num => {\n            var maxNum = num\n            while (num > window) {\n                maxNum = num - maxNum\n            }\n            val value = result.length\n            if (value > 0 && result(value-1) > maxNum) {\n                result.update(value-1, maxNum)\n            }\n        })\n        result.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1ggvb075.scala:10:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010984
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val ret = new mutable.ListBuffer[Long]()\n        for (i <- numbers) {\n            val lastRet = ret.toList.reverse.tail.last\n            val next = i + lastRet\n            if (next > numbers(0))\n                ret.append(next)\n        }\n        return ret.toList.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpiwrkbfu2.scala:9:22 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mret\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                      Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010984
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        if (numbers.isEmpty) return List()\n        numbers.reverse.foldLeft(numbers.reverse.maxBy(_.toLong).asInstanceOf[Long])((max, x) =>\n            if (x <= max) x else max)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpacrgf7hh.scala:10:84 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        numbers.reverse.foldLeft(numbers.reverse.maxBy(_.toLong).asInstanceOf[\u001b[35mLong\u001b[0m])((\u001b[36mmax\u001b[0m, \u001b[36mx\u001b[0m) =>\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Long\n\u001b[31m   |\u001b[0m        Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[33mif\u001b[0m (x <= max) x \u001b[33melse\u001b[0m max)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010991
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        // Create a mutable list to hold rolling max\n        var maxRolling : mutable.Buffer[Long] = mutable.Buffer.empty\n\n        // Start with largest element in the list\n        var largestNum = numbers(0)\n        // Keep iterating the numbers and find the rolling max\n        for (i <- 1 to numbers.size)\n        {\n            // If the current number is the largest so far, then add to list\n            if (numbers(i) > largestNum)\n            {\n                maxRolling = maxRolling.+(largestNum)\n                largestNum = numbers(i)\n            }\n        }\n\n        // Return the max rolling number list\n        maxRolling.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_awno6pi.scala:10:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxRolling\u001b[0m : mutable.Buffer[\u001b[35mLong\u001b[0m] = mutable.Buffer.empty\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp_awno6pi.scala:10:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxRolling\u001b[0m : mutable.Buffer[\u001b[35mLong\u001b[0m] = mutable.Buffer.empty\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010988
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val buffer = new mutable.ListBuffer[Long]()\n        numbers.foreach( x => { if (x < buffer.last) buffer :+= x else buffer.lastOption match {\n            case Some(x) => buffer :+= x\n            case None => buffer.last }})\n        buffer.reverse.foldLeft(List[Long]())( (a,b) => b:: a).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt7iv09g8.scala:9:25 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbuffer\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                         Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010987
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        // Rolling maximum starts at zero (0)\n        val maxes = new mutable.ListBuffer[Long]()\n        var max = 0\n\n        // Rolling maximum found\n        for (number <- numbers) {\n            if (number > max) {\n                max = number\n                maxes += number\n            } else if (number == max) {\n                maxes += number\n            }\n        }\n\n        // Rolling maximum found\n        val result = maxes.toList\n        if (maxes.size == 1)\n            result\n        else\n            rollingMax(result)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6ki54bde.scala:10:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxes\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6ki54bde.scala:16:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                max = number\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    (number : Long)\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660010993
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        def generateMax(x: Int, numbers: List[Long], result: List[Long]): List[Long] = {\n            if (x == numbers.size) {\n                result:::numbers.reverse\n            } else {\n                generateMax(x+1, numbers, generateMax(x, numbers, result))\n            }\n        }\n        generateMax(0, numbers, Nil)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "Exception in thread \"main\" java.lang.StackOverflowError\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpiimw6iwd.scala:13)\n\tat Problem$.generateMax$1(tmpii",
      "stdout": "",
      "timestamp": 1660010996
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val result = new mutable.ArrayBuffer[Long]()\n        var max = 0L\n        var temp = 0L\n        for (i <- 0 until numbers.size - 1) {\n            temp = 0L\n            max = numbers(i)\n            if (temp > max)\n                max = temp\n            result += max :: Nil\n        }\n        result.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9srn56gf.scala:9:25 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                         Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010990
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val listMax = numbers.foldLeft(List[Long]()) ((l, v) => v :: l)\n        val maxIndex = listMax.length\n        val result: List[Long] = new mutable.MutableList[Long]()\n        for (i <- 0 until maxIndex) {\n            val index = i \n            val sum = numbers(index).foldLeft(0l) { \n                case (v, acc) => acc + v \n            }\n            result += (sum / numbers(index))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb3nwldze.scala:11:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m: \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = \u001b[33mnew\u001b[0m mutable.MutableList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb3nwldze.scala:14:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = numbers(index).foldLeft(\u001b[31m0l\u001b[0m) { \n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value foldLeft is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpb3nwldze.scala:17:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            result += (sum / numbers(index))\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of List[Long] - did you mean result.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660010998
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.foldLeft((List[Long](), numbers.head)) {\n            case ((current, max), i) =>\n                val newMax = max max i\n                val newCurrent = (current :+ i, newMax)\n                (newCurrent, newMax)\n        }._1.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpczgzfdyn.scala:13:17 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                (newCurrent, newMax)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    (newCurrent : (List[Long], Long))\n\u001b[31m   |\u001b[0m                 Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010996
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        def rollingMaxRecursively(numbers: List[Long], i: Int, j : Int, result : List[Long]): List[Long] = {\n            if (i >= j)\n                result\n            else\n                rollingMaxRecursively(numbers, i + 1, j, result :+ max(numbers(i), numbers(i + 1)))\n        }\n\n        val n = numbers.size\n        rollingMaxRecursively(numbers, 0, 0, List.empty[Long])\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpt4q4ezde.scala:21)\n\tat Problem.main(tmpt4q4ezde.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660011002
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var current = List[Long](numbers(0))\n        var max = [Long](numbers(0), numbers(0), numbers(0))\n        // Roll until maximum value is found\n        for(i <- 1 until numbers.size)\n            for(j \u2190 0 until 3) {\n                if(j == 0)\n                    current = numbers(i)\n                else {\n                    val newMax = current((j-1).toInt) + (current((j).toInt)-current((j-1).toInt))\n                    if(newMax > max(0))\n                        max = (max(0), max(1), max(2))\n                    current = newMax\n                }\n            }\n        numbers.size\n            match max {\n                case x :: y :: z :: _ => x :: y :: z :: rollingMax(numbers.filter(_ != x))\n                case x :: y :: _ => x :: rollingMax(numbers.filter(_ != x))\n                case x :: _ => x\n            }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7m6umtne.scala:10:24 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmax\u001b[0m = [Long](numbers(\u001b[31m0\u001b[0m), numbers(\u001b[31m0\u001b[0m), numbers(\u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        '=>' expected, but '(' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7m6umtne.scala:24:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m            \u001b[33mmatch\u001b[0m max {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  '{' expected, but identifier found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp7m6umtne.scala:38:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m38 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7m6umtne.scala:15:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                    current = numbers(i)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    Long\n\u001b[31m   |\u001b[0m                              Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp7m6umtne.scala:18:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                    \u001b[33mif\u001b[0m(newMax > max(\u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp7m6umtne.scala:19:31 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                        max = (max(\u001b[31m0\u001b[0m), max(\u001b[31m1\u001b[0m), max(\u001b[31m2\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation ava",
      "stdout": "",
      "timestamp": 1660011003
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var ret: List[Long] = Nil\n        val mum = numbers.foldRight(0l) { (m: Long, i: Long) => if (m < i) m else i }\n        var k = 0\n        for (i <- numbers) {\n            while ( k < i && mum == numbers(k)) {\n                k += 1\n            }\n            if ( k == i) ret::= mum\n            else ret::= mum\n            mum = i\n            k += 1\n        }\n        ret.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpgiurxogy.scala:18:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            mum = i\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val mum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010996
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val numberSet = numbers.toSet\n        if (numberSet.isEmpty) {\n            List()\n        }\n        else {\n            var max_val : Long = numbers.head\n            val numbers = numbers.tail\n            var maxList = List()\n            var currentList = List()\n            numbers.foreach { number =>\n                if (number > max_val) {\n                    max_val = number\n                }\n                else {\n                    currentList += max_val\n                    max_val = number\n                }\n            }\n            currentList += max_val\n            maxList += currentList.toList\n            maxList\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpbo8ok2df.scala:15:26 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnumbers\u001b[0m = numbers.tail\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Recursive \u001b[33mvalue\u001b[0m \u001b[35mnumbers\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbo8ok2df.scala:27:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            currentList += max_val\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[Nothing] - did you mean List[Nothing].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbo8ok2df.scala:28:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            maxList += currentList.toList\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue += is not a member of List[Nothing] - did you mean List[Nothing].!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660011002
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val max = numbers.head\n        val index = numbers.indexOf(0)\n        numbers.dropWhile(_ < max).map { x =>\n            if (x > max) {\n                max = x\n                index\n            } else {\n                numbers.updated(index, x)\n            }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp6cpkbbgr.scala:13:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                max = x\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val max\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6cpkbbgr.scala:16:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                numbers.updated(index, x)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    \u001b[1m\u001b[31mList\u001b[0m\u001b[1m\u001b[31m[\u001b[0mLong\u001b[1m\u001b[31m]\u001b[0m\n\u001b[31m   |\u001b[0m                Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011001
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val max_rolling = 0\n        val rolling_max = scala.collection.mutable.ListBuffer.empty[Long]\n        numbers.foreach(num => \n            if (rolling_max.length < max_rolling + num) \n                rolling_max += num\n            else if (rolling_max exists (_ == num))\n                max_rolling = rolling_max.length\n        )\n        rolling_max.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp_vsoltms.scala:15:28 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                max_rolling = rolling_max.length\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val max_rolling\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660010995
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxRollingWindow = new scala.collection.mutable.ListBuffer[Long]()\n        var sum = 0l\n        var max = 0L\n        for(i <- numbers)\n        {\n            sum += i\n            if(sum > max)\n            {\n                maxRollingWindow.clear()\n                maxRollingWindow.append(sum)\n            }\n            else if(sum < max)\n            {\n                maxRollingWindow.append(sum)\n            }\n        }\n        if(maxRollingWindow.length == 0)\n        {\n            List()\n        }\n        else\n        {\n            maxRollingWindow.reverse\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxszry3e6.scala:31:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m            maxRollingWindow.reverse\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    scala.collection.mutable.ListBuffer[Long]\n\u001b[31m   |\u001b[0m            Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011002
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        if (numbers.isEmpty) numbers\n        else {\n            val list = numbers.head :: numbers.tail\n            val rollingMax = list.reduce({\n                case (a, b) if a.isDefined => a.get\n                case (a, b) if b.isDefined => b.get\n                case (a, b) => b\n            })\n            rollingMax :: rollingMax(list.drop(1))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppp1u22t6.scala:13:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                \u001b[33mcase\u001b[0m (a, b) \u001b[33mif\u001b[0m a.isDefined => a.get\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value isDefined is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppp1u22t6.scala:13:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                \u001b[33mcase\u001b[0m (a, b) \u001b[33mif\u001b[0m a.isDefined => a.get\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       value get is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppp1u22t6.scala:14:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                \u001b[33mcase\u001b[0m (a, b) \u001b[33mif\u001b[0m b.isDefined => b.get\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               value isDefined is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppp1u22t6.scala:14:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                \u001b[33mcase\u001b[0m (a, b) \u001b[33mif\u001b[0m b.isDefined => b.get\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       value get is not a member of Long\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmppp1u22t6.scala:17:26 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            rollingMax :: rollingMax(list.drop(\u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          \u001b[33mvalue\u001b[0m \u001b[35mrollingMax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660011004
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val newNumbers = numbers.reverse.tail.takeWhile(max => {\n                val lastMax = numbers.reverse.tail.last\n                numbers.reverse.tail.indexWhere(x => x > max) === numbers.reverse.tail.size\n        }.reverse.tail.map(i => numbers.reverse.tail.drop(i).max).getOrElse(numbers.reverse.tail.max))\n        rollingMaxHelper(newNumbers, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp91u_bp3r.scala:11:62 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m                numbers.reverse.tail.indexWhere(\u001b[36mx\u001b[0m => x > max) === numbers.reverse.tail.size\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value === is not a member of Int - did you mean Int.==?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp91u_bp3r.scala:13:8 -------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        rollingMaxHelper(newNumbers, \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Not found: rollingMaxHelper\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011003
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxList : mutable.MutableList[Long] = mutable.MutableList[Long]()\n        var maxVal = numbers.head\n        var current = 0\n        var currentIndex = 0\n        while(current < numbers.size) {\n            if(numbers.exists(x => x == maxVal)) {\n                maxList += maxVal\n                maxVal += numbers.drop(currentIndex).head\n                currentIndex++\n            } else if(numbers.exists(x => x == maxVal)) {\n                maxVal += numbers.drop(currentIndex).head\n                currentIndex++\n            } else {\n                maxVal += numbers.drop(currentIndex).head\n                currentIndex++\n            }\n            current++\n        }\n        return maxList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpymd3e485.scala:17:30 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                currentIndex++\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpymd3e485.scala:20:30 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                currentIndex++\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpymd3e485.scala:23:30 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                currentIndex++\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpymd3e485.scala:25:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            current++\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpymd3e485.scala:9:22 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m : mutable.MutableList[\u001b[35mLong\u001b[0m] = mutable.MutableList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                      Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpymd3e485.scala:9:50 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m : mutable.MutableList[\u001b[35m",
      "stdout": "",
      "timestamp": 1660010999
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val rolling = mutable.ListBuffer.empty[Long]\n        var rollingMax = numbers(0)\n        for (i<-0 to numbers.length-1) {\n            if (i == numbers.length - 1) {\n                rolling += rollingMax\n            } else if (numbers(i) < rollingMax) {\n                rollingMax += numbers(i + 1)\n            } else {\n                rollingMax -= numbers(i + 1)\n                rolling += rollingMax\n            }\n        }\n        rolling\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4bwbyruu.scala:9:22 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrolling\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m  |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                      Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011000
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxElement = numbers.head - 1\n        val result = List.newBuilder[Long]\n        var index = 1\n        while (index < numbers.length) {\n            val currElement = numbers(index)\n            if (currElement > maxElement) {\n                if (result == null) result.addLast(maxElement)\n                else result.addAll(maxElement.toString.split('').map(Long.parseLong(_)).asInstanceOf[List[Long]])\n            }\n            result.addLast(currElement)\n            index += 1\n        }\n        result.result()\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpiesaxquh.scala:16:61 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                \u001b[33melse\u001b[0m result.addAll(maxElement.toString.split('').map(Long.parseLong(_)).asInstanceOf[List[Long]])\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                 empty character literal\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiesaxquh.scala:15:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                \u001b[33mif\u001b[0m (result == \u001b[31mnull\u001b[0m) result.addLast(maxElement)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue addLast is not a member of scala.collection.mutable.Builder[Long, List[Long]]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpiesaxquh.scala:18:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            result.addLast(currElement)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue addLast is not a member of scala.collection.mutable.Builder[Long, List[Long]]\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660011005
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        def getMin(x : Int) : Int = {\n            if(x > 0) {\n                getMin(x - 1)\n            } else {\n                if(x == 0) 1\n                else 0\n            }\n        }\n\n        val minIndex = new Int()\n        val maxIndex = new Int()\n        val max = Int.MinValue\n        val maxSize = 0\n        var counter = 0\n        var currentMax = 0\n        var currentMaxIndex = 0\n        val arr = numbers.toArray\n        for(i <- 0 until arr.length)\n        {\n            if(arr(i) < min)\n            {\n                min = arr(i)\n                minIndex = counter\n            }\n            if(arr(i) > max)\n            {\n                max = arr(i)\n                maxIndex = counter\n            }\n            if(arr(i) == max)\n            {\n                currentMax = arr(i)\n                currentMaxIndex = counter\n            }\n            counter += 1\n        }\n        var rollingMax: List[Long] = List()\n        for(i <- 0 until arr.length)\n        {\n            if(minIndex == currentMaxIndex)\n            {\n                if(arr(i) > currentMax)\n                {\n                    currentMax = arr(i)\n                    rollingMax = List()\n                    rollingMax = List((arr.indexOf(i), currentMax))\n                }\n                else\n                {\n                    rollingMax = List((arr.indexOf(i), currentMax))\n                }\n            }\n            else\n            {\n                if(arr(i) > currentMax)\n                {\n                    currentMax = arr(i)\n                    rollingMax = List()\n                    rollingMax = List((arr.indexOf(i), currentMax))\n                }\n                else\n                {\n                    rollingMax = rollingMax.takeRight(rollingMax.length)\n                    rollingMax += List((arr.indexOf(i), currentMax))\n                }\n            }\n        }\n        return rollingMax\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpdel8iv9g.scala:28:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            \u001b[33mif\u001b[0m(arr(i) < min)\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m<\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double): Boolean\n\u001b[31m   |\u001b[0m (x: Float): Boolean\n\u001b[31m   |\u001b[0m (x: Long): Boolean\n\u001b[31m   |\u001b[0m (x: Int): Boolean\n\u001b[31m   |\u001b[0m (x: Char): Boolean\n\u001b[31m   |\u001b[0m (x: Short): Boolean\n\u001b[31m   |\u001b[0m (x: Byte): Boolean\n\u001b[31m   |\u001b[0mmatch arguments ((Int, Int) => Int)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdel8iv9g.scala:30:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                min = arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    Long\n\u001b[31m   |\u001b[0m                      Required: (Int, Int) => Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpdel8iv9g.scala:31:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                minIndex = counter\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val minIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdel8iv9g.scala:35:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                max = arr(i)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    Long\n\u001b[31m   |\u001b[0m                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpdel8iv9g.scala:36:25 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                maxIndex = counter\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val maxIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when c",
      "stdout": "",
      "timestamp": 1660011009
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val index = new mutable.ListBuffer[Long]()\n        var max = 0L\n        var sum = 0L\n        numbers.foreach{n => {\n            sum += n\n            if(sum > max) {\n                max = sum\n            }\n            index += 1\n            sum = 0L\n        }}\n        index ++ List(max)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp21bbwqgs.scala:9:24 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mindex\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                        Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011004
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val res = []\n\n        // rolling max with 1 element as we start from the beginning\n        for (i <- 0 until numbers.size)\n            res = res.append(numbers.drop(i).max)\n\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4bzhtpfj.scala:9:19 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = []\n\u001b[31m\u001b[31m  |\u001b[0m                   ^\u001b[0m\n\u001b[31m  |\u001b[0m                   an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp4bzhtpfj.scala:12:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until numbers.size)\n\u001b[31m\u001b[31m   |\u001b[0m^^^\u001b[0m\n\u001b[31m   |\u001b[0m'=>' expected, but 'end of statement' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4bzhtpfj.scala:13:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            res = res.append(numbers.drop(i).max)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value append is not a member of Null\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660011008
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxes = new collection.mutable.HashSet[Long]()\n        var max = 0L\n        var index = 0\n        while(index < numbers.size && numbers.size > 0) {\n            val current = numbers(index)\n            if(maxes.contains(current)) {\n                max = current\n            }\n            else {\n                maxes.add(current)\n                max = Math.max(max, current)\n                index++\n            }\n        }\n        numbers.take(index).toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmprx3tjezu.scala:20:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                index++\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011006
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        // Use a mutable list to store the result\n        val maxResult = mutable.ListBuffer[Long]()\n        // A list to store all rolling maximum\n        val allMax = mutable.ListBuffer[Long]()\n        // Loop the list until we reached a moment where the rolling max number is no larger than the actual number in list\n        var index = 0\n        for (number <- numbers) {\n            val rollingMaxNumber = number + index\n            // If we found a rolling maximum number larger than the current max number, then add the current max number\n            if (rollingMaxNumber > maxResult.last)\n                maxResult += maxResult.last\n            index += 1\n            // Add the current rolling max number to the all rolling max list\n            allMax += rollingMaxNumber\n        }\n        // Return the max result\n        maxResult.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpak4b6o3z.scala:10:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxResult\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpak4b6o3z.scala:12:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mallMax\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011005
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val result = new mutable.ArrayBuffer(numbers)\n        val max = numbers(0)\n        val maxElement = numbers(0)\n        for (i<-1 to numbers.size-1) {\n            if (result(i) > max) {\n                max = result(i)\n                maxElement = result(i)\n            } else if (result(i) == max) {\n                maxElement = max(result(i), maxElement)\n            }\n            result(i) = max\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqsy_ls0q.scala:9:25 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayBuffer(numbers)\n\u001b[31m\u001b[31m  |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                         Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpqsy_ls0q.scala:14:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                max = result(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val max\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpqsy_ls0q.scala:15:27 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                maxElement = result(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val maxElement\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpqsy_ls0q.scala:17:29 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                maxElement = max(result(i), maxElement)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             \u001b[33mvalue\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660011006
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val result = numbers.foldLeft(List[Long]()) {\n            (acc, value) => {\n                val candidate = acc.lastOption.orElse(value)\n                val currentRoll = candidate.rollingMax\n                if((currentRoll == 0l) && (candidate.number > value)) {\n                    acc.reverse::[Long](value)\n                }\n                else acc\n            }\n        }\n        result.last\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpm6i1rqko.scala:14:33 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                    acc.reverse::[Long](value)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 expression expected but \u001b[31m'['\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpm6i1rqko.scala:11:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mcandidate\u001b[0m = acc.lastOption.orElse(value)\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Found:    (value : Long)\n\u001b[31m   |\u001b[0m                                                Required: Option[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm6i1rqko.scala:12:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mcurrentRoll\u001b[0m = candidate.rollingMax\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value rollingMax is not a member of Option[Long]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpm6i1rqko.scala:19:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        result.last\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Long\n\u001b[31m   |\u001b[0m        Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660011014
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var index = 0\n        var max = 0\n        var temp : List[Long] = ListBuffer.empty\n        for (n <- numbers) {\n            if (index >= n.toInt) {\n                if (n == max) {\n                    temp = temp + (n - max)\n                    index -= (max - max).toInt\n                } else {\n                    temp = temp + (max - n)\n                    index = n.toInt\n                }\n                max = n\n            }\n        }\n        temp.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbox2v41m.scala:11:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mtemp\u001b[0m : \u001b[35mList\u001b[0m[\u001b[35mLong\u001b[0m] = ListBuffer.empty\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Found:    scala.collection.mutable.ListBuffer[A]\n\u001b[31m   |\u001b[0m                        Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                        where:    A is a type variable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbox2v41m.scala:15:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                    temp = temp + (n - max)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbox2v41m.scala:18:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                    temp = temp + (max - n)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue + is not a member of List[Long], but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbox2v41m.scala:21:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                max = n\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m ",
      "stdout": "",
      "timestamp": 1660011018
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxElem = math.max(numbers)\n        val maxList = mutable.ListBuffer[Long]()\n        var rollingMax : List[Long] = numbers\n        var i = 1\n        while ( i <= maxElem ) {\n            var currentMax = rollingMax(i).toLong\n            while ( rollingMax.tail.isEmpty || rollingMax.tail.head.toLong < currentMax ) {\n                rollingMax :+= rollingMax.head\n            }\n            rollingMax :+= rollingMax.head\n            if ( rollingMax.last == maxElem ) {\n                maxList :+= rollingMax.last\n            }\n            rollingMax :+= rollingMax.tail\n            i += 1\n        }\n        return maxList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmptqhv3i4c.scala:9:27 ------------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxElem\u001b[0m = math.max(numbers)\n\u001b[31m\u001b[31m  |\u001b[0m                      ^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m  |\u001b[0m (x: Double, y: Double): Double\n\u001b[31m  |\u001b[0m (x: Float, y: Float): Float\n\u001b[31m  |\u001b[0m (x: Long, y: Long): Long\n\u001b[31m  |\u001b[0m (x: Int, y: Int): Int\n\u001b[31m  |\u001b[0mmatch arguments ((numbers : List[Long]))\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptqhv3i4c.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxList\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptqhv3i4c.scala:22:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            rollingMax :+= rollingMax.tail\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   value :+= is not a member of List[Long] - did you mean List[Long].:+?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660011016
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val result = new scala.collection.mutable.ArrayList[Long]\n        numbers.foreach(x => result.add(x)) // add all elements to list\n        val maxValue = max(result.toList)\n        result.toList.map(x => if (x == maxValue) x else x + 1) // get all possible rolling maximum elements from list\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp2h2ey6ud.scala:9:50 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m scala.collection.mutable.ArrayList[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m  |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                type ArrayList is not a member of scala.collection.mutable\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011016
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        // Initialize max list\n        var maxList = List[Long]()\n\n        // Go through all the elements until the current moment\n        for (number <- numbers) {\n            // If the current number is greater than the maximum found so far,\n            // update max with the current element\n            if (number > maxList.getOrElse(-1l) {\n                maxList :+= number\n            }\n        }\n\n        // Return the resulting list\n        return maxList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpbnaxctdd.scala:19:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        }\n\u001b[31m\u001b[31m   |\u001b[0m        ^\u001b[0m\n\u001b[31m   |\u001b[0m        ')' expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbnaxctdd.scala:16:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mif\u001b[0m (number > maxList.getOrElse(-\u001b[31m1l\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value getOrElse is not a member of List[Long]\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011017
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val results = new mutable.MutableList[Long]()\n        for (x<-numbers)\n        results ::= math.max(x-results.last, results.last)\n        \n        results\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnog3rjca.scala:9:26 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresults\u001b[0m = \u001b[33mnew\u001b[0m mutable.MutableList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                          Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011010
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var maximums = scala.collection.mutable.LinkedHashMap[Long, Int]()\n        var maximum = numbers(0)\n\n        for (number <- numbers) {\n            if (maximums.contains(maximum)) {\n                val prevMax = maximums.last.get + 1\n                maximums.last.put(number, prevMax)\n                maximums.put((number - prevMax), prevMax)\n            } else {\n                maximums.put(number, 0)\n            }\n\n            maximum = max(number, maximum)\n        }\n\n        val keys = maximums.keys\n        val values = maximums.values\n\n        // Return the maximum element of each group\n        (keys zip values map (x => (x._1 - x._2, x._2)))\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppet0bbqy.scala:14:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mprevMax\u001b[0m = maximums.last.get + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value get is not a member of (Long, Int)\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmppet0bbqy.scala:15:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                maximums.last.put(number, prevMax)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value put is not a member of (Long, Int)\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmppet0bbqy.scala:28:9 ---------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        (keys zip values map (\u001b[36mx\u001b[0m => (x._1 - x._2, x._2)))\n\u001b[31m\u001b[31m   |\u001b[0m         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         Found:    Iterable[(Long, Int)]\n\u001b[31m   |\u001b[0m         Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660011020
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val result: List[Long] = List();\n        numbers.foreach(x => {\n            val max = results.last\n            if (max > x)\n                result.add(x)\n            else {\n                if (result.last > x)\n                    result.last = x\n            }\n        })\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpx0tw6xgu.scala:11:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = results.last\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: results\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx0tw6xgu.scala:13:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                result.add(x)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value add is not a member of List[Long]\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpx0tw6xgu.scala:16:32 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                    result.last = x\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Reassignment to val last\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660011020
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        def lastMax(n: Long): Long = {\n            if(numbers.length <= n){\n                return numbers(n)\n            } else {\n                return if(numbers(n) > numbers(n-1)) numbers(n) else numbers(n-1)\n            }\n        }\n        def min(n1: Long, n2: Long) : Long = {\n            if(n1 > n2){\n                n1\n            } else {\n                n2\n            }\n        }\n        def max(n1: Long, n2: Long) : Long = {\n            if(n1 > n2){\n                n2\n            } else {\n                n1\n            }\n        }\n        val maxNums = ListBuffer[Long]()\n        numbers.foldLeft(maxNums){\n            (maxNums, number) => {\n                val newMax = lastMax(number)\n                val newMin = lastMax(number - 1)\n                val newMaxs = if(newMax > newMin) newMax, newMin else newMin, newMax\n                maxNums ++= newMaxs\n            }\n        }\n        return maxNums\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp36ltzat5.scala:35:56 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m35 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mnewMaxs\u001b[0m = \u001b[33mif\u001b[0m(newMax > newMin) newMax, newMin \u001b[33melse\u001b[0m newMin, newMax\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 end of statement expected but ',' found\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp36ltzat5.scala:11:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m                \u001b[33mreturn\u001b[0m numbers(n)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    (n : Long)\n\u001b[31m   |\u001b[0m                               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp36ltzat5.scala:13:34 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[33mif\u001b[0m(numbers(n) > numbers(n-\u001b[31m1\u001b[0m)) numbers(n) \u001b[33melse\u001b[0m numbers(n-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    (n : Long)\n\u001b[31m   |\u001b[0m                                  Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp36ltzat5.scala:13:47 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[33mif\u001b[0m(numbers(n) > numbers(n-\u001b[31m1\u001b[0m)) numbers(n) \u001b[33melse\u001b[0m numbers(n-\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                               Found:    Long\n\u001b[31m   |\u001b[0m                                               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp36ltzat5.scala:13:61 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                \u001b[33mreturn\u001b[0m \u001b[33mif\u001b[0m(numbers(n",
      "stdout": "",
      "timestamp": 1660011024
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.foldLeft((List[Long](0l.toLong), 0)) {\n            (acc, n) =>\n                val max = acc._1\n                val current = acc._2\n                if (n <= current) (n, max) else (max, n)\n        }._1.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4q_q9ekm.scala:13:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                \u001b[33mif\u001b[0m (n <= current) (n, max) \u001b[33melse\u001b[0m (max, n)\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Found:    (n : Long)\n\u001b[31m   |\u001b[0m                                   Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4q_q9ekm.scala:13:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                \u001b[33mif\u001b[0m (n <= current) (n, max) \u001b[33melse\u001b[0m (max, n)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    (max : List[Long])\n\u001b[31m   |\u001b[0m                                      Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4q_q9ekm.scala:13:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                \u001b[33mif\u001b[0m (n <= current) (n, max) \u001b[33melse\u001b[0m (max, n)\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (n : Long)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660011023
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.foldLeft((numbers.head,List[Long]())) {\n            case ((max, rolling),i) => (if (i > numbers.length) max else rolling.max,i.toLong::rolling)\n        }._2\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: head of empty list\n\tat scala.collection.immutable.Nil$.head(List.scala:662)\n\tat scala.collection.immutable.Nil$.head(List.scala:661)\n\tat Problem$.rollingMax(tmppbrzkgsm.scala:9)\n\tat Problem$.main(tmppbrzkgsm.scala:14)\n\tat Problem.main(tmppbrzkgsm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660011026
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var maxList : List[Long] = Nil\n        var maxValue : Long = 0\n        var currentMax = 0\n\n        // Sort the list to find the rolling max element\n        numbers.sortWith(_.compare(_.toLong)) // Sorting in ascending order\n\n        // Find the rolling max element\n        for (number <- numbers) {\n            if (maxValue < number) {\n                maxValue = number\n                maxList = numbers :: Nil\n                currentMax = number\n            }\n            else {\n                if (currentMax == number) {\n                    maxList = maxList :+ number\n                }\n                else {\n                    maxList = maxList :+ currentMax\n                    currentMax = number\n                }\n            }\n        }\n        return maxList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmpn1lidb2t.scala:14:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        numbers.sortWith(_.compare(_.toLong)) \u001b[34m// Sorting in ascending order\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Wrong number of parameters, expected: 2\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn1lidb2t.scala:20:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                maxList = numbers :: Nil\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (numbers : List[Long])\n\u001b[31m   |\u001b[0m                          Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn1lidb2t.scala:21:29 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                currentMax = number\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    (number : Long)\n\u001b[31m   |\u001b[0m                             Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpn1lidb2t.scala:29:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m                    currentMax = number\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (number : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660011025
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        require(numbers.nonEmpty, \"rollingMax: Empty list provided\");\n        val maxRollings = numbers.length\n        val maxIndex = 0\n        // The first rolling is the maximum of the whole list\n        val max = numbers.head\n        // The rest rollings is the maximum of the part after the current rolling list\n        val rest = numbers.tail.takeWhile{ _ != max }\n        // Starting from the second rolling, compare the highest rolling with the current one and update the rolling index\n        // when the rolling index is equal to the maximum rolling index\n        val rollingIndex = 1\n        rest.foreach{ n => if (n == max) {\n                            max <- max\n                            maxIndex <- maxRollings\n                        } else {\n                            maxIndex <- rollingIndex\n                        } }\n        if (maxRollings == rollingIndex) {\n            List(max)\n        } else {\n            rollingMax rest\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpjiuoxw72.scala:20:32 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                            max <- max\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                end of statement expected but '<-' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpjiuoxw72.scala:21:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                            maxIndex <- maxRollings\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                end of statement expected but '<-' found\n\u001b[31m\u001b[31m-- Error: /tmp/tmpjiuoxw72.scala:23:37 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                            maxIndex <- rollingIndex\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                end of statement expected but '<-' found\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpjiuoxw72.scala:28:27 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            rollingMax rest\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmpjiuoxw72.scala:20:28 ----------------\u001b[0m\u001b[0m\n\u001b[33m20 |\u001b[0m                            max <- max\n\u001b[33m\u001b[33m   |\u001b[0m                            ^^^\u001b[0m\n\u001b[33m   |\u001b[0mA pure expression does nothing in statement position; you may be omitting necessary parentheses\n\u001b[33m   |\u001b[0m\n\u001b[33m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 warning found\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660011019
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        // Start with empty rolling max\n        var maxList : List[Long] = Nil\n\n        // Iterate over the given numbers, for each iteration find the max of the rolling max and the given number\n        for (i <- numbers) {\n            var max = 0\n            val rollingMax: List[Long] = maxList\n\n            // For each element find the max of the previous max and the given number i\n            var j = 1\n            while (rollingMax.head <= j && rollingMax.head < i) {\n                max = math.max(max, rollingMax.head)\n                rollingMax = rollingMax :: numbers(i to j)\n                j += 1 // Increment the iteration index\n            }\n\n            // If the maximum element found until moment j is greater than current maximum add it to the rolling max\n            if (max > numbers(i to j)) {\n                maxList ::= numbers(i to j)\n            }\n        }\n\n        // Return the rolling max list\n        return maxList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3qx91tk1.scala:20:47 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                max = math.max(max, rollingMax.head)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    Found:    Long\n\u001b[31m   |\u001b[0m                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3qx91tk1.scala:21:51 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                rollingMax = rollingMax :: numbers(i to j)\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       Found:    scala.collection.immutable.NumericRange.Inclusive[Long]\n\u001b[31m   |\u001b[0m       Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3qx91tk1.scala:26:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mif\u001b[0m (max > numbers(i to j)) {\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       Found:    scala.collection.immutable.NumericRange.Inclusive[Long]\n\u001b[31m   |\u001b[0m       Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3qx91tk1.scala:27:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                maxList ::= numbers(i to j)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   value ::= is not a member of List[Long] - did you mean List[Long].::?\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp3qx91tk1.scala:27:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                maxList ::= numbers(i to j)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       Found:    scala.collection.immutable.NumericRange.Inclusive[Long]\n\u001b[31m   |\u001b[0m       Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling w",
      "stdout": "",
      "timestamp": 1660011026
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        def rollingMaxRec(list: List[Long], max: Long, acc: List[Long]): List[Long] = {\n            if (list.isEmpty)\n                return  acc\n            rollingMaxRec(list.tail, list.head, list match {\n                case Nil =>  acc.reverse\n                case _ => rollingMaxRec(list.tail, max, acc :+ max)\n            })\n        }\n        rollingMaxRec(numbers.reverse, numbers.head) match {\n            case Nil => Nil\n            case _ => numbers.reverse\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpmww5b1rp.scala:17:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        rollingMaxRec(numbers.reverse, numbers.head) \u001b[33mmatch\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter acc of \u001b[33mmethod\u001b[0m \u001b[35mrollingMaxRec\u001b[0m: (list: List[Long], max: Long, acc: List[Long]): List[Long]\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011019
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val currentMax = numbers.head\n        val nextMax = numbers.last\n        val nextMaxToCheck = currentMax + 1\n        val nextMaxList = new mutable.LinkedList[Long]()\n        nextMaxList += currentMax\n        while (nextMaxToCheck < numbers.last) {\n            nextMaxList += nextMax\n            nextMaxToCheck += currentMax + 1\n        }\n        nextMaxList.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpys69a1uk.scala:12:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mnextMaxList\u001b[0m = \u001b[33mnew\u001b[0m mutable.LinkedList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpys69a1uk.scala:16:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            nextMaxToCheck += currentMax + \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m      value += is not a member of Long - did you mean nextMaxToCheck.!=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011023
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val rollingMax = new mutable.LinkedList[Long]()\n        var currentMax = 0L\n        var i = 0\n        while(i < numbers.size) {\n            currentMax = Math.max(currentMax, numbers(i))\n            i += 1\n            if(rollingMax.size < i)\n                rollingMax.add(numbers(i))\n            if(currentMax == numbers(i)) {\n                i += 1\n                currentMax = numbers(i)\n                while(i < numbers.size) {\n                    if(currentMax == numbers(i)) {\n                        i += 1\n                        currentMax = numbers(i)\n                        rollingMax.add(currentMax)\n                    } else {\n                        currentMax = numbers(i)\n                        rollingMax.add(currentMax)\n                        break\n                    }\n                }\n            }\n        }\n        return rollingMax.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8h7afezc.scala:9:29 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMax\u001b[0m = \u001b[33mnew\u001b[0m mutable.LinkedList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8h7afezc.scala:28:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m                        break\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011020
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.foldLeft(List[Long]()){ (acc: List[Long], x: Long) => acc match {\n            case Nil =>\n                acc.append(x)\n            case _ => if (acc.last > x) acc else acc :+ x\n        }}.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi1sotem2.scala:11:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m                acc.append(x)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m value append is not a member of List[Long] - did you mean acc.appended?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011025
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val max = new mutable.HashMap[Long, Long]()\n        numbers.foreach{n => max += n -> math.max(n)}\n        max match {\n            case Nil => Nil\n            case m :: Nil => m\n            case m :: tl =>\n                val tl_max = rollingMax(tl)\n                m._2 match {\n                    case n if n > tl_max(m._1) => m :: tl_max\n                    case n if n < tl_max(m._1) => m :: Nil\n                    case n => m :: tl_max\n                }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7qz6pa78.scala:9:22 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                      Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7qz6pa78.scala:13:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mcase\u001b[0m m :: Nil => m\n\u001b[31m\u001b[31m   |\u001b[0m                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7qz6pa78.scala:15:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mtl_max\u001b[0m = rollingMax(tl)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Not found: tl\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7qz6pa78.scala:16:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                m._2 \u001b[33mmatch\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7qz6pa78.scala:17:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                    \u001b[33mcase\u001b[0m n \u001b[33mif\u001b[0m n > tl_max(m._1) => m :: tl_max\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                  Not found: m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7qz6pa78.scala:18:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                    \u001b[33mcase\u001b[0m n \u001b[33mif\u001b[0",
      "stdout": "",
      "timestamp": 1660011020
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        if (numbers.isEmpty) List(1l)\n        else {\n            val maxList = numbers.maxBy { number =>\n                val index = number % numbers.size\n                number - numbers(index)\n            }\n            rollingMax(maxList :: numbers)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_pn78gv7.scala:13:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                number - numbers(index)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (index : Long)\n\u001b[31m   |\u001b[0m                                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011027
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val nums = numbers.toList\n        val len = nums.size\n        var max = 0l\n        var rollingMax = nums.toList.tail.foldLeft(0l)( (a,b) => if (b > a) b else a )\n        var rollingMaxIndex = 0\n        for ( i <- 1 to len-1 ) {\n            rollingMaxIndex = i\n            val prev = nums(i - 1)\n            val current = nums(i)\n            if ( current > max ) {\n                max = current\n                rollingMax = nums.toList.tail.foldLeft(0l)( (a,b) => if (b > a) b else a )\n            }\n            else if ( current == max ) {\n                rollingMax = nums.toList.tail.foldLeft(0l)( (a,b) => if (b > a) b else a )\n            }\n            else if ( current < max ) {\n                rollingMax = nums.toList.tail.foldLeft(0l)( (a,b) => if (b > a) a else b )\n                max = current\n                rollingMaxIndex = i\n            }\n        }\n        return rollingMax\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpxg92gtkw.scala:31:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m        \u001b[33mreturn\u001b[0m rollingMax\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    (rollingMax : Long)\n\u001b[31m   |\u001b[0m               Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011026
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        require(numbers != null)\n        val rollingMaxElem = mutable.Stack.empty[Long]\n        val maxVal = numbers(0)\n        for (x <- numbers) {\n            if (x < maxVal) {\n                rollingMaxElem += x\n            } else {\n                rollingMaxElem.pop\n                rollingMaxElem += x\n            }\n            maxVal = rollingMaxElem.last\n        }\n        rollingMaxElem\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpzu72cym3.scala:10:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMaxElem\u001b[0m = mutable.Stack.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpzu72cym3.scala:19:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            maxVal = rollingMaxElem.last\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val maxVal\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011023
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        // We will keep a map of rolling max element so far.\n        // We will also keep a rolling max index so that we can remove the element when the moment is reached.\n        val maxes = new mutable.HashMap[Long, Long]\n        val rollingMaxIndex = new mutable.ArrayBuffer[Long]()\n        var currentMax = -1l\n\n        // Start looping through the numbers from the end of the list up to the beginning.\n        numbers.reverse.foreach{\n            // If the current number is greater than the rolling max we just found then update it.\n            if(currentMax < _) maxes += (_ -> currentMax)\n            // Otherwise if the current number is greater than the rolling max in the map of rolling max elements\n            // then we will update it with the current max and add the current index to the list of rolling max indices.\n            else if(!maxes.contains(_)) maxes += (_ -> currentMax)\n            // Otherwise the numbers are equal, thus we will add the index of the current max to the list of rolling max indices.\n            else {\n                maxes += (_ -> currentMax)\n                rollingMaxIndex += currentMax\n            }\n            currentMax = maxes.values.max\n        }\n\n        // Remove the rolling max index at the end as it is no longer needed.\n        rollingMaxIndex.removeAll(_ == currentMax)\n\n        // Return the list of rolling max elements.\n        maxes.toList.sortBy(_._2)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps9dft4aj.scala:11:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxes\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps9dft4aj.scala:12:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMaxIndex\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmps9dft4aj.scala:18:28 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mif\u001b[0m(currentMax < _) maxes += (_ -> currentMax)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$1 of expanded function:\n\u001b[31m   |\u001b[0m   _$1 => currentMax < _$1.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmps9dft4aj.scala:21:36 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(!maxes.contains(_)) maxes += (_ -> currentMax)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter _$3 of expanded function:\n\u001b[31m   |\u001b[0m   _$3 => ! maxes.contains(_$3).\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmps9dft4aj.scala:27:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            currentMax = maxes.values.max\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    Unit\n\u001b[31m   |\u001b[0m            Required: Long => Any\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation availabl",
      "stdout": "",
      "timestamp": 1660011031
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.reverse.foldLeft(List[Long]())((list, number) => {\n            if (numbers.length == list.length) list :+ number\n            else {\n                if (number > list.last) list :+ number\n                else {\n                    list :+ list.last\n                }\n            }\n        })\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: last of empty list\n\tat scala.collection.immutable.Nil$.last(List.scala:665)\n\tat scala.collection.immutable.Nil$.last(List.scala:661)\n\tat Problem$.rollingMax$$anonfun$1(tmp3s_y6g5t.scala:12)\n\tat Problem$.rollingMax$$anonfun$adapted$1(tmp3s_y6g5t.scala:17)\n\tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\tat scala.collection.immutable.List.foldLeft(List.scala:79)\n\tat Problem$.rollingMax(tmp3s_y6g5t.scala:17)\n\tat Problem$.main(tmp3s_y6g5t.scala:21)\n\tat Problem.main(tmp3s_y6g5t.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660011034
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val max = numbers.foldLeft((-1l, 0l)) { (x, y) =>\n            if (y._1 < x._1) (y._1, y._2) else (x._1, x._2)\n        }\n        if (max._1 < 0) numbers else numbers.takeWhile(x => x._2 < max._1).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbuaw0fhe.scala:10:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            \u001b[33mif\u001b[0m (y._1 < x._1) (y._1, y._2) \u001b[33melse\u001b[0m (x._1, x._2)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value _1 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbuaw0fhe.scala:10:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            \u001b[33mif\u001b[0m (y._1 < x._1) (y._1, y._2) \u001b[33melse\u001b[0m (x._1, x._2)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              value _1 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbuaw0fhe.scala:10:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            \u001b[33mif\u001b[0m (y._1 < x._1) (y._1, y._2) \u001b[33melse\u001b[0m (x._1, x._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    value _2 is not a member of Long\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbuaw0fhe.scala:12:62 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mif\u001b[0m (max._1 < \u001b[31m0\u001b[0m) numbers \u001b[33melse\u001b[0m numbers.takeWhile(\u001b[36mx\u001b[0m => x._2 < max._1).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                                            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _2 is not a member of Long\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660011036
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxIndex  = numbers.indexWhere(_.isMax)\n        val rollingMax = new mutable.ListBuffer[Long]()\n        val currentMax = numbers(maxIndex)\n        var i = 0\n        while(i < maxIndex) {\n            rollingMax += numbers(i)\n            currentMax = numbers(i) if maxIndex - i + 1 > rollingMax.size \n                || numbers(i) > rollingMax(rollingMax.size-1)\n            i += 1\n        }\n        rollingMax.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp77ygykgn.scala:15:36 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            currentMax = numbers(i) \u001b[33mif\u001b[0m maxIndex - i + \u001b[31m1\u001b[0m > rollingMax.size \n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                end of statement expected but 'if' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp77ygykgn.scala:9:45 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m  = numbers.indexWhere(_.isMax)\n\u001b[31m\u001b[31m  |\u001b[0m                                           ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                       value isMax is not a member of Long\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp77ygykgn.scala:10:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMax\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp77ygykgn.scala:15:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            currentMax = numbers(i) \u001b[33mif\u001b[0m maxIndex - i + \u001b[31m1\u001b[0m > rollingMax.size \n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val currentMax\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660011036
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val result = mutable.ArrayBuffer.empty[Long]\n        val size = numbers.size\n        def rollingMaxHelper(index: Int, numbers: List[Long], result: List[Long]): Unit = {\n            if (index == size) {\n                result.addAll(numbers.sortBy(_._1).reverse)\n            } else {\n                for (i <- 0 until numbers.size - 1) {\n                    result(i) = if (numbers(i) <= numbers(index)) { numbers(index) } else { numbers(i) }\n                    rollingMaxHelper(index + 1, numbers, result)\n                }\n            }\n        }\n        rollingMaxHelper(0, numbers, result)\n        result.result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp000q4d65.scala:9:21 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m  |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                     Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp000q4d65.scala:13:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                result.addAll(numbers.sortBy(_._1).reverse)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue addAll is not a member of List[Long] - did you mean result.zipAll?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp000q4d65.scala:13:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                result.addAll(numbers.sortBy(_._1).reverse)\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value _1 is not a member of Long\n\u001b[31m\u001b[31m-- Error: /tmp/tmp000q4d65.scala:13:50 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                result.addAll(numbers.sortBy(_._1).reverse)\n\u001b[31m\u001b[31m   |\u001b[0m                                                  ^\u001b[0m\n\u001b[31m   |\u001b[0mambiguous given instances: both \u001b[33mobject\u001b[0m \u001b[35mByte\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m and \u001b[33mobject\u001b[0m \u001b[35mChar\u001b[0m in \u001b[33mobject\u001b[0m \u001b[35mOrdering\u001b[0m match type Ordering[B] of parameter ord of \u001b[33mmethod\u001b[0m \u001b[35msortBy\u001b[0m in \u001b[33mtrait\u001b[0m \u001b[35mSeqOps\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp000q4d65.scala:16:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                    result(i) = \u001b[33mif\u001b[0m (numbers(i) <= numbers(index)) { numbers(index) } \u001b[33melse\u001b[0m { numbers(i) }\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean result.updated?\n5 errors found\n",
      "stdout": "",
      "timestamp": 1660011038
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        if (numbers.isEmpty) return List()\n        val maxRolling = numbers.tail.foldLeft[Long](numbers.head){ (acc,x) => if (acc > x) acc else x }\n        val rest = rollingMax(numbers.tail)\n        rest ::: List(maxRolling.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmphb_72xzr.scala:16)\n\tat Problem.main(tmphb_72xzr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660011040
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        // Define a function to get list of rolling max elements\n        // From a given list of integers, generate a list of rolling maximum element found until given moment\n        // E.g. (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong))\n        // rollingMax(numbers) will return a List containing [1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong]\n        numbers.foldLeft(List[Long]()){ case (acc, number) => acc.zip(rollingMaxUntil(number:_*)) }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfmr8d4j9.scala:13:70 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        numbers.foldLeft(List[\u001b[35mLong\u001b[0m]()){ \u001b[33mcase\u001b[0m (acc, number) => acc.zip(rollingMaxUntil(number:\u001b[35m_*\u001b[0m)) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                      ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                              Not found: rollingMaxUntil\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpfmr8d4j9.scala:13:86 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        numbers.foldLeft(List[\u001b[35mLong\u001b[0m]()){ \u001b[33mcase\u001b[0m (acc, number) => acc.zip(rollingMaxUntil(number:\u001b[35m_*\u001b[0m)) }\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                         Found:    (number : Long)\n\u001b[31m   |\u001b[0m                                         Required: Seq[<?>] | Array[<?>]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011038
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        if (numbers.length == 0) numbers.reverse\n        val max = numbers(0)\n        val rollingMax = List[Long]()\n        for (i <- 1 to numbers.size) {\n            val current = numbers(i)\n            if (current > max) {\n                max = current\n            }\n            else {\n                rollingMax += max\n                max = current\n            }\n        }\n        rollingMax\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmps19za5ns.scala:15:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                max = current\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val max\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmps19za5ns.scala:18:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                rollingMax += max\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean rollingMax.!=?\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmps19za5ns.scala:19:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                max = current\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val max\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660011038
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val r = mutable.ArrayBuffer.empty[Long]\n        numbers.foreach { number =>\n            val rm = r.reverse.foldLeft(number) { case (rm, num) =>\n                if (rm > num)\n                    rm\n                else\n                    num\n            }\n            r.append(rm)\n        }\n        r.foldRight(List[Long]())(_ > _)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpr288830n.scala:9:16 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mr\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011031
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var max = 0L\n        var maxes = new mutable.ArrayList[Long]\n        for (number <- numbers) {\n            max += number\n            maxes += number\n            if (max > number) {\n                max = 0L\n                maxes = new mutable.ArrayList[Long]\n            }\n        }\n        maxes\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3ncxzbtn.scala:10:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mmaxes\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayList[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3ncxzbtn.scala:16:28 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                maxes = \u001b[33mnew\u001b[0m mutable.ArrayList[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                            Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011034
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var max = 0\n        numbers.reverse.foreach { number =>\n            if(number > max) max = number\n        }\n        numbers = numbers :+ max\n        numbers.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqmh7disj.scala:11:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[33mif\u001b[0m(number > max) max = number\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Found:    (number : Long)\n\u001b[31m   |\u001b[0m                                   Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpqmh7disj.scala:13:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        numbers = numbers :+ max\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Reassignment to val numbers\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011039
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        def rollingMaxHelper(numbers : List[Long], acc : List[Long]) : List[Long] = {\n            val maxNum = numbers.min\n            if (numbers.length == 1) acc :+ maxNum\n            else {\n                val nextNum = numbers(0)\n                val index = numbers.indexOf(0)\n                val updatedNums = rollingMaxHelper(numbers.tail, acc :+ maxNum)\n                if (index < numbers.indexOf(0)) {\n                    updatedNums\n                } else {\n                    updatedNums :+ nextNum\n                }\n            }\n        }\n        rollingMaxHelper(numbers, List(0l))\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: empty.min\n\tat scala.collection.IterableOnceOps.min(IterableOnce.scala:914)\n\tat scala.collection.IterableOnceOps.min$(IterableOnce.scala:912)\n\tat scala.collection.AbstractIterable.min(Iterable.scala:926)\n\tat Problem$.rollingMaxHelper$1(tmpbv43ffsc.scala:10)\n\tat Problem$.rollingMax(tmpbv43ffsc.scala:23)\n\tat Problem$.main(tmpbv43ffsc.scala:26)\n\tat Problem.main(tmpbv43ffsc.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660011043
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.foldLeft(List.empty[Long]) { case (acc, x) => \n            if (acc contains x) acc else acc ++ List(max(x,acc.last))\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.util.NoSuchElementException: last of empty list\n\tat scala.collection.immutable.Nil$.last(List.scala:665)\n\tat scala.collection.immutable.Nil$.last(List.scala:661)\n\tat Problem$.rollingMax$$anonfun$1(tmpgp_rhiht.scala:10)\n\tat Problem$.rollingMax$$anonfun$adapted$1(tmpgp_rhiht.scala:11)\n\tat scala.collection.LinearSeqOps.foldLeft(LinearSeq.scala:169)\n\tat scala.collection.LinearSeqOps.foldLeft$(LinearSeq.scala:165)\n\tat scala.collection.immutable.List.foldLeft(List.scala:79)\n\tat Problem$.rollingMax(tmpgp_rhiht.scala:11)\n\tat Problem$.main(tmpgp_rhiht.scala:15)\n\tat Problem.main(tmpgp_rhiht.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660011042
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var max = numbers(0)\n        var result : List[Long] = List()\n        for (number <- numbers) {\n            if (number > max) {\n                max += number\n                result ::= max\n            }\n            else {\n                result += number\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7d23_a6z.scala:17:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                result += number\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011042
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var max = numbers(0)\n        var maxCount = 1\n        var index = 0\n        var rollingMaxResult = new mutable.ArrayList[Long]\n        for(x <- numbers){\n            if(x < max){ \n                rollingMaxResult.add(max)\n                rollingMaxResult.add(index)\n                maxCount = 1\n                max = x\n            }else{\n                maxCount+=1\n                max = x\n            }\n            index += 1\n        }\n        rollingMaxResult\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpd2kdi9yt.scala:12:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mrollingMaxResult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayList[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011038
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val m = numbers.head\n        val rollingMax = m :: rollingMax(numbers.tail)\n        rollingMax.max(numbers.last)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpc3v4rhg8.scala:10:30 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMax\u001b[0m = m :: rollingMax(numbers.tail)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Recursive \u001b[33mvalue\u001b[0m \u001b[35mrollingMax\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011037
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val rollingMax = new mutable.MutableList[Long]()\n        val max = new Long(0)\n        val maxSeq = Seq(numbers)\n        val rollingMaxSeq = rollingMax ++= maxSeq\n        val sumRollingMax = rollingMaxSeq.sum\n        rollingMaxSeq.filter(i => i > max).foreach(i => rollingMaxSeq.filter(_ != i).foreach(x => rollingMaxSeq.filter(_ != x).foreach(y => rollingMaxSeq.filter(_ != y)))) \n        rollingMaxSeq.filter(_ > sumRollingMax).foreach(x => rollingMaxSeq.filter(_ != x).foreach(y => rollingMaxSeq.filter(_ != y)))\n        rollingMax\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp18hbfr05.scala:9:29 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMax\u001b[0m = \u001b[33mnew\u001b[0m mutable.MutableList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp18hbfr05.scala:10:27 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmax\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mLong\u001b[0m(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m         too many arguments for \u001b[33mconstructor\u001b[0m \u001b[35mLong\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mLong\u001b[0m: (): Long\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011038
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        // Keep track of the max found so far\n        var max = 0l\n        // Keep track of how many items are left of the list \n        var left = 0L\n\n        // If the list is empty, just return an empty list\n        if(numbers.isEmpty) Nil\n\n        // Loop through the numbers until we reach the moment we wanted\n        numbers.takeWhile{number => left > 0 || number > max}.\n            // Then find the max of the remaining items\n            foldRight((max, left)){(max, left) => (number, left) =>\n                if(number > max) max = number\n                left -= 1\n                (max, left)}\n\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp9_0xmk1y.scala:20:51 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            foldRight((max, left)){(\u001b[36mmax\u001b[0m, \u001b[36mleft\u001b[0m) => (\u001b[36mnumber\u001b[0m, \u001b[36mleft\u001b[0m) =>\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                     I could not infer the type of the parameter number.\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp9_0xmk1y.scala:20:59 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            foldRight((max, left)){(\u001b[36mmax\u001b[0m, \u001b[36mleft\u001b[0m) => (\u001b[36mnumber\u001b[0m, \u001b[36mleft\u001b[0m) =>\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                       I could not infer the type of the parameter left.\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp9_0xmk1y.scala:21:37 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                \u001b[33mif\u001b[0m(number > max) max = number\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Reassignment to val max\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[33m\u001b[33m-- [E129] Potential Issue Warning: /tmp/tmp9_0xmk1y.scala:15:28 ----------------\u001b[0m\u001b[0m\n\u001b[33m15 |\u001b[0m        \u001b[33mif\u001b[0m(numbers.isEmpty) Nil\n\u001b[33m\u001b[33m   |\u001b[0m                            ^^^\u001b[0m\n\u001b[33m   |\u001b[0mA pure expression does nothing in statement position; you may be omitting necessary parentheses\n\u001b[33m   |\u001b[0m\n\u001b[33m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 warning found\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660011040
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var maxIndex = 0\n        var max = 0L\n        var currentIndex = 0\n        var current = 0L\n        for(i <- 0 until numbers.size) {\n            current = numbers(i)\n            if(i == maxIndex) {\n                max = current\n            }\n            if(i == currentIndex) {\n                max = max max > current ? max : current\n            }\n            if(i == numbers.size-1) {\n                maxIndex = i\n                max = max\n            }\n        }\n        return maxIndex.toList.map(n => n.toLong).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpnvjeabms.scala:19:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                max = max max > current ? max : current\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         expression expected but \u001b[31m:\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnvjeabms.scala:19:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                max = max max > current ? max : current\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: >\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpnvjeabms.scala:19:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                max = max max > current ? max : current\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Not found: ?\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnvjeabms.scala:26:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        \u001b[33mreturn\u001b[0m maxIndex.toList.map(\u001b[36mn\u001b[0m => n.toLong).reverse\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value toList is not a member of Int - did you mean Int.toInt?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660011044
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val len = numbers.length\n        var max = 0l\n        var rollingMax = 0l\n        var i = 0\n        while (i < len) {\n            max = max(numbers(i), max)\n            if (max > rollingMax) {\n                rollingMax = max\n            }\n            i += 1\n        }\n        rollingMax.asInstanceOf[List[Long]]\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpoo0_q87o.scala:14:18 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            max = max(numbers(i), max)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011040
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val res = numbers.foldLeft(List[Long]())((l,cur) => {\n            val max = l(0)\n            for (i <- 0 until l.size) {\n                if (cur <= l(i)) {\n                    max = l(i)\n                }\n            }\n            l.updated(l.size, max)\n        })\n        res.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpfg8yxgtu.scala:13:24 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                    max = l(i)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Reassignment to val max\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011041
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val max = numbers.last\n        val list = numbers.dropRight(numbers.last)\n        val result = new ListBuffer[Long]()\n        for (number <- list) {\n            if (number > max) {\n                result += (number -> max)\n            }\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphqd49mdf.scala:10:45 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = numbers.dropRight(numbers.last)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    Long\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphqd49mdf.scala:14:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                result += (number -> max)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (Long, Long)\n\u001b[31m   |\u001b[0m                           Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011046
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val ret = new mutable.MutableList[Long]()\n        numbers.tail.foreach{ x =>\n            val maxIndex = ret.lastIndex\n            val maxValue = ret(maxIndex)\n            val newMax = if (x == maxValue) x else x + 1\n            if (newMax > maxValue) {\n                ret.updated(maxIndex, newMax)\n            }\n        }\n        return ret.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9wsuasli.scala:9:22 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mret\u001b[0m = \u001b[33mnew\u001b[0m mutable.MutableList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                      Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011042
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxNumbersSoFar = mutable.LinkedHashMap[Long, Long]()\n        val rollingMax = mutable.LinkedHashMap[Long, Long]()\n\n        for (i <- 0 to numbers.length-1) {\n            val thisMax = maxNumbersSoFar.getOrElse(numbers(i), -1l)\n            if (thisMax == -1l) {\n                maxNumbersSoFar.put(numbers(i), numbers(i))\n                rollingMax.put(numbers(i), numbers(i))\n            } else {\n                rollingMax.put(numbers(i), max(rollingMax.getOrElse(numbers(i), -1l), numbers(i)))\n            }\n        }\n\n        maxNumbersSoFar.values\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb7rjt_yv.scala:9:30 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxNumbersSoFar\u001b[0m = mutable.LinkedHashMap[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                              Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpb7rjt_yv.scala:10:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMax\u001b[0m = mutable.LinkedHashMap[\u001b[35mLong\u001b[0m, \u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011045
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val result = mutable.MutableList[Long]()\n        numbers.foreach {\n            number =>\n                val maxNumber = rollingMaxHelper(result, number).max\n                result.add((maxNumber, number))\n        }\n        result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp80fjlaf6.scala:9:21 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.MutableList[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                     Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp80fjlaf6.scala:12:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mmaxNumber\u001b[0m = rollingMaxHelper(result, number).max\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: rollingMaxHelper\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011044
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val m = numbers.foldLeft(0l)(\n            (max, num) => max max if num > max else num\n        )\n        val n = numbers.size - 1\n        (m to n).map { index => numbers(index) }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp0xieuou2.scala:10:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            (\u001b[36mmax\u001b[0m, \u001b[36mnum\u001b[0m) => max max \u001b[33mif\u001b[0m num > max \u001b[33melse\u001b[0m num\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  expression expected but \u001b[31mif\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0xieuou2.scala:13:40 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        (m to n).map { \u001b[36mindex\u001b[0m => numbers(index) }\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Found:    (index : Long)\n\u001b[31m   |\u001b[0m                                        Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011053
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val indexed = numbers.zipWithIndex\n        val rollingMaxedIndex = mutable.ListBuffer[Long]()\n        while(indexed.hasNext) {\n            val value = indexed.next()._2._1.toLong\n            rollingMaxedIndex += value\n        }\n        rollingMaxedIndex.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyqxj_t8n.scala:10:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMaxedIndex\u001b[0m = mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyqxj_t8n.scala:11:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mwhile\u001b[0m(indexed.hasNext) {\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              value hasNext is not a member of List[(Long, Int)]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyqxj_t8n.scala:12:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mvalue\u001b[0m = indexed.next()._2._1.toLong\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue next is not a member of List[(Long, Int)] - did you mean indexed.head?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660011056
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        if(numbers == null || numbers.size == 0) List()\n        val result = new mutable.ListBuffer[Long]()\n        var nextMax = numbers.head\n        var current = numbers.head\n        val lastElements = numbers.tail\n        for((index, element) <- 0 until lastElements.size) {\n            if(element > nextMax) {\n                result += List((current, nextMax))\n                nextMax = element\n            } else if(element == nextMax) {\n                nextMax += 1\n            }\n            current = element\n        }\n        if(nextMax < numbers.last) result += List((current, nextMax))\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpz615ecw_.scala:10:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpz615ecw_.scala:15:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m(element > nextMax) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue > is not a member of Any, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Ordered.orderingToOrdered\n\u001b[31m   |\u001b[0m  import math.Ordering.Implicits.infixOrderingOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz615ecw_.scala:17:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                nextMax = element\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (element : Any)\n\u001b[31m   |\u001b[0m                          Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpz615ecw_.scala:21:22 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m            current = element\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    (element : Any)\n\u001b[31m   |\u001b[0m                      Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660011058
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxSeq = List[Long]()\n        for (i <- numbers.iterator) maxSeq += i\n        var result = List[Long]()\n        for (i<- 1 to numbers.size) {\n            val maxSeqI = maxSeq.takeWhile{ x => x <= numbers(i) }\n            if (maxSeqI.size == 0) {\n                result += numbers(i)\n            }\n            else if (maxSeqI.size == 1) {\n                result += numbers(i)\n            }\n            else {\n                result +=  maxSeqI.toList.max\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkfipij03.scala:10:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- numbers.iterator) maxSeq += i\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of List[Long] - did you mean maxSeq.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkfipij03.scala:15:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                result += numbers(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkfipij03.scala:18:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                result += numbers(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkfipij03.scala:21:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                result +=  maxSeqI.toList.max\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of List[Long] - did you mean List[Long].!=?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660011059
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var maximum = 0\n        var sum = 0\n        var maxNums = List[Long]()\n        for( x <- numbers ) {\n            if(maximum < x) {\n                maximum = x\n            }\n            sum += x\n            if(sum == maximum) {\n                maxNums = List(maximum)\n            } else {\n                maxNums = maxNums :+ maximum\n            }\n        }\n        return maxNums\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6yo7qorm.scala:14:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                maximum = x\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (x : Long)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6yo7qorm.scala:16:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            sum += x\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011059
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val result = new scala.collection.mutable.ListBuffer[Long]()\n        for (i<- 0 until numbers.size) {\n            val rollingMax = numbers.slice(i+1, numbers.size)\n            val rollingMaxElement = rollingMax.max\n            result.append(rollingMaxElement)\n        }\n        return result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.UnsupportedOperationException: empty.max\n\tat scala.collection.IterableOnceOps.max(IterableOnce.scala:945)\n\tat scala.collection.IterableOnceOps.max$(IterableOnce.scala:943)\n\tat scala.collection.AbstractIterable.max(Iterable.scala:926)\n\tat Problem$.rollingMax$$anonfun$1(tmpwo76ygcx.scala:12)\n\tat Problem$.rollingMax$$anonfun$adapted$1(tmpwo76ygcx.scala:14)\n\tat scala.collection.immutable.Range.foreach(Range.scala:190)\n\tat Problem$.rollingMax(tmpwo76ygcx.scala:14)\n\tat Problem$.main(tmpwo76ygcx.scala:19)\n\tat Problem.main(tmpwo76ygcx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660011062
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        if (numbers.isEmpty)\n            numbers\n        else\n            if (numbers.last > numbers.head) {\n                numbers :+ numbers.last\n                rollingMax(numbers.dropRight(numbers.last + 1))\n            } else {\n                rollingMax(numbers.dropRight(numbers.head + 1))\n            }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_r8nds88.scala:14:45 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                rollingMax(numbers.dropRight(numbers.last + \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Found:    Long\n\u001b[31m   |\u001b[0m                                             Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp_r8nds88.scala:16:45 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                rollingMax(numbers.dropRight(numbers.head + \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Found:    Long\n\u001b[31m   |\u001b[0m                                             Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011059
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        // First find the rolling maximum element found\n        var maxElement = numbers.head\n        numbers = numbers.tail\n        var currentIndex = 0\n\n        for(number <- numbers) {\n            if(number > maxElement) {\n                currentIndex = 0\n                maxElement = number\n            } else {\n                currentIndex += 1\n            }\n        }\n\n        // Then generate the sequence of rolling maximum element found\n        var finalList = []\n        for(number <- numbers until numbers.last){\n            finalList += number\n        }\n\n        finalList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8lzf33t7.scala:24:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mfinalList\u001b[0m = []\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp8lzf33t7.scala:25:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m(number <- numbers until numbers.last){\n\u001b[31m\u001b[31m   |\u001b[0m^^^\u001b[0m\n\u001b[31m   |\u001b[0m'=>' expected, but 'end of statement' found\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp8lzf33t7.scala:11:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        numbers = numbers.tail\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Reassignment to val numbers\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8lzf33t7.scala:25:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        \u001b[33mfor\u001b[0m(number <- numbers until numbers.last){\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m value until is not a member of List[Long] - did you mean numbers.unzip?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1660011057
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n      val result = mutable.List.empty[Long]\n      def findMax(nums: List[Long], currentIndex : Int, currentSum : Long, currentMax: Long): Unit = {\n        if(nums.length <= currentIndex) {\n          result :+= currentMax\n          return\n        }\n        val maxIndex = currentIndex\n        val maxSum = currentSum + nums(maxIndex)\n        val maxNum = nums(maxIndex)\n        if(maxSum > currentMax) {\n          currentMax = maxSum\n          currentSum = maxNum\n        }\n        findMax(nums.drop(maxIndex), currentIndex + 1, maxSum, currentMax)\n      }\n      findMax(numbers, 0, numbers.head, numbers.head)\n      result.toList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1vsjt96o.scala:9:19 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.List.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m  |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                   Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp1vsjt96o.scala:19:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m          currentMax = maxSum\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Reassignment to val currentMax\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp1vsjt96o.scala:20:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m          currentSum = maxNum\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Reassignment to val currentSum\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660011050
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val max = numbers.head\n        val maxList = numbers.tail\n        val result = mutable.ListBuffer.empty[Long]\n        // Iterate through all element in the tail of maxList, if current is greater than max, then update max with current element\n        maxList.foreach{ x =>\n            if(x>max) {\n                max = x\n            }\n        }\n        // Append current max to result\n        result += max\n        // Reverse the result and return it.\n        result reverse ::: maxList\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpbap06x9f.scala:21:34 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        result reverse ::: maxList\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                                  expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbap06x9f.scala:11:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer.empty[\u001b[35mLong\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpbap06x9f.scala:15:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                max = x\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val max\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660011050
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val rollingMax = numbers.foldLeft((List[Long](numbers(0).asInstanceOf[Long]), 0)) {\n            case ((acc, value), number) => acc._1 + (number > acc._2 ? number : acc._2)\n            case (acc, value) => acc -> value\n        }._1\n        rollingMax.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp0gcdcw_7.scala:10:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            \u001b[33mcase\u001b[0m ((acc, value), number) => acc._1 + (number > acc._2 ? number : acc._2)\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value _1 is not a member of List[Long]\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0gcdcw_7.scala:11:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[33mcase\u001b[0m (acc, value) => acc -> value\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (\u001b[1m\u001b[31m(\u001b[0mList[Long], Int\u001b[1m\u001b[31m)\u001b[0m\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31mLong\u001b[0m)\n\u001b[31m   |\u001b[0m                                 Required: (List[Long], Int)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011060
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val list = numbers.toList.sortWith((a, b) => math.min(a, b))\n        val result = new mutable.ListBuffer[Long]()\n        for (i <- 0 until list.length) {\n            val x = list.take(i)\n            val y = list.drop(i)\n            val z = (x ++ y ).foldLeft((0,0)){\n                ((x, y) , (i: Int) => math.max(x, y))\n            }\n            result.append(z)\n        }\n        return result.toList.sortWith((a, b) => math.min(a, b))\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpu5q1uwib.scala:9:61 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = numbers.toList.sortWith((\u001b[36ma\u001b[0m, \u001b[36mb\u001b[0m) => math.min(a, b))\n\u001b[31m\u001b[31m  |\u001b[0m                                                     ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                                     Found:    Long\n\u001b[31m  |\u001b[0m                                                     Required: Boolean\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpu5q1uwib.scala:10:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpu5q1uwib.scala:15:43 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                ((x, y) , (\u001b[36mi\u001b[0m: \u001b[35mInt\u001b[0m) => math.max(x, y))\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35mmax\u001b[0m in \u001b[33mpackage\u001b[0m \u001b[35mscala.math\u001b[0m with types\n\u001b[31m   |\u001b[0m (x: Double, y: Double): Double\n\u001b[31m   |\u001b[0m (x: Float, y: Float): Float\n\u001b[31m   |\u001b[0m (x: Long, y: Long): Long\n\u001b[31m   |\u001b[0m (x: Int, y: Int): Int\n\u001b[31m   |\u001b[0mmatch arguments ((x : List[Long]), (y : List[Long]))\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660011060
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val max = numbers(0)\n        val rollingMax = numbers.tail\n\n        for (i <- 0 until numbers.size) {\n            if (rollingMax(i) > max) {\n                max = rollingMax(i)\n            }\n        }\n        rollingMax\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmp9_n7jksx.scala:14:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                max = rollingMax(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val max\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011054
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val result: List[Long] = List()\n        var maxNumber: Long = 0\n        var maxIndex: Long = -1\n        var currentNumber: Long = 0\n        var currentIndex: Long = 0\n        for (currentNumber <- numbers) {\n            if (maxIndex == -1) {\n                if (currentNumber > maxNumber) {\n                    maxNumber = currentNumber\n                    maxIndex = currentIndex\n                }\n            } else {\n                if (currentNumber > maxNumber) {\n                    maxIndex = currentIndex\n                    maxNumber = currentNumber\n                }\n            }\n            currentIndex += 1\n        }\n        result.add(maxIndex)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp59f445xo.scala:28:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        result.add(maxIndex)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value add is not a member of List[Long]\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011062
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val max_so_far = numbers.last\n        val result: List[Long] = numbers.sliding(numbers.size % numbers.size).foldLeft(List[Long](max_so_far)) {\n            (sum: List[Long], el: Long) => {\n                sum.lastOption match {\n                    case None => sum.append(el)\n                    case Some(curMax) =>\n                        if(curMax > el) list(sum.head :: sum.tail)\n                        else list\n                }\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3z0eakxm.scala:13:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                    \u001b[33mcase\u001b[0m None => sum.append(el)\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m value append is not a member of List[Long] - did you mean sum.appended?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3z0eakxm.scala:15:40 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                        \u001b[33mif\u001b[0m(curMax > el) list(sum.head :: sum.tail)\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        Not found: list\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3z0eakxm.scala:16:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                        \u001b[33melse\u001b[0m list\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Not found: list\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660011061
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val rollingMax = mutable.ArrayBuffer.empty[Long]()\n        numbers.foreach { n =>\n            if (rollingMax.isEmpty) {\n                rollingMax.clear()\n                rollingMax += n\n                return\n            }\n            var max = 0\n            var index = 0\n            rollingMax.foreach((e, i) => {\n                if (i <= index) {\n                    return\n                }\n                if (e > max) {\n                    max = e\n                }\n            })\n            index += 1\n            rollingMax += max\n        }\n        rollingMax.clear()\n        rollingMax += numbers(0)\n        return rollingMax\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpl183qixs.scala:9:25 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mrollingMax\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                         Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpl183qixs.scala:14:16 --------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                \u001b[33mreturn\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Found:    Unit\n\u001b[31m   |\u001b[0m                Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011062
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var currentMax = -1l.toLong\n        var results: List[Long] = Nil\n        numbers.foreach{number => currentMax = max(number, currentMax)}\n        results = numbers :+ currentMax\n        results.distinct\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp_k6vnym4.scala:16)\n\tat Problem.main(tmp_k6vnym4.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660011064
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.tail.foldLeft(numbers.head){ (max: Long, element: Long) =>\n            if (element > max)\n                (element.toLong, element)\n            else (max.toLong, max)\n        }.map(_._2)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpr32zwdro.scala:9:45 ---------------------\u001b[0m\u001b[0m\n\u001b[31m 9 |\u001b[0m        numbers.tail.foldLeft(numbers.head){ (\u001b[36mmax\u001b[0m: \u001b[35mLong\u001b[0m, \u001b[36melement\u001b[0m: \u001b[35mLong\u001b[0m) =>\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m             Found:    (\u001b[1m\u001b[31mLong\u001b[0m, Long) => Matchable\n\u001b[31m   |\u001b[0m             Required: (\u001b[1m\u001b[32mMatchable\u001b[0m, Long\u001b[1m\u001b[32m \u001b[0m\u001b[1m\u001b[32m@\u001b[0m\u001b[1m\u001b[32muncheckedVariance\u001b[0m) => Matchable\n\u001b[31m10 |\u001b[0m            \u001b[33mif\u001b[0m (element > max)\n\u001b[31m11 |\u001b[0m                (element.toLong, element)\n\u001b[31m12 |\u001b[0m            \u001b[33melse\u001b[0m (max.toLong, max)\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011063
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        if (numbers.isEmpty) List() else (numbers zip rollingMax(numbers.tail)).filter(_._2 == numbers.head).map(_._1)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpdalwadfp.scala:13)\n\tat Problem.main(tmpdalwadfp.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660011066
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxCount = numbers.count(_.toLong > 0)\n        if(maxCount == 0) List(numbers.head)\n        else {\n            val rollingMaxes = List.fill(maxCount)(numbers.head)\n            val curMax = numbers.head\n\n            var maxIndex = maxCount\n            var curIndex = 0\n            for(i <- 1 to maxCount) {\n                rollingMaxes(i) = if (numbers(i) > curMax) numbers(i) else curMax\n                maxIndex -= 1\n                curIndex += 1\n            }\n            rollingMaxes\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpub4zw68x.scala:18:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                rollingMaxes(i) = \u001b[33mif\u001b[0m (numbers(i) > curMax) numbers(i) \u001b[33melse\u001b[0m curMax\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean rollingMaxes.updated?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011064
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var list = numbers\n        var max: Long = numbers.head\n        var nextMax: Long = numbers.tail.max\n        while(nextMax != numbers.tail.last) {\n            val nextMaxMinusOne = nextMax.min - 1\n            list = list.tail.filter(elem => elem > nextMax && (elem - nextMaxMinusOne) < max)\n            max = nextMax\n            nextMax = list.max\n        }\n        list.filterNot(elem => elem == nextMax)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyol5qutb.scala:13:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnextMaxMinusOne\u001b[0m = nextMax.min - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of Long => Long, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011066
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var maxNumbers = List[Long]()\n        var maxCount = 0\n        for(i <- 0 until numbers.size) {\n            val number = numbers(i)\n            if(maxCount < number) {\n                maxCount = 0\n                maxNumbers = List(number)\n            } else if (maxCount == number) {\n                maxNumbers = maxNumbers :+ number\n            }\n            else {\n                maxCount += 1\n            }\n        }\n        return maxNumbers\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpalgiqae2.scala:27)\n\tat Problem.main(tmpalgiqae2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660011068
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        def rollingMaxIteration(startIndex : Int) : List[Long] = {\n            if (startIndex >= numbers.size) {\n                return List() :: rollingMaxIteration(startIndex)\n            }\n\n            val maxIndex = getMaxIndex(startIndex)\n            val maxValue = numbers(maxIndex)\n            rollingMaxIteration(startIndex + 1) ::: List(maxValue) :: rollingMaxIteration(startIndex)\n        }\n\n        rollingMaxIteration(0) :::\n            rollingMaxIteration(0)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1aq7jo4i.scala:11:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m                \u001b[33mreturn\u001b[0m List() :: rollingMaxIteration(startIndex)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Found:    List[Nothing]\n\u001b[31m   |\u001b[0m                       Required: Long\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp1aq7jo4i.scala:14:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mmaxIndex\u001b[0m = getMaxIndex(startIndex)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: getMaxIndex\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1aq7jo4i.scala:16:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            rollingMaxIteration(startIndex + \u001b[31m1\u001b[0m) ::: List(maxValue) :: rollingMaxIteration(startIndex)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    List[Matchable]\n\u001b[31m   |\u001b[0m            Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660011067
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.zipWithIndex.filter(_._2 % 2 == 0).map(_._1).maxBy(_.toLong)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpb4qkobh3.scala:9:8 ----------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        numbers.zipWithIndex.filter(_._2 % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m).map(_._1).maxBy(_.toLong)\n\u001b[31m\u001b[31m  |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m        Found:    Long\n\u001b[31m  |\u001b[0m        Required: \u001b[1m\u001b[32mList\u001b[0m\u001b[1m\u001b[32m[\u001b[0mLong\u001b[1m\u001b[32m]\u001b[0m\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011068
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.view.zip(numbers.drop(1)).foldLeft(List[Long]())((a,b) => a ++ b).reverse.takeRight(1)\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpdf6kfysp.scala:9:79 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        numbers.view.zip(numbers.drop(\u001b[31m1\u001b[0m)).foldLeft(List[\u001b[35mLong\u001b[0m]())((\u001b[36ma\u001b[0m,\u001b[36mb\u001b[0m) => a ++ b).reverse.takeRight(\u001b[31m1\u001b[0m)\n\u001b[31m\u001b[31m  |\u001b[0m                                                                               ^\u001b[0m\n\u001b[31m  |\u001b[0m                                              Found:    (b : (Long, Long))\n\u001b[31m  |\u001b[0m                                              Required: IterableOnce[Long]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011068
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val size = numbers.size \n        var maxIndex = 0\n        var tempMax = 0l\n        var rollingMax: List[Long] = List()\n        // loop through each element\n        for (i <- 0 until size) {\n            // if number is greater than previous maximum \n            if (numbers(i) > tempMax) {\n                // assign new max to previous maximum\n                tempMax = numbers(i)\n                // set new maximum to zero\n                maxIndex = 0\n            }\n            // if number is equal to previous maximum \n            else if (numbers(i) == tempMax) {\n                // increment maximum index\n                maxIndex = maxIndex + 1\n            }\n            // if current maximum index is greater than max index \n            // then save rolling max element and reset\n            if (maxIndex > rollingMax.length) {\n                // save max element\n                rollingMax(maxIndex) = tempMax\n                maxIndex = 0\n            }\n        }\n        return rollingMax\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc19z2ube.scala:31:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                rollingMax(maxIndex) = tempMax\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue update is not a member of List[Long] - did you mean List[Long].updated?\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011069
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val largest = numbers.reduceRight( _ max )\n        val result: List[Long] = numbers.takeWhile( x => x != largest )\n        result ::: numbers.dropWhile( x => x == largest )\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmptyb8okqn.scala:9:49 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlargest\u001b[0m = numbers.reduceRight( _ max )\n\u001b[31m\u001b[31m  |\u001b[0m                                                 ^\u001b[0m\n\u001b[31m  |\u001b[0m                                         expression expected but \u001b[31m')'\u001b[0m found\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011067
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n      numbers match {\n        case Nil => Nil\n        case x :: Nil => List(x.toLong)\n        case x :: xs => for (n <- numbers) yield {\n          x max n match {\n            case n0 if n0 == x => x\n            case n0 => n0\n          }\n        }\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpostzsr1q.scala:24)\n\tat Problem.main(tmpostzsr1q.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1660011070
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        var maxes = scala.collection.mutable.ArrayBuffer.empty[Long]\n        var index = 0\n        var rollingMax = numbers.head\n        while(maxes.size < numbers.size) {\n            if(numbers(index) > rollingMax) {\n                maxes += numbers(index)\n                index += 1\n            } else {\n                maxes += numbers(index)\n            }\n        }\n        while(index != numbers.size)\n            maxes += numbers(index)\n        return maxes\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmph58manqv.scala:22:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m        \u001b[33mreturn\u001b[0m maxes\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Found:    (maxes : scala.collection.mutable.ArrayBuffer[Long])\n\u001b[31m   |\u001b[0m          Required: List[Long]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1660011069
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        numbers.foldLeft(List[Long]())((acc, cur)=> {\n            val list = new mutable.ListBuffer[Long]()\n            var max = cur\n            while(max < acc.last){\n                list += max\n                max = max(acc)\n            }\n            list += max\n            list += cur\n            acc\n        })\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpmkv18n0z.scala:10:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mlist\u001b[0m = \u001b[33mnew\u001b[0m mutable.ListBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpmkv18n0z.scala:14:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                max = max(acc)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mmax\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1660011069
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // From a given list of integers, generate a list of rolling maximum element found until given moment\n    // in the sequence.\n    // >>> rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 2l.toLong, 3l.toLong, 4l.toLong, 2l.toLong)))\n    // (List[Long](1l.toLong, 2l.toLong, 3l.toLong, 3l.toLong, 3l.toLong, 4l.toLong, 4l.toLong))\n    def rollingMax(numbers : List[Long]) : List[Long] = {\n        val maxSeq = new mutable.ArrayBuffer[Long]()\n        numbers.foreach { number =>\n            maxSeq.clear()\n            numbers = maxSeq.appended(number).reverse\n        }\n        numbers = maxSeq.filter( (x) => x > numbers ).reverse\n        numbers\n    }\n    def main(args: Array[String]) = {\n    assert(rollingMax((List[Long]())).equals((List[Long]())));\n    assert(rollingMax((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))).equals((List[Long](1l.toLong, 2l.toLong, 3l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](4l.toLong, 3l.toLong, 2l.toLong, 1l.toLong))).equals((List[Long](4l.toLong, 4l.toLong, 4l.toLong, 4l.toLong))));\n    assert(rollingMax((List[Long](3l.toLong, 2l.toLong, 3l.toLong, 100l.toLong, 3l.toLong))).equals((List[Long](3l.toLong, 3l.toLong, 3l.toLong, 100l.toLong, 100l.toLong))));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmphbjqoajz.scala:9:25 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmaxSeq\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayBuffer[\u001b[35mLong\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                         Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmphbjqoajz.scala:12:20 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            numbers = maxSeq.appended(number).reverse\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Reassignment to val numbers\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmphbjqoajz.scala:14:16 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        numbers = maxSeq.filter( (\u001b[36mx\u001b[0m) => x > numbers ).reverse\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Reassignment to val numbers\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1660011068
    }
  ]
}