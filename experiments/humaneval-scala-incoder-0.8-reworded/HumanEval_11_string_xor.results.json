{
  "language": "scala",
  "name": "HumanEval_11_string_xor",
  "results": [
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // If length of both strings are same, return empty string immediately\n        if (a.length == b.length){\n            return \"\"\n        }\n        val xor = mutable.StringBuilder(a.length)\n        for (i <- 0 to (a.length - 1)) {\n            xor(i) = if (a(i) == '1') '0' else '1'\n            xor(i + 1) = if (b(i) == '1') '0' else '1'\n        }\n        xor.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp2uaokrnb.scala:13:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mxor\u001b[0m = mutable.StringBuilder(a.length)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978801
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val a1 = a.toCharArray\n        val b1 = b.toCharArray\n        val ret = new StringBuilder\n        val m = Math.min(a.length(), b.length)\n        for( i <- 0 until m) {\n            ret.append(a(i) ^ b(i))\n        }\n        return ret.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659978806
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val listA = a.toIntList\n        val listB = b.toIntList\n        val listAB = listA.zip(listB).toList\n        val res = listAB.map{ case (aa, bb) => (aa xor bb).asInstanceOf[Int].toString }\n        val res = res.filter(_.isDigit)\n        val res = res.reverse.mkString\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7mjon51b.scala:13:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = res.filter(_.isDigit)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mres is already defined as \u001b[33mvalue\u001b[0m \u001b[35mres\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp7mjon51b.scala:14:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = res.reverse.mkString\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mres is already defined as \u001b[33mvalue\u001b[0m \u001b[35mres\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7mjon51b.scala:9:22 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlistA\u001b[0m = a.toIntList\n\u001b[31m\u001b[31m  |\u001b[0m                    ^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                    value toIntList is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7mjon51b.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlistB\u001b[0m = b.toIntList\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value toIntList is not a member of String\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659978806
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aBits = a.toInt\n        val bBits = b.toInt\n        var result : String = \"\"\n        var carry = 0\n        for (i <- 0 until aBits.length){\n            if (carry > 0){\n                result = result + carry.toString\n            }\n            val cBits = aBits.apply(i).xor(bBits.apply(i))\n            if (cBits > 0){\n                result = result + cBits.toString\n            }\n            if (cBits == 0){\n                carry = 1\n            }\n            else {\n                carry = 0\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8mzvxuvd.scala:13:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until aBits.length){\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value length is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8mzvxuvd.scala:17:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mcBits\u001b[0m = aBits.apply(i).xor(bBits.apply(i))\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue apply is not a member of Int, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigDecimal.int2bigDecimal\n\u001b[31m   |\u001b[0m\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978806
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aList = a.toIntList.map(_.toInt)\n        val bList = b.toIntList.map(_.toInt)\n        val xorResult = aList.zip(yList).filter(_._1 == 0).map(_._2).mkString\n        val andResult = aList.zip(yList).filter(_._1 == 1).map(_._2).mkString\n        val finalResult = xorResult + andResult\n        finalResult\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkxi4t_cp.scala:9:22 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maList\u001b[0m = a.toIntList.map(_.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m                    ^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                    value toIntList is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkxi4t_cp.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbList\u001b[0m = b.toIntList.map(_.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value toIntList is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978805
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val xa = a.toList\n        val xb = b.toList\n        xa zip xb map { a => a._1 xor a._2 } toList.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpjbhwzz0e.scala:11:51 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        xa zip xb map { \u001b[36ma\u001b[0m => a._1 xor a._2 } toList.toString()\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'.'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjbhwzz0e.scala:11:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        xa zip xb map { \u001b[36ma\u001b[0m => a._1 xor a._2 } toList.toString()\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             value xor is not a member of Char\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978805
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val map = scala.collection.mutable.Map[Char, Int]()\n        var ans = \"\"\n        var index = 0\n        while(a.charAt(index) != \"0\" && a.charAt(index) != \"1\" && index < a.length){\n            index += 1\n        }\n        while(b.charAt(index) != \"0\" && b.charAt(index) != \"1\" && index < b.length){\n            index += 1\n        }\n        if(index >= a.length){\n            ans = \"0\"\n        } else {\n            map.put(a.charAt(index), 1)\n        }\n        if(index >= b.length){\n            ans = \"0\"\n        } else {\n            map.put(b.charAt(index), 1)\n        }\n        val keys = map.keys.toList\n        val values = map.values.toList\n        for( i <- keys){\n            val temp = scala.math.pow(2,i)\n            val answer = values.take(temp).reduce(_ + _) match {\n                case x if x < ans.length => {\n                    ans\n                }\n                case x => {\n                    ans\n                }\n            }\n            val sum = ans.split(\"\").map(x => if (x.toInt == answer) 1 else 0).sum\n            ans = sum\n        }\n        ans\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp01aiwbl_.scala:12:14 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mwhile\u001b[0m(a.charAt(index) != \u001b[31m\"0\"\u001b[0m && a.charAt(index) != \u001b[31m\"1\"\u001b[0m && index < a.length){\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmp01aiwbl_.scala:12:40 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mwhile\u001b[0m(a.charAt(index) != \u001b[31m\"0\"\u001b[0m && a.charAt(index) != \u001b[31m\"1\"\u001b[0m && index < a.length){\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmp01aiwbl_.scala:15:14 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mwhile\u001b[0m(b.charAt(index) != \u001b[31m\"0\"\u001b[0m && b.charAt(index) != \u001b[31m\"1\"\u001b[0m && index < b.length){\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmp01aiwbl_.scala:15:40 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mwhile\u001b[0m(b.charAt(index) != \u001b[31m\"0\"\u001b[0m && b.charAt(index) != \u001b[31m\"1\"\u001b[0m && index < b.length){\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp01aiwbl_.scala:32:37 --------------------\u001b[0m\u001b[0m\n\u001b[31m32 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36manswer\u001b[0m = values.take(temp).reduce(_ + _) \u001b[33mmatch\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Found:    (temp : Double)\n\u001b[31m   |\u001b[0m                                     Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp",
      "stdout": "",
      "timestamp": 1659978807
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aSet = a.toSet\n        val bSet = b.toSet\n        val result = new mutable.HashMap[Int, Int]()\n        val n = a.length\n        val m = b.length\n        var x = aSet.length\n        var y = bSet.length\n        while (x != 0 || y != 0) {\n            val d = (x * y) % n\n            val l = aSet(d)\n            val r = bSet(d)\n            result.put(d, r)\n            x -= 1\n            y -= 1\n        }\n        result.values.toList\n            .sorted.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc01ysjr2.scala:11:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc01ysjr2.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mx\u001b[0m = aSet.length\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value length is not a member of Set[Char]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc01ysjr2.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36my\u001b[0m = bSet.length\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value length is not a member of Set[Char]\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978806
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val m = a.length\n        val n = b.length\n        if(m > n) {\n            throw new IllegalArgumentException\n        } else {\n            val l = mutable.ArrayBuffer.empty[String]\n            while(m > 0) {\n                if(a(m - 1) != b(n - 1)) {\n                    l(l.get.length - 1) = a(m - 1) ^ b(n - 1)\n                }\n                m--\n                n--\n            }\n            val rm = m.min(l)\n            val ln = l.length\n            val rn = r.length\n            val r = scala.util.Right.fromString(l.take(rm).mkString(\"\"), 0, rm)\n            val l = scala.util.Left.fromString(l.take(ln).mkString(\"\"), 0, ln)\n            l.right(l.length - r)\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpgazyizgj.scala:20:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                n--\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpgazyizgj.scala:26:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36ml\u001b[0m = scala.util.Left.fromString(l.take(ln).mkString(\u001b[31m\"\"\u001b[0m), \u001b[31m0\u001b[0m, ln)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0ml is already defined as \u001b[33mvalue\u001b[0m \u001b[35ml\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgazyizgj.scala:14:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36ml\u001b[0m = mutable.ArrayBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgazyizgj.scala:19:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                m--\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value -- is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgazyizgj.scala:25:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mr\u001b[0m = scala.util.Right.fromString(l.take(rm).mkString(\u001b[31m\"\"\u001b[0m), \u001b[31m0\u001b[0m, rm)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue fromString is not a member of object scala.util.Right - did you mean Right.toString?\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659978806
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val res = a.zip(b).foldLeft[String](\"0\"){\n            case (res, (a, b)) => res + (\"1\" XOR \"0\" XOR ((a XOR b) toInt))\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpvuef_gbp.scala:10:73 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            \u001b[33mcase\u001b[0m (res, (a, b)) => res + (\u001b[31m\"1\"\u001b[0m XOR \u001b[31m\"0\"\u001b[0m XOR ((a XOR b) toInt))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m')'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvuef_gbp.scala:10:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            \u001b[33mcase\u001b[0m (res, (a, b)) => res + (\u001b[31m\"1\"\u001b[0m XOR \u001b[31m\"0\"\u001b[0m XOR ((a XOR b) toInt))\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value XOR is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978804
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      val aBits = a.toInt.map(x => if (x == '1') 1 else 0)\n      val bBits = b.toInt.map(x => if (x == '1') 1 else 0)\n      val result = new Array[Int](aBits.length+bBits.length).init\n      result.zip(Array.tabulate(bBits.length)(_+_)).foreach { case (r, i) =>\n        val aBitsDiff = i.toInt - aBits.length\n        val bBitsDiff = i.toInt - bBits.length\n        for ( i <- 0 until aBits.length; )\n        {\n          if (i < aBitsDiff) {\n            result(i) = aBits(i)\n            i += 1\n          } else if (i < aBitsDiff+bBitsDiff) {\n            result(i) = 0\n            i += 1\n          } else {\n            result(i) = 0\n          }\n        }\n        for ( i <- 0 until bBits.length; )\n        {\n          if (i < bBitsDiff) {\n            result(i) = bBits(i)\n            i += 1\n          } else if (i < bBitsDiff+aBitsDiff) {\n            result(i) = 0\n            i += 1\n          } else {\n            result(i) = 0\n          }\n        }\n      }\n      result.reverse.mkString.reverse.stripPrefix(\"0\")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3nyougcg.scala:15:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mfor\u001b[0m ( i <- \u001b[31m0\u001b[0m until aBits.length; )\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp3nyougcg.scala:27:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mfor\u001b[0m ( i <- \u001b[31m0\u001b[0m until bBits.length; )\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                         pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3nyougcg.scala:9:26 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36maBits\u001b[0m = a.toInt.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m'1'\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m  |\u001b[0m                  ^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                  value map is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3nyougcg.scala:10:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mbBits\u001b[0m = b.toInt.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m'1'\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value map is not a member of Int\n\u001b[31m\u001b[31m-- [E086] Syntax Error: /tmp/tmp3nyougcg.scala:12:46 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m      result.zip(Array.tabulate(bBits.length)(_+_)).foreach { \u001b[33mcase\u001b[0m (r, i) =>\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Wrong number of parameters, expected: 1\n\u001b[31m\u001b[31m-- Error: /tmp/tmp3nyougcg.scala:12:50 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m      result.zip(Array.tabulate(bBits.length)(_+_)).foreach { \u001b[33mcase",
      "stdout": "",
      "timestamp": 1659978807
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var x = 0\n        var y = 0\n        var z = 0\n        var newString = \"\"\n        for (i<-0 to a.length-1) {\n            x = a(i).toInt\n            y = b(i).toInt\n            z = (x XOR y).toInt\n            newString = newString + Integer.toBinaryString(z)\n        }\n        return newString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyzuz82de.scala:16:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            z = (x XOR y).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value XOR is not a member of Int\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978804
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val result = new StringBuilder\n        val latch = new CountDownLatch(2)\n        val taskA = Future {\n            val pair1 = a.split(\"\")\n            val pair2 = b.split(\"\")\n            var sum = 0\n            pair1.zipWithIndex.foreach{ case (x, i) =>\n                sum += (x.toInt == pair2(i).toInt)\n            }\n            latch.countDown()\n            sum\n        }\n        val taskB = Future {\n            val pair1 = a.split(\"\")\n            val pair2 = b.split(\"\")\n            var sum = 0\n            pair2.zipWithIndex.foreach{ case (x, i) =>\n                sum += (x.toInt == pair1(i).toInt)\n            }\n            latch.countDown()\n            sum\n        }\n        latch.await()\n        taskA onComplete { case result => result.foreach(x => result.append(x)) }\n        taskB onComplete { case result => result.foreach(x => result.append(x)) }\n        result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwbkv3t8r.scala:10:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlatch\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mCountDownLatch\u001b[0m(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: type CountDownLatch\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwbkv3t8r.scala:11:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mtaskA\u001b[0m = Future {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: Future\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwbkv3t8r.scala:16:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                sum += (x.toInt == pair2(i).toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpwbkv3t8r.scala:21:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mtaskB\u001b[0m = Future {\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: Future\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwbkv3t8r.scala:26:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                sum += (x.toInt == pair1(i).toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value += is not a member of Int - did you mean Int.!=?\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659978805
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val a = a.toInt\n        val b = b.toInt\n        val xor = (a^b).asInstanceOf[String]\n        return xor\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp98ext207.scala:9:16 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ma\u001b[0m = a.toInt\n\u001b[31m\u001b[31m  |\u001b[0m                ^\u001b[0m\n\u001b[31m  |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35ma\u001b[0m needs type\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp98ext207.scala:10:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mb\u001b[0m = b.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978800
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var c = 0\n        for(i <- a.indices) c += (if (b(i) == \"0\") 1 else 0)\n        for(i <- b.indices) c += (if (a(i) == \"0\") 1 else 0)\n        c + a.size + b.size\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpf3g6mcsc.scala:10:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- a.indices) c += (\u001b[33mif\u001b[0m (b(i) == \u001b[31m\"0\"\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- Error: /tmp/tmpf3g6mcsc.scala:10:38 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- a.indices) c += (\u001b[33mif\u001b[0m (b(i) == \u001b[31m\"0\"\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpf3g6mcsc.scala:11:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- b.indices) c += (\u001b[33mif\u001b[0m (a(i) == \u001b[31m\"0\"\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- Error: /tmp/tmpf3g6mcsc.scala:11:38 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- b.indices) c += (\u001b[33mif\u001b[0m (a(i) == \u001b[31m\"0\"\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpf3g6mcsc.scala:12:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        c + a.size + b.size\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    Int\n\u001b[31m   |\u001b[0m                     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659978807
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aLength = a.length\n        val bLength = b.length\n\n        if (aLength != bLength) {\n            throw new IllegalArgumentException(\"Both arguments should have the same length.\")\n        }\n\n        if ( (a == \"0\") || (b == \"0\") ) {\n            return \"0\"\n        }\n\n        var result = \"\"\n\n        for (i<- 0 until aLength) {\n            val left = a.charAt(i)\n            val right= b.charAt(i)\n            result += \"1\" if ((left == \"0\") || (right == \"0\")) else\n                         \"0\" if ((left == \"1\") || (right == \"1\")) else\n                         throw new IllegalArgumentException(\"The arguments should have the same length.\")\n        }\n\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpwru0f1zk.scala:25:26 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m            result += \u001b[31m\"1\"\u001b[0m \u001b[33mif\u001b[0m ((left == \u001b[31m\"0\"\u001b[0m) || (right == \u001b[31m\"0\"\u001b[0m)) \u001b[33melse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^\u001b[0m\n\u001b[31m   |\u001b[0m                          end of statement expected but 'if' found\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978802
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var ans = \"\"\n        var i = 0\n        var j = 0\n        while(i < a.length && j < b.length){\n            ans += (a(i) XOR b(i)) +\n                   if(i < a.length) a(i += 1) else \"\"\n            if(j < b.length) ans += b(i) XOR \"\"\n        }\n        ans\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpi9caocr3.scala:13:36 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            ans += (a(i) XOR b(i)) +\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    expression expected but \u001b[31mif\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi9caocr3.scala:13:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            ans += (a(i) XOR b(i)) +\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi9caocr3.scala:13:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            ans += (a(i) XOR b(i)) +\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value XOR is not a member of Char\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi9caocr3.scala:15:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m(j < b.length) ans += b(i) XOR \u001b[31m\"\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi9caocr3.scala:15:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m(j < b.length) ans += b(i) XOR \u001b[31m\"\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                    value XOR is not a member of Char\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659978806
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val a = a.toInt\n        val b = b.toInt\n        val result: StringBuilder = new StringBuilder\n        var carry = 0\n        var x = 1\n        var y = 0\n        while (a != 0 || b != 0) {\n            val aDigit = if (a != 0) a else 0\n            val bDigit = if (b != 0) b else 0\n            val sum = carry + aDigit + bDigit\n            result += Integer.toBinaryString(sum)\n            carry = (sum / 2)\n            x += 1\n            y += 1\n        }\n        result += Integer.toBinaryString(carry)\n        result += Integer.toBinaryString(x % 2)\n        result += Integer.toBinaryString(y % 2)\n        result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpgapfxto4.scala:9:16 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ma\u001b[0m = a.toInt\n\u001b[31m\u001b[31m  |\u001b[0m                ^\u001b[0m\n\u001b[31m  |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35ma\u001b[0m needs type\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpgapfxto4.scala:10:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mb\u001b[0m = b.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgapfxto4.scala:19:44 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            result += Integer.toBinaryString(sum)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Found:    String\n\u001b[31m   |\u001b[0m                      Required: Char\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgapfxto4.scala:24:40 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m        result += Integer.toBinaryString(carry)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    String\n\u001b[31m   |\u001b[0m                  Required: Char\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgapfxto4.scala:25:40 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        result += Integer.toBinaryString(x % \u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Found:    String\n\u001b[31m   |\u001b[0m                  Required: Char\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpgapfxto4.scala:26:40 ----------",
      "stdout": "",
      "timestamp": 1659978805
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var result = new StringBuilder\n\n        var a = a.toIntArray()\n        var b = b.toIntArray()\n        var resultIndex = 0\n\n        for (i <- 0 until a.length) {\n            val xor = a(i) xor b(i)\n            result(resultIndex) = xor.asInstanceOf[Char].toString\n            resultIndex += 1\n        }\n        result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp4mywgq_f.scala:11:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ma\u001b[0m = a.toIntArray()\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvariable\u001b[0m \u001b[35ma\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp4mywgq_f.scala:12:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mb\u001b[0m = b.toIntArray()\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvariable\u001b[0m \u001b[35mb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978803
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var c = 0\n        for(i <- 0 until a.length)\n            c += toInt(a(i) ^ toInt(b(i)))\n        val result = (new StringBuilder).append(toChar(c))\n        return result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkfcmty0l.scala:11:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            c += toInt(a(i) ^ toInt(b(i)))\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkfcmty0l.scala:11:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            c += toInt(a(i) ^ toInt(b(i)))\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Not found: toInt\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkfcmty0l.scala:11:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            c += toInt(a(i) ^ toInt(b(i)))\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: toInt\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkfcmty0l.scala:12:48 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = (\u001b[33mnew\u001b[0m \u001b[35mStringBuilder\u001b[0m).append(toChar(c))\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                Not found: toChar\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659978804
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        assert(a.length == b.length, \"stringXor must operate on strings of equal length.\")\n        val aInts = a.grouped(2).map(_.toInt)\n        val bInts = b.grouped(2).map(_.toInt)\n        val xor: mutable.WrappedArray[Int] = mutable.WrappedArray.empty[Int]\n        for (i <- 0 until a.length) {\n            for (j <- 0 until b.length) {\n                val xorI = i + j\n                val xorJ = i + j + 1\n                val xorIJ = i + j + 2\n                // if either input string is too short, pad out with 0's.\n                if ((xorI < a.length) && (xorJ < b.length)) {\n                    xor.push(aInts(xorI) xor bInts(xorJ))\n                } else if ((xorIJ < aInts.length) && (xorIJ < bInts.length)) {\n                    xor.push(aInts(xorIJ) xor bInts(xorJ))\n                } else {\n                    xor.push(aInts(i) xor bInts(j))\n                }\n            }\n        }\n        new String(xor.mkString(\"\"))\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgn6r73oo.scala:12:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mxor\u001b[0m: mutable.WrappedArray[\u001b[35mInt\u001b[0m] = mutable.WrappedArray.empty[\u001b[35mInt\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgn6r73oo.scala:12:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mxor\u001b[0m: mutable.WrappedArray[\u001b[35mInt\u001b[0m] = mutable.WrappedArray.empty[\u001b[35mInt\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                             Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978802
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var result = new StringBuilder\n        var c = 0\n        var i = 0\n        var k = 0\n        while(i < a.length && k < b.length) {\n            c += (scala.util.Char.digit(a(i), 2) XOR scala.util.Char.digit(b(k), 2))\n            i += 1\n            k += 1\n        }\n        while(i < a.length) {\n            c += (scala.util.Char.digit(a(i), 2))\n            i += 1\n        }\n        while(k < b.length) {\n            c += (scala.util.Char.digit(b(k), 2))\n            k += 1\n        }\n        result.append(scala.util.Char.chr((c) XOR '0'))\n        return result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfta0s1ny.scala:14:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            c += (scala.util.Char.digit(a(i), \u001b[31m2\u001b[0m) XOR scala.util.Char.digit(b(k), \u001b[31m2\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfta0s1ny.scala:14:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            c += (scala.util.Char.digit(a(i), \u001b[31m2\u001b[0m) XOR scala.util.Char.digit(b(k), \u001b[31m2\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value Char is not a member of util\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfta0s1ny.scala:19:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            c += (scala.util.Char.digit(a(i), \u001b[31m2\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfta0s1ny.scala:19:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            c += (scala.util.Char.digit(a(i), \u001b[31m2\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value Char is not a member of util\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfta0s1ny.scala:23:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            c += (scala.util.Char.digit(b(k), \u001b[31m2\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfta0s1ny.scala:23:29 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            c += (scala.util.Char.digit(b(k), \u001b[31m2\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  value Char is not a member of util\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfta0s1ny.scala:26:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m        result.append(scala.util.Char.chr((c) XOR \u001b[31m'0'\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                ",
      "stdout": "",
      "timestamp": 1659978807
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n        val bList = b.toList\n        var result = \"\"\n        val aLength = a.length\n        val bLength = b.length\n        aList.foreach(x => bList.foreach(y => result += if (x == y) \"1\" else \"0\"))\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp_kjlaif2.scala:14:56 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        aList.foreach(\u001b[36mx\u001b[0m => bList.foreach(\u001b[36my\u001b[0m => result += \u001b[33mif\u001b[0m (x == y) \u001b[31m\"1\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"0\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        expression expected but \u001b[31mif\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978801
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aBytes = a.toIntArray\n        val bBytes = b.toIntArray\n        var x = 0\n        var y = 0\n        var result : String = \"\"\n\n        while (aBytes.exists(x => x != 0))\n        {\n            y = 0\n            while (b.exists(y => y != 0))\n            {\n                x = x ^ y\n                y = y + 1\n            }\n            result = result + x.toBinaryString\n            x = x + 1\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv3ojyg9w.scala:9:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maBytes\u001b[0m = a.toIntArray\n\u001b[31m\u001b[31m  |\u001b[0m                     ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                     value toIntArray is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv3ojyg9w.scala:10:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbBytes\u001b[0m = b.toIntArray\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value toIntArray is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978813
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val result = a.toInt ^ b.toInt\n        val res = new StringBuilder\n        for(i <- 0 until result.toInt) res.append(if (result == i) \"1\" else \"0\")\n        res.result()\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7ji5dgcz.scala:15)\n\tat Problem.main(tmp7ji5dgcz.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978815
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aList = a.split('')\n        val bList = b.split('')\n        val output = new StringBuilder\n        \n        val aSet = Set(aList).map(_.toInt)\n        val bSet = Set(bList).map(_.toInt)\n        \n        val xor = new mutable.HashMap[Int, Int]()\n        \n        for (i<- 0 until aList.length) {\n            xor(aList(i), bList(i) match {\n                case 0 =>\n                case 1 =>\n                val i = aList(i) xor (bList(i))\n                xor.put(i + 1, i)\n            })\n        }\n        \n        val result = xor.map(x=> (x._2, x._1)).filter(_._1 > 0).map(_._2).mkString\n        output.append(result)\n        return output.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpv4bows4h.scala:9:28 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maList\u001b[0m = a.split('')\n\u001b[31m\u001b[31m  |\u001b[0m                            ^\u001b[0m\n\u001b[31m  |\u001b[0m                            empty character literal\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpv4bows4h.scala:10:18 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbList\u001b[0m = b.split('')\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0m                  expression expected but \u001b[31m=\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpv4bows4h.scala:10:28 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbList\u001b[0m = b.split('')\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            empty character literal\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpv4bows4h.scala:11:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36moutput\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mStringBuilder\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m=\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv4bows4h.scala:10:8 -------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbList\u001b[0m = b.split('')\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Not found: 'val\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpv4bows4h.scala:11:8 -------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36moutput\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mStringBuilder\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Not found: 'val\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv4bows4h.scala:13:36 -----",
      "stdout": "",
      "timestamp": 1659978815
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val x = Array(a,b)\n        val y = Array.ofDim[Char](2)\n        x.zipWithIndex.map { case (z, i) =>\n            z.toCharArray.map(x => x(0) ^ x(1))\n        }.reduce(_++_).mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfnon7p_0.scala:12:35 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            z.toCharArray.map(\u001b[36mx\u001b[0m => x(\u001b[31m0\u001b[0m) ^ x(\u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   \u001b[33mparameter\u001b[0m \u001b[35mx\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpfnon7p_0.scala:12:47 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            z.toCharArray.map(\u001b[36mx\u001b[0m => x(\u001b[31m0\u001b[0m) ^ x(\u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n\u001b[31m\u001b[31m-- Error: /tmp/tmpfnon7p_0.scala:13:9 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        }.reduce(_++_).mkString\n\u001b[31m\u001b[31m   |\u001b[0m         ^\u001b[0m\n\u001b[31m   |\u001b[0m         No ClassTag available for Array[B]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m         where:    B is a type variable\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978815
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray = b.toCharArray\n        var res = \"\"\n        aArray.zip(bArray).foreach{ case (b,a) => res += (a ^ b) }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659978816
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // Using mutable HashMap in order to avoid using mutable states in loops\n        // The HashMap will contain the keys and the corresponding value will store \n        // the result\n        val hm = new mutable.HashMap[Char, Char]\n        for(c <- a) hm.put(c.toInt, c.toInt)\n        for(c <- b) hm(c) = hm(c) ^ c.toInt\n        // The values stored in the HashMap will be stored in an ordered array\n        val resultList = hm.values.toList\n        // We convert these values into string\n        resultList.map(c => c.toString.reverse).mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmplqb3qdzq.scala:12:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mhm\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mChar\u001b[0m, \u001b[35mChar\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978812
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val bina: List[String] = a.split(\"\").filter(c => c != \"0\").toList\n        val binb: List[String] = b.split(\"\").filter(c => c != \"0\").toList\n        bina.zipAll(binb, 0 , \"0\") map {\n        case (a, b, c) => \"1\" + ((a xor b) xor c)\n        } mkString \"\"\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7gr665bb.scala:12:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mcase\u001b[0m (a, b, c) => \u001b[31m\"1\"\u001b[0m + ((a xor b) xor c)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value xor is not a member of Any\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978816
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val res = a.toCharArray\n        val res2 = b.toCharArray\n        for (x<-0 until a.length by 2) {\n            res(x) ^ res2(x)\n        }\n        new String(res).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpx6muuqz2.scala:17)\n\tat Problem.main(tmpx6muuqz2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978817
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aStr : String = a;\n        val bStr : String = b;\n        // Write your code here\n        var retVal : String = null\n        var i = 1\n        var j = 1\n        while(i <= (aStr.length / 2)) {\n            while(j <= (bStr.length / 2)) {\n                if(aStr(i-1) == bStr(j-1)) {\n                    retVal += aStr(i)\n                    retVal += bStr(j)\n                    i++\n                    j++\n                } else if(aStr(i-1) != bStr(j-1)) {\n                    retVal += aStr(i)\n                    retVal += bStr(j)\n                    i++\n                }\n                j++\n            }\n            i++\n            j = 1\n        }\n        retVal\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpvaz8vwfe.scala:21:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                    j++\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpvaz8vwfe.scala:25:23 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                    i++\n\u001b[31m\u001b[31m   |\u001b[0m                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpvaz8vwfe.scala:27:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpvaz8vwfe.scala:30:14 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m            j = \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m              ^\u001b[0m\n\u001b[31m   |\u001b[0m              end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvaz8vwfe.scala:20:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                    i++\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value ++ is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvaz8vwfe.scala:29:13 ------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m            i++\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value ++ is not a member of Int\n6 errors found\n",
      "stdout": "",
      "timestamp": 1659978816
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        def xor(aStr : String, bStr : String): String = {\n            val aVals = aStr.split(\"\\\\W+\").map(_.toInt)\n            val bVals = bStr.split(\"\\\\W+\").map(_.toInt)\n            val resultVals = aVals.zip(bVals).map(x => if (x._1 ^ x._2) x._0 else 0)\n            return resultVals.map(_.toString.toChar).mkString(\"\")\n        }\n        xor(a, b)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqdatn71t.scala:12:59 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresultVals\u001b[0m = aVals.zip(bVals).map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x._1 ^ x._2) x._0 \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                           ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                       Found:    Int\n\u001b[31m   |\u001b[0m                                                       Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqdatn71t.scala:12:74 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresultVals\u001b[0m = aVals.zip(bVals).map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x._1 ^ x._2) x._0 \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                                        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             value _0 is not a member of (Int, Int) - did you mean x._1?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqdatn71t.scala:13:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mreturn\u001b[0m resultVals.map(_.toString.toChar).mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value toChar is not a member of String\n\u001b[31m\u001b[31m-- Error: /tmp/tmpqdatn71t.scala:13:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mreturn\u001b[0m resultVals.map(_.toString.toChar).mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                          No ClassTag available for B\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m                                          where:    B is a type variable\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659978817
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val x = a.toInt\n        val y = b.toInt\n        val xorResult = scala.util.Random.nextInt(256) match {\n            case x if x > y => 255\n            case x if x < y => 0\n            case _ => x + y\n        }\n        xorResult match {\n            case x if x > 0 => (a xor (b .& 0xFF)).toChar.toString\n            case x if x < 0 => ((a .& 0xFF) xor (b .& 0xFF)).toChar.toString\n            case _ => a.toChar.toString\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpyawr4tj2.scala:17:44 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mcase\u001b[0m x \u001b[33mif\u001b[0m x > \u001b[31m0\u001b[0m => (a xor (b .& \u001b[31m0xFF\u001b[0m)).toChar.toString\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 ')' expected, but integer literal found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpyawr4tj2.scala:18:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mcase\u001b[0m x \u001b[33mif\u001b[0m x < \u001b[31m0\u001b[0m => ((a .& \u001b[31m0xFF\u001b[0m) xor (b .& \u001b[31m0xFF\u001b[0m)).toChar.toString\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 ')' expected, but integer literal found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpyawr4tj2.scala:18:54 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mcase\u001b[0m x \u001b[33mif\u001b[0m x < \u001b[31m0\u001b[0m => ((a .& \u001b[31m0xFF\u001b[0m) xor (b .& \u001b[31m0xFF\u001b[0m)).toChar.toString\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 ')' expected, but integer literal found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyawr4tj2.scala:17:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mcase\u001b[0m x \u001b[33mif\u001b[0m x > \u001b[31m0\u001b[0m => (a xor (b .& \u001b[31m0xFF\u001b[0m)).toChar.toString\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value xor is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyawr4tj2.scala:17:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mcase\u001b[0m x \u001b[33mif\u001b[0m x > \u001b[31m0\u001b[0m => (a xor (b .& \u001b[31m0xFF\u001b[0m)).toChar.toString\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       value & is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyawr4tj2.scala:18:36 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mcase\u001b[0m x \u001b[33mif\u001b[0m x < \u001b[31m0\u001b[0m => ((a .&",
      "stdout": "",
      "timestamp": 1659978817
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val bit = scala.collection.mutable.StringBuilder()\n        for {\n            i <- 0\n            c <- \"010\"\n        } yield {\n            if (a(i + (bit.length / 2)) != \"1\") bit.append(\"0\")\n            if (b(i + (bit.length / 2)) != \"1\") bit.append(\"0\")\n            bit.append(\"1\") \n        }\n        if (bit.length == 1) bit.toString\n        else bit.take(bit.length - 1).mkString() + bit.last\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4nxdov5j.scala:11:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            i <- \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                 value flatMap is not a member of Int\n\u001b[31m\u001b[31m-- Error: /tmp/tmp4nxdov5j.scala:19:46 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33melse\u001b[0m bit.take(bit.length - \u001b[31m1\u001b[0m).mkString() + bit.last\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mmissing argument for parameter i of \u001b[33mmethod\u001b[0m \u001b[35mapply\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mStringOps\u001b[0m: (i: Int): Char\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978816
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val a0 = a(0).toInt\n        val a1 = a(1).toInt\n        val a2 = a2(1).toInt\n        val b0 = b(0).toInt\n        val b1 = b(1).toInt\n        val b2 = b(2).toInt\n        var res  = \"0000\"\n        val x = ((b0+b1+b2)&0x0000FF).toInt\n        val y = ((a0+a1+a2)&0x0000FF).toInt\n        val z = (x ^ y).toInt\n        res = res.substring(0, z) + Integer.toString(z)\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp4_sculou.scala:11:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ma2\u001b[0m = a2(\u001b[31m1\u001b[0m).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                 Recursive \u001b[33mvalue\u001b[0m \u001b[35ma2\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978813
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val a = a.toInt\n        val b = b.toInt\n        var res = a\n        var carry = 0\n        for (aDigit <- 0 to a.length - 1)\n            if ((aDigit & (1 << (a.length - aDigit - 1))) != 0)\n                carry = (carry + ((a(aDigit - 1) ^ b(aDigit))) / 2)\n            else\n                carry = 0\n            res = ((res + carry) % 2).toString\n        if (res.length == 1) res = \"0\" + res\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpst65yvy9.scala:9:16 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ma\u001b[0m = a.toInt\n\u001b[31m\u001b[31m  |\u001b[0m                ^\u001b[0m\n\u001b[31m  |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35ma\u001b[0m needs type\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpst65yvy9.scala:10:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mb\u001b[0m = b.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978813
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aMap = new mutable.HashMap[Int, Int]()\n        val bMap = new mutable.HashMap[Int, Int]()\n        a.map(x => aMap.update(x.toInt, aMap.getOrElse(x.toInt, 0)))\n        b.map(x => bMap.update(x.toInt, bMap.getOrElse(x.toInt, 0)))\n        var res = new Array[Int](a.size)\n        var idx = 0\n        while (idx < a.size) {\n            if (aMap(idx) == 0)\n                res(idx) = bMap(idx)\n            else res(idx) = aMap(idx) ^ bMap(idx)\n            idx += 1\n        }\n        new String(res)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp89sphsxi.scala:9:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp89sphsxi.scala:10:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp89sphsxi.scala:21:12 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mnew\u001b[0m \u001b[35mString\u001b[0m(res)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mconstructor\u001b[0m \u001b[35mString\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mString\u001b[0m with types\n\u001b[31m   |\u001b[0m (x$0: StringBuilder): String\n\u001b[31m   |\u001b[0m (x$0: StringBuffer): String\n\u001b[31m   |\u001b[0m (x$0: Array[Byte]): String\n\u001b[31m   |\u001b[0m (x$0: Array[Byte], x$1: Int, x$2: Int): String\n\u001b[31m   |\u001b[0m (x$0: Array[Byte], x$1: java.nio.charset.Charset): String\n\u001b[31m   |\u001b[0m (x$0: Array[Byte], x$1: String): String\n\u001b[31m   |\u001b[0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3: java.nio.charset.Charset): String\n\u001b[31m   |\u001b[0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3: String): String\n\u001b[31m   |\u001b[0m (x$0: Array[Byte], x$1: Int): String\n\u001b[31m   |\u001b[0m (x$0: Array[Byte], x$1: Int, x$2: Int, x$3: Int): String\n\u001b[31m   |\u001b[0m (x$0: Array[Int], x$1: Int, x$2: Int): String\n\u001b[31m   |\u001b[0m (x$0: Array[Char], x$1: Int, x$2: Int): String\n\u001b[31m   |\u001b[0m (x$0: Array[Char]): String\n\u001b[31m   |\u001b[0m (x$0: String): String\n\u001b[31m   |\u001b[0m (): String\n\u001b[31m   |\u001b[0mmatch arguments ((res : Array[Int]))\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978814
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var result = 0\n        for (i <- 0 until a.length)\n            for (j <- 0 until b.length)\n                result = result + ((Character.getNumericValue(b.charAt(j))) ^\n                        (Character.getNumericValue(a.charAt(i))))\n        return result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpl3ey4ndf.scala:17)\n\tat Problem.main(tmpl3ey4ndf.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978818
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val a = a.map(_.toInt)\n        val b = b.map(_.toInt)\n        val d = a.zip(b)\n        val z = d.map(x=>x(0) * x(1))\n        val e = z.map(x=>String.valueOf(x))\n        val f = e.map(x=>String.valueOf(x))\n        a.zip(b.toList).flatMap(x => f(x)).toList.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp3uru2un_.scala:9:16 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ma\u001b[0m = a.map(_.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m                ^\u001b[0m\n\u001b[31m  |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35ma\u001b[0m needs type\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp3uru2un_.scala:10:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mb\u001b[0m = b.map(_.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978813
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var xor = new StringBuilder\n        for (i <- a.indices) {\n            xor.append(a(i) ^ b(i))\n        }\n        xor.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659978818
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // Your code goes here\n        var firstInt = a.toInt\n        var secondInt = b.toInt\n        var result = \"\"\n        for (i<-0 until firstInt.length)\n            result+= (firstInt(i) != secondInt(i) ? \"1\" : \"0\")\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp218__dul.scala:13:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (i<-\u001b[31m0\u001b[0m until firstInt.length)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value length is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp218__dul.scala:14:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result+= (firstInt(i) != secondInt(i) ? \u001b[31m\"1\"\u001b[0m : \u001b[31m\"0\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp218__dul.scala:14:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result+= (firstInt(i) != secondInt(i) ? \u001b[31m\"1\"\u001b[0m : \u001b[31m\"0\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      \u001b[33mvariable\u001b[0m \u001b[35mfirstInt\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978818
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var result = \"\"\n        for (i <- 0 until a.length; j <- 1 until b.length) {\n            val x = a(i) - b(j)\n            if (x == 0 && i != a.length-1)\n                result = \"0\"\n            if (x == 1 && j != b.length-1)\n                result = \"1\"\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpgl0miqqu.scala:20)\n\tat Problem.main(tmpgl0miqqu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978819
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        def xor(a: String, a: String): String = {\n            if (a.length != b.length) {\n                throw new ArithmeticException(\"invalid input\")\n            }\n            var result = \"\"\n            for (i <- 0 until a.length) {\n                result += (a(i) xor b(i)).toString\n            }\n            result\n        }\n        xor(a, b)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmpob7ivgob.scala:9:27 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mdef\u001b[0m \u001b[36mxor\u001b[0m(\u001b[36ma\u001b[0m: \u001b[35mString\u001b[0m, \u001b[36ma\u001b[0m: \u001b[35mString\u001b[0m): \u001b[35mString\u001b[0m = {\n\u001b[31m\u001b[31m  |\u001b[0m                           ^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0ma is already defined as \u001b[33mparameter\u001b[0m \u001b[35ma\u001b[0m\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpob7ivgob.scala:15:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                result += (a(i) xor b(i)).toString\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpob7ivgob.scala:15:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                result += (a(i) xor b(i)).toString\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value xor is not a member of Char\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978818
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // Make a string containing each individual char from input strings\n        // and convert them to binary numbers as string\n        val aBinStr = (for (i <- a.toList) yield Integer.toBinaryString(i)).mkString(\"\") \n        val bBinStr = (for (i <- b.toList) yield Integer.toBinaryString(i)).mkString(\"\")\n        // Perform XOR on strings and return as binary strings\n        val res = aBinStr.zip(bBinStr).map(x => x._1 XOR x._2).toList.map(Integer.toBinaryString).mkString(\"\")\n        // Convert back to string and return results\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpqcng40jp.scala:14:53 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = aBinStr.zip(bBinStr).map(\u001b[36mx\u001b[0m => x._1 XOR x._2).toList.map(Integer.toBinaryString).mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       value XOR is not a member of Char\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978817
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      // Convert strings to bit strings\n      val a = bitStringToInts(a)\n      val b = bitStringToInts(b)\n      \n      // Perform bit XOR on all bit strings and convert to string.\n      val xorBits = zip(a, b).map(x => x._1 ^ x._2)\n      val bitStrings = xorBits.map(x => x.toString(2)).map(x => if (x == '1') x else ('0'))\n      val result = bitStrings.mkString(\"\")\n      result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp08x2y3af.scala:10:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36ma\u001b[0m = bitStringToInts(a)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Not found: bitStringToInts\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp08x2y3af.scala:10:30 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36ma\u001b[0m = bitStringToInts(a)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Recursive \u001b[33mvalue\u001b[0m \u001b[35ma\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp08x2y3af.scala:11:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mb\u001b[0m = bitStringToInts(b)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Not found: bitStringToInts\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp08x2y3af.scala:11:30 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mb\u001b[0m = bitStringToInts(b)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Recursive \u001b[33mvalue\u001b[0m \u001b[35mb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp08x2y3af.scala:14:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mxorBits\u001b[0m = zip(a, b).map(\u001b[36mx\u001b[0m => x._1 ^ x._2)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: zip\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659978814
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var res : String = b.size\n        val a = a.toIntArray\n        val b = b.toIntArray\n        val size = a.length\n        for (i <- 0 until size) {\n            res += (a(i) xor b(i))\n        }\n        return res.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp5ius9gmi.scala:11:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mb\u001b[0m = b.toIntArray\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp5ius9gmi.scala:10:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ma\u001b[0m = a.toIntArray\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35ma\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978819
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aLen = a.length\n        val bLen = b.length\n        val aChars = a.toCharArray\n        val bChars = b.toCharArray\n        val cArray = Array.ofDim[Int](aLen, bLen)\n        for ((i, aIdx) <- 0 until aLen, bIdx <- 0 until bLen)\n        cArray(aIdx, bIdx) = a(aIdx) xor b(bIdx)\n        new String(cArray)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp0wlt8xwy.scala:14:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mfor\u001b[0m ((i, aIdx) <- \u001b[31m0\u001b[0m until aLen, bIdx <- \u001b[31m0\u001b[0m until bLen)\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      ')' expected, but ',' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0wlt8xwy.scala:15:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        cArray(aIdx, bIdx) = a(aIdx) xor b(bIdx)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: bIdx\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0wlt8xwy.scala:15:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        cArray(aIdx, bIdx) = a(aIdx) xor b(bIdx)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    (aIdx : Any)\n\u001b[31m   |\u001b[0m                               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp0wlt8xwy.scala:15:43 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        cArray(aIdx, bIdx) = a(aIdx) xor b(bIdx)\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Not found: bIdx\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp0wlt8xwy.scala:15:15 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        cArray(aIdx, bIdx) = a(aIdx) xor b(bIdx)\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Found:    (aIdx : Any)\n\u001b[31m   |\u001b[0m               Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp0wlt8xwy.scala:16:12 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mnew\u001b[0m \u001b[35mString\u001b[0m(cAr",
      "stdout": "",
      "timestamp": 1659978823
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val a = scala.collection.immutable.BitSet.parse(a).toList\n        val b = scala.collection.immutable.BitSet.parse(b).toList\n        val r = new scala.collection.mutable.StringBuilder\n        for {\n            i <- a\n            j <- b\n        } r.append(i xor j)\n        r.result()\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7n48wf2u.scala:9:50 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ma\u001b[0m = scala.collection.immutable.BitSet.parse(a).toList\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m   value parse is not a member of object scala.collection.immutable.BitSet\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp7n48wf2u.scala:9:56 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ma\u001b[0m = scala.collection.immutable.BitSet.parse(a).toList\n\u001b[31m\u001b[31m  |\u001b[0m                                                        ^\u001b[0m\n\u001b[31m  |\u001b[0m                                              Recursive \u001b[33mvalue\u001b[0m \u001b[35ma\u001b[0m needs type\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7n48wf2u.scala:10:50 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mb\u001b[0m = scala.collection.immutable.BitSet.parse(b).toList\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m value parse is not a member of object scala.collection.immutable.BitSet\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp7n48wf2u.scala:10:56 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mb\u001b[0m = scala.collection.immutable.BitSet.parse(b).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            Recursive \u001b[33mvalue\u001b[0m \u001b[35mb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659978824
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // Write your code here\n        val a1 = a.toInt\n        val b1 = b.toInt\n        val result = (a1 ^ b1) + ((a1 & b1) > 0)\n        result + if (a1 & b1 > 0) \"1\" else \"0\"\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpvgasy22m.scala:13:17 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        result + \u001b[33mif\u001b[0m (a1 & b1 > \u001b[31m0\u001b[0m) \u001b[31m\"1\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"0\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^\u001b[0m\n\u001b[31m   |\u001b[0m                 expression expected but \u001b[31mif\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpvgasy22m.scala:12:31 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = (a1 ^ b1) + ((a1 & b1) > \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m None of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m+\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m  (x: Double): Double\n\u001b[31m   |\u001b[0m  (x: Float): Float\n\u001b[31m   |\u001b[0m  (x: Long): Long\n\u001b[31m   |\u001b[0m  (x: Int): Int\n\u001b[31m   |\u001b[0m  (x: Char): Int\n\u001b[31m   |\u001b[0m  (x: Short): Int\n\u001b[31m   |\u001b[0m  (x: Byte): Int\n\u001b[31m   |\u001b[0m  (x: String): String\n\u001b[31m   |\u001b[0m match arguments (Boolean)\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978821
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray\n        val bArray = b.toCharArray\n        var res = \"\"\n        for (i <- 0 until a.length)\n            res +=  a(i) ^ b(i) \n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659978825
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      var c = 0\n      for( i <- 0 until a.length ) {\n         if( a(0) XOR b(i) == a(0) ) c += 1\n      }\n      val str = if (c>0) b.take(c) else b\n      str + str.tail\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpj6uyxe1o.scala:11:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m         \u001b[33mif\u001b[0m( a(\u001b[31m0\u001b[0m) XOR b(i) == a(\u001b[31m0\u001b[0m) ) c += \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m             ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m             value XOR is not a member of Char\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978825
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var a1 = a.toIntArray\n        var b1 = b.toIntArray\n        var res = []\n        var i = a.length\n        var j = b.length\n        while (i > 0 || j > 0) {\n            if (i==0) res.append(a1.head)\n            else if (j==0) res.append(b1.head)\n            else {\n                if (a1.head^b1.head < 0) res.append(a1.head)\n                else res.append(b1.head)\n            }\n            i -= 1; j -= 1\n        }\n        return res.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpoyhu0w0p.scala:11:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mres\u001b[0m = []\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpoyhu0w0p.scala:12:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mi\u001b[0m = a.length\n\u001b[31m\u001b[31m   |\u001b[0m^^^\u001b[0m\n\u001b[31m   |\u001b[0m'=>' expected, but 'end of statement' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpoyhu0w0p.scala:9:19 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ma1\u001b[0m = a.toIntArray\n\u001b[31m\u001b[31m  |\u001b[0m                 ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                 value toIntArray is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpoyhu0w0p.scala:10:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mb1\u001b[0m = b.toIntArray\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value toIntArray is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpoyhu0w0p.scala:15:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mif\u001b[0m (i==\u001b[31m0\u001b[0m) res.append(a1.head)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToScala.list asScalaBuffer\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpoyhu0w0p.scala:16:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (j==\u001b[31m0\u001b[0m) res.append(b1.head)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue append is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0",
      "stdout": "",
      "timestamp": 1659978828
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var ans = \"\"\n        var i = 0\n        var j = 0\n        while(i < a.length) {\n            ans = ans + \"0\"\n            i += 2\n        }\n        while(j < b.length) {\n            ans = ans + \"1\"\n            j += 2\n        }\n        while(i < a.length) {\n            ans = ans + \"0\"\n            i += 2\n        }\n        while(j < b.length) {\n            ans = ans + \"1\"\n            j += 2\n        }\n        return ans\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp42kdt4ol.scala:31)\n\tat Problem.main(tmp42kdt4ol.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978826
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // Initialize final string\n        val finalString = new mutable.StringBuilder\n        // Iterate over characters in both inputs\n        for (a <- a) {\n            for (b <- b) {\n                // If character are different append them into final string\n                if (a != b)\n                    finalString.append(a ^ b)\n            }\n        }\n        return finalString.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmps1fob9mx.scala:10:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mfinalString\u001b[0m = \u001b[33mnew\u001b[0m mutable.StringBuilder\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978822
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        def xor(x : Int, y : Int) : Int = {\n            x xor y match {\n                case 0 => x\n                case _ => 0\n            }\n        }\n        val length = a.length\n        val resultLen = length * 2\n        val aArray = a.toList\n        val bArray = b.toList\n        val xorValue = new Array[Int](resultLen)\n        val buffer = new Array[Int](resultLen)\n        for (i<- 0 to length-1){\n            buffer[(i * 2)] = xor(aArray(i), bArray(i))\n        }\n        buffer.foreach(xorValue)\n        xorValue.map(x => x % 2).mkString.reverse.charAt(0)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpseltjn9x.scala:22:28 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            buffer[(\u001b[35mi\u001b[0m \u001b[35m*\u001b[0m \u001b[31m2\u001b[0m)] = xor(aArray(i), bArray(i))\n\u001b[31m\u001b[31m   |\u001b[0m                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                            end of statement expected but '=' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpseltjn9x.scala:10:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            x xor y \u001b[33mmatch\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value xor is not a member of Int\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpseltjn9x.scala:22:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            buffer[(\u001b[35mi\u001b[0m \u001b[35m*\u001b[0m \u001b[31m2\u001b[0m)] = xor(aArray(i), bArray(i))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: type *\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpseltjn9x.scala:25:56 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m        xorValue.map(\u001b[36mx\u001b[0m => x % \u001b[31m2\u001b[0m).mkString.reverse.charAt(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Char\n\u001b[31m   |\u001b[0m        Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659978827
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val res = a.zip(b).map {\n            case (aChar, bChar) => aChar ^ bChar\n        }.foldLeft(\"\") { (res, elem) => res + elem.toString }\n        res + \"0\"\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp438q3uwd.scala:15)\n\tat Problem.main(tmp438q3uwd.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978828
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val a = a.toInt * 2\n        val b = b.toInt * 2\n        (a XOR b) XOR a\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp0je2_0ry.scala:9:16 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ma\u001b[0m = a.toInt * \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m  |\u001b[0m                ^\u001b[0m\n\u001b[31m  |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35ma\u001b[0m needs type\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp0je2_0ry.scala:10:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mb\u001b[0m = b.toInt * \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978823
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aLen = a.length()\n        val bLen = b.length()\n        var aIndex = 0\n        var bIndex = 0\n        var xorResult = 0\n        while(true) {\n            xorResult = xorResult + (a.charAt(aIndex) xor b.charAt(bIndex))\n            if (aIndex == aLen-1) && bIndex == bLen-1) {\n                xorResult.toString\n            }\n            if (aIndex == aLen-1) { aIndex = 0 }\n            if (bIndex == bLen-1) { bIndex = 0 }\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpa6dz_ns6.scala:16:53 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mif\u001b[0m (aIndex == aLen-\u001b[31m1\u001b[0m) && bIndex == bLen-\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                             '}' expected, but ')' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpa6dz_ns6.scala:29:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m29 |\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0meof expected, but '}' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpa6dz_ns6.scala:15:54 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            xorResult = xorResult + (a.charAt(aIndex) xor b.charAt(bIndex))\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value xor is not a member of Char\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa6dz_ns6.scala:16:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mif\u001b[0m (aIndex == aLen-\u001b[31m1\u001b[0m) && bIndex == bLen-\u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Not found: &&\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpa6dz_ns6.scala:20:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            \u001b[33mif\u001b[0m (bIndex == bLen-\u001b[31m1\u001b[0m) { bIndex = \u001b[31m0\u001b[0m }\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    Unit\n\u001b[31m   |\u001b[0m            Required: String\n\u001b[31m   |\u001b[0m            Maybe you are missing an else part for the conditional?\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpa6dz_ns6.scala:24:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m    assert(stringXor((\u001b[31m\"111000\"\u001b[0m), (\u001b[31m\"101010\"\u001b[0m)).equals((\u001b[31m\"010010\"\u001b[0m)));\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^^^^\u001b",
      "stdout": "",
      "timestamp": 1659978827
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aNum = a.toInt :: Nil\n        val bNum = b.toInt :: Nil\n        var result : String = \"\"\n\n        var xorValue : Int = 0\n        var xorMask = 0\n        var xorSum = 0\n        for(z <- aNum) {\n            xorValue = z\n            for(h <- bNum) {\n                xorMask = h\n                xorSum = xorValue ^ xorMask\n                result += if(xorSum == 0) \"0\" else if(xorSum == 1) \"1\" else \"?\"\n                xorValue := xorValue >> 1\n                xorMask := xorMask >> 1\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpotase_qq.scala:21:26 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                result += \u001b[33mif\u001b[0m(xorSum == \u001b[31m0\u001b[0m) \u001b[31m\"0\"\u001b[0m \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m(xorSum == \u001b[31m1\u001b[0m) \u001b[31m\"1\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"?\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^\u001b[0m\n\u001b[31m   |\u001b[0m                          expression expected but \u001b[31mif\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpotase_qq.scala:22:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                xorValue := xorValue >> \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value := is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpotase_qq.scala:23:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                xorMask := xorMask >> \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value := is not a member of Int - did you mean Int.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978828
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val result = (a zip b) map { case (x, y) => x ^ y } map {\n            case 1 => \"1\"\n            case 0 => \"0\"\n            case _ => \"\"\n        }\n        result.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "OK",
      "stderr": "",
      "stdout": "",
      "timestamp": 1659978828
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val ba = a.toInt\n        val bb = b.toInt\n        val c = ba.xor(bb)\n        Integer.toBinaryString(c)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvyl989ro.scala:11:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mc\u001b[0m = ba.xor(bb)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value xor is not a member of Int\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978827
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // Convert input strings to an array of integers\n        var a = a.toIntArray\n        var b = b.toIntArray\n        var res = new Array[Int](b.length)\n        var carry = 0\n        // XOR each number in each array\n        for (i <- 0 until a.length) {\n            res(i) += a(i) XOR b(i) XOR carry\n            carry = res(i) mod 2\n        }\n        // Convert result array to string\n        res(0 until a.length).map(\"%02d\".format(_)).mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpcsy99u_v.scala:10:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ma\u001b[0m = a.toIntArray\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvariable\u001b[0m \u001b[35ma\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpcsy99u_v.scala:11:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mb\u001b[0m = b.toIntArray\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvariable\u001b[0m \u001b[35mb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpcsy99u_v.scala:17:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            carry = res(i) mod \u001b[31m2\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue mod is not a member of Int, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mThe following import might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.BigInt.int2bigInt\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpcsy99u_v.scala:20:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        res(\u001b[31m0\u001b[0m until a.length).map(\u001b[31m\"%02d\"\u001b[0m.format(_)).mkString\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    Range\n\u001b[31m   |\u001b[0m            Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659978830
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val arrayA = a.map(x => (x: Int)).toArray\n        val arrayB = b.map(x => (x: Int)).toArray\n        var result = \"\"\n        for (i <- 0 until arrayA.size) {\n            result = (result + arrayA(i) xor arrayB(i)).toString() + \" \"\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp11nj39s6.scala:13:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result = (result + arrayA(i) xor arrayB(i)).toString() + \u001b[31m\" \"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value xor is not a member of String\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978829
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      a.toCharArray.zip(b.toCharArray).map(c => Integer.parseInt(c._1^c._2)).mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp4i9qtpgg.scala:9:65 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m      a.toCharArray.zip(b.toCharArray).map(\u001b[36mc\u001b[0m => Integer.parseInt(c._1^c._2)).mkString\n\u001b[31m\u001b[31m  |\u001b[0m                                                                 ^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                                          Found:    Int\n\u001b[31m  |\u001b[0m                                                          Required: String\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978830
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var ret = \"\"\n        var carry = 0\n        for ((x, y) <- a.zip(b)) {\n            val bin = Integer.parseInt(x) + Integer.parseInt(y) + carry\n            val result = if(bin > 1) bin else bin - 2\n            carry = result / 2\n            ret = ret + Integer.toString(result)\n        }\n        if(!carry)\n            ret += \"0\"\n        ret\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpduuj48zh.scala:12:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = Integer.parseInt(x) + Integer.parseInt(y) + carry\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Found:    (x : Char)\n\u001b[31m   |\u001b[0m                                       Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpduuj48zh.scala:12:61 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mbin\u001b[0m = Integer.parseInt(x) + Integer.parseInt(y) + carry\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (y : Char)\n\u001b[31m   |\u001b[0m                                                    Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpduuj48zh.scala:17:11 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mif\u001b[0m(!carry)\n\u001b[31m\u001b[31m   |\u001b[0m           ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value unary_! is not a member of Int - did you mean Int.unary_+?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978830
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val listA = a.toIntArray.map(x => if (x == 1) 1 else 0)\n        val listB = b.toIntArray.map(x => if (x == 1) 1 else 0)\n        var result = \"\"\n        for (i <- 0 until listA.length) result += listA(i) XOR listB(i)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpca6oq2v3.scala:9:22 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlistA\u001b[0m = a.toIntArray.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m1\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m  |\u001b[0m                    ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                    value toIntArray is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpca6oq2v3.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mlistB\u001b[0m = b.toIntArray.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m1\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value toIntArray is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978830
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val mapA = (a :+ \"\").groupBy(x => x)\n        val mapB = (b :+ \"\").groupBy(x => x)\n        val mapC = mapA.intersect(mapB)\n        val mapD = mapC.map(x => (x._1._1, x._2.length)).toMap\n        val mapE = mapD.filter(_._2 > 1)\n        val mapF = mapE.map(x => (x._1, x._2.length))\n        val mapG = mapE.filter(x => x._2.length > 1)\n        val mapH = mapG.map(x => (x._1, x._2.length))\n        val mapI = mapH.filter(_._2 > 1)\n        val mapJ = mapI.map(x => (x._1, x._2.length))\n        val mapK = mapJ.filter(x => x._2 > 1)\n        val mapL = mapK.map(x => (x._1, x._2.length))\n        val mapM = mapL.filter(_._2 > 1)\n        val mapN = mapM.map(x => (x._1, x._2.length))\n        val mapO = mapN.filter(x => x._2.length > 1)\n        val mapP = mapO.map(x => (x._1, x._2.length))\n        val mapQ = mapP.filter(x => x._2 > 1)\n        val mapR = mapQ.map(x => (x._1, x._2.length))\n        val mapS = mapR.filter(_._2 > 1)\n        val mapT = mapS.map(x => (x._1, x._2.length))\n        val mapU = mapT.filter(x => x._2 > 1)\n        val mapV = mapU.map(x => (x._1, x._2.length))\n        val mapW = mapV.filter(_._2 > 1)\n        val mapX = mapW.map(x => (x._1, x._2.length))\n        val mapY = mapX.filter(x => x._2 > 1)\n        val mapZ = mapY.map(x => (x._1, x._2.length))\n        val mapAA = mapZ.filter(x => x._2 > 1)\n        val mapAB = mapAA.map(x => (x._1, x._2.length))\n        val mapAC = mapAB.filter(x => x._2 > 1)\n        val mapAD = mapAC.map(x => (x._1, x._2.length))\n        val mapAE = map\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbb7h6xoz.scala:11:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmapC\u001b[0m = mapA.intersect(mapB)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue intersect is not a member of Map[Matchable, IndexedSeq[Matchable]]\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpbb7h6xoz.scala:39:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m39 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmapAE\u001b[0m = map\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    Not found: map\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbb7h6xoz.scala:40:5 ---------------------\u001b[0m\u001b[0m\n\u001b[31m40 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m     ^\u001b[0m\n\u001b[31m   |\u001b[0m     Found:    Unit\n\u001b[31m   |\u001b[0m     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978830
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val a = Array(a.split(\"0\"))\n        val b = Array(b.split(\"0\"))\n        var ans = \"\"\n        for (i <- 0 until a.length) {\n            val temp = ans + a(i) XOR b(i)\n            ans = temp\n        }\n        ans\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpx_0o5cix.scala:9:22 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ma\u001b[0m = Array(a.split(\u001b[31m\"0\"\u001b[0m))\n\u001b[31m\u001b[31m  |\u001b[0m                      ^\u001b[0m\n\u001b[31m  |\u001b[0m                      Recursive \u001b[33mvalue\u001b[0m \u001b[35ma\u001b[0m needs type\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpx_0o5cix.scala:10:22 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mb\u001b[0m = Array(b.split(\u001b[31m\"0\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Recursive \u001b[33mvalue\u001b[0m \u001b[35mb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpx_0o5cix.scala:13:34 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mtemp\u001b[0m = ans + a(i) XOR b(i)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value XOR is not a member of String\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978831
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var xor = 0\n        var a = a.toCharArray\n        var b = b.toCharArray\n        a.zip(b).foreach(x => xor ^= x._1)\n        String.fromCharArray(xor.toList)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpdky922ml.scala:10:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ma\u001b[0m = a.toCharArray\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvariable\u001b[0m \u001b[35ma\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpdky922ml.scala:11:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mb\u001b[0m = b.toCharArray\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvariable\u001b[0m \u001b[35mb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdky922ml.scala:13:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        String.fromCharArray(xor.toList)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value fromCharArray is not a member of object String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpdky922ml.scala:13:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        String.fromCharArray(xor.toList)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           value toList is not a member of Int - did you mean Int.toInt?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659978831
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val set1 = a.toIntSet\n        val set2 = b.toIntSet\n        val result = new mutable.MutableSet[Int]()\n        var carry = 0\n        for (i <- set1 union set2) {\n            if ((i & carry) == 0) {\n                result += i\n            } else {\n                carry = 1\n            }\n        }\n        result.toString.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc8nhil5j.scala:9:21 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mset1\u001b[0m = a.toIntSet\n\u001b[31m\u001b[31m  |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                   value toIntSet is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpc8nhil5j.scala:10:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mset2\u001b[0m = b.toIntSet\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value toIntSet is not a member of String\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpc8nhil5j.scala:11:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.MutableSet[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978833
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val xor_map = new mutable.HashMap[String, String]()\n        a.zip(b).foreach { case (x, y) => \n            xor_map(x) = y\n        }\n        val result = xor_map.values.mkString\n        xor_map.clear\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5_x3iql8.scala:9:26 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mxor_map\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mString\u001b[0m, \u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                          Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978831
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val resultSet = mutable.Set.empty[Char]\n        for( c1 <- a ; c2 <- b ) {\n            if( c1 == c2 ) {\n                resultSet += c1\n            } else {\n                resultSet += c2\n            }\n        }\n        new String(resultSet.toSeq)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpqt5nsc9x.scala:9:24 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresultSet\u001b[0m = mutable.Set.empty[\u001b[35mChar\u001b[0m]\n\u001b[31m\u001b[31m  |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                        Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978832
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val length = Math.min(a.length, b.length)\n        val zeros = Array.ofDim[Int](length)\n        val ones = Array.ofDim[Int](length)\n        val aLen = a.length - 1\n        val bLen = b.length - 1\n        (0 until length).map { i => if (a(i) == b(i)) ones(i) = 1 else if (a(i) != b(i)) zeros(i) = 1 }\n        (0 until length).map { i => if (aLen == 0 && bLen > i) ones(i) = 1 else if (aLen > 0 && bLen == i) ones(i) = 1 }\n        (0 until length).map { i => if (aLen == 0 && bLen == i) ones(i) = 1 }\n        String.valueOf(ones.zip(zeros).map { case (a, b) => if (a) b else !b }.mkString(\"\"))\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpv0rp7kg0.scala:17:64 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        String.valueOf(ones.zip(zeros).map { \u001b[33mcase\u001b[0m (a, b) => \u001b[33mif\u001b[0m (a) b \u001b[33melse\u001b[0m !b }.mkString(\u001b[31m\"\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                     Found:    (a : Int)\n\u001b[31m   |\u001b[0m                                                     Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpv0rp7kg0.scala:17:74 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        String.valueOf(ones.zip(zeros).map { \u001b[33mcase\u001b[0m (a, b) => \u001b[33mif\u001b[0m (a) b \u001b[33melse\u001b[0m !b }.mkString(\u001b[31m\"\"\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                                                          ^^\u001b[0m\n\u001b[31m   |\u001b[0m          value unary_! is not a member of Int - did you mean b.unary_+?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978835
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      val xor_result : String = a.zip(b).map(tuple => tuple(0)).fold(\"\")((a, b) => a ^ b)\n      xor_result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5b_tvuhx.scala:9:85 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mxor_result\u001b[0m : \u001b[35mString\u001b[0m = a.zip(b).map(\u001b[36mtuple\u001b[0m => tuple(\u001b[31m0\u001b[0m)).fold(\u001b[31m\"\"\u001b[0m)((\u001b[36ma\u001b[0m, \u001b[36mb\u001b[0m) => a ^ b)\n\u001b[31m\u001b[31m  |\u001b[0m                                                                                   ^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                      value ^ is not a member of Matchable\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978835
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // Convert Strings to bit vectors\n        val aVector = convertToString(a)\n        val bVector = convertToString(b)\n        // Convert bit vectors to bit strings\n        val aBitString = bitString(aVector)\n        val bBitString = bitString(bVector)\n        // Perform bit-wise XOR\n        val result = aBitString Xor bBitString\n        // Convert result back to String\n        convertToString(result)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdjwj411y.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maVector\u001b[0m = convertToString(a)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: convertToString\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdjwj411y.scala:11:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbVector\u001b[0m = convertToString(b)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: convertToString\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdjwj411y.scala:13:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maBitString\u001b[0m = bitString(aVector)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: bitString\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdjwj411y.scala:14:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbBitString\u001b[0m = bitString(bVector)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: bitString\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpdjwj411y.scala:18:8 -------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        convertToString(result)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Not found: convertToString\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659978832
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      var res : String = \"\"\n      var xor = a.zip(b).foldLeft(0)(_ xor _)\n      var digit = xor.toString.reverse\n      while (xor > 0) {\n        res = (digit + \"0\") + res\n        xor = xor / 10\n      }\n      res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpf37beebf.scala:10:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m      \u001b[33mvar\u001b[0m \u001b[36mxor\u001b[0m = a.zip(b).foldLeft(\u001b[31m0\u001b[0m)(_ xor _)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value xor is not a member of Int\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978836
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val resultVal = a.toInt ^ b.toInt\n        result.appendCodePoint(resultVal.toChar)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpe_o8ebxc.scala:10:8 -------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        result.appendCodePoint(resultVal.toChar)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Not found: result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978833
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      val s1 = a.toInt\n      val s2 = b.toInt\n      var result = \"\"\n      if (s1 XOR s2 == 0)\n        result = a.toChar\n      else\n        result = a.toChar XOR b.toChar\n      result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_17eunbe.scala:12:13 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m      \u001b[33mif\u001b[0m (s1 XOR s2 == \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m          ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m          value XOR is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_17eunbe.scala:13:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        result = a.toChar\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value toChar is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_17eunbe.scala:15:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        result = a.toChar XOR b.toChar\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value toChar is not a member of String\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978838
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val bitA = new BitSet(a)\n        val bitB = new BitSet(b)\n        bitA.xor(bitB)\n        bitA.binary.toList.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp6nyxqxcn.scala:9:23 ------------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbitA\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mBitSet\u001b[0m(a)\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0mNone of the overloaded alternatives of \u001b[33mconstructor\u001b[0m \u001b[35mBitSet\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mBitSet\u001b[0m with types\n\u001b[31m  |\u001b[0m (): scala.collection.mutable.BitSet\n\u001b[31m  |\u001b[0m (initSize: Int): scala.collection.mutable.BitSet\n\u001b[31m  |\u001b[0m (elems: Array[Long]): scala.collection.mutable.BitSet\n\u001b[31m  |\u001b[0mmatch arguments ((a : String))\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmp6nyxqxcn.scala:10:23 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbitB\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mBitSet\u001b[0m(b)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mNone of the overloaded alternatives of \u001b[33mconstructor\u001b[0m \u001b[35mBitSet\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mBitSet\u001b[0m with types\n\u001b[31m   |\u001b[0m (): scala.collection.mutable.BitSet\n\u001b[31m   |\u001b[0m (initSize: Int): scala.collection.mutable.BitSet\n\u001b[31m   |\u001b[0m (elems: Array[Long]): scala.collection.mutable.BitSet\n\u001b[31m   |\u001b[0mmatch arguments ((b : String))\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978835
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val set1 = Set(a)\n        val set2 = Set(b)\n        val set3 = Set(a.length min b.length)\n        var res = \"0\"\n        for (x <- set1 diff set2 diff set3) {\n            res = res + x\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpaax7fsck.scala:13:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (x <- set1 diff set2 diff set3) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m           Found:    \u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mset3\u001b[0m\u001b[1m\u001b[31m \u001b[0m\u001b[1m\u001b[31m:\u001b[0m\u001b[1m\u001b[31m \u001b[0mscala.collection.\u001b[1m\u001b[31mmutable\u001b[0m\u001b[1m\u001b[31m.\u001b[0m\u001b[1m\u001b[31mSet\u001b[0m[\u001b[1m\u001b[31mInt\u001b[0m]\u001b[1m\u001b[31m)\u001b[0m\n\u001b[31m   |\u001b[0m           Required: scala.collection.Set\u001b[1m\u001b[32m\u00b2\u001b[0m[\u001b[1m\u001b[32mString\u001b[0m]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m           where:    Set  is a trait in \u001b[33mpackage\u001b[0m \u001b[35mscala.collection.mutable\u001b[0m\n\u001b[31m   |\u001b[0m                     Set\u00b2 is a trait in \u001b[33mpackage\u001b[0m \u001b[35mscala.collection\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978838
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var xor = a.map(c => c XOR b(0))\n        xor = mutable.Stack(xor)\n        xor = mutable.Queue(xor)\n        var res = \"\"\n        while(xor.nonEmpty) {\n            val element = xor.dequeue\n            res = res + element.charAt(0).toString + element.substring(1)\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpubfjxj4o.scala:9:31 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mxor\u001b[0m = a.map(\u001b[36mc\u001b[0m => c XOR b(\u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             value XOR is not a member of Char\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpubfjxj4o.scala:10:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        xor = mutable.Stack(xor)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpubfjxj4o.scala:11:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        xor = mutable.Queue(xor)\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978838
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // Return empty string if either string contains no 1s\n        if(a contains \"0\") && (b contains \"0\")\n            return \"\"\n        val result = new StringBuilder(\"\")\n        val bArray = b.toCharArray\n        val aArray = a.toCharArray\n        val length = a.length\n        // Iterate over the string by converting each character and storing it to result\n        for( i <- 0 until length){\n            if( (aArray(i) XOR bArray(i))==1 )\n                result.append(aArray(i))\n            else\n                result.append(0)\n        }\n        return result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpkqqxptmx.scala:10:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mif\u001b[0m(a contains \u001b[31m\"0\"\u001b[0m) && (b contains \u001b[31m\"0\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Not found: &&\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpkqqxptmx.scala:18:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mif\u001b[0m( (aArray(i) XOR bArray(i))==\u001b[31m1\u001b[0m )\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value XOR is not a member of Char\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978838
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        if (b.length > a.length) b else a\n        val aSet = a.toSet\n        val bSet = b.toSet\n        if (b.length < a.length) {\n            val set1 = aSet\n            val set2 = bSet\n            val result = mutable.ListBuffer.empty[String]\n            for (x <- aSet) {\n                if (set2.contains(x)) {\n                    result += \"1\"\n                } else {\n                    result += \"0\"\n                }\n            }\n            result.toList.toString\n        } else {\n            val set1 = bSet\n            val set2 = aSet\n            val result = mutable.ListBuffer.empty[String]\n            for (x <- bSet) {\n                if (set1.contains(x)) {\n                    result += \"1\"\n                } else {\n                    result += \"0\"\n                }\n            }\n            result.toList.toString\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp49381p__.scala:15:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp49381p__.scala:27:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978836
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val ba = b.toCharArray.dropRight(1)\n        val bb = a.toCharArray.dropRight(1)\n        var res = \"\"\n        for (i <- 0 until ba.length) res += ((ba(i) XOR bb(i)) XOR 1).toChar\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt_fjqbhr.scala:12:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until ba.length) res += ((ba(i) XOR bb(i)) XOR \u001b[31m1\u001b[0m).toChar\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt_fjqbhr.scala:12:52 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until ba.length) res += ((ba(i) XOR bb(i)) XOR \u001b[31m1\u001b[0m).toChar\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       value XOR is not a member of Char\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978841
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var x = a.toInt\n        var y = b.toInt\n        var result = \"\"\n        while (x >= y) {\n            x -= y\n            result += x\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpd2r9hsgm.scala:19)\n\tat Problem.main(tmpd2r9hsgm.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978840
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      val aBitArray = a.toBitArray.map(x => x != 0)\n      val bBitArray = b.toBitArray.map(x => x != 0)\n      val xorBitArray = aBitArray Xor bBitArray\n      xorBitArray.map(_ => 0 -> 1).foldLeft(0)((acc, x) => acc + x)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi9guez47.scala:9:24 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36maBitArray\u001b[0m = a.toBitArray.map(\u001b[36mx\u001b[0m => x != \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m  |\u001b[0m                      ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                      value toBitArray is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi9guez47.scala:10:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mbBitArray\u001b[0m = b.toBitArray.map(\u001b[36mx\u001b[0m => x != \u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value toBitArray is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978841
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aBits = a.toInt.toString.reverse.grouped(2).map(_.toChar).reverse\n        val bBits = b.toInt.toString.reverse.grouped(2).map(_.toChar).reverse\n        val aAndB = a.toInt + b.toInt\n        val resultBits = Array.fill(aAndB.toInt){0}\n        for ( i <- 0 until aAndB.toInt ) {\n            resultBits += ((aBits getOrElse 0)(i) xor (bBits getOrElse 0)(i))\n        }\n        return resultBits.map(_.toChar).mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvirz3692.scala:9:62 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maBits\u001b[0m = a.toInt.toString.reverse.grouped(\u001b[31m2\u001b[0m).map(_.toChar).reverse\n\u001b[31m\u001b[31m  |\u001b[0m                                                            ^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                    value toChar is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvirz3692.scala:10:62 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbBits\u001b[0m = b.toInt.toString.reverse.grouped(\u001b[31m2\u001b[0m).map(_.toChar).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                                                            ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value toChar is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvirz3692.scala:14:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            resultBits += ((aBits getOrElse \u001b[31m0\u001b[0m)(i) xor (bBits getOrElse \u001b[31m0\u001b[0m)(i))\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of Array[Int] - did you mean resultBits.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978841
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        def xor(x: Int, y: Int) : Int = if (x == '1') y else x\n        val x = a.toInt\n        val y = b.toInt\n        (0 until Math.pow(2, (2 * Math.ceil(Math.log(x) / Math.log(2))))).foldLeft((0 until Math.pow(2, (2 * Math.ceil(Math.log(y) / Math.log(2)))))) { case ((acc: Int, acc1: Int), v) => ((acc << 1) | xor((x & (1 << (2 * v))), y)) }.toInt.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqnxm3z02.scala:12:25 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        (\u001b[31m0\u001b[0m until Math.pow(\u001b[31m2\u001b[0m, (\u001b[31m2\u001b[0m * Math.ceil(Math.log(x) / Math.log(\u001b[31m2\u001b[0m))))).foldLeft((\u001b[31m0\u001b[0m until Math.pow(\u001b[31m2\u001b[0m, (\u001b[31m2\u001b[0m * Math.ceil(Math.log(y) / Math.log(\u001b[31m2\u001b[0m)))))) { \u001b[33mcase\u001b[0m ((acc: \u001b[35mInt\u001b[0m, acc1: \u001b[35mInt\u001b[0m), v) => ((acc << \u001b[31m1\u001b[0m) | xor((x & (\u001b[31m1\u001b[0m << (\u001b[31m2\u001b[0m * v))), y)) }.toInt.toString\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Found:    Double\n\u001b[31m   |\u001b[0m                 Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqnxm3z02.scala:12:100 -------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        (\u001b[31m0\u001b[0m until Math.pow(\u001b[31m2\u001b[0m, (\u001b[31m2\u001b[0m * Math.ceil(Math.log(x) / Math.log(\u001b[31m2\u001b[0m))))).foldLeft((\u001b[31m0\u001b[0m until Math.pow(\u001b[31m2\u001b[0m, (\u001b[31m2\u001b[0m * Math.ceil(Math.log(y) / Math.log(\u001b[31m2\u001b[0m)))))) { \u001b[33mcase\u001b[0m ((acc: \u001b[35mInt\u001b[0m, acc1: \u001b[35mInt\u001b[0m), v) => ((acc << \u001b[31m1\u001b[0m) | xor((x & (\u001b[31m1\u001b[0m << (\u001b[31m2\u001b[0m * v))), y)) }.toInt.toString\n\u001b[31m\u001b[31m   |\u001b[0m                                                                                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                        Found:    Double\n\u001b[31m   |\u001b[0m                                                        Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpqnxm3z02.scala:12:188 -------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        (\u001b[31m0\u001b[0m until Math.pow(\u001b[31m2\u001b[0m, (\u001b[31m2\u001b[0m * Math.ceil(Math.log(x) / Math.log(\u001b[31m2\u001b[0m))))).foldLeft((\u001b[31m0\u001b[0m until Math.pow(\u001b[31m2\u001b[0m, (\u001b[31m2\u001b[0m * Math.ceil(Math.log(y) / Math.log(\u001b[31m2\u001b[0m)))))) { \u001b[33mcase\u001b[0m ((acc: \u001b[35mInt\u001b[0m, acc1",
      "stdout": "",
      "timestamp": 1659978842
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        if(a.length != b.length){\n            throw new Exception(\"String lengths are not the same\")\n        }\n        val result = new mutable.MutableString(\"\")\n        for (i <- 0 until a.length)\n            result += a(i) XOR b(i)\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpn3kujhl_.scala:12:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.MutableString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978838
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val ans = mutable.Buffer.empty[Char]\n        var i = 0\n        while ( i < a.length ) {\n            ans += (a(i) XOR b(i))\n            i += 1\n        }\n        ans.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptmv26196.scala:9:18 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mans\u001b[0m = mutable.Buffer.empty[\u001b[35mChar\u001b[0m]\n\u001b[31m\u001b[31m  |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                  Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978837
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      val xor = a.zip(b).filter(_._1 == \"0\" && _._2 == \"0\").map(_._2).reduce(_ + _)\n      xor match {\n        case x if x < 2 => a\n        case x if x < 4 => b\n        case x => \"\"\n      }\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbx2eq3tf.scala:9:34 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mxor\u001b[0m = a.zip(b).filter(_._1 == \u001b[31m\"0\"\u001b[0m && _._2 == \u001b[31m\"0\"\u001b[0m).map(_._2).reduce(_ + _)\n\u001b[31m\u001b[31m  |\u001b[0m                                ^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                value _1 is not a member of Char\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbx2eq3tf.scala:9:77 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mxor\u001b[0m = a.zip(b).filter(_._1 == \u001b[31m\"0\"\u001b[0m && _._2 == \u001b[31m\"0\"\u001b[0m).map(_._2).reduce(_ + _)\n\u001b[31m\u001b[31m  |\u001b[0m                                                                             ^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                                            Found:    Int\n\u001b[31m  |\u001b[0m                                                            Required: Char\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978842
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val xorResult = mutable.StringBuilder()\n        a\n            .zip(b)\n            .foreach { case (x, y) => if (x == y) xorResult += x else xorResult += y}\n        xorResult.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgzchlkg9.scala:9:24 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mxorResult\u001b[0m = mutable.StringBuilder()\n\u001b[31m\u001b[31m  |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                        Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978839
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // This can be done without using StringBuffer by reversing input strings\n        val aReversed : String = a.reverse\n        val bReversed : String = b.reverse\n        val aIndex : Int = aReversed.length\n        val bIndex : Int = bReversed.length\n\n        val aMap : Map[Char, Int] = a.reverse.toCharArray.map(x=> x -> 1).toMap\n        val bMap : Map[Char, Int] = b.reverse.toCharArray.map(x=> x -> 1).toMap\n\n        // xor the two strings character by character and add the results\n        var res = \"\"\n        for (i <- 0 until aIndex) res = res + aMap(aReversed(i)) + bMap(bReversed(i))\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpaqpdng2l.scala:15:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maMap\u001b[0m : \u001b[35mMap\u001b[0m[\u001b[35mChar\u001b[0m, \u001b[35mInt\u001b[0m] = a.reverse.toCharArray.map(\u001b[36mx\u001b[0m=> x -> \u001b[31m1\u001b[0m).toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    Map[Char, Int]\n\u001b[31m   |\u001b[0m                             Required: \u001b[1m\u001b[32mcollection\u001b[0m\u001b[1m\u001b[32m.\u001b[0m\u001b[1m\u001b[32mmutable\u001b[0m\u001b[1m\u001b[32m.\u001b[0mMap[Char, Int]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpaqpdng2l.scala:16:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbMap\u001b[0m : \u001b[35mMap\u001b[0m[\u001b[35mChar\u001b[0m, \u001b[35mInt\u001b[0m] = b.reverse.toCharArray.map(\u001b[36mx\u001b[0m=> x -> \u001b[31m1\u001b[0m).toMap\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                             Found:    Map[Char, Int]\n\u001b[31m   |\u001b[0m                             Required: \u001b[1m\u001b[32mcollection\u001b[0m\u001b[1m\u001b[32m.\u001b[0m\u001b[1m\u001b[32mmutable\u001b[0m\u001b[1m\u001b[32m.\u001b[0mMap[Char, Int]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978844
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var a : Array[Char] = a.toCharArray.sortWith(_ > _) // reverse the order of chars\n        var b : Array[Char] = b.toCharArray.sortWith(_ > _)\n\n        var acc : Array[Char] = Array.zeros[Char](25)\n\n        for (i <- 0 to 25) acc(i) = a(i)\n\n        // we iterate only through elements in the same positions\n        for (i <- 0 to 25) {\n            // we iterate only through elements in the same positions\n            for (j <- 0 to 25) {\n                // if we encounter a 0, we do not have to look anywhere else for the next one\n                if( b(i) != '0' && ( acc(i) ==  0) ) \n                    acc(i) ^= b(j)\n                // if we encounter a 1, we do not have to look anywhere else for the next one\n                if( a(i) != '1' && acc(i) ==  1 ) \n                    acc(i) ^= a(j)\n            }\n        }\n\n        // iterate through the array and transform the results\n        val sb = new StringBuilder\n        for (i <- 0 to 25) sb.append(i%2 + '0' + acc(i).toString)\n        sb.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmposbg2uyk.scala:9:32 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36ma\u001b[0m : \u001b[35mArray\u001b[0m[\u001b[35mChar\u001b[0m] = a.toCharArray.sortWith(_ > _) \u001b[34m// reverse the order of chars\u001b[0m\n\u001b[31m\u001b[31m  |\u001b[0m                              ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                          value toCharArray is not a member of Array[Char]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmposbg2uyk.scala:10:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mb\u001b[0m : \u001b[35mArray\u001b[0m[\u001b[35mChar\u001b[0m] = b.toCharArray.sortWith(_ > _)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value toCharArray is not a member of Array[Char]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmposbg2uyk.scala:12:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36macc\u001b[0m : \u001b[35mArray\u001b[0m[\u001b[35mChar\u001b[0m] = Array.zeros[\u001b[35mChar\u001b[0m](\u001b[31m25\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m  value zeros is not a member of object Array - did you mean Array.from?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmposbg2uyk.scala:22:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                    acc(i) ^= b(j)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value ^= is not a member of Char - did you mean Char.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmposbg2uyk.scala:25:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                    acc(i) ^= a(j)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value ^= is not a member of Char - did you mean Char.!=?\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659978845
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val zeros = Array.fill(b.length)(0)\n        val ones = Array.fill(a.length)(1)\n        val zerosAndOnes = ArrayBuffer.empty[Int]\n        val xorResult = Array.fill(b.length)(0)\n        for (bIndex <- 0 to b.length - 1) {\n            if (b(bIndex) == 0) {\n                for (a <- 0 to a.length - 1) {\n                    if (a(a) == 0) {\n                        zerosAndOnes += 0\n                    } else if (a(a) == 1) {\n                        zerosAndOnes += 1\n                    }\n                }\n            }\n        }\n        var carry = 0\n        for (a <- 0 to a.length - 1) {\n            var currentXorResult = carry + zerosAndOnes(a).toInt\n            carry = 0\n            for (i<- 0 to b.length - 1) {\n                val bit = if (b(i) == 0) 1 else 0\n                currentXorResult += (currentXorResult * bit)\n                carry = if (currentXorResult > 1) 1 else 0\n            }\n            xorResult += currentXorResult\n        }\n        for (i <- 0 to xorResult.length - 1) {\n            if (xorResult(i) < 0) xorResult(i) = xorResult(i) + 1\n        }\n        xorResult.map(String.valueOf(_)).mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp1tj38o3z.scala:16:24 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                    \u001b[33mif\u001b[0m (a(a) == \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                        \u001b[33mparameter\u001b[0m \u001b[35ma\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp1tj38o3z.scala:18:31 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                    } \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m (a(a) == \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               \u001b[33mparameter\u001b[0m \u001b[35ma\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp1tj38o3z.scala:33:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m33 |\u001b[0m            xorResult += currentXorResult\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value += is not a member of Array[Int] - did you mean xorResult.!=?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978844
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // Initialise the return string as empty\n        var ret = \"\"\n        // Iterate over characters in the strings\n        for(a <- a.toCharArray) {\n            for(i <- 1 to b.length()) {\n                // Check if the character is a zero and only a zero\n                if(a(i) == '0') {\n                    // If the character in the string a matches the character in string b\n                    // then XOR the two characters.\n                    ret += a(i) XOR b(i) \n                }\n            }\n        }\n        // Return the return string\n        ret\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfizy683x.scala:15:19 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                \u001b[33mif\u001b[0m(a(i) == \u001b[31m'0'\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                   \u001b[33mparameter\u001b[0m \u001b[35ma\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfizy683x.scala:18:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                    ret += a(i) XOR b(i) \n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpfizy683x.scala:18:27 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                    ret += a(i) XOR b(i) \n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           \u001b[33mparameter\u001b[0m \u001b[35ma\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978845
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      var result = \"\"\n      var bitCount = 2\n      while ( bitCount < maxBitCount(a) + maxBitCount(b) ) {\n        result += xorChars(a, bitCount)\n        result += xorChars(b, bitCount)\n        bitCount *= 2\n      }\n      return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpic4yu376.scala:11:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m      \u001b[33mwhile\u001b[0m ( bitCount < maxBitCount(a) + maxBitCount(b) ) {\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: maxBitCount\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpic4yu376.scala:12:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        result += xorChars(a, bitCount)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpic4yu376.scala:12:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        result += xorChars(a, bitCount)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: xorChars\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpic4yu376.scala:13:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        result += xorChars(b, bitCount)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value += is not a member of String - did you mean String.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpic4yu376.scala:13:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        result += xorChars(b, bitCount)\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: xorChars\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659978846
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aMap = a.map(c => c.toInt).mkString(\"\") + \"\"\n        val bMap = b.map(c => c.toInt).mkString(\"\") + \"\"\n        aMap.length.zip(\n            0 to a.length-1 by -1 zip bMap.length toList\n        ).foreach {\n            case (from, to) =>\n                val c = aMap(from) xor bMap(to)\n                aMap(from) = c.toChar\n                bMap(to) = c.toChar\n        }\n        a.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpm1o_skze.scala:12:56 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[31m0\u001b[0m to a.length-\u001b[31m1\u001b[0m by -\u001b[31m1\u001b[0m zip bMap.length toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                        ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m')'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpm1o_skze.scala:11:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        aMap.length.zip(\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value zip is not a member of Int\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpm1o_skze.scala:12:38 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[31m0\u001b[0m to a.length-\u001b[31m1\u001b[0m by -\u001b[31m1\u001b[0m zip bMap.length toList\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      Found:    Int\n\u001b[31m   |\u001b[0m                                      Required: IterableOnce[Any]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978848
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val xor = a.map(x => if (x == \"1\") \"0\" else \"1\").XOR(b.map(x => if (x == \"1\") \"0\" else \"1\"))\n        xor.map(x => if (x == \"0\") \"0\" else \"1\").mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp6w8r68ww.scala:9:33 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mxor\u001b[0m = a.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m\"1\"\u001b[0m) \u001b[31m\"0\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"1\"\u001b[0m).XOR(b.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m\"1\"\u001b[0m) \u001b[31m\"0\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"1\"\u001b[0m))\n\u001b[31m\u001b[31m  |\u001b[0m                                 ^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m          Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmp6w8r68ww.scala:9:76 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mxor\u001b[0m = a.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m\"1\"\u001b[0m) \u001b[31m\"0\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"1\"\u001b[0m).XOR(b.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m\"1\"\u001b[0m) \u001b[31m\"0\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"1\"\u001b[0m))\n\u001b[31m\u001b[31m  |\u001b[0m                                                                            ^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m          Values of types Char and String cannot be compared with == or !=\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978847
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val result = new mutable.ArrayBuilder[Char]\n        var carry = 0\n        for (i <- a zip b) {\n            val res = i.fold(0)(_ ^ (_ + carry))\n            carry = res >> 8\n            if (carry != 0)\n                result.add(carry & 255)\n        }\n        result.result()\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjlb53yqt.scala:9:25 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayBuilder[\u001b[35mChar\u001b[0m]\n\u001b[31m\u001b[31m  |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                         Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjlb53yqt.scala:12:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = i.fold(\u001b[31m0\u001b[0m)(_ ^ (_ + carry))\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m       value fold is not a member of (Char, Char) - did you mean i.head?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978847
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      val numA = a.map(_.toInt)\n      val numB = b.map(_.toInt)\n      val xors = numA zip numB\n      xors.foldLeft(0)((acc, element) => (acc ^ element))\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpaoouv8l7.scala:12:46 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m      xors.foldLeft(\u001b[31m0\u001b[0m)((\u001b[36macc\u001b[0m, \u001b[36melement\u001b[0m) => (acc ^ element))\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m None of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m^\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m  (x: Long): Long\n\u001b[31m   |\u001b[0m  (x: Int): Int\n\u001b[31m   |\u001b[0m  (x: Char): Int\n\u001b[31m   |\u001b[0m  (x: Short): Int\n\u001b[31m   |\u001b[0m  (x: Byte): Int\n\u001b[31m   |\u001b[0m match arguments ((element : (Int, Int)))\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978845
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val a = a.toInt\n        val b = b.toInt\n        var result = a.toString.toInt\n        for(c in b) result ^= c.toInt\n        result .toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpi8jrw9_e.scala:12:20 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m(c in b) result ^= c.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    '<-' expected, but identifier found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpi8jrw9_e.scala:14:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    '<-' expected, but '}' found\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpi8jrw9_e.scala:9:16 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ma\u001b[0m = a.toInt\n\u001b[31m\u001b[31m  |\u001b[0m                ^\u001b[0m\n\u001b[31m  |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35ma\u001b[0m needs type\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpi8jrw9_e.scala:10:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mb\u001b[0m = b.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpi8jrw9_e.scala:12:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m(c in b) result ^= c.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue withFilter is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversi",
      "stdout": "",
      "timestamp": 1659978848
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var c = a.toInt\n        var d = b.toInt\n        var result = 0\n        while(c != 0){\n            result += (c & d).toInt\n            c >>= 1\n            d >>= 1\n        }\n        val bits = scala.math.pow(2, result.length).toInt\n        var result = new Array[Byte](bits)\n        var k = result.length - 1\n        var bit = 0\n        while(k >= 0){\n            bit = result & (1 << (k - 1))\n            result &= ~bit\n            result |= (bit.toInt << k)\n            k = k - 1\n        }\n        return scala.util.Hex.encodeHexString(result)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E161] Naming Error: /tmp/tmp599o8_hx.scala:18:12 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArray\u001b[0m[\u001b[35mByte\u001b[0m](bits)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mresult is already defined as \u001b[33mvariable\u001b[0m \u001b[35mresult\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mNote that overloaded methods must all be defined in the same group of toplevel definitions\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp599o8_hx.scala:17:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbits\u001b[0m = scala.math.pow(\u001b[31m2\u001b[0m, result.length).toInt\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value length is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp599o8_hx.scala:19:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mk\u001b[0m = result.length - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value length is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp599o8_hx.scala:27:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m        \u001b[33mreturn\u001b[0m scala.util.Hex.encodeHexString(result)\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               value Hex is not a member of util\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659978850
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val setA : Set[Char] = a.toCharArray\n        val setB : Set[Char] = b.toCharArray\n        var result = \"0\"\n        for (i <- setA until (setA.last+1))\n        {\n            val c = setA(i)\n            result += c xor setB(i)\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6_0zzukf.scala:9:31 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msetA\u001b[0m : \u001b[35mSet\u001b[0m[\u001b[35mChar\u001b[0m] = a.toCharArray\n\u001b[31m\u001b[31m  |\u001b[0m                               ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                               Found:    Array[Char]\n\u001b[31m  |\u001b[0m                               Required: collection.mutable.Set[Char]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6_0zzukf.scala:10:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msetB\u001b[0m : \u001b[35mSet\u001b[0m[\u001b[35mChar\u001b[0m] = b.toCharArray\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    Array[Char]\n\u001b[31m   |\u001b[0m                               Required: collection.mutable.Set[Char]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6_0zzukf.scala:12:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- setA until (setA.last+\u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue until is not a member of collection.mutable.Set[Char] - did you mean setA.unzip?\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978851
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      var sum = 0\n      val aList = a.toUpperCase.map(_.toInt)\n      val bList = b.toUpperCase.map(_.toInt)\n      val aLen = aList.length\n      val bLen = bList.length\n      aList.foreach {\n        x => bList.foreach {\n          y => sum += x^y\n        }\n      }\n      aList.zip(List(aLen-1).toList).map {\n        case (xs, y) => sum.toString + xs + '0' + y\n      }.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp8v6s4gle.scala:24)\n\tat Problem.main(tmp8v6s4gle.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978853
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        def sum(x: Int, y: Int) : Int = x xor y\n        var sumX = 0\n        var sumY = 0\n        for(i <- 0 until a.length) {\n            sumX = sumX + a(i) XOR sumY\n            sumY = sumY + b(i) XOR sumX\n        }\n        val result = sumX XOR sumY\n        val str = new String(Array(\"0\", \"1\", \"x\", \"y\").toCharArray, \"UTF-8\")\n        str take (result.length) map { x => x XOR result.toString } mkString \"\"\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6kc2dpn_.scala:9:42 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mdef\u001b[0m \u001b[36msum\u001b[0m(\u001b[36mx\u001b[0m: \u001b[35mInt\u001b[0m, \u001b[36my\u001b[0m: \u001b[35mInt\u001b[0m) : \u001b[35mInt\u001b[0m = x xor y\n\u001b[31m\u001b[31m  |\u001b[0m                                        ^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                        value xor is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6kc2dpn_.scala:13:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            sumX = sumX + a(i) XOR sumY\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value XOR is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6kc2dpn_.scala:14:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            sumY = sumY + b(i) XOR sumX\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value XOR is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6kc2dpn_.scala:16:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = sumX XOR sumY\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value XOR is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6kc2dpn_.scala:17:55 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mstr\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mString\u001b[0m(Array(\u001b[31m\"0\"\u001b[0m, \u001b[31m\"1\"\u001b[0m, \u001b[31m\"x\"\u001b[0m, \u001b[31m\"y\"\u001b[0m).toCharArray, \u001b[31m\"UTF-8\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value toCharArray is not a member of Array[String]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6kc2dpn_.scala:18:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        str take (result.length) map { \u001b[36mx\u001b[0m => x XOR result.toString } mkString \u001b[31m\"\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       value XOR is not a member of Char\n6 errors found\n",
      "stdout": "",
      "timestamp": 1659978852
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // A & B are represented as bit vectors.\n        // Bit vectors are represented by a list of (index, value)\n        val aBitVector = a.toIntVector\n        val bBitVector = b.toIntVector\n        val aBitVectorLength = a.length()\n        val bBitVectorLength = b.length()\n        val xorBitVector = new ListBuffer[Int]()\n        var xorLength = 0\n\n        // Iterate over both bit vectors.\n        for( i <- 0 until aBitVectorLength ) {\n            if( aBitVector(i) == 0 && bBitVector(i) == 1 ) {\n                xorBitVector += xorLength\n                xorLength += aBitVectorLength\n            }\n        }\n        xorLength += bBitVectorLength\n\n        // If both bit vectors are empty or different length,\n        // result vector is empty.\n        if( xorBitVector.length == 0 || xorBitVector.length != xorLength ) {\n            return \"\"\n        }\n\n        // Iterate over both bit vectors.\n        for( i <- 0 until xorBitVector.length ) {\n            if( aBitVector(i) == 0 && bBitVector(i) == 1 ) {\n                xorBitVector(i) = xorBitVector(i).toInt * 2 - 1\n            }\n        }\n\n        // Convert to bits to string.\n        val bitString = String.valueOf(xorBitVector)\n        bitString.toIntVector\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp22a0a7u_.scala:11:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maBitVector\u001b[0m = a.toIntVector\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value toIntVector is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp22a0a7u_.scala:12:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbBitVector\u001b[0m = b.toIntVector\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value toIntVector is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp22a0a7u_.scala:42:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m42 |\u001b[0m        bitString.toIntVector\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value toIntVector is not a member of String\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978851
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // Convert string representation of binary number to a mutable list of\n        // integers\n        def str2ints(s : String) : List[Int] = {\n            s.toInt.grouped(2).map{case i => (i shr 1) + (i >>> 1)}.toList\n        }\n        // Convert string representation of decimal number to a mutable list of\n        // integers\n        def str2intd(s : String) : List[Int] = {\n            s.toInt.grouped(5).map{case i => (i shr 1) + (i >>> 1)}.toList\n        }\n        // Convert string representation of a ternary number to a\n        // list of integers\n        def str2intt(s : String) : List[Int] = {\n            s.toInt.grouped(3).map{case i => (i shr 1) + (i >>> 1)}.toList\n        }\n\n        // Parse string representation of a binary number into an array\n        // of integers\n        def bin2ints(s : String) : List[Int] = {\n            s.grouped(2).map{case i => (i shr 1) + (i >>> 1)}.toList\n        }\n        // Parse string representation of a decimal number into an array\n        // of integers\n        def dec2ints(s : String) : List[Int] = {\n            s.grouped(5).map{case i => (i shr 1) + (i >>> 1)}.toList\n        }\n        // Parse string representation of a ternary number into an array\n        // of integers\n        def tnt2ints(s : String) : List[Int] = {\n            s.grouped(3).map{case i => (i shr 1) + (i >>> 1)}.toList\n        }\n\n        // Parse string representation of a binary number into a binary\n        // representation of the number\n        def bin2bin(s : String) : String = {\n            val ints = bin2ints(s)\n            var binstr = \"\"\n            for((i, c) <- ints zip ints.drop(1)){\n                val b = bin(i.toBinaryString)\n                if(c != 0 && c != 1){\n                    binstr = (c * (b.getBinaryString.length)) + binstr\n                } else {\n                    binstr = c + binstr\n                }\n            }\n            binstr\n        }\n        // Parse string representation of a decimal number into a decimal\n        // representation of the number\n        def dec2dec(s : String) : String = {\n            val ints = dec2ints(s)\n            var decstr = \"\"\n            for((i, c) <- ints zip ints.drop(1)){\n                val b = dec(i.toBinaryString)\n                if(c != 0 && c != 1){\n                    decstr = (c * (b.getBinaryString.length)) + \n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmptgtsv2ve.scala:64:63 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m64 |\u001b[0m                    decstr = (c * (b.getBinaryString.length)) + \n\u001b[31m\u001b[31m   |\u001b[0m                                                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmptgtsv2ve.scala:73:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m73 |\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m^\u001b[0m\n\u001b[31m   |\u001b[0m'}' expected, but eof found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptgtsv2ve.scala:12:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            s.toInt.grouped(\u001b[31m2\u001b[0m).map{\u001b[33mcase\u001b[0m i => (i shr \u001b[31m1\u001b[0m) + (i >>> \u001b[31m1\u001b[0m)}.toList\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value grouped is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptgtsv2ve.scala:17:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            s.toInt.grouped(\u001b[31m5\u001b[0m).map{\u001b[33mcase\u001b[0m i => (i shr \u001b[31m1\u001b[0m) + (i >>> \u001b[31m1\u001b[0m)}.toList\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value grouped is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptgtsv2ve.scala:22:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m            s.toInt.grouped(\u001b[31m3\u001b[0m).map{\u001b[33mcase\u001b[0m i => (i shr \u001b[31m1\u001b[0m) + (i >>> \u001b[31m1\u001b[0m)}.toList\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value grouped is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptgtsv2ve.scala:28:42 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m            s.grouped(\u001b[31m2\u001b[0m).map{\u001b[33mcase\u001b[0m i => (i shr \u001b[31m1\u001b[0m) + (i >>> \u001b[31m1\u001b[0m)}.toList\n\u001b[31m\u001b[31m   |\u001b[0m                                        ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value shr is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmptg",
      "stdout": "",
      "timestamp": 1659978853
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var sum : Int = 0\n        var resultString : String = \"\"\n        for (i <- a ; j <- b) {\n            sum += j.toInt\n        }\n        for (i <- a ; j <- b) {\n            if (sum % 2 == 0) {\n                sum -= i.toInt\n            } else {\n                sum += i.toInt\n            }\n            resultString += if (sum == 0) \"0\" + j.toString else j.toString\n            sum += 0\n        }\n        return resultString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmps6m7jz57.scala:20:28 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            resultString += \u001b[33mif\u001b[0m (sum == \u001b[31m0\u001b[0m) \u001b[31m\"0\"\u001b[0m + j.toString \u001b[33melse\u001b[0m j.toString\n\u001b[31m\u001b[31m   |\u001b[0m                            ^^\u001b[0m\n\u001b[31m   |\u001b[0m                            expression expected but \u001b[31mif\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978847
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // Store the result\n        var result : String = \"\"\n\n        // Iterate over characters in strings\n        for {\n            a <- a\n            b <- b\n        } yield {\n            // Get binary representation of current character\n            val current = Integer.valueOf(a).asBinary\n            val current2 = Integer.valueOf(b).asBinary\n\n            // Get result after XOR\n            result = current XOR current2\n            result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnuqzkk36.scala:18:45 ------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mcurrent\u001b[0m = Integer.valueOf(a).asBinary\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          value asBinary is not a member of Integer\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnuqzkk36.scala:19:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mcurrent2\u001b[0m = Integer.valueOf(b).asBinary\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           value asBinary is not a member of Integer\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978853
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val listA = a\n        val listB = b\n        val length = listA.size\n        val result = mutable.ListBuffer.empty[String]\n        for(i <- 0 until length) {\n            val xOr = listA(i) ^ listB(i)\n            result += (xOr.toChar)\n        }\n        result.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp73yqmwkv.scala:12:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ListBuffer.empty[\u001b[35mString\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978850
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var result : String = \"\"\n        var i = 0\n        var j = 0\n        val x0 = a(i)\n        val x1 = b(i)\n        while (i < a.length) {\n            var x0 = x0\n            var x1 = x1\n            while (j < b.length) {\n                var x0 = x0 ^ b(j)\n                var x1 = x1 ^ a(i)\n                j++\n                i += 1\n            }\n            result = result + x0\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmph87i5mh8.scala:15:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mx0\u001b[0m = x0\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Recursive \u001b[33mvariable\u001b[0m \u001b[35mx0\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmph87i5mh8.scala:16:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mx1\u001b[0m = x1\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Recursive \u001b[33mvariable\u001b[0m \u001b[35mx1\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmph87i5mh8.scala:18:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                \u001b[33mvar\u001b[0m \u001b[36mx0\u001b[0m = x0 ^ b(j)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvariable\u001b[0m \u001b[35mx0\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmph87i5mh8.scala:19:25 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                \u001b[33mvar\u001b[0m \u001b[36mx1\u001b[0m = x1 ^ a(i)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                         Recursive \u001b[33mvariable\u001b[0m \u001b[35mx1\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmph87i5mh8.scala:20:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                j++\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value ++ is not a member of Int\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659978852
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aArray = a.toCharArray.map(c => if (c == '1') '0' else '1')\n        val bArray = b.toCharArray.map(c => if (c == '1') '0' else '1')\n        val resultArray = new Array[Char](b.length)\n        aArray.zip(\n            bArray\n        ).filter(\n            (x:Char, y:Char) => x == '0' && y == '0'\n        ).foreach { \n            (x, y) => resultArray(x.toInt) = (y.toInt) XOR (x.toInt)\n        }\n        return new String(resultArray).reverse\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpbav4x0kw.scala:17:55 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            (\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => resultArray(x.toInt) = (y.toInt) XOR (x.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                                             ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value XOR is not a member of Int\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978855
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aList = a.toList.reverse.map(_.toInt)\n        val bList = b.toList.reverse.map(_.toInt)\n        val xor = a.zip(b).foldLeft(0){\n            case (acc, (x, y)) => acc xor x xor y\n        }\n        xor.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnostbsh9.scala:12:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mcase\u001b[0m (acc, (x, y)) => acc xor x xor y\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  value xor is not a member of Int\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978854
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var result = \"\"\n        for (x <- a ; y <- b) { result += if(x == y) \"1\" else \"0\"  }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpbd699yeg.scala:10:42 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mfor\u001b[0m (x <- a ; y <- b) { result += \u001b[33mif\u001b[0m(x == y) \u001b[31m\"1\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"0\"\u001b[0m  }\n\u001b[31m\u001b[31m   |\u001b[0m                                          ^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        expression expected but \u001b[31mif\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978851
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val xor = a.zip(b).map { x => x._1 xor x._2 }\n        val zeros = new Array[Char](xor.length)\n        zeros.fill('0')\n        val result = xor.foldLeft(zeros) { (x, y) => x xor y }\n        String.fromCharArray(result.take(xor.length).toArray)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5v_gght1.scala:9:43 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mxor\u001b[0m = a.zip(b).map { \u001b[36mx\u001b[0m => x._1 xor x._2 }\n\u001b[31m\u001b[31m  |\u001b[0m                                      ^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                      value xor is not a member of Char\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5v_gght1.scala:11:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        zeros.fill(\u001b[31m'0'\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value fill is not a member of Array[Char]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5v_gght1.scala:12:55 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = xor.foldLeft(zeros) { (\u001b[36mx\u001b[0m, \u001b[36my\u001b[0m) => x xor y }\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                value xor is not a member of Array[Char]\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp5v_gght1.scala:13:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        String.fromCharArray(result.take(xor.length).toArray)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        value fromCharArray is not a member of object String\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659978857
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        def xor(aStr : String, bStr : String) : String = {\n            var str1 = List(aStr)\n            var str2 = List(bStr)\n            var result = (str1 zip str2) map { case (x, y) => (x xor y) } mkString(\"\")\n            return result\n        }\n        result = xor(a.toList, b.toList)\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp8d9hpytt.scala:12:65 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = (str1 zip str2) map { \u001b[33mcase\u001b[0m (x, y) => (x xor y) } mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                               ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value xor is not a member of String\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8d9hpytt.scala:15:8 -------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        result = xor(a.toList, b.toList)\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Not found: result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8d9hpytt.scala:15:23 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        result = xor(a.toList, b.toList)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    List[Char]\n\u001b[31m   |\u001b[0m                     Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp8d9hpytt.scala:15:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        result = xor(a.toList, b.toList)\n\u001b[31m\u001b[31m   |\u001b[0m                               ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    List[Char]\n\u001b[31m   |\u001b[0m                               Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8d9hpytt.scala:16:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mreturn\u001b[0m result\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Not found: result\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659978858
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val a = a.toList\n        val b = b.toList\n        val aLen = a.length\n        val bLen = b.length\n        val res = new ListBuffer[String]()\n        // If one of the inputs is an empty string, then just return the other\n        // The caller must handle this case\n        if (aLen == 0 || bLen == 0) {\n            res(aLen + bLen)\n            return\n        }\n        // Check each character\n        for (i <- 0 until aLen) {\n            for (j <- 0 until bLen) {\n                // If character i of string is 1 and the character j of string b is 0\n                if ((a.charAt(i) == '1') && (b.charAt(j) == '0')) {\n                    res += '0'\n                } else if ((a.charAt(i) == '0') && (b.charAt(j) == '1')) {\n                    res += '1'\n                }\n            }\n        }\n        // Return the string built so far\n        res.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp74c44rlk.scala:9:16 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ma\u001b[0m = a.toList\n\u001b[31m\u001b[31m  |\u001b[0m                ^\u001b[0m\n\u001b[31m  |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35ma\u001b[0m needs type\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp74c44rlk.scala:10:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mb\u001b[0m = b.toList\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp74c44rlk.scala:18:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m            \u001b[33mreturn\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    Unit\n\u001b[31m   |\u001b[0m            Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp74c44rlk.scala:25:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                    res += \u001b[31m'0'\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (\u001b[31m'0'\u001b[0m : Char)\n\u001b[31m   |\u001b[0m                           Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp74c44rlk.scala:27:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                    res += \u001b[31m'1'\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (\u001b[31m'1'\u001b[0m : Char)\n\u001b[31m   |\u001b[0m                           Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659978857
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var result : String = \"\"\n        for (x  <- a; y <- b; y != 0) {\n            var xor = x\n            xor = Integer.bitwiseXor(xor, y)\n            xor = Integer.toHexString(xor)\n            result = xor + result\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpwxg951_a.scala:10:36 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mfor\u001b[0m (x  <- a; y <- b; y != \u001b[31m0\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                    '<-' expected, but ')' found\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978853
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var res = \"\"\n        for (v <- List(a, b)) {\n            val lv = v.toLong\n            val lv_reverse = lv >>> 1\n            val bin = lv_reverse.toBinaryString\n            res = res + bin\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpw4he9w3c.scala:19)\n\tat Problem.main(tmpw4he9w3c.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978859
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var x = 0\n        var result: String = null\n        for(c1 <- a.iterator){\n            for(c2 <- b.iterator){\n                if(c1 == '0' && c2 == '0'){\n                    result = \"0\"\n                }\n                else if(c1 == '0' && c2 == '1'){\n                    result = \"1\"\n                }\n                else if(c1 == '1' && c2 == '0'){\n                    result = \"1\"\n                }\n                else if(c1 == '1' && c2 == '1'){\n                    result = \"0\"\n                }\n                x ^= (c1 ^ c2)\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp1jms79up.scala:31)\n\tat Problem.main(tmp1jms79up.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978859
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aBytes = a.split(\"\").toArray\n        val bBytes = b.split(\"\").toArray\n\n        val result = new mutable.StringBuilder()\n        for( i <- 0 until aBytes.length ) {\n            if( aBytes(i) != bBytes(i) ) {\n                result ++= aBytes(i)\n            }\n        }\n        return result.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp5i0ea321.scala:12:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.StringBuilder()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978856
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var xor = scala.collection.mutable.ListBuffer.empty[String]\n        for(i <- 0 until a.length) xor.append(a(i) xor b(i))\n        xor.toList.reverse.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_zxgzhwt.scala:10:51 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mfor\u001b[0m(i <- \u001b[31m0\u001b[0m until a.length) xor.append(a(i) xor b(i))\n\u001b[31m\u001b[31m   |\u001b[0m                                              ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       value xor is not a member of Char\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978858
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // Write your code here\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp25jgtyf7.scala:8:53 ---------------------\u001b[0m\u001b[0m\n\u001b[31m 8 |\u001b[0m    \u001b[33mdef\u001b[0m \u001b[36mstringXor\u001b[0m(\u001b[36ma\u001b[0m : \u001b[35mString\u001b[0m, \u001b[36mb\u001b[0m : \u001b[35mString\u001b[0m) : \u001b[35mString\u001b[0m = {\n\u001b[31m\u001b[31m   |\u001b[0m                                                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                     Found:    Unit\n\u001b[31m   |\u001b[0m                                                     Required: String\n\u001b[31m 9 |\u001b[0m        \u001b[34m// Write your code here\u001b[0m\n\u001b[31m10 |\u001b[0m    }\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978858
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val xor = a.foldLeft(b.tail.foldLeft(\"\")(_ + _)) { (s, c) => s ^ c }\n        val res = (a ^ (b foldLeft xor) ^ (xor)).toChar\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpceviu1be.scala:9:71 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mxor\u001b[0m = a.foldLeft(b.tail.foldLeft(\u001b[31m\"\"\u001b[0m)(_ + _)) { (\u001b[36ms\u001b[0m, \u001b[36mc\u001b[0m) => s ^ c }\n\u001b[31m\u001b[31m  |\u001b[0m                                                                     ^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                         value ^ is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpceviu1be.scala:10:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = (a ^ (b foldLeft xor) ^ (xor)).toChar\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value ^ is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978859
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val zeros = scala.collection.mutable.BitSet(a.length)\n        val ones = scala.collection.mutable.BitSet(a.length)\n        var res = \"\"\n        for (i <- 0 until a.length) {\n            val iChar = a(i).toInt\n            val jChar = b(i).toInt\n            if (iChar == jChar) {\n                if (iChar == 0) {\n                    zeros(i) = 1\n                } else if (iChar == 1) {\n                    ones(i) = 1\n                }\n            } else if (iChar == 0) {\n                zeros(i) = 1\n            } else if (iChar == 1) {\n                ones(i) = 1\n            }\n        }\n        // Handle the case where the two strings have a different length\n        if (zeros.length != b.length) {\n            return \"\"\n        }\n        for (i <- 0 until a.length) {\n            if (zeros(i) && ones(i)) {\n                res +=  a(i).toChar\n            }\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphb448sbq.scala:17:31 --------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                    zeros(i) = \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                               ^\u001b[0m\n\u001b[31m   |\u001b[0m                               Found:    (\u001b[31m1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                               Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphb448sbq.scala:19:30 --------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                    ones(i) = \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                              ^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    (\u001b[31m1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                              Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphb448sbq.scala:22:27 --------------------\u001b[0m\u001b[0m\n\u001b[31m22 |\u001b[0m                zeros(i) = \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Found:    (\u001b[31m1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                           Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmphb448sbq.scala:24:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                ones(i) = \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                          ^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (\u001b[31m1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                          Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphb448sbq.scala:28:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m28 |\u001b[0m        \u001b[33mif\u001b[0m (zeros.length != b.length) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m         value length is not a member of scala.collection.mutable.BitSet\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659978861
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // To store XOR result\n        val xor = scala.collection.mutable.Buffer[String]()\n        // To store number of 1s found so far\n        val numberOfOnesSoFar = 0\n        // To store number of 0s found so far\n        val numberOfZerosSoFar = 0\n        for (i <- 0 to a.length - b.length) {\n            val num = a(i) XOR b(i)\n            x match {\n                case \"0\" =>\n                    // Update number of 1s found so far\n                    numberOfOnesSoFar += 1 // Add 1 to number of 1s found so far\n                    xor += num.toString\n                case \"1\" =>\n                    // Update number of 0s found so far\n                    numberOfZerosSoFar += 1 // Add 1 to number of 0s found so far\n                    xor += num.toString\n            }\n        }\n        xor.reverse.head + (numberOfOnesSoFar - numberOfZerosSoFar)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3q63tfbv.scala:16:27 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mnum\u001b[0m = a(i) XOR b(i)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value XOR is not a member of Char\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3q63tfbv.scala:17:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            x \u001b[33mmatch\u001b[0m {\n\u001b[31m\u001b[31m   |\u001b[0m            ^\u001b[0m\n\u001b[31m   |\u001b[0m            Not found: x\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3q63tfbv.scala:20:38 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                    numberOfOnesSoFar += \u001b[31m1\u001b[0m \u001b[34m// Add 1 to number of 1s found so far\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m    value += is not a member of Int - did you mean numberOfOnesSoFar.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3q63tfbv.scala:24:39 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                    numberOfZerosSoFar += \u001b[31m1\u001b[0m \u001b[34m// Add 1 to number of 0s found so far\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m   value += is not a member of Int - did you mean numberOfZerosSoFar.!=?\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659978863
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val xorVal = (0 until a.length)\n            .map{\n                if(a(it) == '1') 1\n                else 0\n            }\n            .foldLeft((0,0)){\n                case((acc1, acc2),i) => (acc1 xor acc2 , xorVal(i))\n            }\n            .foldLeft((a,b)){\n                case((acc, xor), i) => (acc.substring(0, i-1) + xor.toString + acc.substring(i), xor)\n            }\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp6_i_zkkl.scala:11:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m                \u001b[33mif\u001b[0m(a(it) == \u001b[31m'1'\u001b[0m) \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: it\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6_i_zkkl.scala:11:33 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m                \u001b[33mif\u001b[0m(a(it) == \u001b[31m'1'\u001b[0m) \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Found:    (\u001b[31m1\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                                 Required: Int => Any\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp6_i_zkkl.scala:12:21 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m                \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     Found:    (\u001b[31m0\u001b[0m : Int)\n\u001b[31m   |\u001b[0m                     Required: Int => Any\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp6_i_zkkl.scala:15:46 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                \u001b[33mcase\u001b[0m((acc1, acc2),i) => (acc1 xor acc2 , xorVal(i))\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                        value xor is not a member of Int\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp6_i_zkkl.scala:15:57 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m                \u001b[33mcase\u001b[0m((acc1, acc2),i) => (acc1 xor acc2 , xorVal(i))\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Recursive \u001b[33mvalue\u001b[0m \u001b[35mxorVal\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007",
      "stdout": "",
      "timestamp": 1659978863
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aChars = a.toCharArray\n        val bChars = b.toCharArray\n        val xorBits = collection.mutable.ArrayBuffer.empty[Int]\n        for (i <- 0 until aChars.size) {\n            xorBits(i) = aChars(i).xor(bChars(i))\n        }\n        xorBits.toString.toUpperCase(Locale.ROOT)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpejri5xgx.scala:13:35 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            xorBits(i) = aChars(i).xor(bChars(i))\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value xor is not a member of Char\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpejri5xgx.scala:15:37 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        xorBits.toString.toUpperCase(Locale.ROOT)\n\u001b[31m\u001b[31m   |\u001b[0m                                     ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     Not found: Locale\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978862
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val binA = new mutable.MutableList[Int]()\n        var binB = new mutable.MutableList[Int]()\n        for (i <- a.toInt until a.length.toInt) {\n            binA.append(i)\n        }\n        for (i <- b.toInt until b.length.toInt) {\n            binB.append(i)\n        }\n\n        // Perform binary XOR on both lists to get one final binary list\n        // of 1s and 0s.\n        binB.reverse.foreach { binA.append(_) }\n        binA.reverse.foreach { binB.append(_) }\n        // Convert binary list back to binary string\n        binB.reverse.foldLeft((new StringBuilder()).+){ (sb, i) => sb.append(i).append(if (i % 2 == 0) \"1\" else \"0\") }.reverse.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgw9993r6.scala:9:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinA\u001b[0m = \u001b[33mnew\u001b[0m mutable.MutableList[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgw9993r6.scala:10:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mbinB\u001b[0m = \u001b[33mnew\u001b[0m mutable.MutableList[\u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978859
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var result = a\n        for (x <- 0 until a.length) {\n            for (y <- 0 until b.length) {\n                result =\n                    if (a(x, y) XOR (b(x, y))) result(x, y) else \"0\"\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1u299oz9.scala:13:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                    \u001b[33mif\u001b[0m (a(x, y) XOR (b(x, y))) result(x, y) \u001b[33melse\u001b[0m \u001b[31m\"0\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    (Int, Int)\n\u001b[31m   |\u001b[0m                          Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1u299oz9.scala:13:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                    \u001b[33mif\u001b[0m (a(x, y) XOR (b(x, y))) result(x, y) \u001b[33melse\u001b[0m \u001b[31m\"0\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Found:    (Int, Int)\n\u001b[31m   |\u001b[0m                                       Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp1u299oz9.scala:13:54 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                    \u001b[33mif\u001b[0m (a(x, y) XOR (b(x, y))) result(x, y) \u001b[33melse\u001b[0m \u001b[31m\"0\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                                      ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                    Found:    (Int, Int)\n\u001b[31m   |\u001b[0m                                                    Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978864
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aSet = new ArraySet[Int](a.toInt)\n        val bSet = new ArraySet[Int](b.toInt)\n        val c = new mutable.ArrayBuffer(a.length)\n        var i\n        for (i = 0; i < a.length; i ++) {\n            if (aSet.contains(i) && bSet.contains(i))\n                c(i) = a(i) xor b(i)\n            else\n                c(i) = a[i]\n        }\n        c.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9yk9bbdd.scala:13:0 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (i = \u001b[31m0\u001b[0m; i < a.length; i ++) {\n\u001b[31m\u001b[31m   |\u001b[0m^^^\u001b[0m\n\u001b[31m   |\u001b[0m'=' expected, but 'end of statement' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9yk9bbdd.scala:13:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (i = \u001b[31m0\u001b[0m; i < a.length; i ++) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp9yk9bbdd.scala:13:32 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (i = \u001b[31m0\u001b[0m; i < a.length; i ++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                ^\u001b[0m\n\u001b[31m   |\u001b[0m                                '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp9yk9bbdd.scala:13:38 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mfor\u001b[0m (i = \u001b[31m0\u001b[0m; i < a.length; i ++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                                      pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9yk9bbdd.scala:9:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maSet\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArraySet\u001b[0m[\u001b[35mInt\u001b[0m](a.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m                       ^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                       Not found: type ArraySet\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp9yk9bbdd.scala:10:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbSet\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mArraySet\u001b[0m[\u001b[35mInt\u001b[0m](b.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       Not found: type ArraySet\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Foun",
      "stdout": "",
      "timestamp": 1659978864
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        def binary(a : String, len : Int) : String = {\n            var ret = \"\"\n            for(i <- 0 until len) {\n                ret += a(i) match {\n                    case '0' => \"0\"\n                    case '1' => \"1\"\n                    case _ => throw new java.lang.NumberFormatException(\"Only 0s and 1s are allowed\")\n                }\n            }\n            return ret\n        }\n        var xor = \"\"\n        for(i <- 0 until a.length) {\n            xor += b(i) match {\n                case '0' => xor(xor.length, b.length, \"0\")\n                case '1' => xor(xor.length, b.length, \"1\")\n                case _ => throw new java.lang.NumberFormatException(\"Only 0s and 1s are allowed\")\n            }\n        }\n        xor(xor.length, a.length, \"0\")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpbm3x3nr2.scala:13:25 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                    \u001b[33mcase\u001b[0m \u001b[31m'0'\u001b[0m => \u001b[31m\"0\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Values of types Char and Unit cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpbm3x3nr2.scala:14:25 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m                    \u001b[33mcase\u001b[0m \u001b[31m'1'\u001b[0m => \u001b[31m\"1\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Values of types Char and Unit cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpbm3x3nr2.scala:23:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m'0'\u001b[0m => xor(xor.length, b.length, \u001b[31m\"0\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Values of types Char and Unit cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbm3x3nr2.scala:23:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m'0'\u001b[0m => xor(xor.length, b.length, \u001b[31m\"0\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                Found:    (Int, Int, String)\n\u001b[31m   |\u001b[0m                                Required: Int\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpbm3x3nr2.scala:24:21 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m'1'\u001b[0m => xor(xor.length, b.length, \u001b[31m\"1\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^\u001b[0m\n\u001b[31m   |\u001b[0m          Values of types Char and Unit cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpbm3x3nr2.scala:24:32 --------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m'1'\u001b[0m => xor(xor.length, b.length, \u001b[31m\"1\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                ^^^^^^^^^^^^^^^",
      "stdout": "",
      "timestamp": 1659978864
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aList = a.toCharArray.map(_ - 48).toList\n        val bList = b.toCharArray.map(_ - 48).toList\n        val result = new StringBuilder(\"\")\n        var c = 0\n        var d = 0\n        while (c < aList.size || d < bList.size) {\n            if (c < aList.size) {\n                val aChar = aList(c)\n                val bChar = bList(d)\n                result += (if (aChar != bChar) '1' else '0')\n                c += 1\n            } else if (d < bList.size) {\n                val aChar = aList(c)\n                val bChar = bList(d+1)\n                result += (if (aChar != bChar) '1' else '0')\n                d += 1\n            } else {\n                result += (if (aList(c) != bList(d)) '1' else '0')\n                c += 1\n                d += 1\n            }\n        }\n        return result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.IndexOutOfBoundsException: 6\n\tat scala.collection.LinearSeqOps.apply(LinearSeq.scala:117)\n\tat scala.collection.LinearSeqOps.apply$(LinearSeq.scala:114)\n\tat scala.collection.immutable.List.apply(List.scala:79)\n\tat Problem$.stringXor(tmp_vv8j86j.scala:21)\n\tat Problem$.main(tmp_vv8j86j.scala:34)\n\tat Problem.main(tmp_vv8j86j.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978866
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val r = new StringBuilder\n        for(i<-0 to (a.length-1)) r.append((i.toInt*a.length)+(a(i)^b(i)))\n        r.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpja12mmfx.scala:14)\n\tat Problem.main(tmpja12mmfx.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978865
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var res = \"\"\n        var carry = 0\n        for (a <- a) {\n            for (b <- b) {\n                val bit = a.toInt() xor b.toInt()\n                res = if (bit == 1) res + 1 else res + (bit + carry)\n                carry = (bit == 1)\n            }\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmpbs9rw0yt.scala:13:28 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mbit\u001b[0m = a.toInt() xor b.toInt()\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mmethod\u001b[0m \u001b[35mtoInt\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mChar\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978861
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var result = \"\"\n        var ia = a.toCharArray.zipWithIndex.filter(_._1.toInt() <> 0).toList\n        var ib = b.toCharArray.zipWithIndex.filter(_._1.toInt() <> 0).toList\n        ia.reverse.foreach{case (v, i) =>\n            result += v\n            if (ib.exists(_._1 == i)) result += v\n        }\n        ia.reverse.foreach{case (v, i) =>\n            result += v\n            if (ia.exists(_._1 == i)) result += v\n        }\n        result.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6yh0wys3.scala:10:56 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mia\u001b[0m = a.toCharArray.zipWithIndex.filter(_._1.toInt() <> \u001b[31m0\u001b[0m).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mmethod\u001b[0m \u001b[35mtoInt\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mChar\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp6yh0wys3.scala:11:56 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mib\u001b[0m = b.toCharArray.zipWithIndex.filter(_._1.toInt() <> \u001b[31m0\u001b[0m).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mmethod\u001b[0m \u001b[35mtoInt\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mChar\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978861
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // Initialize an empty string\n        var result : String = \"\"\n\n        // Iterate over each character of the input strings\n        for ((c1, c2) <- a.zip(b)) {\n            result += (if (c1 == c2) \"1\"  else \"0\")\n        }\n\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp9ye4zgu7.scala:20)\n\tat Problem.main(tmp9ye4zgu7.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978866
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val oneBits = a.toIntBits() == 1;\n        val zeroBits = b.toIntBits() == 0;\n        val firstBit = oneBits || zeroBits;\n        if(oneBits && zeroBits)\n            throw new IllegalArgumentException(\"Cannot perform XOR for both 0 and 1 bits\");\n        if(!oneBits && !zeroBits)\n            throw new IllegalArgumentException(\"Cannot perform XOR on inputs with no bits\");\n        val bits = firstBit ? (a.getLength * 8 + b.getLength) :\n            (Math.min(a.getLength, b.getLength) * 8 + Math.max(a.getLength, b.getLength));\n        val bitMask = (1 << bits) - 1;\n        val bitMaskString = \"1\" * bitMask;\n        val result = (0.to(bits).toList.map(x => if (x % 2 == 0) a.get(x) ^ b.get(x) else \"0\" * x) + \n                      (if (firstBit) 1 else 0).toList.map(x => if (x % 2 == 1) a.get(x) ^ b.get(x) else \"0\" * x)).mkString(\"\");\n        result + bitMaskString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmphwwq73bg.scala:17:21 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            (Math.min(a.getLength, b.getLength) * \u001b[31m8\u001b[0m + Math.max(a.getLength, b.getLength));\n\u001b[31m\u001b[31m   |\u001b[0m                     ^\u001b[0m\n\u001b[31m   |\u001b[0m                     ')' expected, but '(' found\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphwwq73bg.scala:9:24 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36moneBits\u001b[0m = a.toIntBits() == \u001b[31m1\u001b[0m;\n\u001b[31m\u001b[31m  |\u001b[0m                      ^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                      value toIntBits is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphwwq73bg.scala:10:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mzeroBits\u001b[0m = b.toIntBits() == \u001b[31m0\u001b[0m;\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value toIntBits is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphwwq73bg.scala:20:67 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = (\u001b[31m0\u001b[0m.to(bits).toList.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x % \u001b[31m2\u001b[0m == \u001b[31m0\u001b[0m) a.get(x) ^ b.get(x) \u001b[33melse\u001b[0m \u001b[31m\"0\"\u001b[0m * x) + \n\u001b[31m\u001b[31m   |\u001b[0m                                                                 ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                     value get is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmphwwq73bg.scala:21:47 ------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                      (\u001b[33mif\u001b[0m (firstBit) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m).toList.map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x % \u001b[31m2\u001b[0m == \u001b[31m1\u001b[0m) a.get(x) ^ b.get(x) \u001b[33melse\u001b[0m \u001b[31m\"0\"\u001b[0m * x)).mkString(\u001b[31m\"\"\u001b[0m);\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue toList is not a member of (\u001b[31m1\u001b[0m : Int) | (\u001b[31m0\u001b[0m : Int) - did you mean (\u001b[31m1\u001b[0m : Int) | (\u001b[31m0\u001b[0m : Int).toInt?\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659978867
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      val aBits = a.toInt :: Nil\n      val bBits = b.toInt :: Nil\n      val xorBits = bBits ++ aBits\n      var x = 0\n      val len = xorBits.length\n      for( i <- 0 until len )\n        x |= xorBits(i) << (len - i - 1)\n      val output = Integer.toBinaryString(x)\n      if( output.length == 1 ) output else \"0\"\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpg51cd76q.scala:20)\n\tat Problem.main(tmpg51cd76q.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978870
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val a1 = a.toList\n        val b1 = b.toList\n        val list1 = for {\n            x <- a1\n            y <- b1\n        } yield {\n            if (x != y) \"1\" + \"0\"\n            else \"0\"\n        }\n        val string1 = list1.mkString\n        val list2 = for {\n            x <- b1\n            y <- a1\n        } yield {\n            if (x != y) \"1\" + \"0\"\n            else \"0\"\n        }\n        val string2 = list2.mkString\n        return string1 + \"1\" + string2\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp7kxaaqd2.scala:30)\n\tat Problem.main(tmp7kxaaqd2.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978870
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var res = \"\"\n        for (i <- 0 until a.length) {\n            res ++= a(i) XOR b(i)\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmps6bsl7mq.scala:11:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            res ++= a(i) XOR b(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value ++= is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmps6bsl7mq.scala:11:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            res ++= a(i) XOR b(i)\n\u001b[31m\u001b[31m   |\u001b[0m                    ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                    value XOR is not a member of Char\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978868
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      var result = \"\"\n      var carry = 0\n      for (i <- 0 until a.length) result += a.charAt(i).toInt ^ b.charAt(i).toInt\n      for (i <- 0 until a.length - 1) result += carry * a.charAt(a.length - i - 1)\n      result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpyyc3kg3m.scala:16)\n\tat Problem.main(tmpyyc3kg3m.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978870
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val a1 = a.toList\n        val b1 = b.toList\n        val res = mutable.StringBuilder.newBuilder\n        var i = 0\n        while(i < a1.length) {\n            val i1 = i\n            val carry = 0\n            val i2 = i + 2\n            while(i < i2) {\n                val j = a1(j) XOR b1(i) XOR carry\n                carry = if (j > 0xFF) 1 else 0\n                res.append(j.toString.reverse.charAt(0))\n                i += 1\n            }\n            if (carry != 0) res.append(1)\n            i += 1\n        }\n        res.result()\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpra4eanjy.scala:11:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mres\u001b[0m = mutable.StringBuilder.newBuilder\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpra4eanjy.scala:18:27 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m                \u001b[33mval\u001b[0m \u001b[36mj\u001b[0m = a1(j) XOR b1(i) XOR carry\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           Recursive \u001b[33mvalue\u001b[0m \u001b[35mj\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E052] Type Error: /tmp/tmpra4eanjy.scala:19:22 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                carry = \u001b[33mif\u001b[0m (j > \u001b[31m0xFF\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Reassignment to val carry\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978867
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val setA = mutable.Set(a.split(\"1\").map(x => x.toInt))\n        val setB = mutable.Set(b.split(\"1\").map(x => x.toInt))\n        val common = setA intersect setB\n        val result = \"\"\n        common.foreach { x =>\n            result += \"1\" if (x == 1) else \"0\"\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmpo8g8tqwp.scala:14:26 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            result += \u001b[31m\"1\"\u001b[0m \u001b[33mif\u001b[0m (x == \u001b[31m1\u001b[0m) \u001b[33melse\u001b[0m \u001b[31m\"0\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^\u001b[0m\n\u001b[31m   |\u001b[0m                          end of statement expected but 'if' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo8g8tqwp.scala:9:19 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msetA\u001b[0m = mutable.Set(a.split(\u001b[31m\"1\"\u001b[0m).map(\u001b[36mx\u001b[0m => x.toInt))\n\u001b[31m\u001b[31m  |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                   Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpo8g8tqwp.scala:10:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msetB\u001b[0m = mutable.Set(b.split(\u001b[31m\"1\"\u001b[0m).map(\u001b[36mx\u001b[0m => x.toInt))\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978865
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var ans = \"\"\n        for(i <- 0 until a.length) {\n            ans += if (a(i) == '1' && b(i) == '1') '0' else ('a(i) == '0' && b(i) == '0')\n        }\n        return ans\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp5gsbqfhq.scala:11:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            ans += \u001b[33mif\u001b[0m (a(i) == \u001b[31m'1'\u001b[0m && b(i) == \u001b[31m'1'\u001b[0m) \u001b[31m'0'\u001b[0m \u001b[33melse\u001b[0m (\u001b[31m'a\u001b[0m(i) == \u001b[31m'0'\u001b[0m && b(i) == \u001b[31m'0'\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31mif\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978866
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aList = a.toList\n        val bList = b.toList\n        aList.zip(bList).map{ case(x, y) => x ^ y }.mkString.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpoj4obi69.scala:16)\n\tat Problem.main(tmpoj4obi69.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978871
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // Initialize the empty result\n        var result : String = \"\"\n        // Iterate over both the inputs and update result accordingly\n        for (i <- a.indices) {\n            if (i==0) {\n                result+=(if(a(i) == b(i)) \"1\" else \"0\")\n            } else {\n                result+=(if(a(i)==b(i)) \"0\" else \"1\")\n            }\n        }\n        // Return the result\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpvfb8zmzr.scala:23)\n\tat Problem.main(tmpvfb8zmzr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978871
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val bitSet = a.zip(b).map { \n            case (\"0\", \"0\") => 0\n            case (\"0\", \"1\") => 1\n            case (\"1\", \"0\") => 1\n            case (\"1\", \"1\") => 0\n        }\n        (bitSet Xor bitSet.map(_ => 0).map(_ + 48) toString )\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpfc60qfdo.scala:15:60 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        (bitSet Xor bitSet.map(_ => \u001b[31m0\u001b[0m).map(_ + \u001b[31m48\u001b[0m) toString )\n\u001b[31m\u001b[31m   |\u001b[0m                                                            ^\u001b[0m\n\u001b[31m   |\u001b[0m                                       expression expected but \u001b[31m')'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmpfc60qfdo.scala:10:18 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            \u001b[33mcase\u001b[0m (\u001b[31m\"0\"\u001b[0m, \u001b[31m\"0\"\u001b[0m) => \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpfc60qfdo.scala:10:23 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            \u001b[33mcase\u001b[0m (\u001b[31m\"0\"\u001b[0m, \u001b[31m\"0\"\u001b[0m) => \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpfc60qfdo.scala:11:18 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[33mcase\u001b[0m (\u001b[31m\"0\"\u001b[0m, \u001b[31m\"1\"\u001b[0m) => \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpfc60qfdo.scala:11:23 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[33mcase\u001b[0m (\u001b[31m\"0\"\u001b[0m, \u001b[31m\"1\"\u001b[0m) => \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmpfc60qfdo.scala:12:18 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mcase\u001b[0m (\u001b[31m\"1\"\u001b[0m, \u001b[31m\"0\"\u001b[0m) => \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp",
      "stdout": "",
      "timestamp": 1659978871
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n       var result: String = \"\";\n       val bitMap = new mutable.HashMap[Int, Int]();\n       val bitMap2 = new mutable.HashMap[Int, Int]();\n       a.foreach { x =>\n           if (x != \"0\" && x != \"1\") {\n               throw new IllegalArgumentException(\"Only 0 and 1 are allowed for input\");\n           }\n           bitMap(x) = bitMap.getOrElse(x, 0) + 1\n       }\n       b.foreach { x =>\n           if (x != \"0\" && x != \"1\") {\n               throw new IllegalArgumentException(\"Only 0 and 1 are allowed for input\");\n           }\n           bitMap2(x) = bitMap2.getOrElse(x, 0) + 1\n       }\n\n       val bitMapKeys = bitMap.keys;\n       val bitMapValues = bitMap.values;\n       val bitMapKeysSorted = bitMapKeys.sorted;\n       val bitMapValuesSorted = bitMapValues.sorted;\n       bitMapKeysSorted.foreach { x =>\n           val tempBitMapKeys = bitMapKeys.filter(_ != x);\n           val tempBitMapValues = bitMapValues.filter(_ != x);\n           val temp = x ^ bitMap(x);\n           val bitMapUpdated = new mutable.HashMap[Int, Int]();\n           tempBitMapKeys.foreach { y =>\n               bitMapUpdated(y) = bitMapUpdated.getOrElse(y, 0) + temp(y)\n           }\n           bitMapUpdated.foreach { x =>\n               val newBitMapValue = x ^ bitMap2(x);\n               bitMapUpdated(x) = newBitMapValue;\n           }\n           bitMapUpdated.foreach { x =>\n               result += x._1 + x._2\n           }\n       }\n       result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4_x3cjvf.scala:10:24 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m       \u001b[33mval\u001b[0m \u001b[36mbitMap\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]();\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp4_x3cjvf.scala:11:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m       \u001b[33mval\u001b[0m \u001b[36mbitMap2\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]();\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp4_x3cjvf.scala:13:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m           \u001b[33mif\u001b[0m (x != \u001b[31m\"0\"\u001b[0m && x != \u001b[31m\"1\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmp4_x3cjvf.scala:13:27 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m           \u001b[33mif\u001b[0m (x != \u001b[31m\"0\"\u001b[0m && x != \u001b[31m\"1\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmp4_x3cjvf.scala:19:15 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m           \u001b[33mif\u001b[0m (x != \u001b[31m\"0\"\u001b[0m && x != \u001b[31m\"1\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and String cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmp4_x3cjvf.scala:19:27 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m           \u001b[33mif\u001b[0m (x != \u001b[31m\"0\"\u001b[0m && x != \u001b[31m\"1\"\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                           ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types Char and Strin",
      "stdout": "",
      "timestamp": 1659978873
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aList = a.toIntList\n        val bList = b.toIntList\n        aList zip bList map {\n        case (a, b) => a + b\n        case (a, b) => a - b\n        case (a, b) => a * b\n        case (a, b) => a / b\n        case (a, b) => a % b\n        case (a, b) => if a == b { \"1\" + else if a.equals(b) a else a }\n        case (a, b) => if a.equals(b) a else a // this case is never reached\n        case (a, b) => if a == b { \"1\" + else if a < b else \"0\" + else if b <: a else \"1\" + }\n        case (a, b) => if a == b { \"1\" + else if a == 1 else \"0\" + else if b == a  else \"1\" + }\n        case (a, b) => if a == b { \"1\" + else if a.toInt == 1 else \"0\" + else if b == a.toInt else \"1\" + }\n        case (a, b) => if a.toInt == 1 { \"1\" + else if b == a.toInt else \"0\" + else if b < a.toInt else \"1\" + }\n        case (a, b) => if a.toInt == 1 { \"1\" + else if b == a.toInt else \"0\" + else if b < a.toInt else \"1\" + }\n        case (a, b) => if a.toInt == 1 { \"1\" + else if b == a.toInt else \"0\" + else if b < a.toInt else \"1\" + }\n        case (a, b) => if a.toInt == 1 { \"1\" + else if b == a.toInt else \"0\" + else if b < a.toInt else \"1\" + }\n        case (a, b) => if a.toInt == 1 { \"1\" + else if b == a.toInt else \"0\" + else if b < a.toInt else \"1\" + }\n        case (a, b) => if a.toInt == 1 { \"1\" + else if b == a.toInt else \"0\" + else if b < a.toInt else \"1\" + }\n        case (a, b) => if a.toInt == 1 { \"1\" + else if b == a.toInt else \"0\" + else if b < a.toInt else \"1\" + }\n        case (a, b) => if a.toInt == 1 { \"1\" + else if b == a.toInt else \"0\" + else if b < a.toInt else \"1\" + }\n        case (a, b) => if a.toInt == 1 { \"1\" + else if b == a.toInt else \"0\" + else if b < a.toInt else \"1\" + }\n        case (a, b) => if a.toInt == 1 { \"1\" + else if b == a.toInt else \"0\" + else if b < a.\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpqpu5khxn.scala:17:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m        \u001b[33mcase\u001b[0m (a, b) => \u001b[33mif\u001b[0m a == b { \u001b[31m\"1\"\u001b[0m + \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m a.equals(b) a \u001b[33melse\u001b[0m a }\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      expression expected but \u001b[31melse\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqpu5khxn.scala:18:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m18 |\u001b[0m        \u001b[33mcase\u001b[0m (a, b) => \u001b[33mif\u001b[0m a.equals(b) a \u001b[33melse\u001b[0m a \u001b[34m// this case is never reached\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        'then' expected, but 'case' found\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpqpu5khxn.scala:20:41 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m        \u001b[33mcase\u001b[0m (a, b) => \u001b[33mif\u001b[0m a == b { \u001b[31m\"1\"\u001b[0m + \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m a == \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"0\"\u001b[0m + \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m b == a  \u001b[33melse\u001b[0m \u001b[31m\"1\"\u001b[0m + }\n\u001b[31m\u001b[31m   |\u001b[0m                                         ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      expression expected but \u001b[31melse\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpqpu5khxn.scala:21:8 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m        \u001b[33mcase\u001b[0m (a, b) => \u001b[33mif\u001b[0m a == b { \u001b[31m\"1\"\u001b[0m + \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m a.toInt == \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"0\"\u001b[0m + \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m b == a.toInt \u001b[33melse\u001b[0m \u001b[31m\"1\"\u001b[0m + }\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        'then' expected, but 'case' found\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpqpu5khxn.scala:23:47 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mcase\u001b[0m (a, b) => \u001b[33mif\u001b[0m a.toInt == \u001b[31m1\u001b[0m { \u001b[31m\"1\"\u001b[0m + \u001b[33melse\u001b[0m \u001b[33mif\u001b[0m b == a.toInt \u001b[33melse\u001b[0m \u001b[31m\"0\"\u001b[0m",
      "stdout": "",
      "timestamp": 1659978873
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var result = 0\n        var carry = 0\n        for (i <- 0 until a.length) {\n            val x = a.charAt(i).toInt\n            val y = b.charAt(i).toInt\n            val sum = x + y + carry\n            if (sum > 'Z') {\n                result += (sum - 'Z')\n                carry = 0\n            } else {\n                result += sum\n                carry = 1\n            }\n        }\n        if (carry) {\n            result += 1\n        }\n        \"\" + result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpk664cupy.scala:23:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m        \u001b[33mif\u001b[0m (carry) {\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    (carry : Int)\n\u001b[31m   |\u001b[0m            Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978872
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val binA = a.toIntBitArray\n        val binB = b.toIntBitArray\n        val result = new mutable.HashMap[Int, Int]()\n        val len = binA.size + binB.size\n        var i = 0\n        while (i < len) {\n            val k = (i / 2)\n            val v = (binA(k) xor binB(k)).toInt\n            if (result.contains(v)) {\n                val r = result(v)\n                result.remove(k)\n                result(v) = r\n            } else {\n                result(v) = k\n            }\n            i += 1\n        }\n        var res = \"\"\n        for (value <- result.keys) {\n            res +=  value.toString(2)\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt1k08ygv.scala:9:21 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinA\u001b[0m = a.toIntBitArray\n\u001b[31m\u001b[31m  |\u001b[0m                   ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                   value toIntBitArray is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpt1k08ygv.scala:10:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbinB\u001b[0m = b.toIntBitArray\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value toIntBitArray is not a member of String\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt1k08ygv.scala:11:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.HashMap[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978874
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aStr : Seq[Int] = a.toSeq.map(_.toInt)\n        val bStr : Seq[Int] = b.toSeq.map(_.toInt)\n        aStr ++ bStr map {\n            case 0 => 0\n            case 1 => 1\n            case _ => 0\n        }.toSeq.foldLeft((0 , 0)) {\n            case ((c1, c2) , value) => c1 xor c2\n        }._2\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp57vk72pj.scala:9:41 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maStr\u001b[0m : \u001b[35mSeq\u001b[0m[\u001b[35mInt\u001b[0m] = a.toSeq.map(_.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m                              ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                              Found:    IndexedSeq[Int]\n\u001b[31m  |\u001b[0m                              Required: collection.mutable.Seq[Int]\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp57vk72pj.scala:10:41 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbStr\u001b[0m : \u001b[35mSeq\u001b[0m[\u001b[35mInt\u001b[0m] = b.toSeq.map(_.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                              Found:    IndexedSeq[Int]\n\u001b[31m   |\u001b[0m                              Required: collection.mutable.Seq[Int]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E081] Type Error: /tmp/tmp57vk72pj.scala:12:12 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m            \u001b[33mcase\u001b[0m \u001b[31m0\u001b[0m => \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^\u001b[0m\n\u001b[31m   |\u001b[0m   Missing parameter type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m   I could not infer the type of the parameter x$1 of expanded function:\n\u001b[31m   |\u001b[0m   x$1 => \n\u001b[31m   |\u001b[0m     x$1\u001b[33m match \u001b[0m\n\u001b[31m   |\u001b[0m       {\n\u001b[31m   |\u001b[0m         \u001b[33mcase \u001b[0m0 => \n\u001b[31m   |\u001b[0m           0\n\u001b[31m   |\u001b[0m         \u001b[33mcase \u001b[0m1 => \n\u001b[31m   |\u001b[0m           1\n\u001b[31m   |\u001b[0m         \u001b[33mcase \u001b[0m_ => \n\u001b[31m   |\u001b[0m           0\n\u001b[31m   |\u001b[0m       }.\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978875
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val a = a.toCharArray\n        val b = b.toCharArray\n        var res = new mutable.ArrayBuffer[Char]()\n        for(i <- 0 until a.length) {\n            if(a(i) xor b(i) == 0)\n                res += '0'\n            else\n                res += '1'\n        }\n        res.toString.toCharArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpurw1i4od.scala:9:16 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ma\u001b[0m = a.toCharArray\n\u001b[31m\u001b[31m  |\u001b[0m                ^\u001b[0m\n\u001b[31m  |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35ma\u001b[0m needs type\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmpurw1i4od.scala:10:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mb\u001b[0m = b.toCharArray\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpurw1i4od.scala:11:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mres\u001b[0m = \u001b[33mnew\u001b[0m mutable.ArrayBuffer[\u001b[35mChar\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978871
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        def loop(i: Int) : String = {\n            if (i == a.length) {\n                return \"\"\n            } else if (a(i) != b(i)) {\n                return loop(i+1)\n            } else {\n                return loop(i+1)\n            }\n        }\n        return loop(0)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpf3ylg8oe.scala:21)\n\tat Problem.main(tmpf3ylg8oe.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978875
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aa = a\n        val bb = b\n        var outputString = \"\"\n        var binNum = 0\n        var result = 0\n        for(num <- (0 to aa.length)) {\n            binNum = aa.charAt(num).toInt\n            output = aa.replaceAll((\"0\" + binNum.toString), \"\")\n            if(output.length == aa.length) {\n                binNum = bb.charAt(num).toInt\n                output = output.replaceAll((\"0\" + binNum.toString), \"\")\n                result = result + binNum xor binNum\n            }\n            outputString += result.toString\n        }\n        outputString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvn25a2w4.scala:16:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            output = aa.replaceAll((\u001b[31m\"0\"\u001b[0m + binNum.toString), \u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            Not found: output\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvn25a2w4.scala:17:15 ------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m            \u001b[33mif\u001b[0m(output.length == aa.length) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m               Not found: output\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvn25a2w4.scala:19:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                output = output.replaceAll((\u001b[31m\"0\"\u001b[0m + binNum.toString), \u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: output\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpvn25a2w4.scala:19:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m19 |\u001b[0m                output = output.replaceAll((\u001b[31m\"0\"\u001b[0m + binNum.toString), \u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: output\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpvn25a2w4.scala:20:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                result = result + binNum xor binNum\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value xor is not a member of Int\n5 errors found\n",
      "stdout": "",
      "timestamp": 1659978874
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      val aSeq = a.split(\"0\").map(_.toInt)\n      val bSeq = b.split(\"0\").map(_.toInt)\n      var result = \"\"\n      val aSize = a.length\n      val bSize = b.length\n      val aLen = aSeq.length\n      val bLen = bSeq.length\n      val aMid = (aLen + bLen - 1) / 2\n      val bMid = bLen - aMid\n      for (aPos <- 0 to aMid) {\n        for (j <- 0 to bMid) {\n          result = result + \n            if (aSeq(aPos) == bSeq(j))\n              1\n            else\n              0\n        }\n      }\n      result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp5l5lnviu.scala:20:27 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m          result = result + \n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           expression expected but \u001b[31mif\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- Error: /tmp/tmp5l5lnviu.scala:23:12 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m            \u001b[33melse\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            end of statement expected but 'else' found\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978872
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aArray = a.toIntArray\n        val bArray = b.toIntArray\n        val retStr = \"\"\n        aArray.zip(Array.fill(bArray.length)(0)) foreach { case (aNum, aInd) => bArray.zip(aNum) foreach { case (bNum, bInd) => if (aInd == bInd) retStr += \"1\" else \"0\" } }\n        retStr\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuputbnl0.scala:9:23 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maArray\u001b[0m = a.toIntArray\n\u001b[31m\u001b[31m  |\u001b[0m                     ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                     value toIntArray is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpuputbnl0.scala:10:23 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbArray\u001b[0m = b.toIntArray\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     value toIntArray is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978876
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // Use mutable string to keep track of bits in correct position\n        var result = new mutable.StringBuilder\n        // Initialize first bit in result as 1\n        result.append(\"1\")\n        // Iterate through remaining bits in each string, starting at position 1\n        for (pos <- 1 to b.length) {\n            val b = b.substring(0,pos)\n            val a = a.substring(0,pos)\n            // Perform XOR and append result to string builder if appropriate\n            result.append(if (aXOR(b) == 1) \"1\" else \"0\")\n        }\n        return result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptfghopej.scala:10:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mvar\u001b[0m \u001b[36mresult\u001b[0m = \u001b[33mnew\u001b[0m mutable.StringBuilder\n\u001b[31m\u001b[31m   |\u001b[0m                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978873
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aBin = a.map(bin => bin.toChar)\n        val aBinOr = ArrayBuffer(bin.or(bin.xor(aBin(bin.length-1)))) ++\n            aBin.take(aBin.length-1)\n        val bBin = b.map(bin => bin.toChar)\n        val bBinOr = ArrayBuffer(bin.or(bin.xor(bBin(bin.length-1)))) ++\n            bBin.take(bBin.length-1)\n        val orBin = ArrayBuffer(aBinOr).++(bBinOr)\n        orBin.map(bin.asDigit).mkString.reverse\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyu_u1s80.scala:10:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maBinOr\u001b[0m = ArrayBuffer(bin.or(bin.xor(aBin(bin.length-\u001b[31m1\u001b[0m)))) ++\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: bin\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyu_u1s80.scala:13:33 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbBinOr\u001b[0m = ArrayBuffer(bin.or(bin.xor(bBin(bin.length-\u001b[31m1\u001b[0m)))) ++\n\u001b[31m\u001b[31m   |\u001b[0m                                 ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                 Not found: bin\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyu_u1s80.scala:16:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        orBin.map(bin.asDigit).mkString.reverse\n\u001b[31m\u001b[31m   |\u001b[0m                  ^^^\u001b[0m\n\u001b[31m   |\u001b[0m                  Not found: bin\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978875
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        if (b.length < a.length) \n            return stringXor(b, a)\n        else {\n            var result = \"\"\n            for (i <- 0 until a.length) {\n                if (a(i) == '0' && b(i) == '1') \n                    result += \"1\"\n                else if (a(i) == '1' && b(i) == '0') \n                    result += \"0\"\n                else if (a(i) != b(i))\n                    result += \"0\"\n                else {\n                    if (i == a.length - 1) \n                        result += \"0\"\n                    else \n                        result += \"1\"\n                }\n            }\n            result\n        }\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpytqx_wyu.scala:31)\n\tat Problem.main(tmpytqx_wyu.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978878
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aa = a.reverse\n        val bb = b.reverse\n        val res1 = \"0000\"\n        val res2 = \"0000\"\n        val result = \"0000\"\n        val result1 = 0\n        val result2 = 0\n        var aIndex = 0\n        var bIndex = 0\n        var i = 0\n        var j = 0\n        var k = 0\n        while (i < aa.length && j < bb.length) {\n            if (aa(i) == bb(j)) {\n                result(k) = aa(i)\n                result1(k) = aa(i)\n                result2(k) = aa(i)\n                k += 1\n                i += 1\n                j += 1\n            } else if (aa(i) != bb(j)) {\n                result1(k) = aa(i)\n                result2(k) = bb(j)\n                k += 1\n                i += 1\n                j += 1\n            } else {\n                result1(k) = aa(i)\n                result2(k) = bb(j)\n                k += 1\n                i += 1\n                j += 1\n            }\n        }\n        while (i < aa.length) {\n            result1(k) = aa(i)\n            k += 1\n            i += 1\n        }\n        while (j < bb.length) {\n            result2(k) = bb(j)\n            k += 1\n            j += 1\n        }\n        while (k < res.length && k < result1.length) {\n            res(res1(k)) |= result1(k)\n            res(res2(k)) |= result2(k)\n            k += 1\n        }\n        res.reverse()\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnfr8nrya.scala:23:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m23 |\u001b[0m                result(k) = aa(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value update is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnfr8nrya.scala:24:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m24 |\u001b[0m                result1(k) = aa(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value update is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnfr8nrya.scala:25:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m25 |\u001b[0m                result2(k) = aa(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value update is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnfr8nrya.scala:30:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                result1(k) = aa(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value update is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnfr8nrya.scala:31:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m31 |\u001b[0m                result2(k) = bb(j)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value update is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnfr8nrya.scala:36:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m36 |\u001b[0m                result1(k) = aa(i)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value update is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnfr8nrya.scala:37:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m37 |\u001b[0m                result2(k) = bb(j)\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                value update is not a member of Int\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnfr8nrya.scala:44:12 ------------------------\u001b[0m\u001b[0m\n\u001b[31m44 |\u001b[0m            result1(k) = aa(i)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value update is not a member of",
      "stdout": "",
      "timestamp": 1659978879
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var x = 0\n        var y = 0\n        var res: String = \"\"\n        for (x = 0; (x < a.length) && (y < b.length); x++, y++) {\n            res += (a get(x) XOR b get(y))\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp27gigfit.scala:12:15 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (x = \u001b[31m0\u001b[0m; (x < a.length) && (y < b.length); x++, y++) {\n\u001b[31m\u001b[31m   |\u001b[0m               ^\u001b[0m\n\u001b[31m   |\u001b[0m               ')' expected, but '=' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp27gigfit.scala:12:52 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (x = \u001b[31m0\u001b[0m; (x < a.length) && (y < b.length); x++, y++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m                                            '<-' expected, but ';' found\n\u001b[31m\u001b[31m-- [E032] Syntax Error: /tmp/tmp27gigfit.scala:12:57 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (x = \u001b[31m0\u001b[0m; (x < a.length) && (y < b.length); x++, y++) {\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^\u001b[0m\n\u001b[31m   |\u001b[0m                                                        pattern expected\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp27gigfit.scala:12:18 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (x = \u001b[31m0\u001b[0m; (x < a.length) && (y < b.length); x++, y++) {\n\u001b[31m\u001b[31m   |\u001b[0m                  ^\u001b[0m\n\u001b[31m   |\u001b[0mvalue foreach is not a member of Null, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import Option.option2Iterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip2.lazyZip2ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip3.lazyZip3ToIterable\n\u001b[31m   |\u001b[0m  import collection.LazyZip4.lazyZip4ToIterable\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.list asScalaBuffer\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.properties AsScalaMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.enumeration AsScalaIterator\n\u001b[31m   |\u001b[0m  import collection.",
      "stdout": "",
      "timestamp": 1659978878
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // Convert binary strings to bit vectors (0s and 1s)\n        val aBin = Array(a.split(' ').map(x => if (x == '1') 1 else 0).toArray)\n        val bBin = Array(b.split(' ').map(x => if (x == '1') 1 else 0).toArray)\n        // XOR all the vectors together\n        val xor = for (x1 <- 0 until aBin.length step 1) {\n            for (x2 <- 0 until bBin.length step 1) {\n                xor += (aBin(x1) ^ bBin(x2))\n            }\n        }\n        // Convert to string and return result\n        xor.toBitArray.foldLeft(\"\")(_ ++ _).toCharArray\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp9z4jg3uh.scala:10:51 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maBin\u001b[0m = Array(a.split(\u001b[31m' '\u001b[0m).map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m'1'\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m).toArray)\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- Error: /tmp/tmp9z4jg3uh.scala:11:51 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbBin\u001b[0m = Array(b.split(\u001b[31m' '\u001b[0m).map(\u001b[36mx\u001b[0m => \u001b[33mif\u001b[0m (x == \u001b[31m'1'\u001b[0m) \u001b[31m1\u001b[0m \u001b[33melse\u001b[0m \u001b[31m0\u001b[0m).toArray)\n\u001b[31m\u001b[31m   |\u001b[0m                                                   ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Values of types String and Char cannot be compared with == or !=\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp9z4jg3uh.scala:13:49 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mxor\u001b[0m = \u001b[33mfor\u001b[0m (x1 <- \u001b[31m0\u001b[0m until aBin.length step \u001b[31m1\u001b[0m) {\n\u001b[31m\u001b[31m   |\u001b[0m                             ^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mgetter\u001b[0m \u001b[35mstep\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mRange\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978879
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        def inc(a : Char) : Char = {\n            if (a == '1') {\n                return '0'\n            } else {\n                return '1'\n            }\n        }\n        def dec(a : Char) : Char = {\n            if (a == '0') {\n                return '1'\n            } else {\n                return '0'\n            }\n        }\n        val x = 0\n        val y = a.size\n        val z = b.size\n        val newString = a.drop(y) + b.drop(z) + a.take(y) + b.take(z)\n        val res = newString.zip(newString.tail).map {\n            case (x, y) => if (x != y) x else inc(y)\n        }.mkString(\"\")\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpa0qwwe_m.scala:33)\n\tat Problem.main(tmpa0qwwe_m.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978882
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val ab = a.zip(b).map(a => a.toInt ^ b.toInt)\n        val result: List[Int] = ab.map(_.toBinaryString).map(_.replaceAll(\"1\", \"0\")).filter(_ != '0').map(_.toInt).toList\n        result.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgwt64cnp.scala:9:37 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mab\u001b[0m = a.zip(b).map(\u001b[36ma\u001b[0m => a.toInt ^ b.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m                                   ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0mvalue toInt is not a member of (Char, Char), but could be made available as an extension method.\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m  |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m  |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m  |\u001b[0m\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgwt64cnp.scala:10:41 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m: \u001b[35mList\u001b[0m[\u001b[35mInt\u001b[0m] = ab.map(_.toBinaryString).map(_.replaceAll(\u001b[31m\"1\"\u001b[0m, \u001b[31m\"0\"\u001b[0m)).filter(_ != \u001b[31m'0'\u001b[0m).map(_.toInt).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                         value toBinaryString is not a member of Nothing\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpgwt64cnp.scala:10:63 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m: \u001b[35mList\u001b[0m[\u001b[35mInt\u001b[0m] = ab.map(_.toBinaryString).map(_.replaceAll(\u001b[31m\"1\"\u001b[0m, \u001b[31m\"0\"\u001b[0m)).filter(_ != \u001b[31m'0'\u001b[0m).map(_.toInt).toList\n\u001b[31m\u001b[31m   |\u001b[0m                                                             ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue replaceAll is not a member of Nothing, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might fix the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.buffer AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversions.map AsJavaConcurrentMap\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsToJava.buffer AsJavaList\n\u001b[31m   |\u001b[0m  import collection.convert.ImplicitConversionsT",
      "stdout": "",
      "timestamp": 1659978883
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val xor = a.foldLeft(mutable.Set[String]())( (a, b) => a += (b + \"0\") )\n        val xorAll = mutable.Set[String]()\n        b.foldLeft(mutable.Set[String]())( (a, b) => xorAll += a + (b + \"0\") )\n        xorAll.foldLeft(\"\")( (a, b) => a + (b + \"1\") )\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjwiptavy.scala:9:29 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mxor\u001b[0m = a.foldLeft(mutable.Set[\u001b[35mString\u001b[0m]())( (\u001b[36ma\u001b[0m, \u001b[36mb\u001b[0m) => a += (b + \u001b[31m\"0\"\u001b[0m) )\n\u001b[31m\u001b[31m  |\u001b[0m                             ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                             Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpjwiptavy.scala:9:65 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mxor\u001b[0m = a.foldLeft(mutable.Set[\u001b[35mString\u001b[0m]())( (\u001b[36ma\u001b[0m, \u001b[36mb\u001b[0m) => a += (b + \u001b[31m\"0\"\u001b[0m) )\n\u001b[31m\u001b[31m  |\u001b[0m                                                               ^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                      value += is not a member of Any - did you mean a.!=?\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjwiptavy.scala:10:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mxorAll\u001b[0m = mutable.Set[\u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjwiptavy.scala:11:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        b.foldLeft(mutable.Set[\u001b[35mString\u001b[0m]())( (\u001b[36ma\u001b[0m, \u001b[36mb\u001b[0m) => xorAll += a + (b + \u001b[31m\"0\"\u001b[0m) )\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659978881
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      val aBin = a.replace(\"1\", \"0\").replace(\"0\", \"1\")\n      val bBin = b.replace(\"1\", \"0\").replace(\"0\", \"1\")\n      aBin.toCharArray.map(i => bBin.toCharArray.map(j => i ^ j).mkString).mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp2pxl7hgq.scala:14)\n\tat Problem.main(tmp2pxl7hgq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978884
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val c = mutable.Stack[Char]()\n        val d = mutable.Stack[Char]()\n        val e = mutable.Stack[Char]()\n        val g = mutable.Stack[Char]()\n        val h = mutable.Stack[Char]()\n        val i = mutable.Stack[Char]()\n        val j = mutable.Stack[Char]()\n        val l = mutable.Stack[Char]()\n        val m = mutable.Stack[Char]()\n        val n = mutable.Stack[Char]()\n        val o = mutable.Stack[Char]()\n        val p = mutable.Stack[Char]()\n        val q = mutable.Stack[Char]()\n        val r = mutable.Stack[Char]()\n        val s = mutable.Stack[Char]()\n        val t = mutable.Stack[Char]()\n        val u = mutable.Stack[Char]()\n        val v = mutable.Stack[Char]()\n        val w = mutable.Stack[Char]()\n        val x = mutable.Stack[Char]()\n        val y = mutable.Stack[Char]()\n        val z = mutable.Stack[Char]()\n        var w1 = a\n        var w2 = b\n        while(w1 != \"\" && w2 != \"\"){\n            c += w1.charAt(0)\n            d += w2.charAt(0)\n            e += w1.charAt(1)\n            g += w2.charAt(1)\n            h += w1.charAt(2)\n            i += w2.charAt(2)\n            j += w1.charAt(3)\n            l += w2.charAt(3)\n            m += w1.charAt(4)\n            n += w2.charAt(4)\n            o += w1.charAt(5)\n            p += w2.charAt(5)\n            q += w1.charAt(6)\n            r += w2.charAt(6)\n            s += w1.charAt(7)\n            t += w2.charAt(7)\n            u += w1.charAt(8)\n            v += w2.charAt(8)\n            w += w1.charAt(9)\n            x += w2.charAt(9)\n            y += w1.charAt(10)\n            z += w2.charAt(10)\n            w1 += w1.substring(1,w1.length)\n            w2 += w2.substring(1,w2.length)\n        }\n        var xx = c.mkString(\"\") +\n            d.mkString(\"\") +\n            e.mkString(\"\") +\n            g.mkString(\"\") +\n            h.mkString(\"\") +\n            i.mkString(\"\") +\n            j.mkString(\"\") +\n            l.mkString(\"\") +\n            m.\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmpaq02ok2t.scala:68:4 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m68 |\u001b[0m    }\n\u001b[31m\u001b[31m   |\u001b[0m    ^\u001b[0m\n\u001b[31m   |\u001b[0m    an identifier expected, but '}' found\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpaq02ok2t.scala:9:16 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mc\u001b[0m = mutable.Stack[\u001b[35mChar\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpaq02ok2t.scala:10:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36md\u001b[0m = mutable.Stack[\u001b[35mChar\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpaq02ok2t.scala:11:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36me\u001b[0m = mutable.Stack[\u001b[35mChar\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpaq02ok2t.scala:12:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mg\u001b[0m = mutable.Stack[\u001b[35mChar\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpaq02ok2t.scala:13:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mh\u001b[0m = mutable.Stack[\u001b[35mChar\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m                ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpaq02ok2t.sca",
      "stdout": "",
      "timestamp": 1659978882
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val result: String = b.filterNot(a).map(_ => '0').filterNot(b).map(_ => '0').mkString\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzg0kgju1.scala:9:41 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m: \u001b[35mString\u001b[0m = b.filterNot(a).map(_ => \u001b[31m'0'\u001b[0m).filterNot(b).map(_ => \u001b[31m'0'\u001b[0m).mkString\n\u001b[31m\u001b[31m  |\u001b[0m                                         ^\u001b[0m\n\u001b[31m  |\u001b[0m                                         Found:    (a : String)\n\u001b[31m  |\u001b[0m                                         Required: Char => Boolean\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpzg0kgju1.scala:9:68 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m: \u001b[35mString\u001b[0m = b.filterNot(a).map(_ => \u001b[31m'0'\u001b[0m).filterNot(b).map(_ => \u001b[31m'0'\u001b[0m).mkString\n\u001b[31m\u001b[31m  |\u001b[0m                                                                    ^\u001b[0m\n\u001b[31m  |\u001b[0m                                                 Found:    (b : String)\n\u001b[31m  |\u001b[0m                                                 Required: Char => Boolean\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978883
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val bit = a.zip(b).filter(_._1).map(_._2).sum\n        val sum = a.zip(b).filter(_._1).map(_._1).sum\n        val result = bit.toString() + sum.toString\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsdw7ppz0.scala:9:36 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbit\u001b[0m = a.zip(b).filter(_._1).map(_._2).sum\n\u001b[31m\u001b[31m  |\u001b[0m                                  ^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                  Found:    Char\n\u001b[31m  |\u001b[0m                                  Required: Boolean\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpsdw7ppz0.scala:10:36 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36msum\u001b[0m = a.zip(b).filter(_._1).map(_._1).sum\n\u001b[31m\u001b[31m   |\u001b[0m                                  ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                  Found:    Char\n\u001b[31m   |\u001b[0m                                  Required: Boolean\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978884
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aArr : Array[String] = a.split(\"0\").map(s => s.toInt)\n        val bArr : Array[String] = b.split(\"0\").map(s => s.toInt)\n        val aNibble : Array[Int] = aArr.zip(Array(1, 0, 0)).toArray\n        val bNibble : Array[Int] = bArr.zip(Array(1, 0, 0)).toArray\n        val aFinalNibble : Array[Int] = aNibble.zip(bNibble).map(t => t._1 xor t._2)\n        return aFinalNibble.toString.padToLength(16, 0)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpftct5x4e.scala:9:59 ---------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maArr\u001b[0m : \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m] = a.split(\u001b[31m\"0\"\u001b[0m).map(\u001b[36ms\u001b[0m => s.toInt)\n\u001b[31m\u001b[31m  |\u001b[0m                                                         ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                                         Found:    Int\n\u001b[31m  |\u001b[0m                                                         Required: String\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpftct5x4e.scala:10:59 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbArr\u001b[0m : \u001b[35mArray\u001b[0m[\u001b[35mString\u001b[0m] = b.split(\u001b[31m\"0\"\u001b[0m).map(\u001b[36ms\u001b[0m => s.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                                                         ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                                        Found:    Int\n\u001b[31m   |\u001b[0m                                                        Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpftct5x4e.scala:11:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maNibble\u001b[0m : \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m] = aArr.zip(Array(\u001b[31m1\u001b[0m, \u001b[31m0\u001b[0m, \u001b[31m0\u001b[0m)).toArray\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                   Found:    Array[\u001b[1m\u001b[31m(\u001b[0m\u001b[1m\u001b[31mString\u001b[0m\u001b[1m\u001b[31m,\u001b[0m\u001b[1m\u001b[31m \u001b[0mInt\u001b[1m\u001b[31m)\u001b[0m]\n\u001b[31m   |\u001b[0m                                   Required: Array[Int]\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpftct5x4e.scala:12:35 --------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbNibble\u001b[0m : \u001b[35mArray\u001b[0m[\u001b[35mInt\u001b[0m] = bArr.zip(Array(\u001b[31m1\u001b[0m, \u001b[31m0\u001b[0m, \u001b[31m0\u001b[0m)).toArray\n\u001b[31m\u001b[31m   |\u001b[0m     ",
      "stdout": "",
      "timestamp": 1659978884
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val s1 = a.toCharArray\n        val s2 = b.toCharArray\n        var result = 0\n        for (i <- 0 until s1.length) {\n            result += ((s2(i) xor s1(i)).toInt)\n        }\n        val output = new StringBuilder(2*result.toString)\n        output.append('0')\n        for (i <- 0 to (result-1)) {\n            output.append(s(i))\n        }\n        output.toString()\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfdc_5wv7.scala:13:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result += ((s2(i) xor s1(i)).toInt)\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of Int - did you mean Int.!=?\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfdc_5wv7.scala:13:30 ------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            result += ((s2(i) xor s1(i)).toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value xor is not a member of Char\n\u001b[31m\u001b[31m-- [E134] Type Error: /tmp/tmpfdc_5wv7.scala:15:40 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36moutput\u001b[0m = \u001b[33mnew\u001b[0m \u001b[35mStringBuilder\u001b[0m(\u001b[31m2\u001b[0m*result.toString)\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^\u001b[0m\n\u001b[31m   |\u001b[0m None of the overloaded alternatives of \u001b[33mmethod\u001b[0m \u001b[35m*\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mInt\u001b[0m with types\n\u001b[31m   |\u001b[0m  (x: Double): Double\n\u001b[31m   |\u001b[0m  (x: Float): Float\n\u001b[31m   |\u001b[0m  (x: Long): Long\n\u001b[31m   |\u001b[0m  (x: Int): Int\n\u001b[31m   |\u001b[0m  (x: Char): Int\n\u001b[31m   |\u001b[0m  (x: Short): Int\n\u001b[31m   |\u001b[0m  (x: Byte): Int\n\u001b[31m   |\u001b[0m match arguments (String)\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978885
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aArr = a.split('').toList\n        val bArr = b.split('').toList\n        val resultArr = new Array[Int](aArr.length + bArr.length)\n        var index = 0\n        aArr.zip(bArr).foreach { case (x, y) => resultArr += ((x ^ y).toInt) }\n        val resultString = resultArr.map(_.toString(2)).mkString(\"\")\n        resultString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- Error: /tmp/tmp3z5bytom.scala:9:27 ------------------------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maArr\u001b[0m = a.split('').toList\n\u001b[31m\u001b[31m  |\u001b[0m                           ^\u001b[0m\n\u001b[31m  |\u001b[0m                           empty character literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmp3z5bytom.scala:10:27 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbArr\u001b[0m = b.split('').toList\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           empty character literal\n\u001b[31m\u001b[31m-- Error: /tmp/tmp3z5bytom.scala:14:52 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresultString\u001b[0m = resultArr.map(_.toString(\u001b[31m2\u001b[0m)).mkString(\u001b[31m\"\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                                                    ^\u001b[0m\n\u001b[31m   |\u001b[0m         too many arguments for \u001b[33mmethod\u001b[0m \u001b[35mtoString\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mAny\u001b[0m: (): String\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978881
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val a = a.toInt\n        val b = b.toInt\n        // create bit string from both strings\n        val ab = mutable.BitVector.empty ++ BitVector(a.toInt, b.toInt)\n        // XOR bitstring with each other\n        val result = BitVector.iterate(ab) { \n            (a, b) => \n                val result = a.xor(b)\n                (a, b) => (result.binary, result.binary.size) \n            }(ab)\n        val bits = result.toBitString\n        bits.reverse.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp3tgxh_zz.scala:9:16 ----------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36ma\u001b[0m = a.toInt\n\u001b[31m\u001b[31m  |\u001b[0m                ^\u001b[0m\n\u001b[31m  |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35ma\u001b[0m needs type\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E045] Cyclic Error: /tmp/tmp3tgxh_zz.scala:10:16 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mb\u001b[0m = b.toInt\n\u001b[31m\u001b[31m   |\u001b[0m                ^\u001b[0m\n\u001b[31m   |\u001b[0m                Recursive \u001b[33mvalue\u001b[0m \u001b[35mb\u001b[0m needs type\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3tgxh_zz.scala:12:17 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mab\u001b[0m = mutable.BitVector.empty ++ BitVector(a.toInt, b.toInt)\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp3tgxh_zz.scala:14:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = BitVector.iterate(ab) { \n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: BitVector\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n4 errors found\n",
      "stdout": "",
      "timestamp": 1659978879
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aToInt = a.reverse.zipWithIndex.map {\n            case ('0' * n) => n\n            case ('1' * n) => n - 1\n        }.toList\n        val bToInt = b.reverse.zipWithIndex.map {\n            case ('0' * n) => n\n            case ('1' * n) => n - 1\n        }.toList\n        val result = 0\n        for ( x <- 0 until aToInt.size )\n            for ( y <- 0 until bToInt.size )\n                result = result + aToInt(x) * bToInt(y)\n        (result / 2).reverse.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfnotxrfv.scala:10:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            \u001b[33mcase\u001b[0m (\u001b[31m'0'\u001b[0m * n) => n\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: *\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfnotxrfv.scala:11:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[33mcase\u001b[0m (\u001b[31m'1'\u001b[0m * n) => n - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: *\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpfnotxrfv.scala:11:32 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m            \u001b[33mcase\u001b[0m (\u001b[31m'1'\u001b[0m * n) => n - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                              ^^^\u001b[0m\n\u001b[31m   |\u001b[0mvalue - is not a member of Any, but could be made available as an extension method.\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0mOne of the following imports might make progress towards fixing the problem:\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m  import math.Fractional.Implicits.infixFractionalOps\n\u001b[31m   |\u001b[0m  import math.Integral.Implicits.infixIntegralOps\n\u001b[31m   |\u001b[0m  import math.Numeric.Implicits.infixNumericOps\n\u001b[31m   |\u001b[0m\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfnotxrfv.scala:14:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m            \u001b[33mcase\u001b[0m (\u001b[31m'0'\u001b[0m * n) => n\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: *\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpfnotxrfv.scala:15:22 ------------------------\u001b[0m\u001b[0m\n\u001b[31m15 |\u001b[0m            \u001b[33mcase\u001b[0m (\u001b[31m'1'\u001b[0m * n) => n - \u001b[31m1\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m                      Not found: *\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-expl",
      "stdout": "",
      "timestamp": 1659978887
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      val c = mutable.Buffer[Char]()\n      val s = mutable.Queue[Char]()\n      a.foreach { x => if (x == 0) s += '0' else s += '1' }\n      b.foreach { x => if (x == 0) s += '0' else s += '1' }\n      val n = s.length\n      c.clear()\n      c.addAll(s.takeWhile(x => x == '0').toList)\n      c.addAll(s.takeWhile(x => x == '1').toList)\n      c.toString.dropRight(1).dropLeft(n-1).toChar\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjql3jdas.scala:9:14 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mc\u001b[0m = mutable.Buffer[\u001b[35mChar\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m              ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m              Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpjql3jdas.scala:10:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36ms\u001b[0m = mutable.Queue[\u001b[35mChar\u001b[0m]()\n\u001b[31m\u001b[31m   |\u001b[0m              ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m              Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978882
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val ans = \"\"\n        val n1 = a.length()\n        val n2 = b.length()\n        val len = n1 + n2\n        val aHash = a.toCharArray.hashCode\n        val bHash = b.toCharArray.hashCode\n        var i = 0\n        while (i < len) {\n            val aa = aHash & (1 << i)\n            val bb = bHash & (1 << i)\n            val ab = aa^bb\n            ans += if (ab == 0) \"0\" + \"1\" else \"1\"\n            i += 1\n        }\n        return ans\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmpnodzazat.scala:20:19 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            ans += \u001b[33mif\u001b[0m (ab == \u001b[31m0\u001b[0m) \u001b[31m\"0\"\u001b[0m + \u001b[31m\"1\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"1\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^\u001b[0m\n\u001b[31m   |\u001b[0m                   expression expected but \u001b[31mif\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpnodzazat.scala:20:16 ------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m            ans += \u001b[33mif\u001b[0m (ab == \u001b[31m0\u001b[0m) \u001b[31m\"0\"\u001b[0m + \u001b[31m\"1\"\u001b[0m \u001b[33melse\u001b[0m \u001b[31m\"1\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value += is not a member of String - did you mean ans.!=?\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978884
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val c = a.replaceAll(\"1\", \"\").replaceAll(\"0\", \"\").foldLeft((a, b)) { case ((d, c), x) =>\n            if (c == \"1\") d + \"1\" else d + \"0\"\n        }\n        val d = b.replaceAll(\"1\", \"\").replaceAll(\"0\", \"\").foldLeft((a, b)) { case ((d, c), x) =>\n            if (c == \"1\") d + \"1\" else d + \"0\"\n        }\n        c == d ? \"1\" : \"0\"\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjvkeujyj.scala:10:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            \u001b[33mif\u001b[0m (c == \u001b[31m\"1\"\u001b[0m) d + \u001b[31m\"1\"\u001b[0m \u001b[33melse\u001b[0m d + \u001b[31m\"0\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    String\n\u001b[31m   |\u001b[0m                          Required: \u001b[1m\u001b[32m(\u001b[0m\u001b[1m\u001b[32mString\u001b[0m\u001b[1m\u001b[32m,\u001b[0m\u001b[1m\u001b[32m \u001b[0mString\u001b[1m\u001b[32m)\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjvkeujyj.scala:10:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m            \u001b[33mif\u001b[0m (c == \u001b[31m\"1\"\u001b[0m) d + \u001b[31m\"1\"\u001b[0m \u001b[33melse\u001b[0m d + \u001b[31m\"0\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Found:    String\n\u001b[31m   |\u001b[0m                                       Required: \u001b[1m\u001b[32m(\u001b[0m\u001b[1m\u001b[32mString\u001b[0m\u001b[1m\u001b[32m,\u001b[0m\u001b[1m\u001b[32m \u001b[0mString\u001b[1m\u001b[32m)\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjvkeujyj.scala:13:26 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mif\u001b[0m (c == \u001b[31m\"1\"\u001b[0m) d + \u001b[31m\"1\"\u001b[0m \u001b[33melse\u001b[0m d + \u001b[31m\"0\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Found:    String\n\u001b[31m   |\u001b[0m                          Required: \u001b[1m\u001b[32m(\u001b[0m\u001b[1m\u001b[32mString\u001b[0m\u001b[1m\u001b[32m,\u001b[0m\u001b[1m\u001b[32m \u001b[0mString\u001b[1m\u001b[32m)\u001b[0m\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpjvkeujyj.scala:13:39 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mif\u001b[0m (c == \u001b[31m\"1\"\u001b[0m) d + \u001b[31m\"1\"\u001b[0m \u001b[33melse\u001b[0m d + \u001b[31m\"0\"\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       Found:    String\n\u001b[31m   |\u001b[0m                                       Required: ",
      "stdout": "",
      "timestamp": 1659978887
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aSet = a.toIntArray()\n        val bSet = b.toIntArray()\n        val result = mutable.ArrayBuffer(0)\n        for (x <- 0 to aSet.size - 1) {\n            val xor = aSet(x) | bSet(x)\n            result.append(xor)\n        }\n        result.mkString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyy4ogtal.scala:9:21 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36maSet\u001b[0m = a.toIntArray()\n\u001b[31m\u001b[31m  |\u001b[0m                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                   value toIntArray is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpyy4ogtal.scala:10:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mbSet\u001b[0m = b.toIntArray()\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   value toIntArray is not a member of String\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpyy4ogtal.scala:11:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mresult\u001b[0m = mutable.ArrayBuffer(\u001b[31m0\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978887
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var x = 0\n        var y = 0\n        val arrayOfA = a.toIntArray.sortWith(_ < _).reverse\n        val arrayOfB = b.toIntArray.sortWith(_ < _).reverse\n        while (x < arrayOfA.length && y < arrayOfB.length) {\n            if (arrayOfA(x) == arrayOfB(y)) {\n                x += 1\n                y += 1\n            } else {\n                x += 1\n                y += 1\n                x = 0\n                y = 0\n            }\n        }\n        val result = arrayOfA.slice(0, x) ++ arrayOfB.slice(0, y)\n        result.foldLeft(\"\")((x, c) => x + c.toString)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwi7t0920.scala:11:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marrayOfA\u001b[0m = a.toIntArray.sortWith(_ < _).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value toIntArray is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpwi7t0920.scala:12:25 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36marrayOfB\u001b[0m = b.toIntArray.sortWith(_ < _).reverse\n\u001b[31m\u001b[31m   |\u001b[0m                       ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                       value toIntArray is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978886
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        // TODO: Write your code here\n        val aHash = a.hashCode()\n        val bHash = b.hashCode()\n        if(a contains \"0\" && b contains \"0\")\n            0\n        else if(aHash == bHash)\n            a\n        else\n            \"0\"\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpmswtvgyk.scala:12:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mif\u001b[0m(a contains \u001b[31m\"0\"\u001b[0m && b contains \u001b[31m\"0\"\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                      value && is not a member of String\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpmswtvgyk.scala:13:12 --------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[31m0\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m            ^\u001b[0m\n\u001b[31m   |\u001b[0m            Found:    (\u001b[31m0\u001b[0m : Int)\n\u001b[31m   |\u001b[0m            Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978887
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val aVal = a.toInt\n        val bVal = b.toInt\n        val resultVal = aVal ^ bVal\n        Integer.toString(resultVal)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpfedlc70q.scala:15)\n\tat Problem.main(tmpfedlc70q.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978887
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var res: String = null\n        if (b.length != a.length) throw new IllegalArgumentException(\"Invalid StringXor input.\")\n        val m = b.toInt\n        val n = a.toInt\n        for (i <- 0 until m) {\n            var x = m.toInt\n            x ^= n.toInt\n            n ^= x.toInt\n            x ^= n.toInt\n            res = (x + n).asInstanceOf[String]\n        }\n        res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp4stctzx_.scala:16:14 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m            n ^= x.toInt\n\u001b[31m\u001b[31m   |\u001b[0m            ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m            value ^= is not a member of Int - did you mean n.!=?\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978889
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var result = 0\n        var x = a.toInt - b.toInt\n        var y = a.toInt - b.toInt\n        var z = a.toInt - b.toInt\n        while (x > 0)\n        {\n            result += (x % 2)\n            x /= 2\n        }\n        while (y > 0)\n        {\n            result += (y % 2)\n            y /= 2\n        }\n        while (z > 0)\n        {\n            result += (z % 2)\n            z /= 2\n        }\n        return result + a.toString + b.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmpsyqbl8hr.scala:31)\n\tat Problem.main(tmpsyqbl8hr.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978889
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val bits = a.grouped(2).map { _.toInt }\n        val bits2 = b.grouped(2).map { _.toInt }\n        var result = \"\"\n        for (i <- 0 until bits.len) {\n            val b1 = bits(i) XOR bits2(i)\n            if (b1 == 0) {\n                result += 0\n            } else if (b1 == 1) {\n                result += 1\n            }\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp3_cnvnty.scala:12:31 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m        \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until bits.len) {\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m     value len is not a member of Iterator[Int] - did you mean bits.min?\n\u001b[31m\u001b[31m-- [E050] Type Error: /tmp/tmp3_cnvnty.scala:13:21 -----------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m            \u001b[33mval\u001b[0m \u001b[36mb1\u001b[0m = bits(i) XOR bits2(i)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     \u001b[33mvalue\u001b[0m \u001b[35mbits\u001b[0m does not take parameters\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978890
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      val aHashSet = mutable.HashSet(a)\n      val bHashSet = mutable.HashSet(b)\n      \n      val xorString = new mutable.StringBuilder\n      \n      aHashSet.foreach { c =>\n        bHashSet.foreach { d =>\n          if (c == d) xorString.append(c)\n        }\n      }\n      \n      xorString.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8_hxxlc6.scala:9:21 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36maHashSet\u001b[0m = mutable.HashSet(a)\n\u001b[31m\u001b[31m  |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                     Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8_hxxlc6.scala:10:21 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mbHashSet\u001b[0m = mutable.HashSet(b)\n\u001b[31m\u001b[31m   |\u001b[0m                     ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                     Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp8_hxxlc6.scala:12:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mxorString\u001b[0m = \u001b[33mnew\u001b[0m mutable.StringBuilder\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978887
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        if(a.length != b.length) throw new IllegalArgumentException\n        val result = new StringBuilder\n        for(x <- a) result.append(x ^ (b(x) take 1))\n        return result.toString\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpo9vyavtx.scala:11:44 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mfor\u001b[0m(x <- a) result.append(x ^ (b(x) take \u001b[31m1\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m                                       ^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                      value take is not a member of Char\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978890
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val bits = b.toInt\n        def xor(a : Int, b : Int) : Int = \n            a & (~b) match {\n                case 0 => 0\n                case 1 => a\n                case _ => xor(a >> 1, b >> 1) | xor(a & 1, b & 1)\n            }\n        val xors = mutable.HashMap.empty[Int, Int]\n        val aBits = a.toInt\n        val bBits = bits.toInt\n        (1 to bits).foreach( i => {\n            val idx = aBits + i\n            xors.update(xor(idx, idx), idx) \n        })\n        xors.toList.map( x => x._1 -> x._2 ).groupBy( x => x ).map( x => x._1 -> x._2.size ).toList\n            .map(x => x._1 -> x._2.max).toMap\n            .sortBy( x => -x._2 ).map( x => x._1 -> x._2 ).mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpgc5om557.scala:16:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mxors\u001b[0m = mutable.HashMap.empty[\u001b[35mInt\u001b[0m, \u001b[35mInt\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978889
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var bitmap : BitSet = BitSet(a.length)\n        for(bit <- 0 until a.length)\n            bitmap ^= BitSet(a(bit).toInt, b.toInt)\n        bitmap.mkString(\"\")\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmp79o4mguq.scala:15)\n\tat Problem.main(tmp79o4mguq.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978891
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        def stringXor(a: Int, b: Int) : Int = a xor b\n        val m = a.length\n        val n = b.length\n        if (m != n)\n            throw new IllegalArgumentException\n        val xors = mutable.MutableArray.fill(n){0}\n        for (i<- 0 until n) xors(i) = stringXor(a(i), b(i))\n        a.grouped(m).map(x => x.mkString(\"\").padTo(n, 0))\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp7yrg6l4x.scala:9:48 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mdef\u001b[0m \u001b[36mstringXor\u001b[0m(\u001b[36ma\u001b[0m: \u001b[35mInt\u001b[0m, \u001b[36mb\u001b[0m: \u001b[35mInt\u001b[0m) : \u001b[35mInt\u001b[0m = a xor b\n\u001b[31m\u001b[31m  |\u001b[0m                                              ^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                                          value xor is not a member of Int\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmp7yrg6l4x.scala:14:19 ------------------------\u001b[0m\u001b[0m\n\u001b[31m14 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mxors\u001b[0m = mutable.MutableArray.fill(n){\u001b[31m0\u001b[0m}\n\u001b[31m\u001b[31m   |\u001b[0m                   ^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                   Not found: mutable\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmp7yrg6l4x.scala:16:24 --------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m        a.grouped(m).map(\u001b[36mx\u001b[0m => x.mkString(\u001b[31m\"\"\u001b[0m).padTo(n, \u001b[31m0\u001b[0m))\n\u001b[31m\u001b[31m   |\u001b[0m        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m        Found:    Iterator[IndexedSeq[AnyVal]]\n\u001b[31m   |\u001b[0m        Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n3 errors found\n",
      "stdout": "",
      "timestamp": 1659978891
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val map = mutable.HashMap[Char, String]()\n        var index = 0\n        for (c <- a.toCharArray)\n            map.put(c, \"\")\n        for (c <- b.toCharArray)\n            map.put(c, \"\")\n        while (index < a.length) { map.get(a(index)) = b(index); index += 1; }\n        var result = \"\"\n        for (c <- map.values.toList)\n            result += c\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmptvs7zwjb.scala:9:18 -------------------------\u001b[0m\u001b[0m\n\u001b[31m9 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mmap\u001b[0m = mutable.HashMap[\u001b[35mChar\u001b[0m, \u001b[35mString\u001b[0m]()\n\u001b[31m\u001b[31m  |\u001b[0m                  ^^^^^^^\u001b[0m\n\u001b[31m  |\u001b[0m                  Not found: mutable\n\u001b[31m  |\u001b[0m\n\u001b[31m  |\u001b[0m longer explanation available when compiling with `-explain`\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978889
    },
    {
      "exit_code": 0,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var res = \"\"\n        var i = 0\n        while (i < a.length) {\n            res = res + b.charAt(i) + a.charAt(i)\n            i += 1\n        }\n        return res\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "Exception",
      "stderr": "java.lang.AssertionError: assertion failed\n\tat scala.runtime.Scala3RunTime$.assertFailed(Scala3RunTime.scala:11)\n\tat Problem$.main(tmph35meijh.scala:18)\n\tat Problem.main(tmph35meijh.scala)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:77)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:568)\n\tat dotty.tools.runner.RichClassLoader$.run$extension$$anonfun$1(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.ScalaClassLoader$.asContext(ScalaClassLoader.scala:80)\n\tat dotty.tools.runner.RichClassLoader$.dotty$tools$runner$RichClassLoader$$$asContext$extension(ScalaClassLoader.scala:18)\n\tat dotty.tools.runner.RichClassLoader$.run$extension(ScalaClassLoader.scala:36)\n\tat dotty.tools.runner.CommonRunner.run(ObjectRunner.scala:23)\n\tat dotty.tools.runner.CommonRunner.run$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.run(ObjectRunner.scala:48)\n\tat dotty.tools.runner.CommonRunner.runAndCatch(ObjectRunner.scala:30)\n\tat dotty.tools.runner.CommonRunner.runAndCatch$(ObjectRunner.scala:13)\n\tat dotty.tools.runner.ObjectRunner$.runAndCatch(ObjectRunner.scala:48)\n\tat dotty.tools.MainGenericRunner$.run$1(MainGenericRunner.scala:213)\n\tat dotty.tools.MainGenericRunner$.main(MainGenericRunner.scala:268)\n\tat dotty.tools.MainGenericRunner.main(MainGenericRunner.scala)\n",
      "stdout": "",
      "timestamp": 1659978891
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        def bitVector(bv : String) : List[Int] = {\n            bv.length match {\n                case 0 => Nil\n                case _ =>\n                    var bv1 = bv\n                    bv1 += (bv1.head + 1).toString\n                    bv1 += (bv1.tail.reverse.head + 1).toString\n                    bv1.toList match {\n                        case List() =>\n                            Nil\n                        case x :: xs =>\n                            val y = x.toInt\n                            x :: bitVector(xs.filter(_ != y))\n                    }\n            }\n        }\n        var xOrBv = bitVector(a) ::: bitVector(b)\n        var result : String = \"\"\n        var xOr : Int = 0\n        var xOrBvIndex : Int = 0\n        var bvIndex : Int = 0\n        while (xOrBvIndex < xOrBv.length) {\n            xOr = xOrBv(xOrBvIndex)\n            xOrBvIndex += 1\n            xOrBv(xOrBvIndex) match {\n                case 0 => break\n                case x => {\n                    bvIndex = xOrBvIndex + x\n                    xOrBvIndex = xOrBvIndex + x\n                    result = result + xOr.toChar\n                    bvIndex = xOrBvIndex + x\n                }\n            }\n        }\n        result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E007] Type Mismatch Error: /tmp/tmpt1v9mon2.scala:21:52 --------------------\u001b[0m\u001b[0m\n\u001b[31m21 |\u001b[0m                            x :: bitVector(xs.filter(_ != y))\n\u001b[31m\u001b[31m   |\u001b[0m                                           ^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                           Found:    List[Char]\n\u001b[31m   |\u001b[0m                                           Required: String\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E006] Not Found Error: /tmp/tmpt1v9mon2.scala:34:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m34 |\u001b[0m                \u001b[33mcase\u001b[0m \u001b[31m0\u001b[0m => break\n\u001b[31m\u001b[31m   |\u001b[0m                          ^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                          Not found: break\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978891
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        val xa = a.toInt\n        val xb = b.toInt\n        val xc = xa xor xb\n        val xd = xc.toInt\n        xd.toString(2)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpzmwnq4sf.scala:11:20 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m        \u001b[33mval\u001b[0m \u001b[36mxc\u001b[0m = xa xor xb\n\u001b[31m\u001b[31m   |\u001b[0m                 ^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                 value xor is not a member of Int\n1 error found\n",
      "stdout": "",
      "timestamp": 1659978891
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      val aArray = a.toCharArray\n      val bArray = b.toCharArray\n      var result = 0\n      for (i <- 0 until aArray.length) result = result | (aArray(i) xor bArray(i))\n      result.toString(2)\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmpf56atq54.scala:12:68 ------------------------\u001b[0m\u001b[0m\n\u001b[31m12 |\u001b[0m      \u001b[33mfor\u001b[0m (i <- \u001b[31m0\u001b[0m until aArray.length) result = result | (aArray(i) xor bArray(i))\n\u001b[31m\u001b[31m   |\u001b[0m                                                          ^^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                                       value xor is not a member of Char\n\u001b[31m\u001b[31m-- Error: /tmp/tmpf56atq54.scala:13:22 -----------------------------------------\u001b[0m\u001b[0m\n\u001b[31m13 |\u001b[0m      result.toString(\u001b[31m2\u001b[0m)\n\u001b[31m\u001b[31m   |\u001b[0m                      ^\u001b[0m\n\u001b[31m   |\u001b[0m         too many arguments for \u001b[33mmethod\u001b[0m \u001b[35mtoString\u001b[0m in \u001b[33mclass\u001b[0m \u001b[35mAny\u001b[0m: (): String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978891
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n      // Convert strings to bits without leading zeroes\n      val a_bit_array = a.toIntArray\n      val b_bit_array = b.toIntArray\n\n      // Bitwise OR\n      val result_array = a_bit_array | b_bit_array\n\n      // Convert back to string with leading zeroes\n      val result_string = result_array.toString(2).padToLength(a_bit_array.length, 0).padToLength(b_bit_array.length, 0, '0')\n      result_string\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_jfrbfc0.scala:10:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m10 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36ma_bit_array\u001b[0m = a.toIntArray\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value toIntArray is not a member of String\n\u001b[31m\u001b[31m-- [E008] Not Found Error: /tmp/tmp_jfrbfc0.scala:11:26 ------------------------\u001b[0m\u001b[0m\n\u001b[31m11 |\u001b[0m      \u001b[33mval\u001b[0m \u001b[36mb_bit_array\u001b[0m = b.toIntArray\n\u001b[31m\u001b[31m   |\u001b[0m                        ^^^^^^^^^^^^\u001b[0m\n\u001b[31m   |\u001b[0m                        value toIntArray is not a member of String\n2 errors found\n",
      "stdout": "",
      "timestamp": 1659978892
    },
    {
      "exit_code": 1,
      "program": "import scala.math._\nimport scala.collection.mutable._\nobject Problem {\n    // Input are two strings a and b consisting only of 1s and 0s.\n    // Perform binary XOR on these inputs and return result also as a string.\n    // >>> stringXor((\"010\"), (\"110\"))\n    // (\"100\")\n    def stringXor(a : String, b : String) : String = {\n        var result = \"0\"\n        var carry = 0\n        var i = a.length - 1\n        var j = b.length - 1\n        while i >= 0 || j >= 0 {\n            if(i>=0){\n                if(b[j] == '1'){\n                    result += a[i--]\n                    carry++\n                }\n                else{\n                    result += a[i--] + '0'\n                    carry = 0\n                }\n            }\n            if(j>=0){\n                if(a[i] == '1'){\n                    result += b[j--]\n                    carry++\n                }\n                else{\n                    result += b[j--] + '0'\n                    carry = 0\n                }\n            }\n        }\n        if(carry > 0){\n            result += '1' + ('0' * (carry - 1))\n        }\n        return result\n    }\n    def main(args: Array[String]) = {\n    assert(stringXor((\"111000\"), (\"101010\")).equals((\"010010\")));\n    assert(stringXor((\"1\"), (\"1\")).equals((\"0\")));\n    assert(stringXor((\"0101\"), (\"0000\")).equals((\"0101\")));\n    }\n\n}\n",
      "status": "SyntaxError",
      "stderr": "\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp34h9o4o2.scala:16:35 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m16 |\u001b[0m                    result += a[\u001b[35mi--\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp34h9o4o2.scala:17:27 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m17 |\u001b[0m                    carry++\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp34h9o4o2.scala:20:35 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m20 |\u001b[0m                    result += a[\u001b[35mi--\u001b[0m] + \u001b[31m'0'\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp34h9o4o2.scala:26:35 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m26 |\u001b[0m                    result += b[\u001b[35mj--\u001b[0m]\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E018] Syntax Error: /tmp/tmp34h9o4o2.scala:27:27 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m27 |\u001b[0m                    carry++\n\u001b[31m\u001b[31m   |\u001b[0m                           ^\u001b[0m\n\u001b[31m   |\u001b[0m                           expression expected but \u001b[31m'}'\u001b[0m found\n\u001b[31m   |\u001b[0m\n\u001b[31m   |\u001b[0m longer explanation available when compiling with `-explain`\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp34h9o4o2.scala:30:35 ---------------------------\u001b[0m\u001b[0m\n\u001b[31m30 |\u001b[0m                    result += b[\u001b[35mj--\u001b[0m] + \u001b[31m'0'\u001b[0m\n\u001b[31m\u001b[31m   |\u001b[0m                                   ^\u001b[0m\n\u001b[31m   |\u001b[0m                                   an identifier expected, but ']' found\n\u001b[31m\u001b[31m-- [E040] Syntax Error: /tmp/tmp34h9o4o2.scala:35:8 --------------------",
      "stdout": "",
      "timestamp": 1659978892
    }
  ]
}