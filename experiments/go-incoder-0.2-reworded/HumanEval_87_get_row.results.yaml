language: go_test.go
name: HumanEval_87_get_row
results:
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", j)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][1] > result[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprk_gw4i1_test.go:35:5:\
    \ undefined: sort\n/tmp/tmprk_gw4i1_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmprk_gw4i1_test.go:38:5:\
    \ undefined: sort\n/tmp/tmprk_gw4i1_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmprk_gw4i1_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprk_gw4i1_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmprk_gw4i1_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprk_gw4i1_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmprk_gw4i1_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][1] > result[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwu57p3s_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpkwu57p3s_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpkwu57p3s_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpkwu57p3s_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpkwu57p3s_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkwu57p3s_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkwu57p3s_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkwu57p3s_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpkwu57p3s_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][1] > result[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwu57p3s_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpkwu57p3s_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpkwu57p3s_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpkwu57p3s_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpkwu57p3s_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkwu57p3s_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkwu57p3s_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkwu57p3s_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpkwu57p3s_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n   \
    \ sort.Sort(sort.Reverse(sort.IntSlice(result)))\n    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbp95jj9n_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpbp95jj9n_test.go:36:5: undefined: sort\n/tmp/tmpbp95jj9n_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpbp95jj9n_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpbp95jj9n_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpbp95jj9n_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpbp95jj9n_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n        for j := 0; j < len(lst[i]); j++ {\n            result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    for i := 0; i < len(result); i++ {\n        result[i] = result[i][1:]\n\
    \    }\n    for i := 0; i < len(result); i++ {\n        result[i] = result[i][0:1]\n\
    \    }\n    for i := 0; i < len(result); i++ {\n        for j := 0; j < len(result[i]);\
    \ j++ {\n            if result[i][j] == fmt.Sprintf(\"(%d, %d)\", i+1, j+1) {\n\
    \                return result\n            }\n        }\n    }\n    return nil\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqhfkhq2r_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpqhfkhq2r_test.go:32:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqhfkhq2r_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpqhfkhq2r_test.go:35:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqhfkhq2r_test.go:60:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqhfkhq2r_test.go:61:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqhfkhq2r_test.go:62:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqhfkhq2r_test.go:65:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqhfkhq2r_test.go:65:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][1] > result[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwu57p3s_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpkwu57p3s_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpkwu57p3s_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpkwu57p3s_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpkwu57p3s_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkwu57p3s_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkwu57p3s_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkwu57p3s_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpkwu57p3s_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    row := make([][]interface{}, len(lst))\n\
    \    for i := range row {\n        row[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range row {\n        for j := range row[i] {\n          \
    \  row[i][j] = lst[i][j]\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(row[0])))\n    for i := range row {\n\
    \        row[i] = row[i][x:]\n    }\n    return row\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplnohpfej_test.go:33:5:\
    \ undefined: sort\n/tmp/tmplnohpfej_test.go:34:5: undefined: sort\n/tmp/tmplnohpfej_test.go:48:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmplnohpfej_test.go:49:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmplnohpfej_test.go:50:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmplnohpfej_test.go:53:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmplnohpfej_test.go:53:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    i := 0\n    for _, row := range lst {\n        j := 0\n        for\
    \ _, val := range row {\n            if val == x {\n                result[i][j]\
    \ = i\n                j++\n            }\n        }\n        i++\n    }\n   \
    \ sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe7lse68g_test.go:39:5:\
    \ undefined: sort\n/tmp/tmpe7lse68g_test.go:39:15: undefined: byRow\n/tmp/tmpe7lse68g_test.go:40:5:\
    \ undefined: sort\n/tmp/tmpe7lse68g_test.go:40:15: undefined: byCol\n/tmp/tmpe7lse68g_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpe7lse68g_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpe7lse68g_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpe7lse68g_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpe7lse68g_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        row_result := make([]interface{}, len(row))\n\
    \        for j, val := range row {\n            if val == x {\n              \
    \  row_result[j] = fmt.Sprintf(\"%d\", j)\n            }\n        }\n        result[i]\
    \ = row_result\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i][1] > result[j][1]\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpokvubvrn_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpokvubvrn_test.go:35:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpokvubvrn_test.go:37:5:\
    \ undefined: sort\n/tmp/tmpokvubvrn_test.go:38:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpokvubvrn_test.go:50:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpokvubvrn_test.go:51:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpokvubvrn_test.go:52:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpokvubvrn_test.go:55:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpokvubvrn_test.go:55:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][1] > result[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwu57p3s_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpkwu57p3s_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpkwu57p3s_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpkwu57p3s_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpkwu57p3s_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkwu57p3s_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkwu57p3s_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkwu57p3s_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpkwu57p3s_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq28t28hg_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpq28t28hg_test.go:35:15: undefined: byRow\n/tmp/tmpq28t28hg_test.go:36:5:\
    \ undefined: sort\n/tmp/tmpq28t28hg_test.go:36:15: undefined: byCol\n/tmp/tmpq28t28hg_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpq28t28hg_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpq28t28hg_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpq28t28hg_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpq28t28hg_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i+1, j+1)\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    for i := 0; i < len(result);\
    \ i++ {\n        sort.Sort(sort.Reverse(sort.IntSlice(result[i])))\n    }\n  \
    \  for i := 0; i < len(result); i++ {\n        for j := 0; j < len(result[i]);\
    \ j++ {\n            if result[i][j] == fmt.Sprintf(\"(%d, %d)\", i+1, j+1) {\n\
    \                result[i] = append(result[i], fmt.Sprintf(\"(%d, %d)\", i+1,\
    \ j+1))\n            }\n        }\n    }\n    for i := 0; i < len(result); i++\
    \ {\n        if result[i][0] == fmt.Sprintf(\"(%d, %d)\", i+1, 0) {\n        \
    \    result[i] = append(result[i], fmt.Sprintf(\"(%d, %d)\", i+1, 0))\n      \
    \  }\n    }\n    for i := 0; i < len(result); i++ {\n        if result[i][0] ==\
    \ fmt.Sprintf(\"(%d, %d)\", 0, i+1) {\n            result[i] = append(result[i],\
    \ fmt.Sprintf(\"(%d, %d)\", 0, i+1))\n        }\n    }\n    for i := 0; i < len(result);\
    \ i++ {\n        if result[i][0] == fmt.Sprintf(\"(%d, %d)\", 0, 0) {\n      \
    \      result[i] = append(result[i], fmt.Sprintf(\"(%d, %d)\", 0, 0))\n      \
    \  }\n    }\n    for i := 0; i < len(result); i++ {\n        if result[i][0] ==\
    \ fmt.Sprintf(\"(%d, %d)\", i+1, i+1) {\n            result[i] = append(result[i],\
    \ fmt.Sprintf(\"(%d, %d)\", i+1, i+1))\n        }\n    }\n    for i := 0; i <\
    \ len(result); i++ {\n        if result[i][0] == fmt.Sprintf(\"(%d, %d)\", i+1,\
    \ 0) {\n            result[i] = append(result[i], fmt.Sprintf(\"(%d, %d)\", i+1,\
    \ 0))\n        }\n    }\n    for i := 0; i < len(result); i++ {\n        if result[i][0]\
    \ == fmt.Sprintf(\"(%d, %d)\", 0, i+1) {\n            result[i] = append(result[i],\
    \ fmt.Sprintf(\"(%d, %d)\", 0, i+1))\n        }\n    }\n    for i := 0; i < len(result);\
    \ i++ {\n        if result[i][0] == fmt.Sprintf(\"(%d, %d)\", 0, 0) {\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzzlbo3l0_test.go:78:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var result []interface{}\n        for _, val :=\
    \ range row {\n            if val == x {\n                result = append(result,\
    \ val)\n            }\n        }\n        result = append(result, 0)\n       \
    \ result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp85n2i9xl_test.go:126:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        result := append(result, get_row_helper(row,\
    \ x))\n    }\n    sort.Sort(byRow(result))\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8lybya8j_test.go:26:9:\
    \ result declared but not used\n/tmp/tmp8lybya8j_test.go:26:34: undefined: get_row_helper\n\
    /tmp/tmp8lybya8j_test.go:28:5: undefined: sort\n/tmp/tmp8lybya8j_test.go:28:15:\
    \ undefined: byRow\n/tmp/tmp8lybya8j_test.go:39:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp8lybya8j_test.go:40:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp8lybya8j_test.go:41:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp8lybya8j_test.go:44:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp8lybya8j_test.go:44:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        row_result := make([]interface{}, len(row))\n\
    \        for j, cell := range row {\n            if cell == x {\n            \
    \    row_result[j] = fmt.Sprintf(\"%d\", j)\n            }\n        }\n      \
    \  result[i] = row_result\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return len(result[i]) < len(result[j])\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return len(result[j]) < len(result[i])\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj08fwf1e_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpj08fwf1e_test.go:37:5: undefined: sort\n/tmp/tmpj08fwf1e_test.go:50:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpj08fwf1e_test.go:51:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpj08fwf1e_test.go:52:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpj08fwf1e_test.go:55:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpj08fwf1e_test.go:55:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    for i := range r {\n        for j := range r[i] {\n            r[i][j]\
    \ = lst[i][j]\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(row(r))))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(col(r))))\n    r := make([][]interface{},\
    \ len(r))\n    for i := range r {\n        r[i] = make([]interface{}, len(r[i]))\n\
    \    }\n    for i := range r {\n        for j := range r[i] {\n            r[i][j]\
    \ = row(r[i])[j]\n        }\n    }\n    for i := range r {\n        for j := range\
    \ r[i] {\n            if r[i][j] == x {\n                return r\n          \
    \  }\n        }\n    }\n    return nil\n}\n\nfunc TestGet_Row(t *testing.T) {\n\
    \  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp1h4kjmep_test.go:33:5:\
    \ undefined: sort\n/tmp/tmp1h4kjmep_test.go:33:42: undefined: row\n/tmp/tmp1h4kjmep_test.go:34:5:\
    \ undefined: sort\n/tmp/tmp1h4kjmep_test.go:34:42: undefined: col\n/tmp/tmp1h4kjmep_test.go:35:7:\
    \ no new variables on left side of :=\n/tmp/tmp1h4kjmep_test.go:41:23: undefined:\
    \ row\n/tmp/tmp1h4kjmep_test.go:61:132: cannot use []interface{}{\u2026} (value\
    \ of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1h4kjmep_test.go:62:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp1h4kjmep_test.go:63:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp1h4kjmep_test.go:66:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp1h4kjmep_test.go:66:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    for i := range r {\n        for j := range r[i] {\n            r[i][j]\
    \ = lst[i][j]\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(row(r))))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(col(r))))\n    r := make([][]interface{},\
    \ len(r))\n    for i := range r {\n        r[i] = make([]interface{}, len(r[i]))\n\
    \    }\n    for i := range r {\n        for j := range r[i] {\n            r[i][j]\
    \ = row(r[i][j])\n            r[i][j] = col(r[i][j])\n        }\n    }\n    for\
    \ i := range r {\n        for j := range r[i] {\n            if r[i][j] == x {\n\
    \                return r\n            }\n        }\n    }\n    return nil\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpednt0hxt_test.go:33:5:\
    \ undefined: sort\n/tmp/tmpednt0hxt_test.go:33:42: undefined: row\n/tmp/tmpednt0hxt_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpednt0hxt_test.go:34:42: undefined: col\n/tmp/tmpednt0hxt_test.go:35:7:\
    \ no new variables on left side of :=\n/tmp/tmpednt0hxt_test.go:41:23: undefined:\
    \ row\n/tmp/tmpednt0hxt_test.go:42:23: undefined: col\n/tmp/tmpednt0hxt_test.go:62:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpednt0hxt_test.go:63:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpednt0hxt_test.go:64:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpednt0hxt_test.go:64:232: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if x == lst[i][j] {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i+1, j+1)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j\
    \ int) bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2jhz9qo8_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp2jhz9qo8_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp2jhz9qo8_test.go:38:5:\
    \ undefined: sort\n/tmp/tmp2jhz9qo8_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp2jhz9qo8_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp2jhz9qo8_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp2jhz9qo8_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp2jhz9qo8_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp2jhz9qo8_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9or3ocgl_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp9or3ocgl_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp9or3ocgl_test.go:38:5:\
    \ undefined: sort\n/tmp/tmp9or3ocgl_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp9or3ocgl_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9or3ocgl_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9or3ocgl_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9or3ocgl_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp9or3ocgl_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var result []interface{}\n        for _, val :=\
    \ range row {\n            if val == x {\n                result = append(result,\
    \ val)\n            }\n        }\n        if result != nil {\n            result\
    \ = append(result, 0)\n        }\n        result = append(result, 0)\n       \
    \ result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnutfvtgs_test.go:127:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        if result[i][0] < result[j][0] {\n            return true\n\
    \        }\n        return false\n    })\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        if result[i][1] > result[j][1] {\n            return true\n\
    \        }\n        return false\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps6hheimp_test.go:35:5:\
    \ undefined: sort\n/tmp/tmps6hheimp_test.go:36:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmps6hheimp_test.go:41:5:\
    \ undefined: sort\n/tmp/tmps6hheimp_test.go:42:12: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmps6hheimp_test.go:57:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps6hheimp_test.go:58:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmps6hheimp_test.go:59:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps6hheimp_test.go:62:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmps6hheimp_test.go:62:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if x == lst[i][j] {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][1] > result[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3cfllqv_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpx3cfllqv_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpx3cfllqv_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpx3cfllqv_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpx3cfllqv_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx3cfllqv_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx3cfllqv_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx3cfllqv_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx3cfllqv_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        row_result := make([]interface{}, len(row))\n\
    \        for j, val := range row {\n            if val == x {\n              \
    \  row_result[j] = fmt.Sprintf(\"%d\", j)\n            }\n        }\n        result[i]\
    \ = row_result\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n  \
    \  sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgkkmgggx_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpgkkmgggx_test.go:35:5: undefined: sort\n/tmp/tmpgkkmgggx_test.go:46:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpgkkmgggx_test.go:47:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpgkkmgggx_test.go:48:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpgkkmgggx_test.go:51:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpgkkmgggx_test.go:51:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        if result[i][0] < result[j][0] {\n            return true\n\
    \        }\n        if result[i][0] > result[j][0] {\n            return false\n\
    \        }\n        if result[i][1] > result[j][1] {\n            return true\n\
    \        }\n        if result[i][1] < result[j][1] {\n            return false\n\
    \        }\n        return true\n    })\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        if result[i][1] > result[j][1] {\n            return true\n\
    \        }\n        if result[i][1] < result[j][1] {\n            return false\n\
    \        }\n        return true\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6pqt8ttv_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp6pqt8ttv_test.go:36:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp6pqt8ttv_test.go:39:12:\
    \ invalid operation: result[i][0] > result[j][0] (operator > not defined on interface)\n\
    /tmp/tmp6pqt8ttv_test.go:42:12: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmp6pqt8ttv_test.go:45:12: invalid\
    \ operation: result[i][1] < result[j][1] (operator < not defined on interface)\n\
    /tmp/tmp6pqt8ttv_test.go:50:5: undefined: sort\n/tmp/tmp6pqt8ttv_test.go:51:12:\
    \ invalid operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmp6pqt8ttv_test.go:54:12: invalid operation: result[i][1] < result[j][1]\
    \ (operator < not defined on interface)\n/tmp/tmp6pqt8ttv_test.go:69:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmp6pqt8ttv_test.go:70:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp6pqt8ttv_test.go:70:207:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n        for j := 0; j < len(lst[i]); j++ {\n            result[i][j]\
    \ = lst[i][j]\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][1] > result[j][1]\n    })\n    for i\
    \ := 0; i < len(result); i++ {\n        result[i][0] = i\n    }\n    for i :=\
    \ 0; i < len(result); i++ {\n        result[i][1] = i\n    }\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmkooqsaq_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpmkooqsaq_test.go:32:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpmkooqsaq_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpmkooqsaq_test.go:35:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpmkooqsaq_test.go:53:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmkooqsaq_test.go:54:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmkooqsaq_test.go:55:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmkooqsaq_test.go:58:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpmkooqsaq_test.go:58:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n   \
    \ sort.Slice(result, func(i, j int) bool {\n        return result[i][0] < result[j][0]\n\
    \    })\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][1]\
    \ > result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiuyp8wxv_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpiuyp8wxv_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpiuyp8wxv_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpiuyp8wxv_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpiuyp8wxv_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpiuyp8wxv_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpiuyp8wxv_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpiuyp8wxv_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpiuyp8wxv_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if x == lst[i][j] {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][1] > result[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3cfllqv_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpx3cfllqv_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpx3cfllqv_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpx3cfllqv_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpx3cfllqv_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx3cfllqv_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx3cfllqv_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx3cfllqv_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx3cfllqv_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        row_result := make([]interface{}, len(row))\n\
    \        for j, val := range row {\n            if val == x {\n              \
    \  row_result[j] = fmt.Sprintf(\"%d\", j)\n            }\n        }\n        result[i]\
    \ = row_result\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i][1] > result[j][1]\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpokvubvrn_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpokvubvrn_test.go:35:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpokvubvrn_test.go:37:5:\
    \ undefined: sort\n/tmp/tmpokvubvrn_test.go:38:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpokvubvrn_test.go:50:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpokvubvrn_test.go:51:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpokvubvrn_test.go:52:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpokvubvrn_test.go:55:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpokvubvrn_test.go:55:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var result []interface{}\n        for _, col :=\
    \ range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{row, col})\n            }\n        }\n        result = append(result,\
    \ []interface{}{row, len(row)})\n        result = append(result, []interface{}{len(row),\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmnzifdo9_test.go:78:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075280
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        result := append(result, []interface{}{row, get_column(row,\
    \ x)})\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][0]\
    \ < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool {\n     \
    \   return result[i][1] > result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkr1dfvvq_test.go:26:9:\
    \ result declared but not used\n/tmp/tmpkr1dfvvq_test.go:26:53: undefined: get_column\n\
    /tmp/tmpkr1dfvvq_test.go:28:5: undefined: sort\n/tmp/tmpkr1dfvvq_test.go:29:16:\
    \ invalid operation: result[i][0] < result[j][0] (operator < not defined on interface)\n\
    /tmp/tmpkr1dfvvq_test.go:31:5: undefined: sort\n/tmp/tmpkr1dfvvq_test.go:32:16:\
    \ invalid operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmpkr1dfvvq_test.go:44:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpkr1dfvvq_test.go:45:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkr1dfvvq_test.go:46:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkr1dfvvq_test.go:49:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpkr1dfvvq_test.go:49:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var result []interface{}\n        for _, val :=\
    \ range row {\n            if val == x {\n                result = append(result,\
    \ val)\n            }\n        }\n        result = append(result, 0)\n       \
    \ result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp85n2i9xl_test.go:126:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if x == lst[i][j] {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0i4tfvv1_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp0i4tfvv1_test.go:36:5: undefined: sort\n/tmp/tmp0i4tfvv1_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0i4tfvv1_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp0i4tfvv1_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp0i4tfvv1_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp0i4tfvv1_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][1] > result[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwu57p3s_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpkwu57p3s_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpkwu57p3s_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpkwu57p3s_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpkwu57p3s_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkwu57p3s_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkwu57p3s_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkwu57p3s_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpkwu57p3s_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        if result[i][0] < result[j][0] {\n            return true\n\
    \        }\n        return false\n    })\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        if result[i][1] > result[j][1] {\n            return true\n\
    \        }\n        return false\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps6hheimp_test.go:35:5:\
    \ undefined: sort\n/tmp/tmps6hheimp_test.go:36:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmps6hheimp_test.go:41:5:\
    \ undefined: sort\n/tmp/tmps6hheimp_test.go:42:12: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmps6hheimp_test.go:57:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps6hheimp_test.go:58:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmps6hheimp_test.go:59:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps6hheimp_test.go:62:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmps6hheimp_test.go:62:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var result []interface{}\n        for _, val :=\
    \ range row {\n            if val == x {\n                result = append(result,\
    \ val)\n            }\n        }\n        result = append(result, row)\n     \
    \   result = append(result, []interface{}{x})\n        result = append(result,\
    \ []interface{}{x})\n        result = append(result, []interface{}{x})\n     \
    \   result = append(result, []interface{}{x})\n        result = append(result,\
    \ []interface{}{x})\n        result = append(result, []interface{}{x})\n     \
    \   result = append(result, []interface{}{x})\n        result = append(result,\
    \ []interface{}{x})\n        result = append(result, []interface{}{x})\n     \
    \   result = append(result, []interface{}{x})\n        result = append(result,\
    \ []interface{}{x})\n        result = append(result, []interface{}{x})\n     \
    \   result = append(result, []interface{}{x})\n        result = append(result,\
    \ []interface{}{x})\n        result = append(result, []interface{}{x})\n     \
    \   result = append(result, []interface{}{x})\n        result = append(result,\
    \ []interface{}{x})\n        result = append(result, []interface{}{x})\n     \
    \   result = append(result, []interface{}{x})\n        result = append(result,\
    \ []interface{}{x})\n        result = append(result, []interface{}{x})\n     \
    \   result = append(result, []interface{}{x})\n        result = append(result,\
    \ []interface{}{x})\n        result = append(result, []interface{}{x})\n     \
    \   result = append(result, []interface{}{x})\n        result = append(result,\
    \ []interface{}{x})\n        result = append(result, []interface{}{x})\n     \
    \   result = append(result, []interface{}{x})\n        result = append(result,\
    \ []interface{}{x})\n        result = append(result, []interface{}{x})\n     \
    \   result = append(result, []interface{}{x})\n        result = append(result,\
    \ []interface{}{x})\n        result = append(result, []interface{}{x})\n     \
    \   result = append(result, []interface{}{x})\n        result = append(result,\
    \ []interface{}{x})\n        result = append(result, []interface{}{x})\n     \
    \   result = append(result, []interface{}{x})\n        result = append(result,\
    \ []interface{}{x})\n        result = append(result, []interface{}{x})\n     \
    \   result = append(result, []interface{}{x})\n        result = append(result,\
    \ []interface{}{x})\n        result = append(result, []interface{}{x})\n     \
    \   result = append(result, []interface{}{x})\n        result = append(result,\
    \ []interface{}{x})\n        result = append(result, []interface{}{x})\n     \
    \   result = append(result, []interface{}{x})\n        result = append(\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnmkgiger_test.go:80:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Your code here\n    result := make([][]interface{},\
    \ len(lst))\n    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n   \
    \ sort.Slice(result, func(i, j int) bool {\n        return result[i][0] < result[j][0]\n\
    \    })\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][1]\
    \ > result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp6zuwcf_8_test.go:36:5:\
    \ undefined: sort\n/tmp/tmp6zuwcf_8_test.go:37:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp6zuwcf_8_test.go:39:5:\
    \ undefined: sort\n/tmp/tmp6zuwcf_8_test.go:40:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp6zuwcf_8_test.go:52:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6zuwcf_8_test.go:53:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp6zuwcf_8_test.go:54:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp6zuwcf_8_test.go:57:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp6zuwcf_8_test.go:57:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    for i := range r {\n        for j := range r[i] {\n            r[i][j]\
    \ = lst[i][j]\n        }\n    }\n    r := r[x:]\n    r := r[:len(r)/2]\n    r\
    \ := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r :=\
    \ r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r :=\
    \ r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r :=\
    \ r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r :=\
    \ r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r :=\
    \ r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r :=\
    \ r[:len(r)/2]\n    r := r[:len(\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm3z7ow9c_test.go:79:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var result []interface{}\n        for _, val :=\
    \ range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{row, val})\n            }\n        }\n        result = append(result,\
    \ []interface{}{row, 0})\n        result = append(result, get_row(row, x))\n \
    \       result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, \nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxnqp41ls_test.go:90:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Your code here\n    result := make([][]interface{},\
    \ len(lst))\n    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n        for j := 0; j < len(lst[i]); j++ {\n            if lst[i][j]\
    \ == x {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n            }\n\
    \        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i][1] > result[j][1]\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpai4p8odl_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpai4p8odl_test.go:35:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpai4p8odl_test.go:37:5:\
    \ undefined: sort\n/tmp/tmpai4p8odl_test.go:38:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpai4p8odl_test.go:50:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpai4p8odl_test.go:51:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpai4p8odl_test.go:52:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpai4p8odl_test.go:55:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpai4p8odl_test.go:55:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i+1, j+1)\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return len(result[i]) > len(result[j])\n    })\n    sort.Slice(result[len(result)-1],\
    \ func(i, j int) bool {\n        return len(result[len(result)-1][i]) > len(result[len(result)-1][j])\n\
    \    })\n    result := make([][]interface{}, len(result))\n    for i := 0; i <\
    \ len(result); i++ {\n        result[i] = make([]interface{}, len(result[i]))\n\
    \    }\n    for i := 0; i < len(result); i++ {\n        for j := 0; j < len(result[i]);\
    \ j++ {\n            if result[i][j] == fmt.Sprintf(\"(%d, %d)\", i+1, j+1) {\n\
    \                result[i][j] = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n        \
    \    }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n     \
    \   return len(result[i]) > len(result[j])\n    })\n    sort.Slice(result[len(result)-1],\
    \ func(i, j int) bool {\n        return len(result[len(result)-1][i]) > len(result[len(result)-1][j])\n\
    \    })\n    for i := 0; i < len(result); i++ {\n        for j := 0; j < len(result[i]);\
    \ j++ {\n            if result[i][j] == fmt.Sprintf(\"(%d, %d)\", i+1, j+1) {\n\
    \                result[i][j] = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n        \
    \    }\n        }\n    }\n    for i := 0; i < len(result); i++ {\n        for\
    \ j := 0; j < len(result[i]); j++ {\n            if result[i][j] == fmt.Sprintf(\"\
    (%d, %d)\", i+1, j+1) {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i+1, j+1)\n            }\n        }\n    }\n    for i := 0; i < len(result);\
    \ i++ {\n        for j := 0; j < len(result[i]); j++ {\n            if result[i][j]\
    \ == fmt.Sprintf(\"(%d, %d)\", i+1, j+1) {\n                result[i][j] = fmt.Sprintf(\"\
    (%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n    for i := 0; i < len(result);\
    \ i++ {\n        for j := 0; j < len(result[i]); j++ {\n            if result[i][j\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyk6qfmif_test.go:79:27: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    row\
    \ := 0\n    col := len(lst[0]) - 1\n    for _, row := range lst {\n        result\
    \ := append(result, []interface{}{row, col})\n        if row == x {\n        \
    \    break\n        }\n        col--\n    }\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmper2d_67e_test.go:25:5:\
    \ row declared but not used\n/tmp/tmper2d_67e_test.go:28:9: result declared but\
    \ not used\n/tmp/tmper2d_67e_test.go:29:19: invalid operation: row == x (mismatched\
    \ types []int and int)\n/tmp/tmper2d_67e_test.go:44:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmper2d_67e_test.go:45:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmper2d_67e_test.go:46:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmper2d_67e_test.go:49:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmper2d_67e_test.go:49:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"%d\", i)\n            }\n        }\n    }\n    sort.Sort(byRow(result))\n\
    \    sort.Sort(byCol(result))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpll9h3pfd_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpll9h3pfd_test.go:35:15: undefined: byRow\n/tmp/tmpll9h3pfd_test.go:36:5:\
    \ undefined: sort\n/tmp/tmpll9h3pfd_test.go:36:15: undefined: byCol\n/tmp/tmpll9h3pfd_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpll9h3pfd_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpll9h3pfd_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpll9h3pfd_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpll9h3pfd_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][1] > result[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwu57p3s_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpkwu57p3s_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpkwu57p3s_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpkwu57p3s_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpkwu57p3s_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkwu57p3s_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkwu57p3s_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkwu57p3s_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpkwu57p3s_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n   \
    \ sort.Slice(result, func(i, j int) bool {\n        return result[i][0] < result[j][0]\n\
    \    })\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][1]\
    \ > result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiuyp8wxv_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpiuyp8wxv_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpiuyp8wxv_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpiuyp8wxv_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpiuyp8wxv_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpiuyp8wxv_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpiuyp8wxv_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpiuyp8wxv_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpiuyp8wxv_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        if result[i][0] < result[j][0] {\n            return true\n        }\n\
    \        if result[i][0] > result[j][0] {\n            return false\n        }\n\
    \        if result[i][1] < result[j][1] {\n            return true\n        }\n\
    \        if result[i][1] > result[j][1] {\n            return false\n        }\n\
    \        return false\n    })\n    sort.Slice(result, func(i, j int) bool {\n\
    \        if result[i][1] > result[j][1] {\n            return true\n        }\n\
    \        if result[i][1] < result[j][1] {\n            return false\n        }\n\
    \        return false\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4k5s46d5_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp4k5s46d5_test.go:36:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp4k5s46d5_test.go:39:12:\
    \ invalid operation: result[i][0] > result[j][0] (operator > not defined on interface)\n\
    /tmp/tmp4k5s46d5_test.go:42:12: invalid operation: result[i][1] < result[j][1]\
    \ (operator < not defined on interface)\n/tmp/tmp4k5s46d5_test.go:45:12: invalid\
    \ operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmp4k5s46d5_test.go:50:5: undefined: sort\n/tmp/tmp4k5s46d5_test.go:51:12:\
    \ invalid operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmp4k5s46d5_test.go:54:12: invalid operation: result[i][1] < result[j][1]\
    \ (operator < not defined on interface)\n/tmp/tmp4k5s46d5_test.go:69:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmp4k5s46d5_test.go:70:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp4k5s46d5_test.go:70:207:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n   \
    \ sort.Slice(result, func(i, j int) bool {\n        return len(result[i]) < len(result[j])\n\
    \    })\n    sort.Slice(result, func(i, j int) bool {\n        return len(result[j])\
    \ < len(result[i])\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz99rdln0_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpz99rdln0_test.go:38:5: undefined: sort\n/tmp/tmpz99rdln0_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpz99rdln0_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpz99rdln0_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpz99rdln0_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpz99rdln0_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9or3ocgl_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp9or3ocgl_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp9or3ocgl_test.go:38:5:\
    \ undefined: sort\n/tmp/tmp9or3ocgl_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp9or3ocgl_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9or3ocgl_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9or3ocgl_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9or3ocgl_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp9or3ocgl_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var result []interface{}\n        for _, val :=\
    \ range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{row, val})\n            }\n        }\n        result = append(result,\
    \ []interface{}{row, 0})\n        result = append(result, get_row(row, x))\n \
    \       result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, \nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxnqp41ls_test.go:90:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        result := append(result, get_row_test(row, x))\n\
    \    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmptymoykta_test.go:26:9:\
    \ result declared but not used\n/tmp/tmptymoykta_test.go:26:34: undefined: get_row_test\n\
    /tmp/tmptymoykta_test.go:28:5: undefined: sort\n/tmp/tmptymoykta_test.go:39:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmptymoykta_test.go:40:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmptymoykta_test.go:41:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmptymoykta_test.go:44:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmptymoykta_test.go:44:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if x == lst[i][j] {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        if result[i][0] < result[j][0] {\n            return true\n        }\n\
    \        if result[i][0] > result[j][0] {\n            return false\n        }\n\
    \        if result[i][1] < result[j][1] {\n            return true\n        }\n\
    \        if result[i][1] > result[j][1] {\n            return false\n        }\n\
    \        return false\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeqqsih65_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpeqqsih65_test.go:36:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpeqqsih65_test.go:39:12:\
    \ invalid operation: result[i][0] > result[j][0] (operator > not defined on interface)\n\
    /tmp/tmpeqqsih65_test.go:42:12: invalid operation: result[i][1] < result[j][1]\
    \ (operator < not defined on interface)\n/tmp/tmpeqqsih65_test.go:45:12: invalid\
    \ operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmpeqqsih65_test.go:60:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpeqqsih65_test.go:61:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpeqqsih65_test.go:62:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpeqqsih65_test.go:65:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpeqqsih65_test.go:65:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpeqqsih65_test.go:65:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        if result[i][0] > result[j][0] {\n            return true\n        }\n\
    \        if result[i][0] < result[j][0] {\n            return false\n        }\n\
    \        if result[i][1] > result[j][1] {\n            return true\n        }\n\
    \        if result[i][1] < result[j][1] {\n            return false\n        }\n\
    \        return false\n    })\n    sort.Slice(result, func(i, j int) bool {\n\
    \        if result[i][1] > result[j][1] {\n            return true\n        }\n\
    \        if result[i][1] < result[j][1] {\n            return false\n        }\n\
    \        return false\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpom3nesro_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpom3nesro_test.go:36:12: invalid operation: result[i][0]\
    \ > result[j][0] (operator > not defined on interface)\n/tmp/tmpom3nesro_test.go:39:12:\
    \ invalid operation: result[i][0] < result[j][0] (operator < not defined on interface)\n\
    /tmp/tmpom3nesro_test.go:42:12: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmpom3nesro_test.go:45:12: invalid\
    \ operation: result[i][1] < result[j][1] (operator < not defined on interface)\n\
    /tmp/tmpom3nesro_test.go:50:5: undefined: sort\n/tmp/tmpom3nesro_test.go:51:12:\
    \ invalid operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmpom3nesro_test.go:54:12: invalid operation: result[i][1] < result[j][1]\
    \ (operator < not defined on interface)\n/tmp/tmpom3nesro_test.go:69:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpom3nesro_test.go:70:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpom3nesro_test.go:70:207:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    for i := range r {\n        for j := range r[i] {\n            r[i][j]\
    \ = lst[i][j]\n        }\n    }\n    r := r[sort.SearchInts(r, func(i int) bool\
    \ {\n        return r[i][len(r[i])-x]\n    })]\n    r := r[sort.SearchInts(r,\
    \ func(i int) bool {\n        return -r[i][len(r[i])-x]\n    })]\n    return r\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqjncs8v3_test.go:33:7:\
    \ no new variables on left side of :=\n/tmp/tmpqjncs8v3_test.go:33:10: cannot\
    \ use r[sort.SearchInts(r, func(i int) bool {\u2026})] (variable of type []interface{})\
    \ as type [][]interface{} in assignment\n/tmp/tmpqjncs8v3_test.go:33:12: undefined:\
    \ sort\n/tmp/tmpqjncs8v3_test.go:34:16: cannot use r[i][len(r[i]) - x] (variable\
    \ of type interface{}) as type bool in return statement:\n\tneed type assertion\n\
    /tmp/tmpqjncs8v3_test.go:36:7: no new variables on left side of :=\n/tmp/tmpqjncs8v3_test.go:36:10:\
    \ cannot use r[sort.SearchInts(r, func(i int) bool {\u2026})] (variable of type\
    \ []interface{}) as type [][]interface{} in assignment\n/tmp/tmpqjncs8v3_test.go:36:12:\
    \ undefined: sort\n/tmp/tmpqjncs8v3_test.go:37:17: invalid operation: operator\
    \ - not defined on r[i][len(r[i]) - x] (variable of type interface{})\n/tmp/tmpqjncs8v3_test.go:49:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqjncs8v3_test.go:50:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqjncs8v3_test.go:50:207:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        row_result := []interface{}{}\n        for _,\
    \ val := range row {\n            if val == x {\n                row_result =\
    \ append(row_result, val)\n            }\n        }\n        result = append(result,\
    \ row_result)\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ rows(result[i]) < rows(result[j])\n    })\n    sort.Slice(result, func(i, j\
    \ int) bool {\n        return columns(result[i]) < columns(result[j])\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9lo4yy3s_test.go:34:5:\
    \ undefined: sort\n/tmp/tmp9lo4yy3s_test.go:35:16: undefined: rows\n/tmp/tmp9lo4yy3s_test.go:37:5:\
    \ undefined: sort\n/tmp/tmp9lo4yy3s_test.go:38:16: undefined: columns\n/tmp/tmp9lo4yy3s_test.go:50:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9lo4yy3s_test.go:51:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9lo4yy3s_test.go:52:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9lo4yy3s_test.go:55:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp9lo4yy3s_test.go:55:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5aph0kig_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp5aph0kig_test.go:36:5: undefined: sort\n/tmp/tmp5aph0kig_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5aph0kig_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5aph0kig_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5aph0kig_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5aph0kig_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n   \
    \ sort.Slice(result, func(i, j int) bool {\n        return result[i][0] < result[j][0]\n\
    \    })\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][1]\
    \ > result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiuyp8wxv_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpiuyp8wxv_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpiuyp8wxv_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpiuyp8wxv_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpiuyp8wxv_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpiuyp8wxv_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpiuyp8wxv_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpiuyp8wxv_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpiuyp8wxv_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i+1, j+1)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j\
    \ int) bool {\n        if result[i][0] < result[j][0] {\n            return true\n\
    \        }\n        return false\n    })\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        if result[i][1] > result[j][1] {\n            return true\n\
    \        }\n        return false\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3pwka0o_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpx3pwka0o_test.go:36:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpx3pwka0o_test.go:41:5:\
    \ undefined: sort\n/tmp/tmpx3pwka0o_test.go:42:12: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpx3pwka0o_test.go:57:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx3pwka0o_test.go:58:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx3pwka0o_test.go:59:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx3pwka0o_test.go:62:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx3pwka0o_test.go:62:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    row := make([][]interface{}, len(lst))\n\
    \    for i := range row {\n        row[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range row {\n        for j := range row[i] {\n          \
    \  row[i][j] = lst[i][j]\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(row[0])))\n    for i := range row {\n\
    \        sort.Sort(sort.Reverse(sort.IntSlice(row[i])))\n    }\n    result :=\
    \ make([][]interface{}, len(row))\n    for i := range row {\n        result[i]\
    \ = make([]interface{}, len(row[i]))\n    }\n    for i := range row {\n      \
    \  for j := range row[i] {\n            if row[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"%d\", i)\n            }\n        }\n    }\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp074eg5ft_test.go:33:5:\
    \ undefined: sort\n/tmp/tmp074eg5ft_test.go:34:5: undefined: sort\n/tmp/tmp074eg5ft_test.go:36:9:\
    \ undefined: sort\n/tmp/tmp074eg5ft_test.go:59:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp074eg5ft_test.go:60:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp074eg5ft_test.go:61:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp074eg5ft_test.go:64:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp074eg5ft_test.go:64:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"%d\", i)\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxkty8g1f_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpxkty8g1f_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpxkty8g1f_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpxkty8g1f_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpxkty8g1f_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxkty8g1f_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxkty8g1f_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxkty8g1f_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpxkty8g1f_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9or3ocgl_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp9or3ocgl_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp9or3ocgl_test.go:38:5:\
    \ undefined: sort\n/tmp/tmp9or3ocgl_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp9or3ocgl_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9or3ocgl_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9or3ocgl_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9or3ocgl_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp9or3ocgl_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        row_result := make([]interface{}, len(row))\n\
    \        for j, val := range row {\n            if val == x {\n              \
    \  row_result[j] = fmt.Sprintf(\"%d\", j)\n            }\n        }\n        result[i]\
    \ = row_result\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ rows(result[i]) < rows(result[j])\n    })\n    sort.Slice(result, func(i, j\
    \ int) bool {\n        return columns(result[i]) < columns(result[j])\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2ieyhn1l_test.go:34:5:\
    \ undefined: sort\n/tmp/tmp2ieyhn1l_test.go:35:16: undefined: rows\n/tmp/tmp2ieyhn1l_test.go:37:5:\
    \ undefined: sort\n/tmp/tmp2ieyhn1l_test.go:38:16: undefined: columns\n/tmp/tmp2ieyhn1l_test.go:50:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp2ieyhn1l_test.go:51:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp2ieyhn1l_test.go:52:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp2ieyhn1l_test.go:55:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp2ieyhn1l_test.go:55:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075282
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n   \
    \ sort.Sort(sort.Reverse(sort.IntSlice(result)))\n    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpbp95jj9n_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpbp95jj9n_test.go:36:5: undefined: sort\n/tmp/tmpbp95jj9n_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpbp95jj9n_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpbp95jj9n_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpbp95jj9n_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpbp95jj9n_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", j)\n\
    \            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps3xyy5fy_test.go:35:5:\
    \ undefined: sort\n/tmp/tmps3xyy5fy_test.go:36:5: undefined: sort\n/tmp/tmps3xyy5fy_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps3xyy5fy_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmps3xyy5fy_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps3xyy5fy_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmps3xyy5fy_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    x -= 1 // We start from 0\n    for i := range lst {\n        for j\
    \ := range lst[i] {\n            if x == 0 {\n                result[i][j] = nil\n\
    \            } else {\n                result[i][j] = x\n                x--\n\
    \            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwshjc_5r_test.go:39:5:\
    \ undefined: sort\n/tmp/tmpwshjc_5r_test.go:40:5: undefined: sort\n/tmp/tmpwshjc_5r_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwshjc_5r_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpwshjc_5r_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwshjc_5r_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpwshjc_5r_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if x == lst[i][j] {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][1] > result[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx3cfllqv_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpx3cfllqv_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpx3cfllqv_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpx3cfllqv_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpx3cfllqv_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx3cfllqv_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx3cfllqv_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx3cfllqv_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpx3cfllqv_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        result[i] = make([]interface{}, len(row))\n\
    \        for j, val := range row {\n            result[i][j] = val\n        }\n\
    \    }\n    sort.Slice(result, func(i, j int) bool {\n        return rowSort(result[i])\
    \ < rowSort(result[j])\n    })\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return colSort(result[i]) < colSort(result[j])\n    })\n    for i, row\
    \ := range result {\n        sort.Slice(row, func(i, j int) bool {\n         \
    \   return result[i][j] < result[i][j+1]\n        })\n    }\n    for i, row :=\
    \ range result {\n        sort.Slice(row, func(i, j int) bool {\n            return\
    \ result[i][j] > result[i][j+1]\n        })\n    }\n    for i, row := range result\
    \ {\n        result[i] = make([]interface{}, len(row))\n        for j, val :=\
    \ range row {\n            result[i][j] = result[i][j].(int)\n        }\n    }\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptxy0a5ro_test.go:31:5: undefined: sort

    /tmp/tmptxy0a5ro_test.go:32:16: undefined: rowSort

    /tmp/tmptxy0a5ro_test.go:34:5: undefined: sort

    /tmp/tmptxy0a5ro_test.go:35:16: undefined: colSort

    /tmp/tmptxy0a5ro_test.go:37:9: i declared but not used

    /tmp/tmptxy0a5ro_test.go:38:9: undefined: sort

    /tmp/tmptxy0a5ro_test.go:39:20: invalid operation: result[i][j] < result[i][j
    + 1] (operator < not defined on interface)

    /tmp/tmptxy0a5ro_test.go:42:9: i declared but not used

    /tmp/tmptxy0a5ro_test.go:43:9: undefined: sort

    /tmp/tmptxy0a5ro_test.go:44:20: invalid operation: result[i][j] > result[i][j
    + 1] (operator > not defined on interface)

    /tmp/tmptxy0a5ro_test.go:42:9: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    i := 0\n    for _, row := range lst {\n        for _, v := range row\
    \ {\n            r[i][x] = v\n            i++\n        }\n    }\n    r := r[:i]\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(rowSort(r))))\n    sort.Sort(sort.Reverse(sort.IntSlice(colSort(r))))\n\
    \    return r\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr1uatemp_test.go:35:7:\
    \ no new variables on left side of :=\n/tmp/tmpr1uatemp_test.go:36:5: undefined:\
    \ sort\n/tmp/tmpr1uatemp_test.go:36:42: undefined: rowSort\n/tmp/tmpr1uatemp_test.go:37:5:\
    \ undefined: sort\n/tmp/tmpr1uatemp_test.go:37:42: undefined: colSort\n/tmp/tmpr1uatemp_test.go:48:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpr1uatemp_test.go:49:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpr1uatemp_test.go:50:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpr1uatemp_test.go:53:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpr1uatemp_test.go:53:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpr1uatemp_test.go:53:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        result := append(result, get_row_helper(row,\
    \ x))\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return row_inc(result[i])\
    \ < row_inc(result[j])\n    })\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return col_dec(result[j]) < col_dec(result[i])\n    })\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2vlmolc4_test.go:26:9:\
    \ result declared but not used\n/tmp/tmp2vlmolc4_test.go:26:34: undefined: get_row_helper\n\
    /tmp/tmp2vlmolc4_test.go:28:5: undefined: sort\n/tmp/tmp2vlmolc4_test.go:29:16:\
    \ undefined: row_inc\n/tmp/tmp2vlmolc4_test.go:31:5: undefined: sort\n/tmp/tmp2vlmolc4_test.go:32:16:\
    \ undefined: col_dec\n/tmp/tmp2vlmolc4_test.go:44:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp2vlmolc4_test.go:45:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp2vlmolc4_test.go:46:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp2vlmolc4_test.go:49:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp2vlmolc4_test.go:49:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Write your code here\n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \nfunc TestGet_Row(t *testing.T) {\n  candidate :=\
    \ get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph1vum3oi_test.go:279:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075282
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        result := append(result, []interface{}{row, get_col(row,\
    \ x)})\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n  \
    \  return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkhek6ls1_test.go:26:9:\
    \ result declared but not used\n/tmp/tmpkhek6ls1_test.go:26:53: undefined: get_col\n\
    /tmp/tmpkhek6ls1_test.go:28:5: undefined: sort\n/tmp/tmpkhek6ls1_test.go:28:15:\
    \ undefined: byRow\n/tmp/tmpkhek6ls1_test.go:29:5: undefined: sort\n/tmp/tmpkhek6ls1_test.go:29:15:\
    \ undefined: byCol\n/tmp/tmpkhek6ls1_test.go:40:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkhek6ls1_test.go:41:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkhek6ls1_test.go:42:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkhek6ls1_test.go:45:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpkhek6ls1_test.go:45:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    r := r[:0]\n    for i := range lst {\n        for j := range lst[i] {\n\
    \            if lst[i][j] == x {\n                rs = append(rs, []interface{}{i,\
    \ j})\n            }\n        }\n    }\n    sort.Slice(rs, func(i, j int) bool\
    \ {\n        if rs[i].([]interface{})[0].(float64) > rs[j].([]interface{})[0].(float64)\
    \ {\n            return true\n        }\n        if rs[i].([]interface{})[0].(float64)\
    \ < rs[j].([]interface{})[0].(float64) {\n            return false\n        }\n\
    \        if rs[i].([]interface{})[1].(float64) > rs[j].([]interface{})[1].(float64)\
    \ {\n            return true\n        }\n        if rs[i].([]interface{})[1].(float64)\
    \ < rs[j].([]interface{})[1].(float64) {\n            return false\n        }\n\
    \        return true\n    })\n    for _, r := range rs {\n        sort.Slice(rs,\
    \ func(i, j int) bool {\n            if rs[i].([]interface{})[0].(float64) > rs[j].([]interface{})[0].(float64)\
    \ {\n                return true\n            }\n            if rs[i].([]interface{})[0].(float64)\
    \ < rs[j].([]interface{})[0].(float64) {\n                return false\n     \
    \       }\n            if rs[i].([]interface{})[1].(float64) > rs[j].([]interface{})[1].(float64)\
    \ {\n                return true\n            }\n            if rs[i].([]interface{})[1].(float64)\
    \ < rs[j].([]interface{})[1].(float64) {\n                return false\n     \
    \       }\n            return true\n        })\n    }\n    return r\n}\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj7er_wbo_test.go:28:7: no new variables on left side of :=

    /tmp/tmpj7er_wbo_test.go:32:29: undefined: rs

    /tmp/tmpj7er_wbo_test.go:36:5: undefined: sort

    /tmp/tmpj7er_wbo_test.go:36:16: undefined: rs

    /tmp/tmpj7er_wbo_test.go:37:12: undefined: rs

    /tmp/tmpj7er_wbo_test.go:40:12: undefined: rs

    /tmp/tmpj7er_wbo_test.go:43:12: undefined: rs

    /tmp/tmpj7er_wbo_test.go:46:12: undefined: rs

    /tmp/tmpj7er_wbo_test.go:51:23: undefined: rs

    /tmp/tmpj7er_wbo_test.go:52:9: undefined: sort

    /tmp/tmpj7er_wbo_test.go:52:9: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsa6rixn5_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpsa6rixn5_test.go:36:5: undefined: sort\n/tmp/tmpsa6rixn5_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsa6rixn5_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsa6rixn5_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsa6rixn5_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsa6rixn5_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"%d\", i)\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        if result[i][0] > result[j][0] {\n          \
    \  return true\n        }\n        return false\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        if result[i][1] > result[j][1] {\n          \
    \  return true\n        }\n        return false\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp10pq4epg_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp10pq4epg_test.go:36:12: invalid operation: result[i][0]\
    \ > result[j][0] (operator > not defined on interface)\n/tmp/tmp10pq4epg_test.go:41:5:\
    \ undefined: sort\n/tmp/tmp10pq4epg_test.go:42:12: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp10pq4epg_test.go:57:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp10pq4epg_test.go:58:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp10pq4epg_test.go:59:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp10pq4epg_test.go:62:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp10pq4epg_test.go:62:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    var row_index\
    \ int\n    var col_index int\n    for row_index = 0; row_index < len(lst); row_index++\
    \ {\n        col_index = 0\n        for col_index = 0; col_index < len(lst[row_index]);\
    \ col_index++ {\n            if lst[row_index][col_index] == x {\n           \
    \     result = append(result, []interface{}{row_index, col_index})\n         \
    \   }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpyu39k74p_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpyu39k74p_test.go:36:5: undefined: sort\n/tmp/tmpyu39k74p_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyu39k74p_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpyu39k74p_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpyu39k74p_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpyu39k74p_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        row_result := make([]interface{}, len(row))\n\
    \        for j, val := range row {\n            if val == x {\n              \
    \  row_result[j] = fmt.Sprintf(\"%d\", j)\n            }\n        }\n        result[i]\
    \ = row_result\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i][1] > result[j][1]\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpokvubvrn_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpokvubvrn_test.go:35:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpokvubvrn_test.go:37:5:\
    \ undefined: sort\n/tmp/tmpokvubvrn_test.go:38:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpokvubvrn_test.go:50:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpokvubvrn_test.go:51:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpokvubvrn_test.go:52:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpokvubvrn_test.go:55:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpokvubvrn_test.go:55:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    r := r[:0]\n    for _, row := range lst {\n        for _, cell := range\
    \ row {\n            if cell == x {\n                r := append(r, []interface{}{i,\
    \ cell})\n            }\n        }\n    }\n    sort.Slice(r, func(i, j int) bool\
    \ {\n        if r[i].([]interface{})[0].(int) < r[j].([]interface{})[0].(int)\
    \ {\n            return true\n        }\n        return false\n    })\n    sort.Slice(r,\
    \ func(i, j int) bool {\n        if r[i].([]interface{})[1].(int) < r[j].([]interface{})[1].(int)\
    \ {\n            return true\n        }\n        return false\n    })\n    return\
    \ r\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9izirt1t_test.go:28:7:\
    \ no new variables on left side of :=\n/tmp/tmp9izirt1t_test.go:32:17: r declared\
    \ but not used\n/tmp/tmp9izirt1t_test.go:32:46: undefined: i\n/tmp/tmp9izirt1t_test.go:36:5:\
    \ undefined: sort\n/tmp/tmp9izirt1t_test.go:37:12: invalid operation: r[i] (variable\
    \ of type []interface{}) is not an interface\n/tmp/tmp9izirt1t_test.go:37:44:\
    \ invalid operation: r[j] (variable of type []interface{}) is not an interface\n\
    /tmp/tmp9izirt1t_test.go:42:5: undefined: sort\n/tmp/tmp9izirt1t_test.go:43:12:\
    \ invalid operation: r[i] (variable of type []interface{}) is not an interface\n\
    /tmp/tmp9izirt1t_test.go:43:44: invalid operation: r[j] (variable of type []interface{})\
    \ is not an interface\n/tmp/tmp9izirt1t_test.go:58:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9izirt1t_test.go:58:132:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i+1, j+1)\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    for i := 0; i < len(result); i++ {\n        result[i] = result[i][1:]\n \
    \   }\n    return append([][]interface{}{}, result...), x\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9pfs5iv__test.go:33:5:\
    \ undefined: sort\n/tmp/tmp9pfs5iv__test.go:33:15: undefined: byRow\n/tmp/tmp9pfs5iv__test.go:34:5:\
    \ undefined: sort\n/tmp/tmp9pfs5iv__test.go:34:15: undefined: byCol\n/tmp/tmp9pfs5iv__test.go:38:50:\
    \ too many return values\n\thave ([][]interface{}, int)\n\twant ([][]interface{})\n\
    /tmp/tmp9pfs5iv__test.go:48:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmp9pfs5iv__test.go:49:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9pfs5iv__test.go:50:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9pfs5iv__test.go:53:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp9pfs5iv__test.go:53:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9pfs5iv__test.go:53:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        row_result := make([]interface{}, len(row))\n\
    \        for j, val := range row {\n            if val == x {\n              \
    \  row_result[j] = fmt.Sprintf(\"%d\", j)\n            }\n        }\n        result[i]\
    \ = row_result\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n  \
    \  sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\n\
    func TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpgkkmgggx_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpgkkmgggx_test.go:35:5: undefined: sort\n/tmp/tmpgkkmgggx_test.go:46:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpgkkmgggx_test.go:47:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpgkkmgggx_test.go:48:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpgkkmgggx_test.go:51:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpgkkmgggx_test.go:51:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9or3ocgl_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp9or3ocgl_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp9or3ocgl_test.go:38:5:\
    \ undefined: sort\n/tmp/tmp9or3ocgl_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp9or3ocgl_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9or3ocgl_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9or3ocgl_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9or3ocgl_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp9or3ocgl_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        result := append(result, get_row_helper(row,\
    \ x))\n    }\n    sort.Sort(byRow(result))\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8lybya8j_test.go:26:9:\
    \ result declared but not used\n/tmp/tmp8lybya8j_test.go:26:34: undefined: get_row_helper\n\
    /tmp/tmp8lybya8j_test.go:28:5: undefined: sort\n/tmp/tmp8lybya8j_test.go:28:15:\
    \ undefined: byRow\n/tmp/tmp8lybya8j_test.go:39:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp8lybya8j_test.go:40:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp8lybya8j_test.go:41:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp8lybya8j_test.go:44:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp8lybya8j_test.go:44:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    x -= 1 // because row is zero-based, so x is one-based\n    for i\
    \ := range lst {\n        for j := range lst[i] {\n            if x == 0 {\n \
    \               result[i][j] = nil\n            } else {\n                result[i][j]\
    \ = make([]interface{}, 1)\n                result[i][j] = append(result[i][j],\
    \ i)\n                result[i][j] = append(result[i][j], j)\n            }\n\
    \            x--\n        }\n    }\n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp3kxhyyo9_test.go:35:39:\
    \ first argument to append must be a slice; have result[i][j] (variable of type\
    \ interface{})\n/tmp/tmp3kxhyyo9_test.go:36:39: first argument to append must\
    \ be a slice; have result[i][j] (variable of type interface{})\n/tmp/tmp3kxhyyo9_test.go:41:5:\
    \ undefined: sort\n/tmp/tmp3kxhyyo9_test.go:42:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp3kxhyyo9_test.go:44:5:\
    \ undefined: sort\n/tmp/tmp3kxhyyo9_test.go:45:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp3kxhyyo9_test.go:57:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp3kxhyyo9_test.go:58:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp3kxhyyo9_test.go:59:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp3kxhyyo9_test.go:62:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp3kxhyyo9_test.go:62:26:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq28t28hg_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpq28t28hg_test.go:35:15: undefined: byRow\n/tmp/tmpq28t28hg_test.go:36:5:\
    \ undefined: sort\n/tmp/tmpq28t28hg_test.go:36:15: undefined: byCol\n/tmp/tmpq28t28hg_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpq28t28hg_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpq28t28hg_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpq28t28hg_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpq28t28hg_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", j)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        if result[i][0] < result[j][0] {\n            return true\n        }\n\
    \        return false\n    })\n    sort.Slice(result, func(i, j int) bool {\n\
    \        if result[i][1] > result[j][1] {\n            return true\n        }\n\
    \        return false\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnwk2pf4c_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpnwk2pf4c_test.go:36:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpnwk2pf4c_test.go:41:5:\
    \ undefined: sort\n/tmp/tmpnwk2pf4c_test.go:42:12: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpnwk2pf4c_test.go:57:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnwk2pf4c_test.go:58:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnwk2pf4c_test.go:59:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnwk2pf4c_test.go:62:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnwk2pf4c_test.go:62:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    rows,\
    \ _ := len(lst), len(lst[0])\n    for i := 0; i < rows; i++ {\n        row :=\
    \ lst[i]\n        result := append(result, []interface{}{i, len(row)})\n    }\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n\
    \    for _, row := range result {\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n\
    \    }\n    for _, row := range result {\n        for _, col := range row {\n\
    \            if col == x {\n                return result\n            }\n   \
    \     }\n    }\n    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp4ldlvlkb_test.go:28:9:\
    \ result declared but not used\n/tmp/tmp4ldlvlkb_test.go:30:5: undefined: sort\n\
    /tmp/tmp4ldlvlkb_test.go:31:5: undefined: sort\n/tmp/tmp4ldlvlkb_test.go:33:9:\
    \ undefined: sort\n/tmp/tmp4ldlvlkb_test.go:52:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp4ldlvlkb_test.go:53:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp4ldlvlkb_test.go:54:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp4ldlvlkb_test.go:57:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp4ldlvlkb_test.go:57:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if x == lst[i][j] {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        if result[i][0] < result[j][0] {\n            return true\n        }\n\
    \        if result[i][0] > result[j][0] {\n            return false\n        }\n\
    \        if result[i][1] > result[j][1] {\n            return true\n        }\n\
    \        if result[i][1] < result[j][1] {\n            return false\n        }\n\
    \        return false\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpctna1o4y_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpctna1o4y_test.go:36:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpctna1o4y_test.go:39:12:\
    \ invalid operation: result[i][0] > result[j][0] (operator > not defined on interface)\n\
    /tmp/tmpctna1o4y_test.go:42:12: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmpctna1o4y_test.go:45:12: invalid\
    \ operation: result[i][1] < result[j][1] (operator < not defined on interface)\n\
    /tmp/tmpctna1o4y_test.go:60:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpctna1o4y_test.go:61:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpctna1o4y_test.go:62:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpctna1o4y_test.go:65:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpctna1o4y_test.go:65:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpctna1o4y_test.go:65:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    r := r[:0]\n    for _, row := range lst {\n        for _, val := range\
    \ row {\n            if val == x {\n                r := append(r, []interface{}{row,\
    \ val})\n            }\n        }\n    }\n    sort.Slice(r, func(i, j int) bool\
    \ {\n        if r[i].([]interface{})[0].([]interface{})[1] < r[j].([]interface{})[0].([]interface{})[1]\
    \ {\n            return true\n        }\n        return false\n    })\n    sort.Slice(r,\
    \ func(i, j int) bool {\n        if r[i].([]interface{})[0].([]interface{})[1]\
    \ > r[j].([]interface{})[0].([]interface{})[1] {\n            return true\n  \
    \      }\n        return false\n    })\n    return r\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp96cgouah_test.go:28:7:\
    \ no new variables on left side of :=\n/tmp/tmp96cgouah_test.go:32:17: r declared\
    \ but not used\n/tmp/tmp96cgouah_test.go:36:5: undefined: sort\n/tmp/tmp96cgouah_test.go:37:12:\
    \ invalid operation: r[i] (variable of type []interface{}) is not an interface\n\
    /tmp/tmp96cgouah_test.go:37:57: invalid operation: r[j] (variable of type []interface{})\
    \ is not an interface\n/tmp/tmp96cgouah_test.go:42:5: undefined: sort\n/tmp/tmp96cgouah_test.go:43:12:\
    \ invalid operation: r[i] (variable of type []interface{}) is not an interface\n\
    /tmp/tmp96cgouah_test.go:43:57: invalid operation: r[j] (variable of type []interface{})\
    \ is not an interface\n/tmp/tmp96cgouah_test.go:58:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp96cgouah_test.go:59:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp96cgouah_test.go:59:207: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n   \
    \ sort.Slice(result, func(i, j int) bool {\n        return len(result[i]) > len(result[j])\n\
    \    })\n    sort.Slice(result, func(i, j int) bool {\n        return len(result[j])\
    \ > len(result[i])\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_i3r8co0_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp_i3r8co0_test.go:38:5: undefined: sort\n/tmp/tmp_i3r8co0_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp_i3r8co0_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp_i3r8co0_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp_i3r8co0_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp_i3r8co0_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        if result[i][0] < result[j][0] {\n          \
    \  return true\n        }\n        if result[i][0] > result[j][0] {\n        \
    \    return false\n        }\n        if result[i][1] > result[j][1] {\n     \
    \       return true\n        }\n        if result[i][1] < result[j][1] {\n   \
    \         return false\n        }\n        return false\n    })\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmnb6x8x0_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpmnb6x8x0_test.go:36:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpmnb6x8x0_test.go:39:12:\
    \ invalid operation: result[i][0] > result[j][0] (operator > not defined on interface)\n\
    /tmp/tmpmnb6x8x0_test.go:42:12: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmpmnb6x8x0_test.go:45:12: invalid\
    \ operation: result[i][1] < result[j][1] (operator < not defined on interface)\n\
    /tmp/tmpmnb6x8x0_test.go:60:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpmnb6x8x0_test.go:61:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmnb6x8x0_test.go:62:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmnb6x8x0_test.go:65:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpmnb6x8x0_test.go:65:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmnb6x8x0_test.go:65:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    row := 0\n    for _, row := range lst {\n        for _, col := range\
    \ row {\n            if col == x {\n                result[row] = append(result[row],\
    \ fmt.Sprintf(\"%d\", col))\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        if result[i][0] < result[j][0] {\n          \
    \  return true\n        }\n        return false\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        if result[i][1] > result[j][1] {\n          \
    \  return true\n        }\n        return false\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpc6eb73sf_test.go:28:5:\
    \ row declared but not used\n/tmp/tmpc6eb73sf_test.go:32:45: invalid argument:\
    \ index row (variable of type []int) must be integer\n/tmp/tmpc6eb73sf_test.go:36:5:\
    \ undefined: sort\n/tmp/tmpc6eb73sf_test.go:37:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpc6eb73sf_test.go:42:5:\
    \ undefined: sort\n/tmp/tmpc6eb73sf_test.go:43:12: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpc6eb73sf_test.go:58:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpc6eb73sf_test.go:59:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpc6eb73sf_test.go:60:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpc6eb73sf_test.go:63:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpc6eb73sf_test.go:63:26:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"%d\", i)\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxkty8g1f_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpxkty8g1f_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpxkty8g1f_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpxkty8g1f_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpxkty8g1f_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxkty8g1f_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxkty8g1f_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxkty8g1f_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpxkty8g1f_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    i := 0\n    for _, row := range lst {\n        j := 0\n        for _,\
    \ v := range row {\n            r[i][j] = v\n            j++\n        }\n    \
    \    i++\n    }\n    r := r[:i]\n    sort.Slice(r, func(i, j int) bool {\n   \
    \     if r[i][0] < r[j][0] {\n            return true\n        }\n        if r[i][0]\
    \ > r[j][0] {\n            return false\n        }\n        if r[i][1] < r[j][1]\
    \ {\n            return true\n        }\n        if r[i][1] > r[j][1] {\n    \
    \        return false\n        }\n        return false\n    })\n    r := r[:i]\n\
    \    sort.Slice(r, func(i, j int) bool {\n        if r[i][1] < r[j][1] {\n   \
    \         return true\n        }\n        if r[i][1] > r[j][1] {\n           \
    \ return false\n        }\n        return false\n    })\n    return r\n}\n\nfunc\
    \ TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0qaii97i_test.go:37:7: no new variables on left side of :=

    /tmp/tmp0qaii97i_test.go:38:5: undefined: sort

    /tmp/tmp0qaii97i_test.go:39:12: invalid operation: r[i][0] < r[j][0] (operator
    < not defined on interface)

    /tmp/tmp0qaii97i_test.go:42:12: invalid operation: r[i][0] > r[j][0] (operator
    > not defined on interface)

    /tmp/tmp0qaii97i_test.go:45:12: invalid operation: r[i][1] < r[j][1] (operator
    < not defined on interface)

    /tmp/tmp0qaii97i_test.go:48:12: invalid operation: r[i][1] > r[j][1] (operator
    > not defined on interface)

    /tmp/tmp0qaii97i_test.go:53:7: no new variables on left side of :=

    /tmp/tmp0qaii97i_test.go:54:5: undefined: sort

    /tmp/tmp0qaii97i_test.go:55:12: invalid operation: r[i][1] < r[j][1] (operator
    < not defined on interface)

    /tmp/tmp0qaii97i_test.go:58:12: invalid operation: r[i][1] > r[j][1] (operator
    > not defined on interface)

    /tmp/tmp0qaii97i_test.go:58:12: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    for i := range r {\n        for j := range r[i] {\n            r[i][j]\
    \ = lst[i][j]\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(row(r))))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(col(r))))\n    return r\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe_mdmoor_test.go:33:5:\
    \ undefined: sort\n/tmp/tmpe_mdmoor_test.go:33:42: undefined: row\n/tmp/tmpe_mdmoor_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpe_mdmoor_test.go:34:42: undefined: col\n/tmp/tmpe_mdmoor_test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpe_mdmoor_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpe_mdmoor_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpe_mdmoor_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpe_mdmoor_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075284
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    for i := range r {\n        for j := range r[i] {\n            r[i][j]\
    \ = lst[i][j]\n        }\n    }\n    r := r[x:]\n    r := r[:len(r)/2]\n    r\
    \ := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r :=\
    \ r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r :=\
    \ r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r :=\
    \ r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r :=\
    \ r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r :=\
    \ r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n\
    \    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r := r[:len(r)/2]\n    r :=\
    \ r[:len(r)/2]\n    r := r[:len(\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm3z7ow9c_test.go:79:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var result []interface{}\n        for _, value :=\
    \ range row {\n            if value == x {\n                result = append(result,\
    \ value)\n            }\n        }\n        result = append(result, 0)\n     \
    \   result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, 0)\n        result = append(result, 0)\n        result = append(result,\
    \ 0)\n        result = append(result, 0)\n        result = append(result, 0)\n\
    \        result = append(result, 0)\n        result = append(result, 0)\n    \
    \    result = append(result, 0)\n        result = append(result, 0)\n        result\
    \ = append(result, \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpojrx6qy6_test.go:126:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", j)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][1] > result[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprk_gw4i1_test.go:35:5:\
    \ undefined: sort\n/tmp/tmprk_gw4i1_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmprk_gw4i1_test.go:38:5:\
    \ undefined: sort\n/tmp/tmprk_gw4i1_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmprk_gw4i1_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprk_gw4i1_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmprk_gw4i1_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprk_gw4i1_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmprk_gw4i1_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsa6rixn5_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpsa6rixn5_test.go:36:5: undefined: sort\n/tmp/tmpsa6rixn5_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsa6rixn5_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsa6rixn5_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsa6rixn5_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsa6rixn5_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var result []interface{}\n        for _, val :=\
    \ range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{row, val})\n            }\n        }\n        result = append(result,\
    \ []interface{}{row, 0})\n        result = append(result, get_row(row, x))\n \
    \       result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, \nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxnqp41ls_test.go:90:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        result := append(result, get_row_helper(row,\
    \ x))\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return row_inc(result[i])\
    \ < row_inc(result[j])\n    })\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return col_dec(result[j]) < col_dec(result[i])\n    })\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2vlmolc4_test.go:26:9:\
    \ result declared but not used\n/tmp/tmp2vlmolc4_test.go:26:34: undefined: get_row_helper\n\
    /tmp/tmp2vlmolc4_test.go:28:5: undefined: sort\n/tmp/tmp2vlmolc4_test.go:29:16:\
    \ undefined: row_inc\n/tmp/tmp2vlmolc4_test.go:31:5: undefined: sort\n/tmp/tmp2vlmolc4_test.go:32:16:\
    \ undefined: col_dec\n/tmp/tmp2vlmolc4_test.go:44:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp2vlmolc4_test.go:45:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp2vlmolc4_test.go:46:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp2vlmolc4_test.go:49:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp2vlmolc4_test.go:49:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        result[i] = make([]interface{}, len(row))\n\
    \        for j, val := range row {\n            result[i][j] = val\n        }\n\
    \    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n    return\
    \ filterByRow(result, x)\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate :=\
    \ get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpr0v2aipm_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpr0v2aipm_test.go:31:15: undefined: byRow\n/tmp/tmpr0v2aipm_test.go:32:5:\
    \ undefined: sort\n/tmp/tmpr0v2aipm_test.go:32:15: undefined: byCol\n/tmp/tmpr0v2aipm_test.go:33:12:\
    \ undefined: filterByRow\n/tmp/tmpr0v2aipm_test.go:43:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpr0v2aipm_test.go:44:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpr0v2aipm_test.go:45:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpr0v2aipm_test.go:48:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpr0v2aipm_test.go:48:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpr0v2aipm_test.go:48:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075285
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n        for j := 0; j < len(lst[i]); j++ {\n            result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    for i := 0; i < len(result); i++ {\n        result[i] = result[i][1:]\n\
    \    }\n    return [][]interface{}{result[x]}\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpp0sp0hox_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpp0sp0hox_test.go:32:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpp0sp0hox_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpp0sp0hox_test.go:35:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpp0sp0hox_test.go:50:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpp0sp0hox_test.go:51:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpp0sp0hox_test.go:52:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpp0sp0hox_test.go:55:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpp0sp0hox_test.go:55:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075285
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var result []interface{}\n        for _, col :=\
    \ range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{row, col})\n            }\n        }\n        result = append(result,\
    \ []interface{}{row, len(row)})\n        result = append(result, []interface{}{len(row),\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{0, 0})\n        result = append(result, []interface{}{0,\
    \ 0})\n        result = append(result, []interface{}{0, 0})\n        result =\
    \ append(result, []interface{}{\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmnzifdo9_test.go:78:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075280
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    i := 0\n    for _, row := range lst {\n        j = 0\n        for _,\
    \ v := range row {\n            r[i][j] = v\n            j++\n        }\n    \
    \    i++\n    }\n    r := r[:i]\n    sort.Sort(sort.Reverse(sort.IntSlice(rowSort(r))))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(colSort(r))))\n    r := r[:x]\n    return\
    \ r\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmbo3d6m5_test.go:30:9:\
    \ undefined: j\n/tmp/tmpmbo3d6m5_test.go:32:18: undefined: j\n/tmp/tmpmbo3d6m5_test.go:33:13:\
    \ undefined: j\n/tmp/tmpmbo3d6m5_test.go:37:7: no new variables on left side of\
    \ :=\n/tmp/tmpmbo3d6m5_test.go:38:5: undefined: sort\n/tmp/tmpmbo3d6m5_test.go:38:42:\
    \ undefined: rowSort\n/tmp/tmpmbo3d6m5_test.go:39:5: undefined: sort\n/tmp/tmpmbo3d6m5_test.go:39:42:\
    \ undefined: colSort\n/tmp/tmpmbo3d6m5_test.go:40:7: no new variables on left\
    \ side of :=\n/tmp/tmpmbo3d6m5_test.go:51:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmbo3d6m5_test.go:51:132:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075285
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp5aph0kig_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp5aph0kig_test.go:36:5: undefined: sort\n/tmp/tmp5aph0kig_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5aph0kig_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp5aph0kig_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp5aph0kig_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp5aph0kig_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Your code here\n    result := [][]interface{}{}\n\
    \    for _, row := range lst {\n        result := append(result, []interface{}{row[x],\
    \ len(row)})\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i][1] > result[j][1]\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpt3ufcds3_test.go:27:9:\
    \ result declared but not used\n/tmp/tmpt3ufcds3_test.go:29:5: undefined: sort\n\
    /tmp/tmpt3ufcds3_test.go:30:16: invalid operation: result[i][0] < result[j][0]\
    \ (operator < not defined on interface)\n/tmp/tmpt3ufcds3_test.go:32:5: undefined:\
    \ sort\n/tmp/tmpt3ufcds3_test.go:33:16: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmpt3ufcds3_test.go:45:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpt3ufcds3_test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpt3ufcds3_test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpt3ufcds3_test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpt3ufcds3_test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpt3ufcds3_test.go:50:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075285
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq28t28hg_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpq28t28hg_test.go:35:15: undefined: byRow\n/tmp/tmpq28t28hg_test.go:36:5:\
    \ undefined: sort\n/tmp/tmpq28t28hg_test.go:36:15: undefined: byCol\n/tmp/tmpq28t28hg_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpq28t28hg_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpq28t28hg_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpq28t28hg_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpq28t28hg_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        if result[i][0] < result[j][0] {\n            return true\n\
    \        }\n        return false\n    })\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        if result[i][1] > result[j][1] {\n            return true\n\
    \        }\n        return false\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps6hheimp_test.go:35:5:\
    \ undefined: sort\n/tmp/tmps6hheimp_test.go:36:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmps6hheimp_test.go:41:5:\
    \ undefined: sort\n/tmp/tmps6hheimp_test.go:42:12: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmps6hheimp_test.go:57:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps6hheimp_test.go:58:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmps6hheimp_test.go:59:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps6hheimp_test.go:62:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmps6hheimp_test.go:62:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        result := append(result, []interface{}{row, get_col(row,\
    \ x)})\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return row_inc(result[i])\
    \ < row_inc(result[j])\n    })\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return col_dec(result[i]) < col_dec(result[j])\n    })\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj7k_958o_test.go:26:9:\
    \ result declared but not used\n/tmp/tmpj7k_958o_test.go:26:53: undefined: get_col\n\
    /tmp/tmpj7k_958o_test.go:28:5: undefined: sort\n/tmp/tmpj7k_958o_test.go:29:16:\
    \ undefined: row_inc\n/tmp/tmpj7k_958o_test.go:31:5: undefined: sort\n/tmp/tmpj7k_958o_test.go:32:16:\
    \ undefined: col_dec\n/tmp/tmpj7k_958o_test.go:44:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpj7k_958o_test.go:45:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpj7k_958o_test.go:46:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpj7k_958o_test.go:49:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpj7k_958o_test.go:49:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075285
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n   \
    \ sort.Slice(result, func(i, j int) bool {\n        return result[i][0] < result[j][0]\n\
    \    })\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][1]\
    \ > result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiuyp8wxv_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpiuyp8wxv_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpiuyp8wxv_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpiuyp8wxv_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpiuyp8wxv_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpiuyp8wxv_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpiuyp8wxv_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpiuyp8wxv_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpiuyp8wxv_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var result []interface{}\n        for _, val :=\
    \ range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{row, val})\n            }\n        }\n        result = append(result,\
    \ []interface{}{row, 0})\n        result = append(result, get_row(row, x))\n \
    \       result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, \nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxnqp41ls_test.go:90:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    for i := range r {\n        for j := range r[i] {\n            r[i][j]\
    \ = lst[i][j]\n        }\n    }\n    sort.Sort(byRow(r))\n    sort.Sort(byCol(r))\n\
    \    return r\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppumflnu__test.go:33:5:\
    \ undefined: sort\n/tmp/tmppumflnu__test.go:33:15: undefined: byRow\n/tmp/tmppumflnu__test.go:34:5:\
    \ undefined: sort\n/tmp/tmppumflnu__test.go:34:15: undefined: byCol\n/tmp/tmppumflnu__test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmppumflnu__test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmppumflnu__test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmppumflnu__test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmppumflnu__test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075285
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        if result[i][0] > result[j][0] {\n            return true\n\
    \        }\n        if result[i][0] < result[j][0] {\n            return false\n\
    \        }\n        if result[i][1] > result[j][1] {\n            return true\n\
    \        }\n        if result[i][1] < result[j][1] {\n            return false\n\
    \        }\n        return false\n    })\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        if result[i][1] > result[j][1] {\n            return true\n\
    \        }\n        if result[i][1] < result[j][1] {\n            return false\n\
    \        }\n        return false\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuzd63r7m_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpuzd63r7m_test.go:36:12: invalid operation: result[i][0]\
    \ > result[j][0] (operator > not defined on interface)\n/tmp/tmpuzd63r7m_test.go:39:12:\
    \ invalid operation: result[i][0] < result[j][0] (operator < not defined on interface)\n\
    /tmp/tmpuzd63r7m_test.go:42:12: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmpuzd63r7m_test.go:45:12: invalid\
    \ operation: result[i][1] < result[j][1] (operator < not defined on interface)\n\
    /tmp/tmpuzd63r7m_test.go:50:5: undefined: sort\n/tmp/tmpuzd63r7m_test.go:51:12:\
    \ invalid operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmpuzd63r7m_test.go:54:12: invalid operation: result[i][1] < result[j][1]\
    \ (operator < not defined on interface)\n/tmp/tmpuzd63r7m_test.go:69:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpuzd63r7m_test.go:70:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpuzd63r7m_test.go:70:207:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075285
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Sort(byRow(result))\n\
    \    sort.Sort(byCol(result))\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcdhyv0_c_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpcdhyv0_c_test.go:35:15: undefined: byRow\n/tmp/tmpcdhyv0_c_test.go:36:5:\
    \ undefined: sort\n/tmp/tmpcdhyv0_c_test.go:36:15: undefined: byCol\n/tmp/tmpcdhyv0_c_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcdhyv0_c_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcdhyv0_c_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcdhyv0_c_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpcdhyv0_c_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075285
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        result[i] = make([]interface{}, len(row))\n\
    \        for j, val := range row {\n            result[i][j] = val\n        }\n\
    \    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n    result\
    \ := result[x:]\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu58l8jf4_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpu58l8jf4_test.go:31:15: undefined: byRow\n/tmp/tmpu58l8jf4_test.go:32:5:\
    \ undefined: sort\n/tmp/tmpu58l8jf4_test.go:32:15: undefined: byCol\n/tmp/tmpu58l8jf4_test.go:33:12:\
    \ no new variables on left side of :=\n/tmp/tmpu58l8jf4_test.go:44:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpu58l8jf4_test.go:45:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpu58l8jf4_test.go:46:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpu58l8jf4_test.go:49:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpu58l8jf4_test.go:49:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpu58l8jf4_test.go:49:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075285
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    for i := range r {\n        for j := range r[i] {\n            r[i][j]\
    \ = lst[i][j]\n        }\n    }\n    sort.Sort(byRow(r))\n    sort.Sort(byCol(r))\n\
    \    r := make([][]interface{}, len(r))\n    for i := range r {\n        r[i]\
    \ = make([]interface{}, len(r[i]))\n        for j := range r[i] {\n          \
    \  r[i][j] = r[i][j].(int)\n        }\n    }\n    for i := range r {\n       \
    \ for j := range r[i] {\n            if r[i][j] == x {\n                return\
    \ r\n            }\n        }\n    }\n    return nil\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk09fmcua_test.go:33:5:\
    \ undefined: sort\n/tmp/tmpk09fmcua_test.go:33:15: undefined: byRow\n/tmp/tmpk09fmcua_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpk09fmcua_test.go:34:15: undefined: byCol\n/tmp/tmpk09fmcua_test.go:35:7:\
    \ no new variables on left side of :=\n/tmp/tmpk09fmcua_test.go:59:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpk09fmcua_test.go:60:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpk09fmcua_test.go:61:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk09fmcua_test.go:64:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpk09fmcua_test.go:64:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpk09fmcua_test.go:64:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075285
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var result []interface{}\n        for _, val :=\
    \ range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{row, val})\n            }\n        }\n        result = append(result,\
    \ []interface{}{row, 0})\n        result = append(result, get_row(row, x))\n \
    \       result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, \nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxnqp41ls_test.go:90:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpig1z6di9_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpig1z6di9_test.go:36:5: undefined: sort\n/tmp/tmpig1z6di9_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpig1z6di9_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpig1z6di9_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpig1z6di9_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpig1z6di9_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075285
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    for i := range r {\n        for j := range r[i] {\n            r[i][j]\
    \ = lst[i][j]\n        }\n    }\n    r := r[x:]\n    sort.Slice(r, func(i, j int)\
    \ bool {\n        if r[i][0] < r[j][0] {\n            return true\n        }\n\
    \        if r[i][0] > r[j][0] {\n            return false\n        }\n       \
    \ if r[i][1] < r[j][1] {\n            return true\n        }\n        if r[i][1]\
    \ > r[j][1] {\n            return false\n        }\n        return false\n   \
    \ })\n    r := r[:x]\n    sort.Slice(r, func(i, j int) bool {\n        if r[i][1]\
    \ < r[j][1] {\n            return true\n        }\n        if r[i][1] > r[j][1]\
    \ {\n            return false\n        }\n        return false\n    })\n    return\
    \ r\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0vw_kyyl_test.go:33:7: no new variables on left side of :=

    /tmp/tmp0vw_kyyl_test.go:34:5: undefined: sort

    /tmp/tmp0vw_kyyl_test.go:35:12: invalid operation: r[i][0] < r[j][0] (operator
    < not defined on interface)

    /tmp/tmp0vw_kyyl_test.go:38:12: invalid operation: r[i][0] > r[j][0] (operator
    > not defined on interface)

    /tmp/tmp0vw_kyyl_test.go:41:12: invalid operation: r[i][1] < r[j][1] (operator
    < not defined on interface)

    /tmp/tmp0vw_kyyl_test.go:44:12: invalid operation: r[i][1] > r[j][1] (operator
    > not defined on interface)

    /tmp/tmp0vw_kyyl_test.go:49:7: no new variables on left side of :=

    /tmp/tmp0vw_kyyl_test.go:50:5: undefined: sort

    /tmp/tmp0vw_kyyl_test.go:51:12: invalid operation: r[i][1] < r[j][1] (operator
    < not defined on interface)

    /tmp/tmp0vw_kyyl_test.go:54:12: invalid operation: r[i][1] > r[j][1] (operator
    > not defined on interface)

    /tmp/tmp0vw_kyyl_test.go:54:12: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    rows\
    \ := make([][]int, len(lst))\n    for i := 0; i < len(rows); i++ {\n        rows[i]\
    \ = make([]int, len(lst[i]))\n    }\n    for i := 0; i < len(rows); i++ {\n  \
    \      for j := 0; j < len(rows[i]); j++ {\n            rows[i][j] = lst[i][j]\n\
    \        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(rows)))\n    for _,\
    \ row := range rows {\n        sort.Sort(sort.Reverse(sort.IntSlice(row)))\n \
    \       if x == row[0] {\n            result = append(result, row)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpcllz99b8_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpcllz99b8_test.go:36:9: undefined: sort\n/tmp/tmpcllz99b8_test.go:38:37:\
    \ cannot use row (variable of type []int) as type []interface{} in argument to\
    \ append\n/tmp/tmpcllz99b8_test.go:51:132: cannot use []interface{}{\u2026} (value\
    \ of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcllz99b8_test.go:52:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpcllz99b8_test.go:53:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpcllz99b8_test.go:56:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpcllz99b8_test.go:56:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"%d\", i)\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        if result[i][0] < result[j][0] {\n          \
    \  return true\n        }\n        if result[i][0] > result[j][0] {\n        \
    \    return false\n        }\n        if result[i][1] > result[j][1] {\n     \
    \       return true\n        }\n        if result[i][1] < result[j][1] {\n   \
    \         return false\n        }\n        return false\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        if result[i][1] > result[j][1] {\n          \
    \  return true\n        }\n        if result[i][1] < result[j][1] {\n        \
    \    return false\n        }\n        return false\n    })\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmptyryqh_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpmptyryqh_test.go:36:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpmptyryqh_test.go:39:12:\
    \ invalid operation: result[i][0] > result[j][0] (operator > not defined on interface)\n\
    /tmp/tmpmptyryqh_test.go:42:12: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmpmptyryqh_test.go:45:12: invalid\
    \ operation: result[i][1] < result[j][1] (operator < not defined on interface)\n\
    /tmp/tmpmptyryqh_test.go:50:5: undefined: sort\n/tmp/tmpmptyryqh_test.go:51:12:\
    \ invalid operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmpmptyryqh_test.go:54:12: invalid operation: result[i][1] < result[j][1]\
    \ (operator < not defined on interface)\n/tmp/tmpmptyryqh_test.go:69:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpmptyryqh_test.go:70:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmptyryqh_test.go:70:207:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", j)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        if result[i][0] < result[j][0] {\n            return true\n        }\n\
    \        if result[i][0] > result[j][0] {\n            return false\n        }\n\
    \        if result[i][1] < result[j][1] {\n            return true\n        }\n\
    \        if result[i][1] > result[j][1] {\n            return false\n        }\n\
    \        return false\n    })\n    sort.Slice(result, func(i, j int) bool {\n\
    \        if result[i][1] > result[j][1] {\n            return true\n        }\n\
    \        if result[i][1] < result[j][1] {\n            return false\n        }\n\
    \        return false\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxoqlzrg4_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpxoqlzrg4_test.go:36:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpxoqlzrg4_test.go:39:12:\
    \ invalid operation: result[i][0] > result[j][0] (operator > not defined on interface)\n\
    /tmp/tmpxoqlzrg4_test.go:42:12: invalid operation: result[i][1] < result[j][1]\
    \ (operator < not defined on interface)\n/tmp/tmpxoqlzrg4_test.go:45:12: invalid\
    \ operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmpxoqlzrg4_test.go:50:5: undefined: sort\n/tmp/tmpxoqlzrg4_test.go:51:12:\
    \ invalid operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmpxoqlzrg4_test.go:54:12: invalid operation: result[i][1] < result[j][1]\
    \ (operator < not defined on interface)\n/tmp/tmpxoqlzrg4_test.go:69:132: cannot\
    \ use []interface{}{\u2026} (value of type []interface{}) as type []int in array\
    \ or slice literal\n/tmp/tmpxoqlzrg4_test.go:70:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxoqlzrg4_test.go:70:207:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        result := append(result, get_row_helper(row,\
    \ x))\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return row_inc(result[i])\
    \ < row_inc(result[j])\n    })\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return col_dec(result[i]) < col_dec(result[j])\n    })\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjywttn4o_test.go:26:9:\
    \ result declared but not used\n/tmp/tmpjywttn4o_test.go:26:34: undefined: get_row_helper\n\
    /tmp/tmpjywttn4o_test.go:28:5: undefined: sort\n/tmp/tmpjywttn4o_test.go:29:16:\
    \ undefined: row_inc\n/tmp/tmpjywttn4o_test.go:31:5: undefined: sort\n/tmp/tmpjywttn4o_test.go:32:16:\
    \ undefined: col_dec\n/tmp/tmpjywttn4o_test.go:44:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpjywttn4o_test.go:45:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpjywttn4o_test.go:46:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpjywttn4o_test.go:49:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpjywttn4o_test.go:49:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    row := make([][]interface{}, len(lst))\n\
    \    for i := range row {\n        row[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    i := 0\n    for _, row := range lst {\n        for _, col := range\
    \ row {\n            row[i][x] = col\n            i++\n        }\n    }\n    sort.Slice(row,\
    \ func(i, j int) bool {\n        return row[i][0] < row[j][0]\n    })\n    sort.Slice(row,\
    \ func(i, j int) bool {\n        return row[i][1] > row[j][1]\n    })\n    return\
    \ row\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7k2v_30z_test.go:31:19:\
    \ invalid operation: cannot index row[i] (variable of type int)\n/tmp/tmp7k2v_30z_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp7k2v_30z_test.go:36:16: invalid operation: row[i][0]\
    \ < row[j][0] (operator < not defined on interface)\n/tmp/tmp7k2v_30z_test.go:38:5:\
    \ undefined: sort\n/tmp/tmp7k2v_30z_test.go:39:16: invalid operation: row[i][1]\
    \ > row[j][1] (operator > not defined on interface)\n/tmp/tmp7k2v_30z_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7k2v_30z_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp7k2v_30z_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7k2v_30z_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp7k2v_30z_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp7k2v_30z_test.go:56:106: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if x == lst[i][j] {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        if i == len(result) || j == len(result[i]) || result[i][j] != result[i-1][j]\
    \ {\n            return result[i][j] < result[i-1][j]\n        }\n        return\
    \ false\n    })\n    sort.Slice(result, func(i, j int) bool {\n        if i ==\
    \ len(result) || j == len(result[i]) || result[i][j] != result[i-1][j] {\n   \
    \         return result[i][j] > result[i-1][j]\n        }\n        return false\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp_4pmy6x2_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp_4pmy6x2_test.go:37:20: invalid operation: result[i][j]\
    \ < result[i - 1][j] (operator < not defined on interface)\n/tmp/tmp_4pmy6x2_test.go:41:5:\
    \ undefined: sort\n/tmp/tmp_4pmy6x2_test.go:43:20: invalid operation: result[i][j]\
    \ > result[i - 1][j] (operator > not defined on interface)\n/tmp/tmp_4pmy6x2_test.go:57:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp_4pmy6x2_test.go:58:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp_4pmy6x2_test.go:59:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp_4pmy6x2_test.go:62:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp_4pmy6x2_test.go:62:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq28t28hg_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpq28t28hg_test.go:35:15: undefined: byRow\n/tmp/tmpq28t28hg_test.go:36:5:\
    \ undefined: sort\n/tmp/tmpq28t28hg_test.go:36:15: undefined: byCol\n/tmp/tmpq28t28hg_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpq28t28hg_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpq28t28hg_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpq28t28hg_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpq28t28hg_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", j)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        if result[i][0] < result[j][0] {\n            return true\n        }\n\
    \        return false\n    })\n    sort.Slice(result, func(i, j int) bool {\n\
    \        if result[i][1] > result[j][1] {\n            return true\n        }\n\
    \        return false\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpnwk2pf4c_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpnwk2pf4c_test.go:36:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpnwk2pf4c_test.go:41:5:\
    \ undefined: sort\n/tmp/tmpnwk2pf4c_test.go:42:12: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpnwk2pf4c_test.go:57:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnwk2pf4c_test.go:58:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpnwk2pf4c_test.go:59:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpnwk2pf4c_test.go:62:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpnwk2pf4c_test.go:62:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", j)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][1] > result[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmprk_gw4i1_test.go:35:5:\
    \ undefined: sort\n/tmp/tmprk_gw4i1_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmprk_gw4i1_test.go:38:5:\
    \ undefined: sort\n/tmp/tmprk_gw4i1_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmprk_gw4i1_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprk_gw4i1_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmprk_gw4i1_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmprk_gw4i1_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmprk_gw4i1_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        result := append(result, get_row_helper(row,\
    \ x))\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return row_inc(result[i])\
    \ < row_inc(result[j])\n    })\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return col_dec(result[i]) < col_dec(result[j])\n    })\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjywttn4o_test.go:26:9:\
    \ result declared but not used\n/tmp/tmpjywttn4o_test.go:26:34: undefined: get_row_helper\n\
    /tmp/tmpjywttn4o_test.go:28:5: undefined: sort\n/tmp/tmpjywttn4o_test.go:29:16:\
    \ undefined: row_inc\n/tmp/tmpjywttn4o_test.go:31:5: undefined: sort\n/tmp/tmpjywttn4o_test.go:32:16:\
    \ undefined: col_dec\n/tmp/tmpjywttn4o_test.go:44:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpjywttn4o_test.go:45:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpjywttn4o_test.go:46:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpjywttn4o_test.go:49:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpjywttn4o_test.go:49:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        result := append(result, get_row(row, x))\n \
    \   }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate :=\
    \ get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpq3czh4nn_test.go:26:9:\
    \ result declared but not used\n/tmp/tmpq3czh4nn_test.go:26:34: cannot use get_row(row,\
    \ x) (value of type [][]interface{}) as type []interface{} in argument to append\n\
    /tmp/tmpq3czh4nn_test.go:26:42: cannot use row (variable of type []int) as type\
    \ [][]int in argument to get_row\n/tmp/tmpq3czh4nn_test.go:38:132: cannot use\
    \ []interface{}{\u2026} (value of type []interface{}) as type []int in array or\
    \ slice literal\n/tmp/tmpq3czh4nn_test.go:39:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpq3czh4nn_test.go:40:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpq3czh4nn_test.go:43:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpq3czh4nn_test.go:43:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    var row_index\
    \ int\n    var col_index int\n    for row_index = 0; row_index < len(lst); row_index++\
    \ {\n        col_index = 0\n        for col_index = 0; col_index < len(lst[row_index]);\
    \ col_index++ {\n            if lst[row_index][col_index] == x {\n           \
    \     result = append(result, []interface{}{row_index, col_index})\n         \
    \   }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n      \
    \  return result[i][0] > result[j][0]\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][1] > result[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe4qydsmb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpe4qydsmb_test.go:36:16: invalid operation: result[i][0]\
    \ > result[j][0] (operator > not defined on interface)\n/tmp/tmpe4qydsmb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpe4qydsmb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpe4qydsmb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpe4qydsmb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpe4qydsmb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpe4qydsmb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpe4qydsmb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        result[i] = make([]interface{}, len(row))\n\
    \        for j, val := range row {\n            result[i][j] = val\n        }\n\
    \    }\n    sort.Slice(result, func(i, j int) bool {\n        return rows(result[i])\
    \ < rows(result[j])\n    })\n    sort.Slice(result, func(i, j int) bool {\n  \
    \      return cols(result[i]) < cols(result[j])\n    })\n    for i := range result\
    \ {\n        result[i] = result[i][cols(result[i])-x:]\n    }\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzitgnnv0_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpzitgnnv0_test.go:32:16: undefined: rows\n/tmp/tmpzitgnnv0_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpzitgnnv0_test.go:35:16: undefined: cols\n/tmp/tmpzitgnnv0_test.go:38:31:\
    \ undefined: cols\n/tmp/tmpzitgnnv0_test.go:50:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpzitgnnv0_test.go:51:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpzitgnnv0_test.go:52:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpzitgnnv0_test.go:55:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpzitgnnv0_test.go:55:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpzitgnnv0_test.go:55:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n        for j := 0; j < len(lst[i]); j++ {\n            result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return len(result[i]) < len(result[j])\n    })\n\
    \    sort.Slice(result[len(result)-1], func(i, j int) bool {\n        return len(result[len(result)-1])\
    \ < len(result[len(result)-1][j])\n    })\n    for i := 0; i < len(result); i++\
    \ {\n        sort.Slice(result[i], func(i, j int) bool {\n            return result[i][j]\
    \ < result[i][j+1]\n        })\n    }\n    for i := 0; i < len(result); i++ {\n\
    \        sort.Slice(result[i], func(i, j int) bool {\n            return result[i][j]\
    \ > result[i][j-1]\n        })\n    }\n    for i := 0; i < len(result); i++ {\n\
    \        sort.Slice(result[i], func(i, j int) bool {\n            return result[i][j]\
    \ < result[i+1][j]\n        })\n    }\n    for i := 0; i < len(result); i++ {\n\
    \        sort.Slice(result[i], func(i, j int) bool {\n            return result[i][j]\
    \ > result[i-1][j]\n        })\n    }\n    for i := 0; i < len(result); i++ {\n\
    \        sort.Slice(result[i], func(i, j int) bool {\n            return result[i][j]\
    \ < result[i][len(result[i])-1]\n        })\n    }\n    for i := 0; i < len(result);\
    \ i++ {\n        sort.Slice(result[i], func(i, j int) bool {\n            return\
    \ result[i][j] > result[i][len(result[i])-1]\n        })\n    }\n    for i :=\
    \ 0; i < len(result); i++ {\n        sort.Slice(result[i], func(i, j int) bool\
    \ {\n            return result[i][j] < result[i+1][len(result[i])-1]\n       \
    \ })\n    }\n    for i := 0; i < len(result); i++ {\n        sort.Slice(result[i],\
    \ func(i, j int) bool {\n            return result[i][j] > result[i-1][len(result[i])-1]\n\
    \        })\n    }\n    for i := 0; i < len(result); i++ {\n        sort.Slice(result[i],\
    \ func(i, j int) bool {\n            return result[i][j] < result[i][len(result[i])-1]\n\
    \        })\n    }\n    for i := 0; i < len(result); i++ {\n        sort.Slice(result[i],\
    \ func(i, j int) bool {\n            return result[i][j\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9b6jp80i_test.go:84:31: expected '']'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075285
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    for i := range r {\n        for j := range r[i] {\n            r[i][j]\
    \ = lst[i][j]\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(row(r))))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(col(r))))\n    for i := range r {\n\
    \        r[i] = r[i][col(r[i])]\n    }\n    return r\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps2kt0i7j_test.go:33:5:\
    \ undefined: sort\n/tmp/tmps2kt0i7j_test.go:33:42: undefined: row\n/tmp/tmps2kt0i7j_test.go:34:5:\
    \ undefined: sort\n/tmp/tmps2kt0i7j_test.go:34:42: undefined: col\n/tmp/tmps2kt0i7j_test.go:36:16:\
    \ cannot use r[i][col(r[i])] (variable of type interface{}) as type []interface{}\
    \ in assignment:\n\tneed type assertion\n/tmp/tmps2kt0i7j_test.go:36:21: undefined:\
    \ col\n/tmp/tmps2kt0i7j_test.go:48:132: cannot use []interface{}{\u2026} (value\
    \ of type []interface{}) as type []int in array or slice literal\n/tmp/tmps2kt0i7j_test.go:49:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps2kt0i7j_test.go:50:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmps2kt0i7j_test.go:53:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmps2kt0i7j_test.go:53:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        if result[i][0] < result[j][0] {\n            return true\n        }\n\
    \        return false\n    })\n    for i := range result {\n        sort.Slice(result[i],\
    \ func(j, k int) bool {\n            if result[i][j] < result[i][k] {\n      \
    \          return true\n            }\n            return false\n        })\n\
    \    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmyv4586__test.go:35:5:\
    \ undefined: sort\n/tmp/tmpmyv4586__test.go:36:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpmyv4586__test.go:42:9:\
    \ undefined: sort\n/tmp/tmpmyv4586__test.go:43:16: invalid operation: result[i][j]\
    \ < result[i][k] (operator < not defined on interface)\n/tmp/tmpmyv4586__test.go:59:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmyv4586__test.go:60:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmyv4586__test.go:61:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmyv4586__test.go:64:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpmyv4586__test.go:64:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][1] > result[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwu57p3s_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpkwu57p3s_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpkwu57p3s_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpkwu57p3s_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpkwu57p3s_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkwu57p3s_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkwu57p3s_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkwu57p3s_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpkwu57p3s_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        if result[i][0] < result[j][0] {\n            return true\n\
    \        }\n        return false\n    })\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        if result[i][1] > result[j][1] {\n            return true\n\
    \        }\n        return false\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps6hheimp_test.go:35:5:\
    \ undefined: sort\n/tmp/tmps6hheimp_test.go:36:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmps6hheimp_test.go:41:5:\
    \ undefined: sort\n/tmp/tmps6hheimp_test.go:42:12: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmps6hheimp_test.go:57:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps6hheimp_test.go:58:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmps6hheimp_test.go:59:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps6hheimp_test.go:62:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmps6hheimp_test.go:62:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        row_result := []interface{}{}\n        for _,\
    \ cell := range row {\n            if cell == x {\n                row_result\
    \ = append(row_result, cell)\n            }\n        }\n        result = append(result,\
    \ row_result)\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ rows(result[i]) < rows(result[j])\n    })\n    sort.Slice(result, func(i, j\
    \ int) bool {\n        return columns(result[i]) < columns(result[j])\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpi1xizqm5_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpi1xizqm5_test.go:35:16: undefined: rows\n/tmp/tmpi1xizqm5_test.go:37:5:\
    \ undefined: sort\n/tmp/tmpi1xizqm5_test.go:38:16: undefined: columns\n/tmp/tmpi1xizqm5_test.go:50:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpi1xizqm5_test.go:51:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpi1xizqm5_test.go:52:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpi1xizqm5_test.go:55:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpi1xizqm5_test.go:55:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsa6rixn5_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpsa6rixn5_test.go:36:5: undefined: sort\n/tmp/tmpsa6rixn5_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsa6rixn5_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsa6rixn5_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsa6rixn5_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsa6rixn5_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"%d\", i)\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxkty8g1f_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpxkty8g1f_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpxkty8g1f_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpxkty8g1f_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpxkty8g1f_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxkty8g1f_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxkty8g1f_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxkty8g1f_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpxkty8g1f_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var found bool\n        for _, value := range row\
    \ {\n            if value == x {\n                found = true\n             \
    \   break\n            }\n        }\n        if found {\n            result =\
    \ append(result, []interface{}{row, x})\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return rows(result[i]) < rows(result[j])\n  \
    \  })\n    sort.Slice(result, func(i, j int) bool {\n        return columns(result[i])\
    \ < columns(result[j])\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpo__s3e6l_test.go:37:5:\
    \ undefined: sort\n/tmp/tmpo__s3e6l_test.go:38:16: undefined: rows\n/tmp/tmpo__s3e6l_test.go:40:5:\
    \ undefined: sort\n/tmp/tmpo__s3e6l_test.go:41:16: undefined: columns\n/tmp/tmpo__s3e6l_test.go:53:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpo__s3e6l_test.go:54:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpo__s3e6l_test.go:55:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpo__s3e6l_test.go:58:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpo__s3e6l_test.go:58:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        result := append(result, get_row_helper(row,\
    \ x))\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return row_inc(result[i])\
    \ < row_inc(result[j])\n    })\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return col_dec(result[i]) < col_dec(result[j])\n    })\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjywttn4o_test.go:26:9:\
    \ result declared but not used\n/tmp/tmpjywttn4o_test.go:26:34: undefined: get_row_helper\n\
    /tmp/tmpjywttn4o_test.go:28:5: undefined: sort\n/tmp/tmpjywttn4o_test.go:29:16:\
    \ undefined: row_inc\n/tmp/tmpjywttn4o_test.go:31:5: undefined: sort\n/tmp/tmpjywttn4o_test.go:32:16:\
    \ undefined: col_dec\n/tmp/tmpjywttn4o_test.go:44:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpjywttn4o_test.go:45:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpjywttn4o_test.go:46:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpjywttn4o_test.go:49:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpjywttn4o_test.go:49:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    for i := range r {\n        for j := range r[i] {\n            r[i][j]\
    \ = lst[i][j]\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(row(r))))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(col(r))))\n    result := make([][]interface{},\
    \ len(r))\n    for i := range r {\n        result[i] = make([]interface{}, len(r[i]))\n\
    \    }\n    for i := range r {\n        for j := range r[i] {\n            if\
    \ r[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n    \
    \        }\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpb93ayaky_test.go:33:5:\
    \ undefined: sort\n/tmp/tmpb93ayaky_test.go:33:42: undefined: row\n/tmp/tmpb93ayaky_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpb93ayaky_test.go:34:42: undefined: col\n/tmp/tmpb93ayaky_test.go:56:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpb93ayaky_test.go:57:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpb93ayaky_test.go:58:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpb93ayaky_test.go:61:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpb93ayaky_test.go:61:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"%d\", i)\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    for i := 0; i < len(result); i++ {\n        sort.Sort(sort.Reverse(sort.IntSlice(result[i])))\n\
    \    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpser13vk4_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpser13vk4_test.go:37:9: undefined: sort\n/tmp/tmpser13vk4_test.go:49:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpser13vk4_test.go:50:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpser13vk4_test.go:51:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpser13vk4_test.go:54:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpser13vk4_test.go:54:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        result := append(result, get_row_helper(row,\
    \ x))\n    }\n    sort.Sort(byRow(result))\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8lybya8j_test.go:26:9:\
    \ result declared but not used\n/tmp/tmp8lybya8j_test.go:26:34: undefined: get_row_helper\n\
    /tmp/tmp8lybya8j_test.go:28:5: undefined: sort\n/tmp/tmp8lybya8j_test.go:28:15:\
    \ undefined: byRow\n/tmp/tmp8lybya8j_test.go:39:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp8lybya8j_test.go:40:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp8lybya8j_test.go:41:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp8lybya8j_test.go:44:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp8lybya8j_test.go:44:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n   \
    \ sort.Slice(result, func(i, j int) bool {\n        if result[i][0] < result[j][0]\
    \ {\n            return true\n        }\n        if result[i][0] > result[j][0]\
    \ {\n            return false\n        }\n        if result[i][1] > result[j][1]\
    \ {\n            return true\n        }\n        if result[i][1] < result[j][1]\
    \ {\n            return false\n        }\n        return false\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp63y7nap1_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp63y7nap1_test.go:36:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp63y7nap1_test.go:39:12:\
    \ invalid operation: result[i][0] > result[j][0] (operator > not defined on interface)\n\
    /tmp/tmp63y7nap1_test.go:42:12: invalid operation: result[i][1] > result[j][1]\
    \ (operator > not defined on interface)\n/tmp/tmp63y7nap1_test.go:45:12: invalid\
    \ operation: result[i][1] < result[j][1] (operator < not defined on interface)\n\
    /tmp/tmp63y7nap1_test.go:60:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmp63y7nap1_test.go:61:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp63y7nap1_test.go:62:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp63y7nap1_test.go:65:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmp63y7nap1_test.go:65:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp63y7nap1_test.go:65:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"%d\", i)\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxkty8g1f_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpxkty8g1f_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpxkty8g1f_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpxkty8g1f_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpxkty8g1f_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxkty8g1f_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxkty8g1f_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxkty8g1f_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpxkty8g1f_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var result []interface{}\n        for _, val :=\
    \ range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{row, val})\n            }\n        }\n        result = append(result,\
    \ []interface{}{row, 0})\n        result = append(result, get_row(row, x))\n \
    \       result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, \nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxnqp41ls_test.go:90:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        row_result := make([]interface{}, len(row))\n\
    \        for j, val := range row {\n            if val == x {\n              \
    \  row_result[j] = fmt.Sprintf(\"%d\", j)\n            }\n        }\n        result[i]\
    \ = row_result\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i][1] > result[j][1]\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpokvubvrn_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpokvubvrn_test.go:35:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpokvubvrn_test.go:37:5:\
    \ undefined: sort\n/tmp/tmpokvubvrn_test.go:38:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpokvubvrn_test.go:50:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpokvubvrn_test.go:51:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpokvubvrn_test.go:52:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpokvubvrn_test.go:55:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpokvubvrn_test.go:55:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Write your code here\n    \n    row\
    \ := make([][]interface{}, len(lst))\n    for i := range row {\n        row[i]\
    \ = make([]interface{}, len(lst[i]))\n    }\n    \n    for i := range row {\n\
    \        for j := range row[i] {\n            row[i][j] = lst[i][j]\n        }\n\
    \    }\n    \n    sort.Slice(row, func(i, j int) bool {\n        return row[i][0]\
    \ < row[j][0]\n    })\n    \n    sort.Slice(row, func(i, j int) bool {\n     \
    \   return row[i][1] > row[j][1]\n    })\n    \n    for i := range row {\n   \
    \     row[i] = append([]interface{}{row[i][0], row[i][1]}, row[i][2:]...)\n  \
    \  }\n    \n    return row\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpu429fdll_test.go:37:5:\
    \ undefined: sort\n/tmp/tmpu429fdll_test.go:38:16: invalid operation: row[i][0]\
    \ < row[j][0] (operator < not defined on interface)\n/tmp/tmpu429fdll_test.go:41:5:\
    \ undefined: sort\n/tmp/tmpu429fdll_test.go:42:16: invalid operation: row[i][1]\
    \ > row[j][1] (operator > not defined on interface)\n/tmp/tmpu429fdll_test.go:59:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpu429fdll_test.go:60:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpu429fdll_test.go:61:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpu429fdll_test.go:64:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpu429fdll_test.go:64:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Your code here\n    result := make([][]interface{},\
    \ len(lst))\n    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfh5i_wkd_test.go:36:5:\
    \ undefined: sort\n/tmp/tmpfh5i_wkd_test.go:37:5: undefined: sort\n/tmp/tmpfh5i_wkd_test.go:48:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfh5i_wkd_test.go:49:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpfh5i_wkd_test.go:50:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfh5i_wkd_test.go:53:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpfh5i_wkd_test.go:53:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        result[i] = make([]interface{}, len(row))\n\
    \        for j, val := range row {\n            result[i][j] = val\n        }\n\
    \    }\n    sort.Slice(result, func(i, j int) bool {\n        return rows(result[i])\
    \ < rows(result[j])\n    })\n    sort.Slice(result, func(i, j int) bool {\n  \
    \      return columns(result[i]) < columns(result[j])\n    })\n    for i := range\
    \ result {\n        result[i] = sort_coordinates(result[i])\n    }\n    return\
    \ filter_by_row(result, x)\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpx2ii492v_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpx2ii492v_test.go:32:16: undefined: rows\n/tmp/tmpx2ii492v_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpx2ii492v_test.go:35:16: undefined: columns\n/tmp/tmpx2ii492v_test.go:38:21:\
    \ undefined: sort_coordinates\n/tmp/tmpx2ii492v_test.go:40:12: undefined: filter_by_row\n\
    /tmp/tmpx2ii492v_test.go:50:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpx2ii492v_test.go:51:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpx2ii492v_test.go:52:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpx2ii492v_test.go:55:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpx2ii492v_test.go:55:26: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    row := 0\n    column := 0\n    for _, row := range lst {\n       \
    \ for _, value := range row {\n            if value == x {\n                result[row][column]\
    \ = fmt.Sprintf(\"%d\", i)\n            }\n            column++\n        }\n \
    \       column = 0\n        row++\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpfdlgiown_test.go:28:5:\
    \ row declared but not used\n/tmp/tmpfdlgiown_test.go:33:24: invalid argument:\
    \ index row (variable of type []int) must be integer\n/tmp/tmpfdlgiown_test.go:33:57:\
    \ undefined: i\n/tmp/tmpfdlgiown_test.go:38:9: invalid operation: row++ (non-numeric\
    \ type []int)\n/tmp/tmpfdlgiown_test.go:40:5: undefined: sort\n/tmp/tmpfdlgiown_test.go:41:16:\
    \ invalid operation: result[i][0] < result[j][0] (operator < not defined on interface)\n\
    /tmp/tmpfdlgiown_test.go:43:5: undefined: sort\n/tmp/tmpfdlgiown_test.go:44:16:\
    \ invalid operation: result[i][1] > result[j][1] (operator > not defined on interface)\n\
    /tmp/tmpfdlgiown_test.go:56:132: cannot use []interface{}{\u2026} (value of type\
    \ []interface{}) as type []int in array or slice literal\n/tmp/tmpfdlgiown_test.go:57:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpfdlgiown_test.go:57:207: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpig1z6di9_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpig1z6di9_test.go:36:5: undefined: sort\n/tmp/tmpig1z6di9_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpig1z6di9_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpig1z6di9_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpig1z6di9_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpig1z6di9_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075285
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        row_result := []interface{}{}\n        for _,\
    \ val := range row {\n            if val == x {\n                row_result =\
    \ append(row_result, val)\n            }\n        }\n        result = append(result,\
    \ row_result)\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i][1] > result[j][1]\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmphe3uttfz_test.go:34:5:\
    \ undefined: sort\n/tmp/tmphe3uttfz_test.go:35:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmphe3uttfz_test.go:37:5:\
    \ undefined: sort\n/tmp/tmphe3uttfz_test.go:38:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmphe3uttfz_test.go:50:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphe3uttfz_test.go:51:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmphe3uttfz_test.go:52:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmphe3uttfz_test.go:55:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmphe3uttfz_test.go:55:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i, j)\n            }\n        }\n    }\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][0] < result[j][0]\n    })\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return result[i][1] > result[j][1]\n\
    \    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9or3ocgl_test.go:35:5:\
    \ undefined: sort\n/tmp/tmp9or3ocgl_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmp9or3ocgl_test.go:38:5:\
    \ undefined: sort\n/tmp/tmp9or3ocgl_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmp9or3ocgl_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9or3ocgl_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmp9or3ocgl_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmp9or3ocgl_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmp9or3ocgl_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := [][]interface{}{}\n    for\
    \ _, row := range lst {\n        result := append(result, get_row_helper(row,\
    \ x))\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpe54qxdd__test.go:26:9:\
    \ result declared but not used\n/tmp/tmpe54qxdd__test.go:26:34: undefined: get_row_helper\n\
    /tmp/tmpe54qxdd__test.go:28:5: undefined: sort\n/tmp/tmpe54qxdd__test.go:39:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpe54qxdd__test.go:40:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpe54qxdd__test.go:41:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpe54qxdd__test.go:44:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpe54qxdd__test.go:44:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpig1z6di9_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpig1z6di9_test.go:36:5: undefined: sort\n/tmp/tmpig1z6di9_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpig1z6di9_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpig1z6di9_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpig1z6di9_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpig1z6di9_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075285
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        result[i] = make([]interface{}, len(row))\n\
    \        for j, val := range row {\n            result[i][j] = val\n        }\n\
    \    }\n    sort.Slice(result, func(i, j int) bool {\n        return rows(result[i])\
    \ < rows(result[j])\n    })\n    sort.Slice(result, func(i, j int) bool {\n  \
    \      return cols(result[i]) < cols(result[j])\n    })\n    result := result[x:]\n\
    \    sort.Slice(result, func(i, j int) bool {\n        return rows(result[i])\
    \ < rows(result[j])\n    })\n    sort.Slice(result, func(i, j int) bool {\n  \
    \      return cols(result[i]) < cols(result[j])\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpwsmyd7_1_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpwsmyd7_1_test.go:32:16: undefined: rows\n/tmp/tmpwsmyd7_1_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpwsmyd7_1_test.go:35:16: undefined: cols\n/tmp/tmpwsmyd7_1_test.go:37:12:\
    \ no new variables on left side of :=\n/tmp/tmpwsmyd7_1_test.go:38:5: undefined:\
    \ sort\n/tmp/tmpwsmyd7_1_test.go:39:16: undefined: rows\n/tmp/tmpwsmyd7_1_test.go:41:5:\
    \ undefined: sort\n/tmp/tmpwsmyd7_1_test.go:42:16: undefined: cols\n/tmp/tmpwsmyd7_1_test.go:54:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpwsmyd7_1_test.go:54:132: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n        for j := 0; j < len(lst[i]); j++ {\n            result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n        }\n    }\n    sort.Sort(byRow(lst))\n\
    \    sort.Sort(byCol(lst))\n    for i := 0; i < len(lst); i++ {\n        sort.Sort(byCol(lst[i]))\n\
    \    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0; j < len(lst[i]);\
    \ j++ {\n            if lst[i][j] == x {\n                return result\n    \
    \        }\n        }\n    }\n    return nil\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpjftxv7me_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpjftxv7me_test.go:31:15: undefined: byRow\n/tmp/tmpjftxv7me_test.go:32:5:\
    \ undefined: sort\n/tmp/tmpjftxv7me_test.go:32:15: undefined: byCol\n/tmp/tmpjftxv7me_test.go:34:9:\
    \ undefined: sort\n/tmp/tmpjftxv7me_test.go:34:19: undefined: byCol\n/tmp/tmpjftxv7me_test.go:53:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpjftxv7me_test.go:54:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpjftxv7me_test.go:55:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpjftxv7me_test.go:58:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpjftxv7me_test.go:58:26:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        if result[i][0] < result[j][0] {\n            return true\n\
    \        }\n        return false\n    })\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        if result[i][1] > result[j][1] {\n            return true\n\
    \        }\n        return false\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmps6hheimp_test.go:35:5:\
    \ undefined: sort\n/tmp/tmps6hheimp_test.go:36:12: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmps6hheimp_test.go:41:5:\
    \ undefined: sort\n/tmp/tmps6hheimp_test.go:42:12: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmps6hheimp_test.go:57:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps6hheimp_test.go:58:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmps6hheimp_test.go:59:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmps6hheimp_test.go:62:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmps6hheimp_test.go:62:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Slice(result, func(i, j int) bool {\n\
    \        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i,\
    \ j int) bool {\n        return result[i][1] > result[j][1]\n    })\n    return\
    \ result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpkwu57p3s_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpkwu57p3s_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpkwu57p3s_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpkwu57p3s_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpkwu57p3s_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkwu57p3s_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpkwu57p3s_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpkwu57p3s_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpkwu57p3s_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := 0; i < len(lst); i++ {\n        result[i] = make([]interface{},\
    \ len(lst[i]))\n    }\n    for i := 0; i < len(lst); i++ {\n        for j := 0;\
    \ j < len(lst[i]); j++ {\n            if lst[i][j] == x {\n                result[i][j]\
    \ = fmt.Sprintf(\"(%d, %d)\", i+1, j+1)\n            }\n        }\n    }\n   \
    \ sort.Slice(result, func(i, j int) bool {\n        return result[i][0] < result[j][0]\n\
    \    })\n    sort.Slice(result, func(i, j int) bool {\n        return result[i][1]\
    \ > result[j][1]\n    })\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpiuyp8wxv_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpiuyp8wxv_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpiuyp8wxv_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpiuyp8wxv_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpiuyp8wxv_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpiuyp8wxv_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpiuyp8wxv_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpiuyp8wxv_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpiuyp8wxv_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075281
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        return result[i][0] < result[j][0]\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return result[i][1] > result[j][1]\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpqm6tkmqb_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:36:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:38:5:\
    \ undefined: sort\n/tmp/tmpqm6tkmqb_test.go:39:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpqm6tkmqb_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpqm6tkmqb_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpqm6tkmqb_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        result[i] = make([]interface{}, len(row))\n\
    \        for j, val := range row {\n            result[i][j] = val\n        }\n\
    \    }\n    sort.Slice(result, func(i, j int) bool {\n        return rows(result[i])\
    \ < rows(result[j])\n    })\n    sort.Slice(result, func(i, j int) bool {\n  \
    \      return cols(result[i]) < cols(result[j])\n    })\n    for i := range result\
    \ {\n        result[i] = result[i][cols(result[i])-x:]\n    }\n    return result\n\
    }\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzitgnnv0_test.go:31:5:\
    \ undefined: sort\n/tmp/tmpzitgnnv0_test.go:32:16: undefined: rows\n/tmp/tmpzitgnnv0_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpzitgnnv0_test.go:35:16: undefined: cols\n/tmp/tmpzitgnnv0_test.go:38:31:\
    \ undefined: cols\n/tmp/tmpzitgnnv0_test.go:50:132: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpzitgnnv0_test.go:51:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpzitgnnv0_test.go:52:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpzitgnnv0_test.go:55:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmpzitgnnv0_test.go:55:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpzitgnnv0_test.go:55:106:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075286
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"%d\", i)\n\
    \            }\n        }\n    }\n    sort.Sort(byRow(result))\n    sort.Sort(byCol(result))\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpmua1zwc4_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpmua1zwc4_test.go:35:15: undefined: byRow\n/tmp/tmpmua1zwc4_test.go:36:5:\
    \ undefined: sort\n/tmp/tmpmua1zwc4_test.go:36:15: undefined: byCol\n/tmp/tmpmua1zwc4_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmua1zwc4_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpmua1zwc4_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpmua1zwc4_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpmua1zwc4_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var result []interface{}\n        for _, col :=\
    \ range row {\n            if col == x {\n                result = append(result,\
    \ []interface{}{row, col})\n            }\n        }\n        result = append(result,\
    \ []interface{}{row, len(row)})\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr4cutngg_test.go:90:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i, row := range lst {\n        row_result := make([]interface{}, len(row))\n\
    \        for j, val := range row {\n            if val == x {\n              \
    \  row_result[j] = fmt.Sprintf(\"%d\", j)\n            }\n        }\n        result[i]\
    \ = row_result\n    }\n    sort.Slice(result, func(i, j int) bool {\n        return\
    \ result[i][0] < result[j][0]\n    })\n    sort.Slice(result, func(i, j int) bool\
    \ {\n        return result[i][1] > result[j][1]\n    })\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpokvubvrn_test.go:34:5:\
    \ undefined: sort\n/tmp/tmpokvubvrn_test.go:35:16: invalid operation: result[i][0]\
    \ < result[j][0] (operator < not defined on interface)\n/tmp/tmpokvubvrn_test.go:37:5:\
    \ undefined: sort\n/tmp/tmpokvubvrn_test.go:38:16: invalid operation: result[i][1]\
    \ > result[j][1] (operator > not defined on interface)\n/tmp/tmpokvubvrn_test.go:50:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpokvubvrn_test.go:51:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpokvubvrn_test.go:52:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpokvubvrn_test.go:55:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpokvubvrn_test.go:55:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075279
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsa6rixn5_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpsa6rixn5_test.go:36:5: undefined: sort\n/tmp/tmpsa6rixn5_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsa6rixn5_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsa6rixn5_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsa6rixn5_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsa6rixn5_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    // Write your code here\n    \n    \n\
    \    return [][]interface{}{}\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpxxrgkzw9_test.go:37:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxxrgkzw9_test.go:38:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpxxrgkzw9_test.go:39:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpxxrgkzw9_test.go:42:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpxxrgkzw9_test.go:42:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        if x == row[0] {\n            result = append(result,\
    \ row)\n        }\n    }\n    return result\n}\n\nfunc TestGet_Row(t *testing.T)\
    \ {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph2pdon8h_test.go:27:37:\
    \ cannot use row (variable of type []int) as type []interface{} in argument to\
    \ append\n/tmp/tmph2pdon8h_test.go:40:132: cannot use []interface{}{\u2026} (value\
    \ of type []interface{}) as type []int in array or slice literal\n/tmp/tmph2pdon8h_test.go:41:207:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmph2pdon8h_test.go:42:232: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmph2pdon8h_test.go:45:26:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type [][]int\
    \ in argument to candidate\n/tmp/tmph2pdon8h_test.go:45:106: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(result)))\n\
    \    sort.Sort(sort.Reverse(sort.IntSlice(result[0])))\n    return result\n}\n\
    \nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1,\
    \ 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1,\
    \ 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2, 0}} },\n    \
    \ { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1,\
    \ 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1}, []interface{}{1,\
    \ 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4, 1}, []interface{}{5,\
    \ 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4, 5, 6}, []int{1, 2, 3,\
    \ 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 0}, []interface{}{2, 1}, []interface{}{2, 0}, []interface{}{3,\
    \ 2}, []interface{}{3, 0}, []interface{}{4, 3}, []interface{}{4, 0}, []interface{}{5,\
    \ 4}, []interface{}{5, 0}, []interface{}{6, 5}, []interface{}{6, 0}} },\n    \
    \ { actual: candidate([][]int{}, 1), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([][]int{[]int{1}}, 2), expected: [][]interface{}{} },\n     { actual:\
    \ candidate([]interface{}{[]interface{}{}, []int{1}, []int{1, 2, 3}}, 3), expected:\
    \ [][]int{[]interface{}{2, 2}} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpsa6rixn5_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpsa6rixn5_test.go:36:5: undefined: sort\n/tmp/tmpsa6rixn5_test.go:47:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsa6rixn5_test.go:48:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpsa6rixn5_test.go:49:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpsa6rixn5_test.go:52:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpsa6rixn5_test.go:52:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075283
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    for i := range r {\n        for j := range r[i] {\n            r[i][j]\
    \ = lst[i][j]\n        }\n    }\n    sort.Sort(byRow(r))\n    sort.Sort(byCol(r))\n\
    \    return r\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmppumflnu__test.go:33:5:\
    \ undefined: sort\n/tmp/tmppumflnu__test.go:33:15: undefined: byRow\n/tmp/tmppumflnu__test.go:34:5:\
    \ undefined: sort\n/tmp/tmppumflnu__test.go:34:15: undefined: byCol\n/tmp/tmppumflnu__test.go:45:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmppumflnu__test.go:46:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmppumflnu__test.go:47:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmppumflnu__test.go:50:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmppumflnu__test.go:50:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075285
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i, j)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        if result[i][0] > result[j][0] {\n            return true\n\
    \        }\n        if result[i][0] < result[j][0] {\n            return false\n\
    \        }\n        if result[i][1] > result[j][1] {\n            return true\n\
    \        }\n        if result[i][1] < result[j][1] {\n            return false\n\
    \        }\n        return false\n    })\n    sort.Slice(result, func(i, j int)\
    \ bool {\n        if result[i][1] > result[j][1] {\n            return true\n\
    \        }\n        if result[i][1] < result[j][1] {\n            return false\n\
    \        }\n        if result[i][0] > result[j][0] {\n            return true\n\
    \        }\n        if result[i][0] < result[j][0] {\n            return false\n\
    \        }\n        return false\n    })\n    return result\n}\n\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_gz4kdh4_test.go:35:5: undefined: sort

    /tmp/tmp_gz4kdh4_test.go:36:12: invalid operation: result[i][0] > result[j][0]
    (operator > not defined on interface)

    /tmp/tmp_gz4kdh4_test.go:39:12: invalid operation: result[i][0] < result[j][0]
    (operator < not defined on interface)

    /tmp/tmp_gz4kdh4_test.go:42:12: invalid operation: result[i][1] > result[j][1]
    (operator > not defined on interface)

    /tmp/tmp_gz4kdh4_test.go:45:12: invalid operation: result[i][1] < result[j][1]
    (operator < not defined on interface)

    /tmp/tmp_gz4kdh4_test.go:50:5: undefined: sort

    /tmp/tmp_gz4kdh4_test.go:51:12: invalid operation: result[i][1] > result[j][1]
    (operator > not defined on interface)

    /tmp/tmp_gz4kdh4_test.go:54:12: invalid operation: result[i][1] < result[j][1]
    (operator < not defined on interface)

    /tmp/tmp_gz4kdh4_test.go:57:12: invalid operation: result[i][0] > result[j][0]
    (operator > not defined on interface)

    /tmp/tmp_gz4kdh4_test.go:60:12: invalid operation: result[i][0] < result[j][0]
    (operator < not defined on interface)

    /tmp/tmp_gz4kdh4_test.go:60:12: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    r := make([][]interface{}, len(lst))\n\
    \    for i := range r {\n        r[i] = make([]interface{}, len(lst[i]))\n   \
    \ }\n    for i := range r {\n        for j := range r[i] {\n            r[i][j]\
    \ = lst[i][j]\n        }\n    }\n    r := r[x:]\n    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n\
    \    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n\
    \    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n\
    \    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n\
    \    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n\
    \    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n\
    \    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n\
    \    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n\
    \    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n\
    \    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n\
    \    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n\
    \    r := r[:len(r)/len(r[0])][len(r)/len(r[0]):]\n    r := r[:len(\nfunc TestGet_Row(t\
    \ *testing.T) {\n  candidate := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1,\
    \ 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected:\
    \ [][]int{[]interface{}{0, 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2,\
    \ 5}, []interface{}{2, 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0,\
    \ 1}, []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvm8m45pk_test.go:57:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 2
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    result := make([][]interface{}, len(lst))\n\
    \    for i := range lst {\n        result[i] = make([]interface{}, len(lst[i]))\n\
    \    }\n    for i := range lst {\n        for j := range lst[i] {\n          \
    \  if lst[i][j] == x {\n                result[i][j] = fmt.Sprintf(\"(%d, %d)\"\
    , i+1, j+1)\n            }\n        }\n    }\n    sort.Slice(result, func(i, j\
    \ int) bool {\n        return len(result[i]) > len(result[j])\n    })\n    sort.Slice(result,\
    \ func(i, j int) bool {\n        return len(result[j]) > len(result[i])\n    })\n\
    \    return result\n}\n\nfunc TestGet_Row(t *testing.T) {\n  candidate := get_row\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6},\
    \ []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpuhc9a7zz_test.go:35:5:\
    \ undefined: sort\n/tmp/tmpuhc9a7zz_test.go:38:5: undefined: sort\n/tmp/tmpuhc9a7zz_test.go:51:132:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpuhc9a7zz_test.go:52:207: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type []int in array or slice literal\n/tmp/tmpuhc9a7zz_test.go:53:232:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n/tmp/tmpuhc9a7zz_test.go:56:26: cannot use []interface{}{\u2026\
    } (value of type []interface{}) as type [][]int in argument to candidate\n/tmp/tmpuhc9a7zz_test.go:56:106:\
    \ cannot use []interface{}{\u2026} (value of type []interface{}) as type []int\
    \ in array or slice literal\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075287
- exit_code: 1
  program: "package get_row_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // You are given a 2 dimensional data, as a nested lists,\n// which is similar\
    \ to matrix, however, unlike matrices,\n// each row may contain a different number\
    \ of columns.\n// Given lst, and integer x, find integers x in the list,\n// and\
    \ return list of lists, [(x1, y1), (x2, y2) ...] such that\n// each list is a\
    \ coordinate - (row, columns), starting with 0.\n// Sort coordinates initially\
    \ by rows in ascending order.\n// Also, sort coordinates of the row by columns\
    \ in descending order.\n// Examples:\n// >>> get_row([][]int{[]int{1, 2, 3, 4,\
    \ 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1)\n// [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}}\n// >>> get_row([][]int{}, 1)\n// [][]interface{}{}\n// >>> get_row([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3)\n// [][]int{[]interface{}{2, 2}}\nfunc get_row(lst\
    \ [][]int, x int) [][]interface{} {\n    var result [][]interface{}\n    for _,\
    \ row := range lst {\n        var result []interface{}\n        for _, val :=\
    \ range row {\n            if val == x {\n                result = append(result,\
    \ []interface{}{row, val})\n            }\n        }\n        result = append(result,\
    \ []interface{}{row, 0})\n        result = append(result, get_row(row, x))\n \
    \       result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, get_row(row, x))\n        result = append(result,\
    \ get_row(row, x))\n        result = append(result, get_row(row, x))\n       \
    \ result = append(result, get_row(row, x))\n        result = append(result, get_row(row,\
    \ x))\n        result = append(result, \nfunc TestGet_Row(t *testing.T) {\n  candidate\
    \ := get_row\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5,\
    \ 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5, 1}}, 1), expected: [][]int{[]interface{}{0,\
    \ 0}, []interface{}{1, 4}, []interface{}{1, 0}, []interface{}{2, 5}, []interface{}{2,\
    \ 0}} },\n     { actual: candidate([][]int{[]int{1, 2, 3, 4, 5, 6}, []int{1, 2,\
    \ 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}}, 2), expected: [][]int{[]interface{}{0, 1},\
    \ []interface{}{1, 1}, []interface{}{2, 1}, []interface{}{3, 1}, []interface{}{4,\
    \ 1}, []interface{}{5, 1}} },\n     { actual: candidate([][]int{[]int{1, 2, 3,\
    \ 4, 5, 6}, []int{1, 2, 3, 4, 5, 6}, []int{1, 1, 3, 4, 5, 6}, []int{1, 2, 1, 4,\
    \ 5, 6}, []int{1, 2, 3, 1, 5, 6}, []int{1, 2, 3, 4, 1, 6}, []int{1, 2, 3, 4, 5,\
    \ 1}}, 1), expected: [][]int{[]interface{}{0, 0}, []interface{}{1, 0}, []interface{}{2,\
    \ 1}, []interface{}{2, 0}, []interface{}{3, 2}, []interface{}{3, 0}, []interface{}{4,\
    \ 3}, []interface{}{4, 0}, []interface{}{5, 4}, []interface{}{5, 0}, []interface{}{6,\
    \ 5}, []interface{}{6, 0}} },\n     { actual: candidate([][]int{}, 1), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([][]int{[]int{1}}, 2), expected:\
    \ [][]interface{}{} },\n     { actual: candidate([]interface{}{[]interface{}{},\
    \ []int{1}, []int{1, 2, 3}}, 3), expected: [][]int{[]interface{}{2, 2}} },\n \
    \  }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\",\
    \ i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxnqp41ls_test.go:90:6: expected ''('', found TestGet_Row

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075281
