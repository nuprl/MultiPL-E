language: go_test.go
name: HumanEval_10_make_palindrome
results:
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[i : i+longestPalindromeLen]\n    }\n    longestPalindromeLen -=\
    \ len(myString)\n    longestPalindrome += myString[0 : longestPalindromeLen]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:6] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:6] with length 3\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpv412wq81_test.go:23\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpv412wq81_test.go:39\
    \ +0x6a5\ntesting.tRunner(0xc0001036c0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075440
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        prefix := myString[:i]\n        suffix := myString[i:]\n        longestPalindromeLen\
    \ := len(longestPalindrome)\n        longestPalindrome = longestPalindrome + suffix\n\
    \        if longestPalindromeLen > len(prefix) {\n            longestPalindrome\
    \ = longestPalindrome + prefix\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp389c562s_test.go:30:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myPalindrome string = \"\"\n    var myPalindromeLen int = 0\n    var myPalindromeLen\
    \ int = len(myString)\n    var myPalindromePrefix string = \"\"\n    var myPalindromeSuffix\
    \ string = \"\"\n    var myPalindromeSuffixLen int = 0\n    var myPalindromeSuffixLen\
    \ int = len(myPalindromeSuffix)\n\n    for myPalindromeSuffixLen = myPalindromeLen\
    \ - 1; myPalindromeSuffixLen >= 0; myPalindromeSuffixLen-- {\n        myPalindromeSuffix\
    \ = myString[myPalindromeSuffixLen]\n        myPalindromePrefix = myString[0:myPalindromeSuffixLen]\n\
    \        myPalindrome = myPalindromePrefix + myPalindromeSuffix + myPalindrome\n\
    \        myPalindromeLen = len(myPalindrome)\n    }\n\n    return myPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp9igp0lk1_test.go:21:9:\
    \ myPalindromeLen redeclared in this block\n\t/tmp/tmp9igp0lk1_test.go:20:9: other\
    \ declaration of myPalindromeLen\n/tmp/tmp9igp0lk1_test.go:25:9: myPalindromeSuffixLen\
    \ redeclared in this block\n\t/tmp/tmp9igp0lk1_test.go:24:9: other declaration\
    \ of myPalindromeSuffixLen\n/tmp/tmp9igp0lk1_test.go:28:30: cannot use myString[myPalindromeSuffixLen]\
    \ (value of type byte) as type string in assignment\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength = 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLength++\n\
    \            }\n        }\n        if longestPalindromeLength > longestPalindromeLength\
    \ {\n            longestPalindrome = myString\n            longestPalindromeLength\
    \ = longestPalindromeLength\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1\
    \ (0.00s)\n        tmpw4jiiw15_test.go:53: expected 'x', got ''\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__2 (0.00s)\n        tmpw4jiiw15_test.go:53: expected\
    \ 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n   \
    \     tmpw4jiiw15_test.go:53: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmpw4jiiw15_test.go:53: expected 'jerryrrej', got ''\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075440
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Initialize result with empty string\n    var result string = \"\"\n\n    //\
    \ Initialize a variable to hold longest postfix of supplied string\n    var longestPostfix\
    \ string = \"\"\n\n    // Initialize a variable to hold a character from the supplied\
    \ string\n    var currentChar string = \"\"\n\n    // Initialize a variable to\
    \ hold a character from the longest postfix of supplied string\n    var longestChar\
    \ = \"\"\n\n    // Initialize a variable to hold a character from the longest\
    \ postfix of supplied string\n    var longestCharPrefix string = \"\"\n\n    //\
    \ Initialize a variable to hold a character from the longest postfix of supplied\
    \ string\n    var longestCharSuffix string = \"\"\n\n    // Initialize a variable\
    \ to hold a character from the longest postfix of supplied string\n    var longestCharSuffixPrefix\
    \ string = \"\"\n\n    // Initialize a variable to hold a character from the longest\
    \ postfix of supplied string\n    var longestCharSuffixSuffix string = \"\"\n\n\
    \    // Initialize a variable to hold a character from the longest postfix of\
    \ supplied string\n    var longestCharSuffixSuffixPrefix string = \"\"\n\n   \
    \ // Initialize a variable to hold a character from the longest postfix of supplied\
    \ string\n    var longestCharSuffixSuffixSuffix string = \"\"\n\n    // Initialize\
    \ a variable to hold a character from the longest postfix of supplied string\n\
    \    var longestCharSuffixSuffixSuffixPrefix string = \"\"\n\n    // Initialize\
    \ a variable to hold a character from the longest postfix of supplied string\n\
    \    var longestCharSuffixSuffixSuffixSuffix string = \"\"\n\n    // Initialize\
    \ a variable to hold a character from the longest postfix of supplied string\n\
    \    var longestCharSuffixSuffixSuffixSuffixPrefix string = \"\"\n\n    // Initialize\
    \ a variable to hold a character from the longest postfix of supplied string\n\
    \    var longestCharSuffixSuffixSuffixSuffixSuffix string = \"\"\n\n    // Initialize\
    \ a variable to hold a character from the longest postfix of supplied string\n\
    \    var longestCharSuffixSuffixSuffixSuffixSuffixPrefix string = \"\"\n\n   \
    \ // Initialize a variable to hold a character from the longest postfix of supplied\
    \ string\n    var longestCharSuffixSuffixSuffixSuffixSuffixSuffix string = \"\"\
    \n\n    // Initialize a variable to hold a character from the longest postfix\
    \ of supplied string\n    var longestCharSuffixSuffixSuffixSuffixSuffixSuffixPrefix\
    \ string = \"\"\n\n    // Initialize a variable to hold a character from the longest\
    \ postfix of supplied string\n    var longestCharSuffixSuffixSuffixSuffixSuffixSuffixSuffix\
    \ string = \"\"\n\n    // Initialize a variable to hold a character from the longest\
    \ postfix of supplied string\n    var longestCharSuffixSuffixSuffixSuffixSuffixSuffixSuffixPrefix\
    \ string = \"\"\n\n    // Initialize a variable to hold a character from the longest\
    \ postfix of \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpescyzi6t_test.go:77:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome\n    longestPalindrome\
    \ := \"\"\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindromeLen := len(longestPalindrome)\n\n\
    \    // Append reverse of string prefix that comes before the palindromic suffix\n\
    \    prefix := myString[:longestPalindromeLen]\n    reversedPrefix := make([]rune,\
    \ len(prefix))\n    for i := 0; i < len(prefix); i++ {\n        reversedPrefix[i]\
    \ = prefix[len(prefix)-1-i]\n    }\n    reversedSuffix := make([]rune, longestPalindromeLen)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        reversedSuffix[i] =\
    \ longestPalindrome[len(longestPalindrome)-1-i]\n    }\n\n    // Append the reversed\
    \ prefix and suffix\n    return prefix + reversedPrefix + reversedSuffix\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph_xkj8sr_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmph_xkj8sr_test.go:30:29: cannot use prefix[len(prefix) - 1 - i] (value
    of type byte) as type rune in assignment

    /tmp/tmph_xkj8sr_test.go:34:29: cannot use longestPalindrome[len(longestPalindrome)
    - 1 - i] (value of type byte) as type rune in assignment

    /tmp/tmph_xkj8sr_test.go:38:12: invalid operation: prefix + reversedPrefix (mismatched
    types string and []rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        postfix := myString[i:]\n       \
    \ postfix += strings.Reverse(prefix)\n        longestPalindromeLen := len(postfix)\n\
    \        if longestPalindromeLen > longestPalindromeLen {\n            longestPalindrome\
    \ = postfix\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9f75pqoc_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmp9f75pqoc_test.go:24:20: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[:i+1]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+2]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+3]\n        postfix += \"-\"\n    \
    \    postfix += myString[:i+4]\n        postfix += \"-\"\n        postfix += myString[:i+5]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+6]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+7]\n        postfix += \"-\"\n    \
    \    postfix += myString[:i+8]\n        postfix += \"-\"\n        postfix += myString[:i+9]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+10]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+11]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+12]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+13]\n        postfix += \"-\"\n        postfix += myString[:i+14]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+15]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+16]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+17]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+18]\n        postfix += \"-\"\n        postfix += myString[:i+19]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+20]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+21]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+22]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+23]\n        postfix += \"-\"\n        postfix += myString[:i+24]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+25]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+26]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+27]\n        postfix += \"-\"\n        post\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp99c04t_d_test.go:81:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        postfix\
    \ := reverseString(prefix)\n        if postfix != suffix {\n            longestPalindrome\
    \ = prefix + postfix\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    if longestPalindromeLen > 0 {\n        return longestPalindrome\
    \ + reverseString(myString[:longestPalindromeLen])\n    }\n    return myString\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6iz2byxq_test.go:24:20: undefined: reverseString

    /tmp/tmp6iz2byxq_test.go:31:36: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[:i]\n        postfix += myString[len(myString)-i:]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ myString[len(myString)-len(postfix):len(myString)]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)]\n     \
    \   postfix += myString[:len(myString)-len(postfix)]\n        postfix += myString[len(myString)-len(postfix):len(myString)]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ myString[len(myString)-len(postfix):len(myString)]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)]\n     \
    \   postfix += myString[:len(myString)-len(postfix)]\n        postfix += myString[len(myString)-len(postfix):len(myString)]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ myString[len(myString)-len(postfix):len(myString)]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix):len(myString)]\n     \
    \   postfix += myString[:len(myString)-len(postfix)]\n        postfix += myString[len(myString)-len(postfix):len(myString)]\n\
    \        postfix += myString[:len(myString)-len(postfix)]\n        postfix +=\
    \ my\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfw6reu8y_test.go:56:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringPalindrome string\n    var myStringPalindromeLen int\n\
    \n    // Find longest postfix of myString that is a palindrome\n    for i := 0;\
    \ i < myStringLen; i++ {\n        myStringPrefix = myString[0:i]\n        myStringSuffix\
    \ = myString[i:]\n        myStringPalindrome = myStringPrefix + reverse(myStringSuffix)\
    \ + myStringSuffix\n        myStringPalindromeLen = len(myStringPalindrome)\n\
    \        if myStringPalindromeLen > myStringLen {\n            myStringLen = myStringPalindromeLen\n\
    \        }\n    }\n\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix\n    myStringPalindrome = myString[0:myStringLen]\
    \ + reverse(myString[myStringLen:]) + myString[myStringLen:]\n\n    return myStringPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4yapqo3d_test.go:29:47: undefined: reverse

    /tmp/tmp4yapqo3d_test.go:37:52: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // If no such postfix\
    \ exists, return myString unchanged.\n    longestPalindrome := \"\"\n    for i\
    \ := 0; i < len(myString); i++ {\n        longestPalindrome += myString[i]\n \
    \   }\n    longestPalindromeLen := len(longestPalindrome)\n    longestPalindromeLen\
    \ += longestPalindromeLen % 2\n    longestPalindromeLen /= 2\n    longestPalindromeLen\
    \ += longestPalindromeLen % 2\n    longestPalindromeLen /= 2\n    longestPalindromeLen\
    \ += longestPalindromeLen % 2\n    longestPalindromeLen /= 2\n    longestPalindromeLen\
    \ += longestPalindromeLen % 2\n    longestPalindromeLen /= 2\n    longestPalindromeLen\
    \ += longestPalindromeLen % 2\n    longestPalindromeLen /= 2\n    longestPalindromeLen\
    \ += longestPalindromeLen % 2\n    longestPalindromeLen /= 2\n    longestPalindromeLen\
    \ += longestPalindromeLen % 2\n    longestPalindromeLen /= 2\n    longestPalindromeLen\
    \ += longestPalindromeLen % 2\n    longestPalindromeLen /= 2\n    longestPalindromeLen\
    \ += longestPalindromeLen % 2\n    longestPalindromeLen /= 2\n    longestPalindromeLen\
    \ += longestPalindromeLen % 2\n    longestPalindromeLen /= 2\n    longestPalindromeLen\
    \ += longestPalindromeLen % 2\n    longestPalindromeLen /= 2\n    longestPalindromeLen\
    \ += longestPalindromeLen % 2\n    longestPalindromeLen /= 2\n    longestPalindromeLen\
    \ += longestPalindromeLen % 2\n    longestPalindromeLen /= 2\n    longestPalindromeLen\
    \ += longestPalindromeLen % 2\n    longestPalindromeLen /= 2\n    longestPalindromeLen\
    \ += longestPalindromeLen % 2\n    longestPalindromeLen /= 2\n    longestPalindromeLen\
    \ += longestPalindromeLen % 2\n    longestPalindromeLen /= 2\n    \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp87or34sy_test.go:59:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    var longestPalindrome\
    \ string = \"\"\n    var longestPalindromeLen int = 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLen += 1 // Increment the length of the longest\
    \ palindrome so far.\n        longestPalindrome += myString[i]\n        if myString[len(myString)-i-1]\
    \ == myString[len(myString)-i] {\n            longestPalindromeLen += 1 // Increment\
    \ the length of the longest palindrome so far.\n        }\n    }\n    \n    //\
    \ Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n    // Algorithm idea is simple:\n    // - Find the\
    \ longest postfix of supplied string that is a palindrome.\n    // - Append to\
    \ the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    var longestPalindromeReverse string = \"\"\n    var longestPalindromeReverseLen\
    \ int = 0\n    for i := 0; i < len(myString); i++ {\n        longestPalindromeReverseLen\
    \ += 1 // Increment the length of the longest palindrome reverse.\n        longestPalindromeReverse\
    \ += myString[len(myString)-i-1]\n        if myString[len(myString)-i-1] == myString[len(myString)-i]\
    \ {\n            longestPalindromeReverseLen += 1 // Increment the length of the\
    \ longest palindrome reverse.\n        }\n    }\n    \n    // Return the concatenation\
    \ of both strings.\n    return longest\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpimaxf8hm_test.go:65:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // The longest postfix\
    \ is found by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The prefix is found by finding the longest prefix of myString that is\
    \ a palindrome.\n    // The longest prefix is found by finding the longest prefix\
    \ of myString that is a palindrome.\n    // The longest prefix is found by finding\
    \ the longest prefix of myString that is a palindrome.\n    // The longest prefix\
    \ is found by finding the longest prefix of myString that is a palindrome.\n \
    \   // The longest prefix is found by finding the longest prefix of myString that\
    \ is a palindrome.\n    // The longest prefix is found by finding the longest\
    \ prefix of myString that is a palindrome.\n    // The longest prefix is found\
    \ by finding the longest prefix of myString that is a palindrome.\n    // The\
    \ longest prefix is found by finding the longest prefix of myString that is a\
    \ palindrome.\n    // The longest prefix is found by finding the longest prefix\
    \ of myString that is a palindrome.\n    // The longest prefix is found by finding\
    \ the longest prefix of myString that is a palindrome.\n    // The longest prefix\
    \ is found by finding the longest prefix of myString that is a palindrome.\n \
    \   // The longest prefix is found by finding the longest prefix of myString that\
    \ is a palindrome.\n    // The longest prefix is found by finding the longest\
    \ prefix of myString that is a palindrome.\n    // The longest prefix is found\
    \ by finding the longest prefix of myString that is a palindrome.\n    // The\
    \ longest prefix is found by finding the longest prefix of myString that is a\
    \ palindrome.\n    // The longest prefix is found by finding the longest prefix\
    \ of myString that is a palindrome.\n    // The longest prefix is found by finding\
    \ the longest prefix of myString that is a palindrome.\n    // The longest prefix\
    \ is found by finding the longest prefix of myString that is a palindrome.\n \
    \   // The longest prefix is found by finding the longest prefix of myString that\
    \ is a palindrome.\n    // The longest prefix is found by finding the longest\
    \ prefix of myString that is a palindrome.\n    // The longest prefix is found\
    \ by finding the \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1m17ed3i_test.go:42:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[:i+1]\n        longestPalindrome += myString[len(myString) - i:]\n\
    \    }\n    longestPalindrome += myString[:longestPalindromeLen]\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:6] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:6] with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp1d5qk2w4_test.go:26\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp1d5qk2w4_test.go:39\
    \ +0x71f\ntesting.tRunner(0xc0001a01a0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.010s\nFAIL\n"
  timestamp: 1660075440
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n \
    \       prefix := myString[:i]\n        reversedPostfix := append([]rune(postfix)[:len(postfix)-1],\
    \ []rune(postfix)[len(postfix)-1:]...)\n        if longestPalindromeLen > len(reversedPostfix)\
    \ {\n            longestPalindromeLen = len(reversedPostfix)\n            longestPalindrome\
    \ = prefix\n        }\n        if longestPalindromeLen > len(postfix) {\n    \
    \        longestPalindromeLen = len(postfix)\n            longestPalindrome =\
    \ postfix\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1\
    \ (0.00s)\n        tmpxe0w8sx4_test.go:55: expected 'x', got ''\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__2 (0.00s)\n        tmpxe0w8sx4_test.go:55: expected\
    \ 'xyzyx', got 'xy'\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n \
    \       tmpxe0w8sx4_test.go:55: expected 'xyx', got 'xy'\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmpxe0w8sx4_test.go:55: expected 'jerryrrej', got 'jerr'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075440
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength++\n        longestPalindrome += myString[i]\n\
    \    }\n    for i := 0; i < longestPalindromeLength; i++ {\n        longestPalindrome\
    \ += myString[len(myString)-1-i]\n    }\n    return longestPalindrome\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2krrnqb3_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmp2krrnqb3_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n      \
    \  longestPalindromeLen := len(longestPalindrome)\n        longestPalindrome =\
    \ longestPalindrome + suffix\n        if longestPalindromeLen > len(prefix) {\n\
    \            longestPalindrome = longestPalindrome + prefix[len(prefix):]\n  \
    \      }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdhme6jm6_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ If string is empty, return empty string\n    if len(myString) == 0 {\n     \
    \   return \"\"\n    }\n\n    // Find longest postfix of string that is a palindrome\n\
    \    longestPalindrome := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n\
    \        // If character is not a palindrome, skip it\n        if myString[i]\
    \ != myString[len(myString)-i-1] {\n            continue\n        }\n\n      \
    \  // If palindrome is longer than the longest palindrome, update longest palindrome\n\
    \        if len(longestPalindrome) > len(myString) {\n            longestPalindrome\
    \ = myString\n        }\n    }\n\n    // Append reverse of longest postfix to\
    \ end of string\n    return myString + strings.Reverse(longestPalindrome)\n}\n\
    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5rb7qz86_test.go:39:23: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        postfix\
    \ := make_palindrome_test(suffix)\n        if postfix != \"\" {\n            longestPalindrome\
    \ = prefix + postfix\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    if longestPalindromeLen > 0 {\n        return longestPalindrome\n\
    \    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5a_xwxw5_test.go:24:20: undefined: make_palindrome_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // The longest postfix\
    \ is found by reversing all characters in myString that come before the longest\
    \ postfix.\n    // The longest postfix is found by reversing all characters in\
    \ myString that come before the longest postfix.\n    // The longest postfix is\
    \ found by reversing all characters in myString that come before the longest postfix.\n\
    \    // The longest postfix is found by reversing all characters in myString that\
    \ come before the longest postfix.\n    // The longest postfix is found by reversing\
    \ all characters in myString that come before the longest postfix.\n    // The\
    \ longest postfix is found by reversing all characters in myString that come before\
    \ the longest postfix.\n    // The longest postfix is found by reversing all characters\
    \ in myString that come before the longest postfix.\n    // The longest postfix\
    \ is found by reversing all characters in myString that come before the longest\
    \ postfix.\n    // The longest postfix is found by reversing all characters in\
    \ myString that come before the longest postfix.\n    // The longest postfix is\
    \ found by reversing all characters in myString that come before the longest postfix.\n\
    \    // The longest postfix is found by reversing all characters in myString that\
    \ come before the longest postfix.\n    // The longest postfix is found by reversing\
    \ all characters in myString that come before the longest postfix.\n    // The\
    \ longest postfix is found by reversing all characters in myString that come before\
    \ the longest postfix.\n    // The longest postfix is found by reversing all characters\
    \ in myString that come before the longest postfix.\n    // The longest postfix\
    \ is found by reversing all characters in myString that come before the longest\
    \ postfix.\n    // The longest postfix is found by reversing all characters in\
    \ myString that come before the longest postfix.\n    // The longest postfix is\
    \ found by reversing all characters in myString that come before the longest postfix.\n\
    \    // The longest postfix is found by reversing all characters in myString that\
    \ come before the longest postfix.\n    // The longest postfix is found by reversing\
    \ all characters in myString that come before the longest postfix.\n    // The\
    \ longest postfix is found by reversing all characters in myString that come before\
    \ the longest \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0129s1tt_test.go:40:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    \n    // Append to the end of the string reverse of\
    \ a string prefix that comes before the palindromic suffix.\n    longestPalindrome\
    \ += myString[len(myString)-len(longestPalindrome):]\n    \n    // Return the\
    \ palindrome string.\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnt5q5qfy_test.go:33:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString); i >= 0;\
    \ i-- {\n        prefix := myString[:i]\n        suffix := myString[i:]\n    \
    \    postfix := reverse(prefix)\n        if postfix != suffix {\n            longestPalindrome\
    \ = append(longestPalindrome, postfix)\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    if longestPalindromeLen > 0 {\n        return append(myString[:longestPalindromeLen],\
    \ longestPalindrome...)\n    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4k2x2uos_test.go:24:20: undefined: reverse

    /tmp/tmp4k2x2uos_test.go:26:40: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    /tmp/tmp4k2x2uos_test.go:31:31: first argument to append must be a slice; have
    myString[:longestPalindromeLen] (value of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075440
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i:]\n \
    \       postfix := append(prefix, suffix)\n        postfix = append(postfix, suffix[len(suffix)-1:])\n\
    \        postfix = append(postfix, prefix[:len(prefix)-1])\n        postfix =\
    \ append(postfix, suffix[:len(suffix)-1])\n        postfix = append(postfix, suffix[len(suffix)-1:])\n\
    \        postfix = append(postfix, prefix[:len(prefix)-1])\n        postfix =\
    \ append(postfix, suffix[:len(suffix)-1])\n        postfix = append(postfix, suffix[len(suffix)-1:])\n\
    \        postfix = append(postfix, prefix[:len(prefix)-1])\n        postfix =\
    \ append(postfix, suffix[:len(suffix)-1])\n        postfix = append(postfix, suffix[len(suffix)-1:])\n\
    \        postfix = append(postfix, prefix[:len(prefix)-1])\n        postfix =\
    \ append(postfix, suffix[:len(suffix)-1])\n        postfix = append(postfix, suffix[len(suffix)-1:])\n\
    \        postfix = append(postfix, prefix[:len(prefix)-1])\n        postfix =\
    \ append(postfix, suffix[:len(suffix)-1])\n        postfix = append(postfix, suffix[len(suffix)-1:])\n\
    \        postfix = append(postfix, prefix[:len(prefix)-1])\n        postfix =\
    \ append(postfix, suffix[:len(suffix)-1])\n        postfix = append(postfix, suffix[len(suffix)-1:])\n\
    \        postfix = append(postfix, prefix[:len(prefix)-1])\n        postfix =\
    \ append(postfix, suffix[:len(suffix)-1])\n        postfix = append(postfix, suffix[len(suffix)-1:])\n\
    \        postfix = append(postfix, prefix[:len(prefix)-1])\n        postfix =\
    \ append(postfix, suffix[:len(suffix)-1])\n        postfix = append(postfix, suffix[len(suffix)-1:])\n\
    \        postfix = append(postfix, prefix[:len(prefix)-1])\n        postfix =\
    \ append(postfix, suffix[:len(suffix)-1])\n        postfix = append(postfix, suffix[len(suffix)-1:])\n\
    \        postfix = append(postfix, prefix[:len(prefix)-1])\n        postfix =\
    \ append(postfix, suffix[:len(suffix)-1])\n        postfix = append(postfix, suffix[len(suffix)-1:])\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy5u30ajn_test.go:56:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075440
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n      \
    \  postfix := make_palindrome_test(prefix, suffix)\n        if postfix != \"\"\
    \ {\n            longestPalindrome = append(longestPalindrome, postfix)\n    \
    \        longestPalindromeLen = len(postfix)\n        }\n    }\n    if longestPalindromeLen\
    \ > 0 {\n        return append(myString[:longestPalindromeLen], longestPalindrome...)\n\
    \    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps6saoze3_test.go:24:20: undefined: make_palindrome_test

    /tmp/tmps6saoze3_test.go:26:40: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    /tmp/tmps6saoze3_test.go:31:31: first argument to append must be a slice; have
    myString[:longestPalindromeLen] (value of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075440
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = longestPalindrome + postfix\n           \
    \ longestPalindromeLen = len(longestPalindrome)\n        }\n    }\n\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    prefix := myString[:longestPalindromeLen]\n    return prefix +\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2i3x8i7r_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075440
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        longestPalindrome += myString[i]\n\
    \        for j := 0; j < i; j++ {\n            if myString[j] != myString[len(myString)-j-1]\
    \ {\n                longestPalindromeLen += 1\n            }\n        }\n   \
    \     if longestPalindromeLen > longestPalindromeLen {\n            longestPalindrome\
    \ = myString\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph4h31s_p_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmph4h31s_p_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075440
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ If string is empty or contains only letters, return empty string\n    if len(myString)\
    \ == 0 || myString[0] == 'a' || myString[0] == 'A' {\n        return \"\"\n  \
    \  }\n\n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[i:]\n        postfix += myString[:i]\n        postfix\
    \ += myString[len(myString)-i:]\n        postfix += myString[:len(myString)-i]\n\
    \        postfix += myString[len(myString)-i:len(myString)]\n        postfix +=\
    \ myString[:len(myString)-len(postfix)]\n        postfix += myString[len(myString)-len(postfix):len(myString)]\n\
    \        postfix += myString[:len(myString)-len(postfix)-1]\n        postfix +=\
    \ myString[len(myString)-len(postfix)-1:len(myString)]\n        postfix += myString[:len(myString)-len(postfix)-2]\n\
    \        postfix += myString[len(myString)-len(postfix)-2:len(myString)]\n   \
    \     postfix += myString[:len(myString)-len(postfix)-3]\n        postfix += myString[len(myString)-len(postfix)-3:len(myString)]\n\
    \        postfix += myString[:len(myString)-len(postfix)-4]\n        postfix +=\
    \ myString[len(myString)-len(postfix)-4:len(myString)]\n        postfix += myString[:len(myString)-len(postfix)-5]\n\
    \        postfix += myString[len(myString)-len(postfix)-5:len(myString)]\n   \
    \     postfix += myString[:len(myString)-len(postfix)-6]\n        postfix += myString[len(myString)-len(postfix)-6:len(myString)]\n\
    \        postfix += myString[:len(myString)-len(postfix)-7]\n        postfix +=\
    \ \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppqmdmete_test.go:58:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075440
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringReverseSuffix string\n    var myStringReversePrefix\
    \ string\n    var myStringReversedSuffix string\n    var myStringReversedPrefix\
    \ string\n    var myStringReversedReversedSuffix string\n    var myStringReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedSuffix string\n    var myStringReversedReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myStringReversedReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myStringReversedReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myStringReversedReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myStringReversedReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myStringReversedReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myString\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpow2j9hn7_test.go:54:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075440
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        prefix := myString[:i]\n       \
    \ postfix, prefix := reverseString(postfix), reverseString(prefix)\n        if\
    \ postfix != prefix {\n            longestPalindrome = myString[:longestPalindromeLen]\n\
    \            longestPalindromeLen += len(postfix)\n            break\n       \
    \ }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphtpwdcql_test.go:24:25: no new variables on left side of :=

    /tmp/tmphtpwdcql_test.go:24:28: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075440
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[len(myString)-i:] + myString[:len(myString)-i]\n    }\n    for i\
    \ := 0; i < len(myString); i++ {\n        longestPalindromeLen -= i\n        longestPalindrome\
    \ += myString[len(myString)-i:] + myString[:len(myString)-i]\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1\
    \ (0.00s)\n        tmpa0taegwm_test.go:49: expected 'x', got 'xx'\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__2 (0.00s)\n        tmpa0taegwm_test.go:49: expected\
    \ 'xyzyx', got 'xyzzxyyzxxyzzxyyzx'\n    --- FAIL: TestMake_Palindrome/test_num__3\
    \ (0.00s)\n        tmpa0taegwm_test.go:49: expected 'xyx', got 'xyxxxyyxxxyxxxyyxx'\n\
    \    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpa0taegwm_test.go:49:\
    \ expected 'jerryrrej', got 'jerryyjerrryjerrryjeerryjjerryyjerrryjerrryjeerryj'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075442
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < i; j++ {\n   \
    \         if myString[j] != myString[j+i] {\n                longestPalindromeLen++\n\
    \            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString[:i]\n            longestPalindromeLen\
    \ = i\n        }\n    }\n    return longestPalindrome + myString[len(longestPalindrome):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcz8qtaj5_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string = \"\"\n    var\
    \ myStringSuffix string = \"\"\n    var myStringPalindrome string = \"\"\n   \
    \ var myStringPalindromeLen int = 0\n    var myStringPalindromePrefix string =\
    \ \"\"\n    var myStringPalindromeSuffix string = \"\"\n    var myStringPalindromePalindrome\
    \ string = \"\"\n    var myStringPalindromePalindromeLen int = 0\n    var myStringPalindromePalindromePrefix\
    \ string = \"\"\n    var myStringPalindromePalindromeSuffix string = \"\"\n  \
    \  var myStringPalindromePalindromePalindrome string = \"\"\n    var myStringPalindromePalindromePalindromeLen\
    \ int = 0\n    var myStringPalindromePalindromePalindromePrefix string = \"\"\n\
    \    var myStringPalindromePalindromePalindromeSuffix string = \"\"\n    var myStringPalindromePalindromePalindromePalindrome\
    \ string = \"\"\n    var myStringPalindromePalindromePalindromePalindromeLen int\
    \ = 0\n    var myStringPalindromePalindromePalindromePalindromePrefix string =\
    \ \"\"\n    var myStringPalindromePalindromePalindromePalindromeSuffix string\
    \ = \"\"\n    var myStringPalindromePalindromePalindromePalindromePalindrome string\
    \ = \"\"\n    var myStringPalindromePalindromePalindromePalindromePalindromeLen\
    \ int = 0\n    var myStringPalindromePalindromePalindromePalindromePalindromePrefix\
    \ string = \"\"\n    var myStringPalindromePalindromePalindromePalindromePalindromeSuffix\
    \ string = \"\"\n    var myStringPalindromePalindromePalindromePalindromePalindromePalindrome\
    \ string = \"\"\n    var myStringPalindromePalindromePalindromePalindromePalindromePalindromeLen\
    \ int = 0\n    var myStringPalindromePalindromePalindromePalindromePalindromePalindromePrefix\
    \ string = \"\"\n    var myStringPalindromePalin\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpza6jaf61_test.go:45:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < i; j++ {\n   \
    \         if myString[j] != myString[j+i] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3s3s0gfo_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome += myString[i]\n\
    \    }\n    \n    // Append to the end of the string reverse of a string prefix\
    \ that comes before the palindromic suffix.\n    longestPalindromeReverse := \"\
    \"\n    for i := 0; i < len(myString); i++ {\n        longestPalindromeReverse\
    \ += myString[len(myString)-i-1]\n    }\n    \n    // Return the palindrome that\
    \ begins with the supplied string.\n    return longestPalindrome + longestPalindromeReverse\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsg9t0dpn_test.go:33:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpsg9t0dpn_test.go:39:9: invalid operation: longestPalindromeReverse +=
    myString[len(myString) - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        prefix := myString[:i]\n        postfix := myString[i:]\n   \
    \     postfix += make_palindrome(postfix)\n        if postfix != prefix {\n  \
    \          longestPalindrome = prefix\n            longestPalindromeLength = i\n\
    \        }\n    }\n    return longestPalindrome + myString[longestPalindromeLength:]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0368\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x51f361?, 0x5e2ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmp9tws2165_test.go:18 +0x12e fp=0xc0201e0378 sp=0xc0201e0370\
    \ pc=0x4ef78e\ncommand-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t\
    /tmp/tmp9tws2165_test.go:24 +0x85 fp=0xc0201e03d8 sp=0xc0201e0378 pc=0x4ef6e5\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmp9tws2165_test.go:24\
    \ +0x85 fp=0xc0201e0438 sp=0xc0201e03d8 pc=0x4ef6e5\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmp9tws2165_test.go:24 +0x85 fp=0xc0201e0498 sp=0xc0201e0438 pc=0x4ef6e5\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmp9tws2165_test.go:24\
    \ +0x85 fp=0xc0201e04f8 sp=0xc0201e0498 pc=0x4ef6e5\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmp9tws2165_test.go:24 +0x85 fp=0xc0201e0558 sp=0xc0201e04f8 pc=0x4ef6e5\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmp9tws2165_test.go:24\
    \ +0x85 fp=0xc0201e05b8 sp=0xc0201e0558 pc=0x4ef6e5\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmp9tws2165_test.go:24 +0x85 fp=0xc0201e0618 sp=0xc0201e05b8 pc=0x4ef6e5\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmp9tws2165_test.go:24\
    \ +0x85 fp=0xc0201e0678 sp=0xc0201e0618 pc=0x4ef6e5\ncommand-line-arguments_test.make_palindrome({0x51d187,\
    \ 0x1})\n\t/tmp/tmp9tws2165_test.go:24 +0x85 fp=0xc0201e06d8 sp=0xc0201e0678 pc=0x4ef6e5\n\
    command-line-arguments_test.make_palindrome({0x51d187, 0x1})\n\t/tmp/tmp9tws2165_test.go:24\
    \ +0x85 fp=0xc0201e0738 sp=0xc0201e06d8 pc=0x4ef6e5\ncommand-line-arguments_test.make_pa"
  timestamp: 1660075443
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < i; j++ {\n   \
    \         if myString[j] != myString[len(myString)-j-1] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString[:i+longestPalindromeLen]\n     \
    \   }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr8ughzl7_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += 1 // add one to length for every letter\n\
    \        longestPalindrome += myString[i]\n    }\n    longestPalindromeLen -=\
    \ 1 // remove one from length for every letter\n    for i := 0; i < longestPalindromeLen;\
    \ i++ {\n        longestPalindrome += myString[len(myString)-i]\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_4arygni_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmp_4arygni_test.go:27:9: invalid operation: longestPalindrome += myString[len(myString)
    - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[:i+1]\n        longestPalindrome += myString[len(myString)-i:len(myString)]\n\
    \    }\n    longestPalindrome += myString[len(myString)-longestPalindromeLen:]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [-3:] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [-3:]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpkbk0ngk4_test.go:26\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpkbk0ngk4_test.go:39\
    \ +0x75f\ntesting.tRunner(0xc0001924e0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075442
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < i; j++ {\n   \
    \         if myString[j] != myString[j+i] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString[:i+longestPalindromeLen]\n     \
    \   }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbgnymsvv_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n\
    \        if isPalindrome(prefix, suffix) {\n            longestPalindrome = prefix\
    \ + suffix\n            longestPalindromeLen = len(longestPalindrome)\n      \
    \  }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp322rxah4_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmp322rxah4_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[:i]\n        longestPalindrome += myString[len(myString)-i:len(myString)]\n\
    \    }\n    longestPalindrome += myString[len(myString)-longestPalindromeLen:]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [-3:] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [-3:]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpjbug_3v__test.go:26\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpjbug_3v__test.go:39\
    \ +0x75f\ntesting.tRunner(0xc0001a01a0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075442
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString); i >= 0;\
    \ i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n  \
    \      postfix := reverseString(prefix)\n        if postfix != suffix {\n    \
    \        longestPalindrome = prefix + postfix\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    if longestPalindromeLen > 0\
    \ {\n        return longestPalindrome + reverseString(myString[:longestPalindromeLen])\n\
    \    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1pe48pa5_test.go:24:20: undefined: reverseString

    /tmp/tmp1pe48pa5_test.go:31:36: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075442
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        postfix += \"-\"\n        postfix\
    \ += myString[:i]\n        postfix += \"-\"\n        postfix += myString[:i+1]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+2]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+3]\n        postfix += \"-\"\n    \
    \    postfix += myString[:i+4]\n        postfix += \"-\"\n        postfix += myString[:i+5]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+6]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+7]\n        postfix += \"-\"\n    \
    \    postfix += myString[:i+8]\n        postfix += \"-\"\n        postfix += myString[:i+9]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+10]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+11]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+12]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+13]\n        postfix += \"-\"\n        postfix += myString[:i+14]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+15]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+16]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+17]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+18]\n        postfix += \"-\"\n        postfix += myString[:i+19]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+20]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+21]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+22]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+23]\n        postfix += \"-\"\n        postfix += myString[:i+24]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+25]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+26]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+27]\n        postfix += \"-\"\n        post\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp99c04t_d_test.go:81:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := longestPalindromeLen + 1\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindromeLen -= 1 // remove last char\n \
    \   for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome +=\
    \ myString[len(myString)-i]\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuqt9g6fk_test.go:22:9: longestPalindromeLen declared but not used

    /tmp/tmpuqt9g6fk_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpuqt9g6fk_test.go:27:9: invalid operation: longestPalindrome += myString[len(myString)
    - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075442
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // The longest postfix\
    \ is found by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // The longest\
    \ postfix is found by reversing a prefix of myString that comes before a palindromic\
    \ suffix.\n    // The longest postfix is found by reversing a prefix of myString\
    \ that comes before a palindromic suffix.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // The longest\
    \ postfix is found by reversing a prefix of myString that comes before a palindromic\
    \ suffix.\n    // The longest postfix is found by reversing a prefix of myString\
    \ that comes before a palindromic suffix.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // The longest\
    \ postfix is found by reversing a prefix of myString that comes before a palindromic\
    \ suffix.\n    // The longest postfix is found by reversing a prefix of myString\
    \ that comes before a palindromic suffix.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0t5cjntv_test.go:38:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[i:]\n        postfix := append(postfix, myString[:i]...)\n\
    \        postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, \nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5fh57y4j_test.go:59:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLength := len(myString)\n\
    \    for i := 0; i < longestPalindromeLength; i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    for i := 0; i < longestPalindromeLength; i++ {\n\
    \        if myString[i] != myString[len(myString)-(i+1)] {\n            longestPalindrome\
    \ += myString[len(myString)-(i+1)]\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnad3vx8n_test.go:21:29: no new variables on left side of :=

    /tmp/tmpnad3vx8n_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpnad3vx8n_test.go:27:13: invalid operation: longestPalindrome += myString[len(myString)
    - (i + 1)] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075442
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // The longest postfix\
    \ is found by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // The longest\
    \ postfix is found by reversing a prefix of myString that comes before a palindromic\
    \ suffix.\n    // The longest postfix is found by reversing a prefix of myString\
    \ that comes before a palindromic suffix.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // The longest\
    \ postfix is found by reversing a prefix of myString that comes before a palindromic\
    \ suffix.\n    // The longest postfix is found by reversing a prefix of myString\
    \ that comes before a palindromic suffix.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // The longest\
    \ postfix is found by reversing a prefix of myString that comes before a palindromic\
    \ suffix.\n    // The longest postfix is found by reversing a prefix of myString\
    \ that comes before a palindromic suffix.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0t5cjntv_test.go:38:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string = \"\"\n    var\
    \ myStringSuffix string = \"\"\n    var myStringReversedSuffix string = \"\"\n\
    \    var myStringReversedPrefix string = \"\"\n    var myStringReversedSuffix\
    \ string = \"\"\n\n    for i := 0; i < myStringLen; i++ {\n        myStringPrefix\
    \ = myStringPrefix + myString[i]\n        myStringSuffix = myStringSuffix + myString[i]\n\
    \        myStringReversedSuffix = myStringReversedSuffix + myString[i]\n     \
    \   myStringReversedPrefix = myStringReversedPrefix + myString[i]\n    }\n\n \
    \   if myStringLen > 0 {\n        myStringReversedPrefix = myStringReversedPrefix\
    \ + myString[myStringLen-1]\n    }\n\n    if myStringLen > 1 {\n        myStringReversedSuffix\
    \ = myStringReversedSuffix + myString[myStringLen-2]\n    }\n\n    if myStringLen\
    \ > 2 {\n        myStringReversedSuffix = myStringReversedSuffix + myString[myStringLen-3]\n\
    \    }\n\n    if myStringLen > 3 {\n        myStringReversedSuffix = myStringReversedSuffix\
    \ + myString[myStringLen-4]\n    }\n\n    if myStringLen > 4 {\n        myStringReversedSuffix\
    \ = myStringReversedSuffix + myString[myStringLen-5]\n    }\n\n    if myStringLen\
    \ > 5 {\n        myStringReversedSuffix = myStringReversedSuffix + myString[myStringLen-6]\n\
    \    }\n\n    if myStringLen > 6 {\n        myStringReversedSuffix = myStringReversedSuffix\
    \ + myString[myStringLen-7]\n    }\n\n    if myStringLen > 7 {\n        myStringReversedSuffix\
    \ = myStringReversedSuffix + myString[myStringLen-8]\n    }\n\n    if myStringLen\
    \ > 8 {\n        myStringReversedSuffix = myStringReversedSuffix + myString[myStringLen-9]\n\
    \    }\n\n    if myStringLen > 9 {\n        myStringReversedSuffix = myStringReversedSuffix\
    \ + myString[myStringLen-10]\n    }\n\n    if myStringLen > 10 {\n        myStringReversedSuffix\
    \ = myStringReversedSuffix + myString[myStringLen-11]\n    }\n\n    if myStringLen\
    \ > 11 {\n        myStringReversedSuffix = myStringReversedSuffix + myString[myStringLen-12]\n\
    \    }\n\n    if myStringLen > 12 {\n        myStringReversedSuffix = myStringReversedSuffix\
    \ + myString\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy3wuhmx9_test.go:83:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        postfix := myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf_zp1_se_test.go:56:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075442
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        postfix += string(myString[len(myString)-i-1:])\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = postfix\n\
    \            longestPalindromeLen = len(postfix)\n        }\n    }\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    return longestPalindrome + string(myString[:longestPalindromeLen])\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpeg_1ru5h_test.go:34:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075442
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLength := len(myString)\n\
    \    for i := 0; i < longestPalindromeLength; i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    for i := 0; i < longestPalindromeLength; i++ {\n\
    \        longestPalindrome += myString[longestPalindromeLength - i - 1]\n    }\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbimxpcz8_test.go:21:29: no new variables on left side of :=

    /tmp/tmpbimxpcz8_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpbimxpcz8_test.go:26:9: invalid operation: longestPalindrome += myString[longestPalindromeLength
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075442
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindrome += myString[len(myString)-1:]\n\
    \n    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    prefix := \"\"\n    for i := len(longestPalindrome)\
    \ - 1; i >= 0; i-- {\n        prefix += longestPalindrome[i]\n    }\n    prefix\
    \ += longestPalindrome[len(longestPalindrome)-1:]\n\n    return prefix\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp29n1oxr8_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmp29n1oxr8_test.go:29:9: invalid operation: prefix += longestPalindrome[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075442
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        postfix += string(myString[len(myString)-i:len(myString)])\n\
    \        if postfix != reverse(postfix) {\n            continue\n        }\n \
    \       if longestPalindromeLen < len(postfix) {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLen = len(postfix)\n        }\n    }\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplxw6xg16_test.go:25:23: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075442
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringReverseSuffix string\n    var myStringReversePrefix\
    \ string\n    var myStringReverseReverseSuffix string\n    var myStringReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverseReversePrefix\
    \ string\n    var myStringReverseReverseReverseSuffix string\n    var myStringReverseReverse\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7mm6u6iz_test.go:71:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075442
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringReverse string\n    var myStringPalindrome string\n\n\
    \    for i := 0; i < myStringLen; i++ {\n        myStringPrefix = myString[:i]\n\
    \        myStringSuffix = myString[i:]\n        myStringReverse = reverse(myStringPrefix)\n\
    \        myStringPalindrome = myStringPrefix + myStringReverse\n        if myStringPalindrome\
    \ == myString {\n            return myStringPalindrome\n        }\n    }\n   \
    \ return \"\"\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnli_51bt_test.go:21:9: myStringSuffix declared but not used

    /tmp/tmpnli_51bt_test.go:28:27: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075443
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < i; j++ {\n   \
    \         if myString[j] != myString[j+i] {\n                longestPalindromeLen\
    \ = i\n                break\n            }\n        }\n        if longestPalindromeLen\
    \ > longestPalindromeLen {\n            longestPalindrome = myString[:longestPalindromeLen]\n\
    \        }\n    }\n    return longestPalindrome + make_palindrome(myString[len(longestPalindrome):])\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphzw886ui_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075443
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        postfix := myString[i:]\n\
    \        postfix += strings.Reverse(prefix)\n        longestPalindrome = longestPalindrome[:0]\n\
    \        longestPalindromeLen = 0\n        for j := len(postfix) - 1; j >= 0;\
    \ j-- {\n            longestPalindrome = longestPalindrome + postfix[j]\n    \
    \        longestPalindromeLen++\n            if longestPalindromeLen > longestPalindromeLen\
    \ {\n                longestPalindrome = longestPalindrome[:0]\n             \
    \   longestPalindromeLen = 0\n            }\n        }\n        if longestPalindromeLen\
    \ > longestPalindromeLen {\n            longestPalindrome = longestPalindrome[:0]\n\
    \            longestPalindromeLen = 0\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbkd4qh65_test.go:24:20: undefined: strings

    /tmp/tmpbkd4qh65_test.go:28:33: invalid operation: longestPalindrome + postfix[j]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075443
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // The longest postfix\
    \ is found by reversing myString and finding the first character that does not\
    \ match it.\n    // The longest postfix is found by reversing myString and finding\
    \ the first character that does not match it.\n    // >>> make_palindrome(\"cat\"\
    )\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n\
    \    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString)\
    \ - 1; i >= 0; i-- {\n        char := myString[i]\n        if char != myString[len(myString)-(i+1)]\
    \ {\n            longestPalindrome = myString[:len(myString)-(i+1)] + longestPalindrome\n\
    \            longestPalindromeLen = len(longestPalindrome)\n        }\n    }\n\
    \    // Append the reverse of the longest postfix to the end of the string.\n\
    \    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    return longestPalindrome + myString[len(myString)-longestPalindromeLen:]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [-3:] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [-3:]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpn8zwaagz_test.go:40\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpn8zwaagz_test.go:54\
    \ +0x5f4\ntesting.tRunner(0xc0001a0340, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075443
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLength := len(myString)\n\
    \    for i := 0; i < longestPalindromeLength; i++ {\n        longestPalindrome\
    \ = longestPalindrome + myString[len(myString)-i-1]\n    }\n    for i := 0; i\
    \ < len(myString); i++ {\n        if myString[i] != longestPalindrome[len(longestPalindrome)-i-1]\
    \ {\n            longestPalindrome = longestPalindrome + myString[len(myString)-i-1]\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyn526yh1_test.go:21:29: no new variables on left side of :=

    /tmp/tmpyn526yh1_test.go:23:29: invalid operation: longestPalindrome + myString[len(myString)
    - i - 1] (mismatched types string and byte)

    /tmp/tmpyn526yh1_test.go:27:33: invalid operation: longestPalindrome + myString[len(myString)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075443
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < i; j++ {\n   \
    \         if myString[j] != myString[len(myString)-1-j] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjepph57a_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075443
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = postfix\n\
    \            break\n        }\n    }\n\n    // Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n    prefix\
    \ := myString[:len(longestPalindrome)]\n    return prefix + longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptt3fuwp1_test.go:23:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075443
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n  \
    \      postfix := reverse(prefix)\n        if suffix == postfix {\n          \
    \  longestPalindrome = append(longestPalindrome, prefix)\n            longestPalindromeLength\
    \ = i + 1\n        }\n    }\n    if longestPalindromeLength < len(myString) {\n\
    \        return \"\"\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3a15_92c_test.go:24:20: undefined: reverse

    /tmp/tmp3a15_92c_test.go:26:40: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075443
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromePrefix := \"\
    \"\n    longestPalindromeSuffix := \"\"\n    longestPalindromePostfix := \"\"\n\
    \    longestPalindromePostfixLength := 0\n    longestPalindromePostfixPrefix :=\
    \ \"\"\n    longestPalindromePostfixSuffix := \"\"\n    longestPalindromePostfixPostfix\
    \ := \"\"\n    longestPalindromePostfixPostfixLength := 0\n    longestPalindromePostfixPostfixPrefix\
    \ := \"\"\n    longestPalindromePostfixPostfixSuffix := \"\"\n    longestPalindromePostfixPostfixPostfix\
    \ := \"\"\n\n    for i := 0; i < len(myString); i++ {\n        char := myString[i]\n\
    \        longestPalindromeLength += 1\n        longestPalindromePrefix = longestPalindromePrefix\
    \ + char\n        longestPalindromeSuffix = longestPalindromeSuffix + char\n \
    \       longestPalindromePostfix = longestPalindromePostfix + char\n        longestPalindromePostfixLength\
    \ += 1\n        longestPalindromePostfixPrefix = longestPalindromePostfixPrefix\
    \ + char\n        longestPalindromePostfixSuffix = longestPalindromePostfixSuffix\
    \ + char\n        longestPalindromePostfixPostfix = longestPalindromePostfixPostfix\
    \ + char\n        longestPalindromePostfixPostfixLength += 1\n        longestPalindromePostfixPostfixPrefix\
    \ = longestPalindromePostfixPostfixPrefix + char\n        longestPalindromePostfixPostfixSuffix\
    \ = longestPalindromePostfixPostfixSuffix + char\n        longestPalindromePostfixPostfixPostfix\
    \ = longestPalindromePostfixPostfixPostfix + char\n    }\n\n    if longestPalindromeLength\
    \ > longestPalindromePostfixLength {\n        longestPalindrome = longestPalindromePostfix\n\
    \    } else {\n        longestPalindrome = longestPalindromePrefix\n    }\n\n\
    \    for i := 0; i < longestPalindromeLength; i++ {\n        char := myString[longestPalindromeLength\
    \ - i - 1]\n        longestPalindrome = longestPalindrome + char\n    }\n\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_sm6l9rz_test.go:61:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075443
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    prefix :=\
    \ myString[:longestPalindromeLen]\n    suffix := myString[longestPalindromeLen:]\n\
    \    return prefix + reverse(suffix)\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu79016mc_test.go:20:5: longestPalindrome declared but not used

    /tmp/tmpu79016mc_test.go:24:12: undefined: isPalindrome

    /tmp/tmpu79016mc_test.go:33:21: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075443
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // The\
    \ longest postfix is defined as the longest prefix of myString that is a palindrome.\n\
    \    // The longest prefix is defined as the longest prefix of myString that is\
    \ a palindrome.\n    // The longest prefix of myString that is a palindrome is\
    \ defined as the longest prefix of myString that is a palindrome.\n    // The\
    \ longest prefix of myString that is a palindrome is defined as the longest prefix\
    \ of myString that is a palindrome.\n    // The longest prefix of myString that\
    \ is a palindrome is defined as the longest prefix of myString that is a palindrome.\n\
    \    // The longest prefix of myString that is a palindrome is defined as the\
    \ longest prefix of myString that is a palindrome.\n    // The longest prefix\
    \ of myString that is a palindrome is defined as the longest prefix of myString\
    \ that is a palindrome.\n    // The longest prefix of myString that is a palindrome\
    \ is defined as the longest prefix of myString that is a palindrome.\n    // The\
    \ longest prefix of myString that is a palindrome is defined as the longest prefix\
    \ of myString that is a palindrome.\n    // The longest prefix of myString that\
    \ is a palindrome is defined as the longest prefix of myString that is a palindrome.\n\
    \    // The longest prefix of myString that is a palindrome is defined as the\
    \ longest prefix of myString that is a palindrome.\n    // The longest prefix\
    \ of myString that is a palindrome is defined as the longest prefix of myString\
    \ that is a palindrome.\n    // The longest prefix of myString that is a palindrome\
    \ is defined as the longest prefix of myString that is a palindrome.\n    // The\
    \ longest prefix of myString that is a palindrome is defined as the longest prefix\
    \ of myString that is a palindrome.\n    // The longest prefix of myString that\
    \ is a palindrome is defined as the longest prefix of myString that is a palindrome.\n\
    \    // The longest prefix of myString that is a palindrome is defined as the\
    \ longest prefix of myString that is a palindrome.\n    // The longest prefix\
    \ of myString that is a palindrome is defined as the longest prefix of myString\
    \ that is a palindrome.\n    // The lon\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplg4ebgky_test.go:38:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075443
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome\n    longestPalindrome\
    \ := \"\"\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n\
    \    longestPalindrome = longestPalindrome + make_palindrome(longestPalindrome)\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8hebklg8_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075444
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        prefix := myString[:i]\n\
    \        postfix += reverseString(prefix)\n        if postfix != prefix {\n  \
    \          longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr3tezt6j_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpr3tezt6j_test.go:24:20: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075444
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ If string is empty, return empty string\n    if len(myString) == 0 {\n     \
    \   return \"\"\n    }\n\n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // The longest postfix is defined as the longest postfix\
    \ of myString that is a palindrome.\n    // The longest postfix of myString that\
    \ is a palindrome is defined as the longest postfix of myString that is a palindrome\
    \ + the reverse of myString that comes before it.\n    // For example, the longest\
    \ postfix of \"cata\" is \"tac\", and the reverse of \"tac\" is \"atc\".\n   \
    \ // The longest postfix of \"cat\" is \"tac\", and the reverse of \"tac\" is\
    \ \"atc\".\n    // The longest postfix of \"cat\" is \"tac\", and the reverse\
    \ of \"tac\" is \"atc\".\n    // The longest postfix of \"cat\" is \"tac\", and\
    \ the reverse of \"tac\" is \"atc\".\n    // The longest postfix of \"cat\" is\
    \ \"tac\", and the reverse of \"tac\" is \"atc\".\n    // The longest postfix\
    \ of \"cat\" is \"tac\", and the reverse of \"tac\" is \"atc\".\n    // The longest\
    \ postfix of \"cat\" is \"tac\", and the reverse of \"tac\" is \"atc\".\n    //\
    \ The longest postfix of \"cat\" is \"tac\", and the reverse of \"tac\" is \"\
    atc\".\n    // The longest postfix of \"cat\" is \"tac\", and the reverse of \"\
    tac\" is \"atc\".\n    // The longest postfix of \"cat\" is \"tac\", and the reverse\
    \ of \"tac\" is \"atc\".\n    // The longest postfix of \"cat\" is \"tac\", and\
    \ the reverse of \"tac\" is \"atc\".\n    // The longest postfix of \"cat\" is\
    \ \"tac\", and the reverse of \"tac\" is \"atc\".\n    // The longest postfix\
    \ of \"cat\" is \"tac\", and the reverse of \"tac\" is \"atc\".\n    // The longest\
    \ postfix of \"cat\" is \"tac\", and the reverse of \"tac\" is \"atc\".\n    //\
    \ The longest postfix of \"cat\" is \"tac\", and the reverse of \"tac\" is \"\
    atc\".\n    // The longest postfix of \"cat\" is \"tac\", and the reverse of \"\
    tac\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx4lnq4kz_test.go:43:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075443
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        postfix += string(myString[len(myString)-i-1:])\n\
    \        if postfix != make_palindrome(postfix) {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLen = len(postfix)\n        }\n    }\n\
    \n    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    prefix := myString[:longestPalindromeLen]\n\
    \    suffix := myString[longestPalindromeLen:]\n    return prefix + string([]rune(suffix))\
    \ + suffix\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1uobnuhp_test.go:20:5: longestPalindrome declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075444
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindrome += myString[len(myString)-1]\n\
    \    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    longestPalindrome += myString[:len(myString)-len(longestPalindrome)]\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn61hhuc0_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpn61hhuc0_test.go:24:5: invalid operation: longestPalindrome += myString[len(myString)
    - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075444
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        postfix += string(myString[len(myString)-i-1:])\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = postfix\n\
    \            longestPalindromeLen = len(postfix)\n        }\n    }\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    prefix := myString[:longestPalindromeLen]\n    prefix += string(myString[longestPalindromeLen-1:])\n\
    \    return prefix + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4t_1xayq_test.go:25:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075444
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // The longest postfix\
    \ is found by reversing all prefixes of myString that come before myString.\n\
    \    // The longest postfix is found by reversing all prefixes of myString that\
    \ come before myString.\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\
    \n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPostfix :=\
    \ \"\"\n    longestPostfixLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[:i]\n        postfix += myString[len(myString)-i:]\n\
    \        postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)-i]\n        postfix +=\
    \ myString[len(myString)-len(postfix)-len(postfix):]\n        postfix += myString[:len(myString)-len(postfix)-len(postfix)-i]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)-len(postfix)-len(postfix)-i]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix):]\n\
    \        postfix += myString[:len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-len(postfix)]\n\
    \        postfix += myString[len(myString)-len(postfix)-len(postfix)-len(postfix)-len(postfix)-\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpad4z1_zy_test.go:45:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075443
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix) {\n \
    \           longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n    \n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    prefix := myString[:longestPalindromeLen]\n\
    \    return prefix + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_wy17bpu_test.go:35:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075444
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        postfix\
    \ := reverse(prefix)\n        postfix += suffix\n        postfix += prefix\n \
    \       postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        postfix += suffix\n\
    \        postfix += prefix\n        postfix += suffix\n        postfix += prefix\n\
    \        postfix += suffix\n        postfix += prefix\n        post\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl7u96nt1_test.go:102:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075444
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n\
    \        if suffix == reverseString(prefix) {\n            longestPalindrome =\
    \ prefix + longestPalindrome\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    if longestPalindromeLen > 0 {\n        return longestPalindrome\n\
    \    } else {\n        return myString\n    }\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphnqlrulz_test.go:24:22: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075444
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = longestPalindrome + postfix\n           \
    \ longestPalindromeLen = len(longestPalindrome)\n        }\n    }\n\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    prefix := myString[:longestPalindromeLen]\n    suffix := myString[longestPalindromeLen:]\n\
    \    return prefix + reverse(suffix)\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpate51lh7_test.go:24:12: undefined: isPalindrome

    /tmp/tmpate51lh7_test.go:33:21: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075444
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := len(myString) - 1; i\
    \ >= 0; i-- {\n        postfix := myString[:i+1]\n        postfix += string(myString[len(myString)-i-1:])\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = postfix\n\
    \            longestPalindromeLength = i + 1\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgfwotm5a_test.go:20:5: longestPalindromeLength declared but not used

    /tmp/tmpgfwotm5a_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075444
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    longestPalindrome += myString[longestPalindromeLen-1:]\n\
    \    longestPalindromeLen += len(myString) - longestPalindromeLen + 1\n    for\
    \ i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome += myString[len(myString)-(i+1)]\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp72izowe9_test.go:21:26: no new variables on left side of :=

    /tmp/tmp72izowe9_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmp72izowe9_test.go:28:9: invalid operation: longestPalindrome += myString[len(myString)
    - (i + 1)] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075445
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[i : i+longestPalindromeLen]\n    }\n    longestPalindromeLen +=\
    \ len(myString) - longestPalindromeLen\n    longestPalindrome += myString[longestPalindromeLen\
    \ : len(myString)]\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:6] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:6] with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpv44h7146_test.go:23\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpv44h7146_test.go:39\
    \ +0x645\ntesting.tRunner(0xc0001a0340, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n"
  timestamp: 1660075445
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of string that is a palindrome\n    longestPalindrome :=\
    \ \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        postfix := append(postfix, myString[:i]...)\n\
    \        postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ my\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpogxoxnnw_test.go:56:38: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075444
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[0:i]\n        postfix += myString[len(myString)-i:]\n\
    \        postfix += myString[len(myString)-i-1:]\n        postfix += myString[len(myString)-i-2:]\n\
    \        postfix += myString[len(myString)-i-3:]\n        postfix += myString[len(myString)-i-4:]\n\
    \        postfix += myString[len(myString)-i-5:]\n        postfix += myString[len(myString)-i-6:]\n\
    \        postfix += myString[len(myString)-i-7:]\n        postfix += myString[len(myString)-i-8:]\n\
    \        postfix += myString[len(myString)-i-9:]\n        postfix += myString[len(myString)-i-10:]\n\
    \        postfix += myString[len(myString)-i-11:]\n        postfix += myString[len(myString)-i-12:]\n\
    \        postfix += myString[len(myString)-i-13:]\n        postfix += myString[len(myString)-i-14:]\n\
    \        postfix += myString[len(myString)-i-15:]\n        postfix += myString[len(myString)-i-16:]\n\
    \        postfix += myString[len(myString)-i-17:]\n        postfix += myString[len(myString)-i-18:]\n\
    \        postfix += myString[len(myString)-i-19:]\n        postfix += myString[len(myString)-i-20:]\n\
    \        postfix += myString[len(myString)-i-21:]\n        postfix += myString[len(myString)-i-22:]\n\
    \        postfix += myString[len(myString)-i-23:]\n        postfix += myString[len(myString)-i-24:]\n\
    \        postfix += myString[len(myString)-i-25:]\n        postfix += myString[len(myString)-i-26:]\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqawwzj0h_test.go:60:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075444
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += string(myString[i:len(myString)-i]) + string(myString[len(myString)-i:])\n\
    \    }\n    longestPalindromeLen -= len(myString)\n    // Append to the end of\
    \ the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    longestPalindrome += string(myString[len(myString)-longestPalindromeLen:])\n\
    \    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n\
    \  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [2:1] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [2:1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp6udg_enj_test.go:33\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp6udg_enj_test.go:50\
    \ +0x77d\ntesting.tRunner(0xc0001a01a0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075446
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindrome += myString[len(myString)-1:]\n\
    \n    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    prefix := myString[:len(myString)-1]\n \
    \   suffix := myString[len(myString)-1:]\n    suffix += reverseString(prefix)\n\
    \    longestPalindrome += suffix\n\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9x38fab8_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmp9x38fab8_test.go:29:15: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075445
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[:i]\n        reverse := myString[i+1:]\n    \
    \    postfix += reverse\n        longestPalindromeLen := len(postfix)\n      \
    \  if longestPalindromeLen > longestPalindromeLen {\n            longestPalindrome\
    \ = postfix\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5dqx3o3r_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075445
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringPrefixLen int\n    var myStringSuffixLen int\n    var\
    \ myStringReversedLen int\n    var myStringReversedPrefix string\n    var myStringReversedSuffix\
    \ string\n    var myStringReversedPrefixLen int\n    var myStringReversedSuffixLen\
    \ int\n    var myStringReversedReversedLen int\n    var myStringReversedReversedPrefix\
    \ string\n    var myStringReversedReversedSuffix string\n    var myStringReversedReversedPrefixLen\
    \ int\n    var myStringReversedReversedSuffixLen int\n    var myStringReversedReversedReversedLen\
    \ int\n    var myStringReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedPrefixLen int\n    var myStringReversedReversedReversedSuffixLen\
    \ int\n    var myStringReversedReversedReversedReversedLen int\n    var myStringReversedReversedReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedPrefixLen int\n    var myStringReversedReversedReversedReversedSuffixLen\
    \ int\n    var myStringReversedReversedReversedReversedReversedLen int\n    var\
    \ myStringReversedReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefixLen int\n\
    \    var myStringReversedReversedReversedReversedReversedSuffixLen int\n    var\
    \ myStringReversedReversedReversedReversedReversedReversedLen int\n    var myStringReversedReversedReversedReversedReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedPrefixLen\
    \ int\n    var myStringReversedReversedReversedReversedReversedReversedSuffixLen\
    \ int\n    var myStringReversedReversedReversedReversedReversedReversedReversedLen\
    \ int\n    var myStringReversedReversedReversedReversedReversedReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedReversedReversedReversedReversedSuffix\
    \ string\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp21z_e12b_test.go:57:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075445
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[:i]\n        revPostfix := myString[len(postfix):]\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = append(longestPalindrome,\
    \ postfix)\n            longestPalindromeLen = len(postfix)\n        }\n     \
    \   longestPalindrome = append(longestPalindrome, revPostfix)\n        longestPalindromeLen\
    \ = len(longestPalindrome)\n    }\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return append(longestPalindrome,\
    \ myString[longestPalindromeLen:])\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps77v49cx_test.go:34:12: undefined: isPalindrome

    /tmp/tmps77v49cx_test.go:35:40: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    /tmp/tmps77v49cx_test.go:38:36: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    /tmp/tmps77v49cx_test.go:48:19: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075445
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        postfix += myString[:i]\n      \
    \  postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-1-i:]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += myString[len(myString)-1:]\n        postfix += myString[:len(myString)-len(postfix)]\n\
    \        postfix += my\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5u06yigk_test.go:59:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075445
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    prefix :=\
    \ myString[:longestPalindromeLen]\n    suffix := myString[longestPalindromeLen:]\n\
    \    return prefix + reverseString(suffix) + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpm8onoa5m_test.go:24:12: undefined: isPalindrome

    /tmp/tmpm8onoa5m_test.go:33:21: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075445
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // This will be\
    \ the length of the palindrome plus one.\n    longestPalindrome := 0\n    for\
    \ i := 0; i < len(myString); i++ {\n        longestPalindrome = longestPalindrome\
    \ + 1\n        if myString[len(myString)-i-1] != myString[len(myString)-i-longestPalindrome]\
    \ {\n            break\n        }\n    }\n\n    // Append the reverse of the string\
    \ prefix that comes before the\n    // palindromic suffix.\n    result := myString\n\
    \    for i := 0; i < longestPalindrome; i++ {\n        result = result + myString[len(myString)-i]\n\
    \    }\n\n    return result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvrlne1bj_test.go:33:18: invalid operation: result + myString[len(myString)
    - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075445
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        postfix += myString[len(myString)-i-1:]\n\
    \        if myString[len(myString)-i-1:] == reverse(postfix) {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLen = len(postfix)\n        }\n    }\n\
    \    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    prefix := myString[:longestPalindromeLen]\n\
    \    return prefix + reverse(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpffn1btu8_test.go:25:44: undefined: reverse

    /tmp/tmpffn1btu8_test.go:32:21: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075445
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindrome += myString[len(myString)-1:]\n\
    \    longestPalindrome = reverse(longestPalindrome)\n    // Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    longestPalindrome += myString[:len(myString)-len(longestPalindrome)]\n  \
    \  return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk95u0si3_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpk95u0si3_test.go:25:25: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075445
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[i:]\n        postfix := append(postfix, myString[:i]...)\n\
    \        postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbdnxnutz_test.go:60:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075445
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n      \
    \  longestPalindromeLen := len(longestPalindrome)\n        longestPalindrome =\
    \ longestPalindrome + suffix\n        if longestPalindromeLen > len(prefix) {\n\
    \            longestPalindrome = longestPalindrome + prefix\n            longestPalindromeLen\
    \ = len(longestPalindrome)\n        }\n    }\n    return longestPalindrome\n}\n\
    \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg6g0y7rk_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        postfix := myString[i:]\n\
    \        if isPalindrome(prefix, postfix) {\n            longestPalindrome = prefix\
    \ + longestPalindrome\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzm12zdls_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpzm12zdls_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        prefix := myString[0:i]\n \
    \       suffix := myString[i:]\n        postfix := reversePostfix(prefix)\n  \
    \      postfix += suffix\n        postfix += reversePostfix(suffix)\n        if\
    \ postfix != \"\" {\n            longestPalindromeLen += len(postfix)\n      \
    \      if longestPalindromeLen > longestPalindromeLen {\n                longestPalindrome\
    \ = postfix\n                longestPalindromeLen = len(postfix)\n           \
    \ }\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppobnsav7_test.go:25:20: undefined: reversePostfix

    /tmp/tmppobnsav7_test.go:27:20: undefined: reversePostfix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[0:i]\n        postfix += string(myString[len(myString)-i:][:len(myString)-i])\n\
    \        postfix += myString[len(myString)-i:len(myString)]\n        postfix +=\
    \ myString[len(myString)-i:len(myString)]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[len(myString)-i:len(myString)]\n        postfix +=\
    \ myString[len(myString)-i:len(myString)]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[len(myString)-i:len(myString)]\n        postfix +=\
    \ myString[len(myString)-i:len(myString)]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[len(myString)-i:len(myString)]\n        postfix +=\
    \ myString[len(myString)-i:len(myString)]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[len(myString)-i:len(myString)]\n        postfix +=\
    \ myString[len(myString)-i:len(myString)]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[len(myString)-i:len(myString)]\n        postfix +=\
    \ myString[len(myString)-i:len(myString)]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[len(myString)-i:len(myString)]\n        postfix +=\
    \ myString[len(myString)-i:len(myString)]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[len(myString)-i:len(myString)]\n        postfix +=\
    \ myString[len(myString)-i:len(myString)]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[len(myString)-i:len(myString)]\n        postfix +=\
    \ myString[len(myString)-i:len(myString)]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += my\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0pwtc_a0_test.go:53:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075445
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        longestPalindrome += myString[i]\n\
    \        for j := i + 1; j < len(myString); j++ {\n            if myString[j]\
    \ != myString[j] {\n                longestPalindromeLen += 1\n              \
    \  if longestPalindromeLen > longestPalindromeLen {\n                    longestPalindrome\
    \ = myString[:j]\n                    longestPalindromeLen = longestPalindromeLen\
    \ - 1\n                }\n                break\n            }\n        }\n  \
    \  }\n    return longestPalindrome + myString[len(longestPalindrome):]\n}\n\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprvvx321q_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmprvvx321q_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringReverseSuffix string\n    var myStringReversePrefix\
    \ string\n    var myStringReversedSuffix string\n    var myStringReversedPrefix\
    \ string\n    var myStringReversedReversedSuffix string\n    var myStringReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedSuffix string\n    var myStringReversedReversedReversedPrefix\
    \ string\n    var myStringReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myStringReversedReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myStringReversedReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myStringReversedReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myStringReversedReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myStringReversedReversedReversedReversedReversedSuffix string\n    var\
    \ myStringReversedReversedReversedReversedReversedPrefix string\n    var myStringReversedReversedReversedReversedReversedSuffix\
    \ string\n    var myStringReversedReversedReversedReversedReversedPrefix string\n\
    \    var myString\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpow2j9hn7_test.go:54:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075440
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        if\
    \ isPalindrome(prefix, suffix) {\n            longestPalindrome = prefix + reverseString(suffix)\
    \ + longestPalindrome\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3t__51sv_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmp3t__51sv_test.go:24:12: undefined: isPalindrome

    /tmp/tmp3t__51sv_test.go:25:42: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n      \
    \  longestPalindrome += myString[len(myString)-1-i]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc84rx_qd_test.go:21:26: no new variables on left side of :=

    /tmp/tmpc84rx_qd_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpc84rx_qd_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    \n    // Append to the end of the string reverse of\
    \ a string prefix that comes before the palindromic suffix.\n    longestPalindromeReverse\
    \ := \"\"\n    for i := 0; i < len(myString); i++ {\n        longestPalindromeReverse\
    \ += myString[len(myString)-1-i]\n    }\n    \n    // Return the string that is\
    \ the palindrome of the supplied string.\n    return longestPalindrome + longestPalindromeReverse\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4_cybm1b_test.go:33:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmp4_cybm1b_test.go:39:9: invalid operation: longestPalindromeReverse +=
    myString[len(myString) - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[:i]\n        reverse := myString[i+1:]\n    \
    \    if isPalindrome(postfix) {\n            longestPalindrome = longestPalindrome\
    \ + reverse + postfix\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnrz_ktrn_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpnrz_ktrn_test.go:24:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[len(myString)-i:len(myString)]\n    }\n    for i := 0; i < len(myString);\
    \ i++ {\n        if myString[len(myString)-i:len(myString)] != longestPalindrome[len(longestPalindrome)-i:len(longestPalindrome)]\
    \ {\n            longestPalindrome = longestPalindrome[:len(longestPalindrome)-i]\n\
    \            break\n        }\n    }\n    return longestPalindrome\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1\
    \ (0.00s)\n        tmp65_r6nen_test.go:51: expected 'x', got ''\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__2 (0.00s)\n        tmp65_r6nen_test.go:51: expected\
    \ 'xyzyx', got 'zyz'\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n\
    \        tmp65_r6nen_test.go:51: expected 'jerryrrej', got 'yryrryerry'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075447
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringReversedPrefix string\n    var myStringReversedSuffix\
    \ string\n    var myStringReversedSuffixLen int\n    var myStringReversedSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixLen int\n    var myStringReversedSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixLen int\n    var\
    \ myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixLen int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixSuffixLen\
    \ int\n    var myStringReversedSuffixSuffixSuffixSuffixSuffixSuffixSuffix\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxob3n0ce_test.go:46:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n  \
    \      suffix := myString[i:]\n        postfix := append(prefix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate :=\
    \ make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc738n13f_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindromeLen := len(longestPalindrome)\n\n\
    \    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    prefix := \"\"\n    for i := 0; i < longestPalindromeLen;\
    \ i++ {\n        prefix += myString[len(myString)-(i+1)]\n    }\n    return prefix\
    \ + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6jt3k8iz_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmp6jt3k8iz_test.go:29:9: invalid operation: prefix += myString[len(myString)
    - (i + 1)] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // Assume that myString\
    \ is at least 1 character long.\n    longestPalindrome := \"\"\n    longestPalindromeLen\
    \ := 0\n    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n\
    \        postfix := myString[i:]\n        postfix += strings.Reverse(prefix)\n\
    \        postfix += longestPalindrome\n        longestPalindromeLen = len(postfix)\n\
    \        if longestPalindromeLen > len(longestPalindrome) {\n            longestPalindrome\
    \ = postfix\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_o_l9_ds_test.go:26:20: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075447
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[i+1:]\n        postfix\
    \ += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[i+1:]\n        postfix\
    \ += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[i+1:]\n        postfix\
    \ += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[i+1:]\n        postfix\
    \ += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[i+1:]\n        postfix\
    \ += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[i+1:]\n        postfix\
    \ += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[i+1:]\n        postfix\
    \ += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[i+1:]\n        postfix\
    \ += myString[:len(myString)-i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += \nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvrk4ziwx_test.go:62:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[i:]\n        postfix := append(postfix, myString[:i]...)\n\
    \        postfix := append(postfix, myString[len(myString)-i:]...)\n        postfix\
    \ := append(postfix, myString[len(myString)-i:]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        post\nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplsjibx00_test.go:59:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // The longest postfix\
    \ is always one character longer than the original string.\n    // The longest\
    \ postfix is always a palindrome.\n    // The longest postfix is always a palindrome.\n\
    \    // The longest postfix is always a palindrome.\n    // The longest postfix\
    \ is always a palindrome.\n    // The longest postfix is always a palindrome.\n\
    \    // The longest postfix is always a palindrome.\n    // The longest postfix\
    \ is always a palindrome.\n    // The longest postfix is always a palindrome.\n\
    \    // The longest postfix is always a palindrome.\n    // The longest postfix\
    \ is always a palindrome.\n    // The longest postfix is always a palindrome.\n\
    \    // The longest postfix is always a palindrome.\n    // The longest postfix\
    \ is always a palindrome.\n    // The longest postfix is always a palindrome.\n\
    \    // The longest postfix is always a palindrome.\n    // The longest postfix\
    \ is always a palindrome.\n    // The longest postfix is always a palindrome.\n\
    \    // The longest postfix is always a palindrome.\n    // The longest postfix\
    \ is always a palindrome.\n    // The longest postfix is always a palindrome.\n\
    \    // The longest postfix is always a palindrome.\n    // The longest postfix\
    \ is always a palindrome.\n    // The longest postfix is always a palindrome.\n\
    \    // The longest postfix is always a palindrome.\n    // The longest postfix\
    \ is always a palindrome.\n    // The longest postfix is always a palindrome.\n\
    \    // The longest postfix is always a palindrome.\n    // The longest postfix\
    \ is always a palindrome.\n    // The longest postfix is always a palindrome.\n\
    \    // The longest postfix is always a palindrome.\n    // The longest postfix\
    \ is always a palindrome.\n    // The longest postfix is always a palindrome.\n\
    \    // The longest postfix is always a palindrome.\n    // The longest postfix\
    \ is always a palindrome.\n    // The longest \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkp5htbh2_test.go:56:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLength := len(myString)\n\
    \    for i := 0; i < longestPalindromeLength; i++ {\n        prefix := myString[0:i]\n\
    \        suffix := myString[i+1:]\n        postfix := reversePostfix(prefix)\n\
    \        if suffix == postfix {\n            longestPalindrome = prefix + postfix\n\
    \            longestPalindromeLength = len(longestPalindrome)\n        }\n   \
    \ }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5pgfz4ba_test.go:21:29: no new variables on left side of :=

    /tmp/tmp5pgfz4ba_test.go:25:20: undefined: reversePostfix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075447
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // The longest postfix\
    \ is found by reversing all characters in myString that come before the longest\
    \ postfix.\n    // The longest postfix is found by reversing all characters in\
    \ myString that come before the longest postfix.\n    // The longest postfix is\
    \ found by reversing all characters in myString that come before the longest postfix.\n\
    \    // The longest postfix is found by reversing all characters in myString that\
    \ come before the longest postfix.\n    // The longest postfix is found by reversing\
    \ all characters in myString that come before the longest postfix.\n    // The\
    \ longest postfix is found by reversing all characters in myString that come before\
    \ the longest postfix.\n    // The longest postfix is found by reversing all characters\
    \ in myString that come before the longest postfix.\n    // The longest postfix\
    \ is found by reversing all characters in myString that come before the longest\
    \ postfix.\n    // The longest postfix is found by reversing all characters in\
    \ myString that come before the longest postfix.\n    // The longest postfix is\
    \ found by reversing all characters in myString that come before the longest postfix.\n\
    \    // The longest postfix is found by reversing all characters in myString that\
    \ come before the longest postfix.\n    // The longest postfix is found by reversing\
    \ all characters in myString that come before the longest postfix.\n    // The\
    \ longest postfix is found by reversing all characters in myString that come before\
    \ the longest postfix.\n    // The longest postfix is found by reversing all characters\
    \ in myString that come before the longest postfix.\n    // The longest postfix\
    \ is found by reversing all characters in myString that come before the longest\
    \ postfix.\n    // The longest postfix is found by reversing all characters in\
    \ myString that come before the longest postfix.\n    // The longest postfix is\
    \ found by reversing all characters in myString that come before the longest postfix.\n\
    \    // The longest postfix is found by reversing all characters in myString that\
    \ come before the longest postfix.\n    // The longest postfix is found by reversing\
    \ all characters in myString that come before the longest postfix.\n    // The\
    \ longest postfix is found by reversing all characters in myString that come before\
    \ the longest \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0129s1tt_test.go:40:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        postfix := myString[i:]\n \
    \       reverse := myString[:i]\n        if isPalindrome(postfix) {\n        \
    \    longestPalindromeLen += len(postfix)\n            longestPalindrome = longestPalindrome\
    \ + reverse + postfix\n        }\n    }\n    return longestPalindrome\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxp_trh8e_test.go:25:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075447
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // The longest postfix\
    \ is found by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // The longest\
    \ postfix is found by reversing a prefix of myString that comes before a palindromic\
    \ suffix.\n    // The longest postfix is found by reversing a prefix of myString\
    \ that comes before a palindromic suffix.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // The longest\
    \ postfix is found by reversing a prefix of myString that comes before a palindromic\
    \ suffix.\n    // The longest postfix is found by reversing a prefix of myString\
    \ that comes before a palindromic suffix.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a palindromic suffix.\n    // The longest\
    \ postfix is found by reversing a prefix of myString that comes before a palindromic\
    \ suffix.\n    // The longest postfix is found by reversing a prefix of myString\
    \ that comes before a palindromic suffix.\n    // The longest postfix is found\
    \ by reversing a prefix of myString that comes before a palindromic suffix.\n\
    \    // The longest postfix is found by reversing a prefix of myString that comes\
    \ before a palindromic suffix.\n    // The longest postfix is found by reversing\
    \ a prefix of myString that comes before a \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0t5cjntv_test.go:38:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[i:]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i]\n        postfix += \"-\"\n        postfix += myString[:i+1]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+2]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+3]\n        postfix += \"-\"\n    \
    \    postfix += myString[:i+4]\n        postfix += \"-\"\n        postfix += myString[:i+5]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+6]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+7]\n        postfix += \"-\"\n    \
    \    postfix += myString[:i+8]\n        postfix += \"-\"\n        postfix += myString[:i+9]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+10]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+11]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+12]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+13]\n        postfix += \"-\"\n        postfix += myString[:i+14]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+15]\n        postfix\
    \ += \"-\"\n        postfix += myString[:i+16]\n        postfix += \"-\"\n   \
    \     postfix += myString[:i+17]\n        postfix += \"-\"\n        postfix +=\
    \ myString[:i+18]\n        postfix += \"-\"\n        postfix += myString[:i+19]\n\
    \        postfix += \"-\"\n        postfix += myString[:i+20]\n        postfix\
    \ += \"-\"\n        postfix += myString[:\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp36h3dlu8_test.go:77:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Initialize result to empty string\n    var result string = \"\"\n    // Initialize\
    \ longest postfix to empty string\n    var longest string = \"\"\n    // Initialize\
    \ longest postfix length to 0\n    var longestLength int = 0\n    // Initialize\
    \ longest postfix to empty string\n    var longestPostfix string = \"\"\n    //\
    \ Initialize longest postfix length to 0\n    var longestPostfixLength int = 0\n\
    \    // Initialize longest postfix to empty string\n    var longestPostfix2 string\
    \ = \"\"\n    // Initialize longest postfix length to 0\n    var longestPostfix2Length\
    \ int = 0\n    // Initialize longest postfix to empty string\n    var longestPostfix3\
    \ string = \"\"\n    // Initialize longest postfix length to 0\n    var longestPostfix3Length\
    \ int = 0\n    // Initialize longest postfix to empty string\n    var longestPostfix4\
    \ string = \"\"\n    // Initialize longest postfix length to 0\n    var longestPostfix4Length\
    \ int = 0\n    // Initialize longest postfix to empty string\n    var longestPostfix5\
    \ string = \"\"\n    // Initialize longest postfix length to 0\n    var longestPostfix5Length\
    \ int = 0\n    // Initialize longest postfix to empty string\n    var longestPostfix6\
    \ string = \"\"\n    // Initialize longest postfix length to 0\n    var longestPostfix6Length\
    \ int = 0\n    // Initialize longest postfix to empty string\n    var longestPostfix7\
    \ string = \"\"\n    // Initialize longest postfix length to 0\n    var longestPostfix7Length\
    \ int = 0\n    // Initialize longest postfix to empty string\n    var longestPostfix8\
    \ string = \"\"\n    // Initialize longest postfix length to 0\n    var longestPostfix8Length\
    \ int = 0\n    // Initialize longest postfix to empty string\n    var longestPostfix9\
    \ string = \"\"\n    // Initialize longest postfix length to 0\n    var longestPostfix9Length\
    \ int = 0\n    // Initialize longest postfix to empty string\n    var longestPostfix10\
    \ string = \"\"\n    // Initialize longest postfix length to 0\n    var longestPostfix10Length\
    \ int = 0\n    // Initialize longest postfix to empty string\n    var longestPostfix11\
    \ string = \"\"\n    // Initialize longest postfix length to 0\n    var longestPostfix11Length\
    \ int = 0\n    // Initialize longest postfix to empty string\n    var longestPostfix12\
    \ string = \"\"\n    // Initialize longest postfix length to 0\n    var longestPostfix12Length\
    \ int = 0\n    // Initialize longest postfix to empty string\n    var longestPost\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcloqshzt_test.go:74:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        longestPalindrome += myString[i]\n\
    \        for j := 0; j < i; j++ {\n            if myString[j] != myString[j+i]\
    \ {\n                longestPalindromeLen += 1\n                break\n      \
    \      }\n        }\n        if longestPalindromeLen > longestPalindromeLen {\n\
    \            longestPalindrome = myString\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzkm2z654_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpzkm2z654_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075447
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[:i]\n        longestPalindrome += myString[len(myString)-i:len(myString)]\n\
    \    }\n    longestPalindromeLen -= len(myString)\n    longestPalindrome += myString\n\
    \    longestPalindrome += myString[len(myString)-longestPalindromeLen:]\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [-5:] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [-5:]\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc0001c4018})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc0001c4018})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpljj8rsc4_test.go:28\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpljj8rsc4_test.go:43\
    \ +0x7a9\ntesting.tRunner(0xc000184ea0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075448
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringReversedSuffix string\n    var myStringReversedPrefix\
    \ string\n\n    for i := 0; i < myStringLen; i++ {\n        myStringPrefix = myString[0:i]\n\
    \        myStringSuffix = myString[i:]\n        myStringReversedSuffix = myStringSuffix[0:myStringLen-i-1]\n\
    \        myStringReversedPrefix = myStringPrefix[0:myStringLen-i-1]\n        if\
    \ myStringSuffix == myStringReversedSuffix {\n            return myStringPrefix\
    \ + myStringReversedPrefix\n        }\n    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:2] with length 0 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:2] with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp24bky806_test.go:29\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp24bky806_test.go:46\
    \ +0x670\ntesting.tRunner(0xc0001a0340, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075448
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome.\n    // This will be\
    \ the longest palindrome prefix.\n    var longestPalindromePrefix string\n   \
    \ for i := 0; i < len(myString); i++ {\n        // Find longest palindrome suffix\
    \ that ends with myString[i].\n        // This will be the longest palindrome\
    \ suffix.\n        var longestPalindromeSuffix string\n        for j := len(myString)\
    \ - 1; j >= i; j-- {\n            if myString[j] != myString[j] {\n          \
    \      // This is not a palindrome suffix.\n                // So skip this character.\n\
    \                break\n            }\n            longestPalindromeSuffix = myString[j]\
    \ + longestPalindromeSuffix\n        }\n        // If this suffix is a palindrome\
    \ suffix, then append it to longestPalindromePrefix.\n        if longestPalindromeSuffix\
    \ == longestPalindromeSuffix {\n            longestPalindromePrefix = myString[:i]\
    \ + longestPalindromePrefix\n        }\n    }\n    // Append reverse of the longest\
    \ palindrome prefix to myString.\n    return longestPalindromePrefix + myString[len(longestPalindromePrefix):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpucg91859_test.go:32:39: invalid operation: myString[j] + longestPalindromeSuffix
    (mismatched types byte and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075448
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLength := len(myString)\n\
    \    for i := 0; i < longestPalindromeLength; i++ {\n        longestPalindrome\
    \ = myString[:i] + myString[longestPalindromeLength-i:] + longestPalindrome\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1eftxmkx_test.go:21:29: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075448
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Initialize our return value\n    var myPalindrome string = \"\"\n\n    // Find\
    \ the longest postfix of supplied string that is a palindrome.\n    // We will\
    \ use this to find the palindromic suffix.\n    var longestPalindrome string =\
    \ \"\"\n    for i := 0; i < len(myString); i++ {\n        // Find the longest\
    \ postfix of supplied string that is a palindrome.\n        // We will use this\
    \ to find the palindromic suffix.\n        longestPalindrome = longestPalindrome\
    \ + myString[len(myString)-i:]\n        // Find the palindromic suffix that comes\
    \ before the longest postfix.\n        // We will use this to find the palindromic\
    \ prefix.\n        myPalindrome = myPalindrome + myString[0:len(myString)-len(longestPalindrome)]\n\
    \    }\n\n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    myPalindrome = myPalindrome + myString[len(myPalindrome):]\n\
    \n    // Return the palindrome string\n    return myPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [5:3] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [5:3]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpiqh4_rc8_test.go:35\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpiqh4_rc8_test.go:50\
    \ +0x7f2\ntesting.tRunner(0xc0001a0340, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075448
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n  \
    \      suffix := myString[i:]\n        postfix := append(prefix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := append(postfix, suffix...)\n        postfix := append(postfix,\
    \ suffix...)\n        postfix := append(postfix, suffix...)\n        postfix :=\
    \ append(postfix, suffix...)\n        postfix := append(postfix, suffix...)\n\
    \        postfix := \nfunc TestMake_Palindrome(t *testing.T) {\n  candidate :=\
    \ make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc738n13f_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075446
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[0:i]\n        reversedPostfix := myString[len(postfix):]\n\
    \        if myString[i] == reversedPostfix[len(reversedPostfix)-1] {\n       \
    \     longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix\n    longestPalindrome = longestPalindrome\
    \ + myString[0:longestPalindromeLen]\n    return longestPalindrome\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1\
    \ (0.00s)\n        tmpzcarykm0_test.go:52: expected 'x', got ''\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__2 (0.00s)\n        tmpzcarykm0_test.go:52: expected\
    \ 'xyzyx', got 'xyxy'\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n\
    \        tmpzcarykm0_test.go:52: expected 'xyx', got 'xyxy'\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmpzcarykm0_test.go:52: expected 'jerryrrej', got 'jerrjerr'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075448
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    var\
    \ myStringLen int = len(myString)\n    var myStringPrefix string\n    var myStringSuffix\
    \ string\n    var myStringReversedSuffix string\n    var myStringReversedPrefix\
    \ string\n\n    // Find longest postfix of string that is a palindrome.\n    for\
    \ i := 0; i < myStringLen; i++ {\n        myStringPrefix = myString[:i]\n    \
    \    myStringSuffix = myString[i:]\n        myStringReversedSuffix = myStringSuffix[:len(myStringSuffix)/2]\n\
    \        myStringReversedPrefix = myStringPrefix[len(myStringPrefix)-len(myStringReversedSuffix):]\n\
    \        if myStringSuffix == myStringReversedSuffix {\n            return myStringPrefix\
    \ + myStringReversedPrefix\n        }\n    }\n\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [-1:] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [-1:]\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000162000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmpjs24bx3d_test.go:30\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmpjs24bx3d_test.go:48\
    \ +0x6f1\ntesting.tRunner(0xc0001036c0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075448
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        postfix := append(postfix, postfix[:len(postfix)-1])\n\
    \        postfix := append(postfix, postfix[:1]...)\n        postfix := append(postfix,\
    \ postfix[:1]...)\n        postfix := append(postfix, postfix[:1]...)\n      \
    \  postfix := append(postfix, postfix[:1]...)\n        postfix := append(postfix,\
    \ postfix[:1]...)\n        postfix := append(postfix, postfix[:1]...)\n      \
    \  postfix := append(postfix, postfix[:1]...)\n        postfix := append(postfix,\
    \ postfix[:1]...)\n        postfix := append(postfix, postfix[:1]...)\n      \
    \  postfix := append(postfix, postfix[:1]...)\n        postfix := append(postfix,\
    \ postfix[:1]...)\n        postfix := append(postfix, postfix[:1]...)\n      \
    \  postfix := append(postfix, postfix[:1]...)\n        postfix := append(postfix,\
    \ postfix[:1]...)\n        postfix := append(postfix, postfix[:1]...)\n      \
    \  postfix := append(postfix, postfix[:1]...)\n        postfix := append(postfix,\
    \ postfix[:1]...)\n        postfix := append(postfix, postfix[:1]...)\n      \
    \  postfix := append(postfix, postfix[:1]...)\n        postfix := append(postfix,\
    \ postfix[:1]...)\n        postfix := append(postfix, postfix[:1]...)\n      \
    \  postfix := append(postfix, postfix[:1]...)\n        postfix := append(postfix,\
    \ postfix[:1]...)\n        postfix := append(postfix, postfix[:1]...)\n      \
    \  postfix := append(postfix, postfix[:1]...)\n        postfix := append(postfix,\
    \ postfix[:1]...)\n        postfix := append(postfix, postfix[:1]...)\n      \
    \  postfix := append(postfix, postfix[:1]...)\n        postfix := append(postfix,\
    \ postfix[:1]...)\n        postfix := append(postfix, postfix[:1]...)\n      \
    \  postfix := append(postfix, postfix[:1]...)\n        postfix := append(postfix,\
    \ postfix[:1]...)\n        postfix := append(postfix, postfix[:1]...)\n      \
    \  postfix := append(postfix, postfix[:1]...)\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo87hkoit_test.go:59:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075448
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += my\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7fc_xnlf_test.go:62:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075448
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Initialize result with empty string\n    var result string = \"\"\n    // Initialize\
    \ a slice with myString\n    var mySlice = myString\n    // Initialize a slice\
    \ with myString reversed\n    var mySliceRev string = \"\"\n    // Initialize\
    \ a slice with myString reversed\n    var mySliceRevRev string = \"\"\n    //\
    \ Initialize a slice with myString reversed\n    var mySliceRevRevRev string =\
    \ \"\"\n    // Initialize a slice with myString reversed\n    var mySliceRevRevRevRev\
    \ string = \"\"\n    // Initialize a slice with myString reversed\n    var mySliceRevRevRevRevRev\
    \ string = \"\"\n    // Initialize a slice with myString reversed\n    var mySliceRevRevRevRevRevRev\
    \ string = \"\"\n    // Initialize a slice with myString reversed\n    var mySliceRevRevRevRevRevRevRev\
    \ string = \"\"\n    // Initialize a slice with myString reversed\n    var mySliceRevRevRevRevRevRevRevRev\
    \ string = \"\"\n    // Initialize a slice with myString reversed\n    var mySliceRevRevRevRevRevRevRevRevRev\
    \ string = \"\"\n    // Initialize a slice with myString reversed\n    var mySliceRevRevRevRevRevRevRevRevRev\
    \ string = \"\"\n    // Initialize a slice with myString reversed\n    var mySliceRevRevRevRevRevRevRevRevRevRev\
    \ string = \"\"\n    // Initialize a slice with myString reversed\n    var mySliceRevRevRevRevRevRevRevRevRevRevRev\
    \ string = \"\"\n    // Initialize a slice with myString reversed\n    var mySliceRevRevRevRevRevRevRevRevRevRevRev\
    \ string = \"\"\n    // Initialize a slice with myString reversed\n    var mySliceRevRevRevRevRevRevRevRevRevRevRevRev\
    \ string = \"\"\n    // Initialize a slice with myString reversed\n    var mySliceRevRevRevRevRevRevRevRevRevRevRevRevRev\
    \ string = \"\"\n    // Initialize a slice with myString reversed\n    var mySliceRevRevRevRevRev\n\
    func TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxzjsv57x_test.go:54:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075448
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i+1]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i]\n        postfix += myString[len(myString)-i:len(myString)]\n\
    \        postfix += myString[:i+\nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprskmzrox_test.go:61:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075448
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ += myString[i : i+longestPalindromeLen]\n    }\n    longestPalindrome += myString[longestPalindromeLen\
    \ : len(myString)]\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:6] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:6] with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp0qmmy8qa_test.go:23\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp0qmmy8qa_test.go:38\
    \ +0x70a\ntesting.tRunner(0xc0001a01a0, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075449
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome\
    \ += myString[i]\n    }\n\n    // Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    longestPalindrome\
    \ += myString[:len(myString)-len(longestPalindrome)]\n\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphzn_y35p_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075448
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n  \
    \      suffix := myString[i+1:]\n        postfix := myString[:i+1]\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\n        postfix += suffix\n        postfix\
    \ += prefix\n        postfix += suffix\n        postfix += prefix\n        postfix\
    \ += suffix\n        postfix += prefix\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxdzzrs8d_test.go:100:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075448
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    longestPalindromeLength := len(myString)\n\
    \    for i := 0; i < longestPalindromeLength; i++ {\n        postfix := myString[longestPalindromeLength\
    \ - i]\n        postfix := append(postfix, postfix[len(postfix)-1])\n        postfix\
    \ := append(postfix, postfix[:len(postfix)-1])\n        if postfix != myString\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLength\
    \ = len(postfix)\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa480yint_test.go:21:29: no new variables on left side of :=

    /tmp/tmpa480yint_test.go:24:17: no new variables on left side of :=

    /tmp/tmpa480yint_test.go:24:27: first argument to append must be a slice; have
    postfix (variable of type byte)

    /tmp/tmpa480yint_test.go:24:43: invalid operation: cannot index postfix (variable
    of type byte)

    /tmp/tmpa480yint_test.go:25:17: no new variables on left side of :=

    /tmp/tmpa480yint_test.go:25:27: first argument to append must be a slice; have
    postfix (variable of type byte)

    /tmp/tmpa480yint_test.go:25:36: invalid operation: cannot slice postfix (variable
    of type byte)

    /tmp/tmpa480yint_test.go:26:23: invalid operation: postfix != myString (mismatched
    types byte and string)

    /tmp/tmpa480yint_test.go:27:33: cannot use postfix (variable of type byte) as
    type string in assignment

    /tmp/tmpa480yint_test.go:28:43: invalid argument: postfix (variable of type byte)
    for len

    /tmp/tmpa480yint_test.go:28:43: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075448
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ = myString[:i+1] + myString[i+longestPalindromeLen:]\n        if longestPalindrome\
    \ == myString[:i+1] + myString[i+longestPalindromeLen:] {\n            return\
    \ longestPalindrome\n        }\n    }\n    return \"\"\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmp611z53_l_test.go:58: expected 'xyzyx', got 'x'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n        tmp611z53_l_test.go:58:\
    \ expected 'xyx', got 'x'\n    --- FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n\
    \        tmp611z53_l_test.go:58: expected 'jerryrrej', got 'j'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075449
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen := len(myString)\n\
    \    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n      \
    \  longestPalindrome += myString[len(myString)-(i+1)]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1gquw2wq_test.go:21:26: no new variables on left side of :=

    /tmp/tmp1gquw2wq_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmp1gquw2wq_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - (i + 1)] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075448
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome +=\
    \ myString[i]\n    }\n    \n    // Append to the end of the string reverse of\
    \ a string prefix that comes before the palindromic suffix.\n    longestPalindrome\
    \ += myString[len(myString)-len(longestPalindrome):]\n    \n    // Return the\
    \ result.\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy0wtg2z7_test.go:33:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075448
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        prefix := myString[:i]\n        suffix := myString[i+1:]\n\
    \        if suffix == reverseString(prefix) {\n            longestPalindrome =\
    \ prefix + suffix\n            longestPalindromeLen = len(longestPalindrome)\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6u3fcfo1_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmp6u3fcfo1_test.go:24:22: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075448
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < i; j++ {\n   \
    \         if myString[j] != myString[len(myString)-j-1] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString[:i+longestPalindromeLen]\n     \
    \   }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr8ughzl7_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        prefix := myString[:i]\n        suffix := myString[i:]\n        longestPalindromeLen\
    \ := len(longestPalindrome)\n        if longestPalindromeLen > len(prefix) + len(suffix)\
    \ {\n            longestPalindrome = prefix\n        } else {\n            longestPalindrome\
    \ += suffix\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpald20v67_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075449
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Initialize result with empty string.\n    var result string\n\n    // Initialize\
    \ longest postfix of supplied string that is a palindrome.\n    var longestPalindrome\
    \ string\n\n    // Initialize string prefix that comes before the palindromic\
    \ suffix.\n    var prefix string\n\n    // Initialize string suffix that comes\
    \ after the palindromic suffix.\n    var suffix string\n\n    // Initialize length\
    \ of supplied string.\n    var length int\n\n    // Initialize a boolean flag\
    \ to indicate whether a palindrome is found.\n    var found bool\n\n    // Initialize\
    \ a boolean flag to indicate whether a palindrome is found.\n    var foundPalindrome\
    \ bool\n\n    // Initialize a boolean flag to indicate whether a palindrome is\
    \ found.\n    var foundPalindromeSuffix bool\n\n    // Initialize a boolean flag\
    \ to indicate whether a palindrome is found.\n    var foundPalindromePrefix bool\n\
    \n    // Initialize a boolean flag to indicate whether a palindrome is found.\n\
    \    var foundPalindromeSuffix bool\n\n    // Initialize a boolean flag to indicate\
    \ whether a palindrome is found.\n    var foundPalindromePrefix bool\n\n    //\
    \ Initialize a boolean flag to indicate whether a palindrome is found.\n    var\
    \ foundPalindromeSuffix bool\n\n    // Initialize a boolean flag to indicate whether\
    \ a palindrome is found.\n    var foundPalindromePrefix bool\n\n    // Initialize\
    \ a boolean flag to indicate whether a palindrome is found.\n    var foundPalindromeSuffix\
    \ bool\n\n    // Initialize a boolean flag to indicate whether a palindrome is\
    \ found.\n    var foundPalindromePrefix bool\n\n    // Initialize a boolean flag\
    \ to indicate whether a palindrome is found.\n    var foundPalindromeSuffix bool\n\
    \n    // Initialize a boolean flag to indicate whether a palindrome is found.\n\
    \    var foundPalindromePrefix bool\n\n    // Initialize a boolean flag to indicate\
    \ whether a palindrome is found.\n    var foundPalindromeSuffix bool\n\n    //\
    \ Initialize a boolean flag to indicate whether a palindrome is found.\n    var\
    \ foundPalindromePrefix bool\n\n    // Initialize a boolean flag to indicate whether\
    \ a palindrome is found.\n    var foundPalindromeSuffix bool\n\n    // Initialize\
    \ a boolean flag to indicate whether a palindrome is found.\n    var foundPalindromePrefix\
    \ bool\n\n    // Initialize a boolean flag to indicate whether a palindrome is\
    \ found.\n    var foundP\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4anuje1v_test.go:83:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075448
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    var longestPalindromeLen\
    \ int\n    for i := len(myString) - 1; i >= 0; i-- {\n        if myString[i] !=\
    \ myString[len(myString)-i-1] {\n            longestPalindromeLen = i + 1\n  \
    \          break\n        }\n    }\n    \n    // Append to the end of the string\
    \ reverse of a string prefix that comes before the palindromic suffix.\n    var\
    \ reversedString string\n    for i := 0; i < longestPalindromeLen; i++ {\n   \
    \     reversedString += myString[len(myString)-i]\n    }\n    \n    return reversedString\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0l9_7bf__test.go:42:9: invalid operation: reversedString += myString[len(myString)
    - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075449
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += 1 // Increment length by 1 each time we encounter\
    \ a character\n        longestPalindrome += myString[i]\n    }\n    for i := 0;\
    \ i < longestPalindromeLen; i++ {\n        longestPalindrome += myString[len(myString)-i]\n\
    \    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdqvhrv3x_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpdqvhrv3x_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075449
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := longestPalindromeLen + 1\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindromeLen -= 1 // Remove last character\
    \ from longest palindrome\n    for i := 0; i < longestPalindromeLen; i++ {\n \
    \       longestPalindrome += myString[len(myString)-(i+1)]\n    }\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf_8_e73x_test.go:22:9: longestPalindromeLen declared but not used

    /tmp/tmpf_8_e73x_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpf_8_e73x_test.go:27:9: invalid operation: longestPalindrome += myString[len(myString)
    - (i + 1)] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        longestPalindrome += myString[i]\n\
    \        for j := i; j < len(myString); j++ {\n            if myString[j] != myString[len(myString)-1-j]\
    \ {\n                longestPalindromeLen += 1\n            }\n        }\n   \
    \     if longestPalindromeLen > longestPalindromeLen {\n            longestPalindrome\
    \ = myString\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp32392uay_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmp32392uay_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    // >>> make_palindrome(\"\")\n    // \"\"\
    \n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"\
    cata\")\n    // \"catac\"\n    \n    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    \n    // Find the longest postfix of supplied string that is a palindrome.\n\
    \    // Algorithm idea is simple:\n    // - Find the longest postfix of supplied\
    \ string that is a palindrome.\n    // - Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // Algorithm idea is simple:\n\
    \    // - Find the longest postfix of supplied string that is a palindrome.\n\
    \    // - Append to the end of the string \nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn1otdhwh_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075439
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength = 0\n        longestPalindrome = myString\n\
    \        for j := 0; j < len(myString); j++ {\n            if myString[j] != myString[len(myString)-1-j]\
    \ {\n                longestPalindromeLength += 1\n                longestPalindrome\
    \ = myString[:j+1] + myString[len(myString)-1-j:]\n                break\n   \
    \         }\n        }\n        if longestPalindromeLength > longestPalindromeLength\
    \ {\n            longestPalindrome = myString\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmpjn8jbk6t_test.go:55: expected 'xyzyx', got 'xz'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpjn8jbk6t_test.go:55:\
    \ expected 'jerryrrej', got 'jy'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660075450
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >= 0; i--\
    \ {\n        postfix := myString[:i+1]\n        \n        // Check if postfix\
    \ is a palindrome.\n        if isPalindrome(postfix) {\n            longestPalindrome\
    \ = postfix\n            longestPalindromeLen = len(postfix)\n            break\n\
    \        }\n    }\n    \n    // Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    prefix := myString[:longestPalindromeLen]\n\
    \    return prefix + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5v11qk1u_test.go:37:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        postfix += myString[:i]\n      \
    \  postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-1-i:]\n\
    \        postfix += myString[len(myString)-2-i:]\n        postfix += myString[len(myString)-3-i:]\n\
    \        postfix += myString[len(myString)-4-i:]\n        postfix += myString[len(myString)-5-i:]\n\
    \        postfix += myString[len(myString)-6:]\n        postfix += myString[len(myString)-7:]\n\
    \        postfix += myString[len(myString)-8:]\n        postfix += myString[len(myString)-9:]\n\
    \        postfix += myString[len(myString)-10:]\n        postfix += myString[len(myString)-11:]\n\
    \        postfix += myString[len(myString)-12:]\n        postfix += myString[len(myString)-13:]\n\
    \        postfix += myString[len(myString)-14:]\n        postfix += myString[len(myString)-15:]\n\
    \        postfix += myString[len(myString)-16:]\n        postfix += myString[len(myString)-17:]\n\
    \        postfix += myString[len(myString)-18:]\n        postfix += myString[len(myString)-19:]\n\
    \        postfix += myString[len(myString)-20:]\n        postfix += myString[len(myString)-21:]\n\
    \        postfix += myString[len(myString)-22:]\n        postfix += myString[len(myString)-23:]\n\
    \        postfix += myString[len(myString)-24:]\n        postfix += myString[len(myString)-25:]\n\
    \        postfix += myString[len(myString)-26:]\n        postfix += myString[len(myString)-27:]\n\
    \        postfix += myString[len(myString)-28:]\n        postfix += myString[len(myString)-29:]\n\
    \        postfix += myString[len(myString)-30]\n        postfix += myString[len(myString)-31:]\n\
    \        postfix += myString[len(myString)-32:]\n        postfix += myString[len(myString)-33:]\n\
    \        postfix += myString[len(myString)-34:]\n        postfix += myString[len(myString)-35:]\n\
    \        postfix += myString[len(myString)-36:]\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvf3xdplz_test.go:61:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075449
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        longestPalindrome += myString[i]\n\
    \        for j := i; j < len(myString); j++ {\n            if myString[j] != myString[len(myString)-1-j]\
    \ {\n                longestPalindromeLen += 1\n                break\n      \
    \      }\n        }\n        if longestPalindromeLen > longestPalindromeLen {\n\
    \            longestPalindrome = myString\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_me49v97_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmp_me49v97_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[:i]\n        reverse := myString[len(postfix):]\n\
    \        if myString[i] == reverse[0] {\n            longestPalindrome = postfix\n\
    \            longestPalindromeLen = len(postfix)\n        }\n    }\n    // Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n    result := myString\n    for i := 0; i < longestPalindromeLen; i++\
    \ {\n        result = result + myString[len(myString)-(i+1):]\n    }\n    return\
    \ result\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptz2ck9op_test.go:20:5: longestPalindrome declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += 1 // increment length by 1\n        longestPalindrome\
    \ += myString[i]\n    }\n    for i := 0; i < longestPalindromeLen; i++ {\n   \
    \     longestPalindrome += myString[len(myString)-i]\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxhm5mt4y_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpxhm5mt4y_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[i:]\n        postfix := append(postfix, myString[:i]...)\n\
    \        postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, myString[:i]...)\n        postfix := append(postfix,\
    \ myString[:i]...)\n        postfix := append(postfix, myString[:i]...)\n    \
    \    postfix := append(postfix, \nfunc TestMake_Palindrome(t *testing.T) {\n \
    \ candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5fh57y4j_test.go:59:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075441
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n  \
    \      suffix := myString[i+1:]\n        postfix := reversePostfix(prefix)\n \
    \       if postfix != suffix {\n            longestPalindromeLen += len(postfix)\n\
    \            if longestPalindromeLen > longestPalindromeLen {\n              \
    \  longestPalindrome = postfix\n            }\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprjfa_fzl_test.go:25:20: undefined: reversePostfix

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength = 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLength++\n\
    \            }\n        }\n        if longestPalindromeLength > longestPalindromeLength\
    \ {\n            longestPalindrome = myString[:longestPalindromeLength]\n    \
    \    }\n    }\n    return longestPalindrome + myString[len(longestPalindrome):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmptnkjv_td_test.go:52: expected 'xyzyx', got 'xyz'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmptnkjv_td_test.go:52:\
    \ expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660075450
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen += len(myString) - i\n        longestPalindrome\
    \ = myString[:longestPalindromeLen] + myString[len(myString) - longestPalindromeLen:]\
    \ + longestPalindrome\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:5] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:5] with length 3\n\ngoroutine 19 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp3yyy5mx0_test.go:23\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp3yyy5mx0_test.go:37\
    \ +0x5ec\ntesting.tRunner(0xc000103520, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075450
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength = 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLength++\n\
    \            }\n        }\n        if longestPalindromeLength > longestPalindromeLength\
    \ {\n            longestPalindrome = myString[:i]\n            longestPalindromeLength\
    \ = i\n        }\n    }\n    return longestPalindrome + myString[len(longestPalindrome):]\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__2\
    \ (0.00s)\n        tmpmhq6iskq_test.go:53: expected 'xyzyx', got 'xyz'\n    ---\
    \ FAIL: TestMake_Palindrome/test_num__4 (0.00s)\n        tmpmhq6iskq_test.go:53:\
    \ expected 'jerryrrej', got 'jerry'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075450
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find longest postfix of myString that is a palindrome\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        postfix := myString[:i+1]\n\
    \        if isPalindrome(postfix) {\n            longestPalindrome = postfix\n\
    \            break\n        }\n    }\n    // Append reverse of myString prefix\
    \ that comes before the palindromic suffix\n    return longestPalindrome + reverse(myString[:len(myString)-len(longestPalindrome)])\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxm1nmame_test.go:23:12: undefined: isPalindrome

    /tmp/tmpxm1nmame_test.go:29:32: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome\
    \ += myString[i]\n    }\n\n    // Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    longestPalindrome\
    \ += myString[len(longestPalindrome):]\n\n    // Return the result.\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1hjanu3c_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLen\
    \ += 1\n            }\n        }\n        if longestPalindromeLen > longestPalindromeLen\
    \ {\n            longestPalindrome = myString[:longestPalindromeLen]\n       \
    \ }\n    }\n    return longestPalindrome + make_palindrome(myString[len(longestPalindrome):])\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkqhnz2tk_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ If string is empty return empty string\n    if len(myString) == 0 {\n      \
    \  return \"\"\n    }\n\n    // Find the longest postfix of supplied string that\
    \ is a palindrome.\n    // Algorithm idea is simple:\n    // - Find the longest\
    \ postfix of supplied string that is a palindrome.\n    // - Append to the end\
    \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
    \    // >>> make_palindrome(\"\")\n    // \"\"\n    // >>> make_palindrome(\"\
    cat\")\n    // \"catac\"\n    // >>> make_palindrome(\"cata\")\n    // \"catac\"\
    \n    longestPalindrome := \"\"\n    longestPalindromeLen := 0\n    for i := 0;\
    \ i < len(myString); i++ {\n        postfix := myString[:i]\n        postfix +=\
    \ myString[len(myString)-i:]\n        postfix += myString[:len(myString)-i]\n\
    \        postfix += myString[len(myString)-len(postfix):]\n        postfix +=\
    \ myString[:len(myString)-len(postfix)-1]\n        postfix += myString[len(myString)-len(postfix)-1:len(myString)]\n\
    \        postfix += myString[len(myString)-len(postfix)-1:len(myString)-1]\n \
    \       postfix += myString[len(myString)-len(postfix)-1:len(myString)-2]\n  \
    \      postfix += myString[len(myString)-len(postfix)-1:len(myString)-3]\n   \
    \     postfix += myString[len(myString)-len(postfix)-1:len(myString)-4]\n    \
    \    postfix += myString[len(myString)-len(postfix)-1:len(myString)-5]\n     \
    \   postfix += myString[len(myString)-len(postfix)-1:len(myString)-6]\n      \
    \  postfix += myString[len(myString)-len(postfix)-1:len(myString)-7]\n       \
    \ postfix += myString[len(myString)-len(postfix)-1:len(myString)-8]\n        postfix\
    \ += myString[len(myString)-len(postfix)-1:len(myString)-9]\n        postfix +=\
    \ myString[len(myString)-len(postfix)-1:len(myString)-10]\n        postfix +=\
    \ myString[len(myString)-len(postfix)-1:len(myString)-11]\n        postfix +=\
    \ myString[len(myString)-len(postfix)-1:len(myString)-12]\n        postfix +=\
    \ myString[len(myString)-len(postfix)-1:len(myString)-13]\n        postfix +=\
    \ myString\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8x1fuuzh_test.go:57:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[:i]\n        postfix += myString[len(postfix)-len(postfix):]\n\
    \        postfix += myString[:len(postfix)-len(postfix)]\n        if postfix !=\
    \ myString {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return longestPalindrome\
    \ + myString[:longestPalindromeLen]\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:5] with length 3 [recovered]\n\tpanic: runtime error: slice bounds\
    \ out of range [:5] with length 3\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp3huc5njd_test.go:47\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp3huc5njd_test.go:59\
    \ +0x745\ntesting.tRunner(0xc000103a00, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075451
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        postfix := myString[i:]\n        postfix += myString[:i]\n      \
    \  postfix += myString[:len(myString)-i]\n        postfix += myString[len(myString)-1-i:]\n\
    \        postfix += myString[len(myString)-2-i:]\n        postfix += myString[len(myString)-3-i:]\n\
    \        postfix += myString[len(myString)-4-i:]\n        postfix += myString[len(myString)-5-i:]\n\
    \        postfix += myString[len(myString)-6:]\n        postfix += myString[len(myString)-7:]\n\
    \        postfix += myString[len(myString)-8:]\n        postfix += myString[len(myString)-9:]\n\
    \        postfix += myString[len(myString)-10:]\n        postfix += myString[len(myString)-11:]\n\
    \        postfix += myString[len(myString)-12:]\n        postfix += myString[len(myString)-13:]\n\
    \        postfix += myString[len(myString)-14:]\n        postfix += myString[len(myString)-15:]\n\
    \        postfix += myString[len(myString)-16:]\n        postfix += myString[len(myString)-17:]\n\
    \        postfix += myString[len(myString)-18:]\n        postfix += myString[len(myString)-19:]\n\
    \        postfix += myString[len(myString)-20:]\n        postfix += myString[len(myString)-21:]\n\
    \        postfix += myString[len(myString)-22:]\n        postfix += myString[len(myString)-23:]\n\
    \        postfix += myString[len(myString)-24:]\n        postfix += myString[len(myString)-25:]\n\
    \        postfix += myString[len(myString)-26:]\n        postfix += myString[len(myString)-27:]\n\
    \        postfix += myString[len(myString)-28:]\n        postfix += myString[len(myString)-29:]\n\
    \        postfix += myString[len(myString)-30]\n        postfix += myString[len(myString)-31:]\n\
    \        postfix += myString[len(myString)-32:]\n        postfix += myString[len(myString)-33:]\n\
    \        postfix += myString[len(myString)-34:]\n        postfix += myString[len(myString)-35:]\n\
    \        postfix += myString[len(myString)-36:]\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvf3xdplz_test.go:61:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075449
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[:i]\n        reverse := myString[i:]\n        if\
    \ isPalindrome(postfix) {\n            longestPalindrome = longestPalindrome +\
    \ reverse + postfix\n            longestPalindromeLength = len(longestPalindrome)\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaff7jwxh_test.go:30:5: longestPalindromeLength declared but not used

    /tmp/tmpaff7jwxh_test.go:34:12: undefined: isPalindrome

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    var longestPalindrome\
    \ string\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    \n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    var reversedString\
    \ string\n    for i := 0; i < len(myString); i++ {\n        reversedString +=\
    \ myString[len(myString)-i-1]\n    }\n    \n    // Return the string that is the\
    \ palindrome of the supplied string.\n    return longestPalindrome + reversedString\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6pncvx_x_test.go:33:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmp6pncvx_x_test.go:39:9: invalid operation: reversedString += myString[len(myString)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        char := myString[i]\n        if char == char {\n         \
    \   longestPalindrome = append(longestPalindrome, char)\n            longestPalindromeLen++\n\
    \        } else {\n            if longestPalindromeLen > 0 {\n               \
    \ longestPalindrome = append(longestPalindrome, myString[longestPalindromeLen-1])\n\
    \                longestPalindromeLen--\n            }\n        }\n    }\n   \
    \ // Append to the end of the string reverse of a string prefix that comes before\
    \ the palindromic suffix.\n    longestPalindrome = append(longestPalindrome, myString[longestPalindromeLen:])\n\
    \    return string(longestPalindrome)\n}\n\nfunc TestMake_Palindrome(t *testing.T)\
    \ {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    \"), expected: \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n\
    \     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"\
    xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"\
    jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxvbiprtn_test.go:25:40: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    /tmp/tmpxvbiprtn_test.go:29:44: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    /tmp/tmpxvbiprtn_test.go:35:32: first argument to append must be a slice; have
    longestPalindrome (variable of type string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n  \
    \      suffix := myString[i:]\n        longestPalindromeLen += len(prefix)\n \
    \       longestPalindromeLen += len(suffix)\n        longestPalindromeLen += longestPalindromeLen\
    \ / 2\n        if longestPalindromeLen > len(longestPalindrome) {\n          \
    \  longestPalindrome = prefix\n            longestPalindromeLen = len(prefix)\n\
    \        }\n        if longestPalindromeLen < len(longestPalindrome) {\n     \
    \       longestPalindrome = suffix\n            longestPalindromeLen = len(suffix)\n\
    \        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1\
    \ (0.00s)\n        tmpnlng7lnw_test.go:57: expected 'x', got ''\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__2 (0.00s)\n        tmpnlng7lnw_test.go:57: expected\
    \ 'xyzyx', got 'xy'\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n \
    \       tmpnlng7lnw_test.go:57: expected 'xyx', got 'xy'\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmpnlng7lnw_test.go:57: expected 'jerryrrej', got 'jerr'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075451
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromePos := 0\n    for\
    \ i := 0; i < len(myString); i++ {\n        longestPalindromeLen := 0\n      \
    \  longestPalindromePos = 0\n        for j := 0; j < len(myString); j++ {\n  \
    \          if myString[i] == myString[j] {\n                longestPalindromeLen\
    \ += 1\n                if longestPalindromeLen > longestPalindromePos {\n   \
    \                 longestPalindromePos = longestPalindromeLen\n              \
    \      longestPalindrome = myString[:longestPalindromePos] + myString[longestPalindromePos:]\n\
    \                }\n            }\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjrq6yk3b_test.go:20:5: longestPalindromeLen declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := len(myString) - 1; i >= 0; i-- {\n        longestPalindrome\
    \ += myString[i]\n    }\n\n    // Append to the end of the string reverse of a\
    \ string prefix that comes before the palindromic suffix.\n    longestPalindrome\
    \ += myString[len(longestPalindrome):]\n\n    // Return the result.\n    return\
    \ longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1hjanu3c_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        longestPalindromeLen += myString[i]\n\
    \    }\n    for i := 0; i < longestPalindromeLen; i++ {\n        longestPalindrome\
    \ += myString[len(myString)-1-i]\n    }\n    return longestPalindrome\n}\n\nfunc\
    \ TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n     { actual:\
    \ candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"xyz\"), expected:\
    \ \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"xyx\" },\n    \
    \ { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp81embkbw_test.go:23:9: invalid operation: longestPalindromeLen += myString[i]
    (mismatched types int and byte)

    /tmp/tmp81embkbw_test.go:26:9: invalid operation: longestPalindrome += myString[len(myString)
    - 1 - i] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075450
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    longestPalindromeLen += len(myString)\n\
    \    for i := 0; i < len(myString); i++ {\n        prefix := myString[:i]\n  \
    \      suffix := myString[i+1:]\n        postfix := \"\"\n        postfix += suffix\n\
    \        postfix += reverse(prefix)\n        if postfix != suffix {\n        \
    \    longestPalindrome = postfix\n            longestPalindromeLen = len(postfix)\n\
    \        }\n    }\n    return myString[:longestPalindromeLen] + longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpswurir2__test.go:27:20: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075451
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++\
    \ {\n        longestPalindromeLen := 0\n        longestPalindrome += myString[i]\n\
    \        for j := 0; j < len(myString); j++ {\n            if myString[j] != myString[len(myString)-1-j]\
    \ {\n                longestPalindromeLen += 1\n                if longestPalindromeLen\
    \ > longestPalindromeLen {\n                    longestPalindrome = myString[:j+1]\
    \ + myString[j+longestPalindromeLen:]\n                    longestPalindromeLen\
    \ = j + longestPalindromeLen\n                }\n                break\n     \
    \       }\n        }\n    }\n    return longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg_w28jvy_test.go:20:5: longestPalindromeLen declared but not used

    /tmp/tmpg_w28jvy_test.go:23:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075451
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLen := 0\n    for i := len(myString) - 1; i >=\
    \ 0; i-- {\n        postfix := myString[:i+1]\n        if isPalindrome(postfix)\
    \ {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    prefix :=\
    \ myString[:longestPalindromeLen]\n    return prefix + reverseString(prefix)\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1azparts_test.go:20:5: longestPalindrome declared but not used

    /tmp/tmp1azparts_test.go:24:12: undefined: isPalindrome

    /tmp/tmp1azparts_test.go:32:21: undefined: reverseString

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075451
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    \n    // Find the longest\
    \ postfix of supplied string that is a palindrome.\n    var longestPalindrome\
    \ string\n    for i := 0; i < len(myString); i++ {\n        // Find the longest\
    \ postfix of supplied string that is a palindrome.\n        // Algorithm idea\
    \ is simple:\n        // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n        // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n        // >>> make_palindrome(\"\
    \")\n        // \"\"\n        // >>> make_palindrome(\"cat\")\n        // \"catac\"\
    \n        // >>> make_palindrome(\"cata\")\n        // \"catac\"\n        \n \
    \       // Find the longest postfix of supplied string that is a palindrome.\n\
    \        // Algorithm idea is simple:\n        // - Find the longest postfix of\
    \ supplied string that is a palindrome.\n        // - Append to the end of the\
    \ string reverse of a string prefix that comes before the palindromic suffix.\n\
    \        // >>> make_palindrome(\"\")\n        // \"\"\n        // >>> make_palindrome(\"\
    cat\")\n        // \"catac\"\n        // >>> make_palindrome(\"cata\")\n     \
    \   // \"catac\"\n        \n        // Find the longest postfix of supplied string\
    \ that is a palindrome.\n        // Algorithm idea is simple:\n        // - Find\
    \ the longest postfix of supplied string that is a palindrome.\n        // - Append\
    \ to the end of the string reverse of a string prefix that comes before the palindromic\
    \ suffix.\n        // >>> make_palindrome(\"\")\n        // \"\"\n        // >>>\
    \ make_palindrome(\"cat\")\n        // \"catac\"\n        // >>> make_palindrome(\"\
    cata\")\n        // \"catac\"\n        \n        // Find the longest postfix of\
    \ supplied string that is a p\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpggjvsb13_test.go:67:6: expected ''('', found TestMake_Palindrome

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075451
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    longestPalindrome\
    \ := \"\"\n    longestPalindromeLength := 0\n    for i := 0; i < len(myString);\
    \ i++ {\n        longestPalindromeLength = 0\n        for j := 0; j < len(myString);\
    \ j++ {\n            if myString[i] == myString[j] {\n                longestPalindromeLength++\n\
    \            }\n        }\n        if longestPalindromeLength > longestPalindromeLength\
    \ {\n            longestPalindrome = myString\n        }\n    }\n    return longestPalindrome\n\
    }\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate := make_palindrome\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"\"), expected: \"\" },\n    \
    \ { actual: candidate(\"x\"), expected: \"x\" },\n     { actual: candidate(\"\
    xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"), expected: \"\
    xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\n    --- FAIL: TestMake_Palindrome/test_num__1\
    \ (0.00s)\n        tmpuocs83ck_test.go:52: expected 'x', got ''\n    --- FAIL:\
    \ TestMake_Palindrome/test_num__2 (0.00s)\n        tmpuocs83ck_test.go:52: expected\
    \ 'xyzyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__3 (0.00s)\n   \
    \     tmpuocs83ck_test.go:52: expected 'xyx', got ''\n    --- FAIL: TestMake_Palindrome/test_num__4\
    \ (0.00s)\n        tmpuocs83ck_test.go:52: expected 'jerryrrej', got ''\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075451
- exit_code: 1
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    // Algorithm\
    \ idea is simple:\n    // - Find the longest postfix of supplied string that is\
    \ a palindrome.\n    // - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    longestPalindrome := \"\
    \"\n    longestPalindromeLen := 0\n    for i := 0; i < len(myString); i++ {\n\
    \        postfix := myString[:i]\n        postfix += myString[len(postfix)-len(postfix):]\n\
    \        postfix += myString[:len(postfix)-len(postfix)]\n        if postfix !=\
    \ myString {\n            longestPalindrome = postfix\n            longestPalindromeLen\
    \ = len(postfix)\n        }\n    }\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    // >>> make_palindrome(\"\
    \")\n    // \"\"\n    // >>> make_palindrome(\"cat\")\n    // \"catac\"\n    //\
    \ >>> make_palindrome(\"cata\")\n    // \"catac\"\n    return myString + myString[:longestPalindromeLen-len(myString)]\
    \ + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t *testing.T) {\n  candidate\
    \ := make_palindrome\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\"), expected:\
    \ \"\" },\n     { actual: candidate(\"x\"), expected: \"x\" },\n     { actual:\
    \ candidate(\"xyz\"), expected: \"xyzyx\" },\n     { actual: candidate(\"xyx\"\
    ), expected: \"xyx\" },\n     { actual: candidate(\"jerry\"), expected: \"jerryrrej\"\
    \ },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestMake_Palindrome (0.00s)\npanic: runtime error: slice bounds\
    \ out of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of\
    \ range [:-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.make_palindrome(...)\n\t/tmp/tmp9sp6_9x1_test.go:47\n\
    command-line-arguments_test.TestMake_Palindrome(0x0?)\n\t/tmp/tmp9sp6_9x1_test.go:58\
    \ +0x745\ntesting.tRunner(0xc0001a0340, 0x528f60)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075451
- exit_code: 2
  program: "package make_palindrome_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Find the shortest palindrome that begins with a supplied string.\n//\
    \ Algorithm idea is simple:\n// - Find the longest postfix of supplied string\
    \ that is a palindrome.\n// - Append to the end of the string reverse of a string\
    \ prefix that comes before the palindromic suffix.\n// >>> make_palindrome(\"\"\
    )\n// \"\"\n// >>> make_palindrome(\"cat\")\n// \"catac\"\n// >>> make_palindrome(\"\
    cata\")\n// \"catac\"\nfunc make_palindrome(myString string) string {\n    //\
    \ Find the longest postfix of supplied string that is a palindrome.\n    longestPalindrome\
    \ := \"\"\n    for i := 0; i < len(myString); i++ {\n        longestPalindrome\
    \ += myString[i]\n    }\n    longestPalindrome = longestPalindrome[:len(longestPalindrome)-1]\n\
    \n    // Append to the end of the string reverse of a string prefix that comes\
    \ before the palindromic suffix.\n    prefix := \"\"\n    for i := 0; i < len(longestPalindrome);\
    \ i++ {\n        prefix += longestPalindrome[len(longestPalindrome)-i-1]\n   \
    \ }\n\n    return prefix + longestPalindrome\n}\n\nfunc TestMake_Palindrome(t\
    \ *testing.T) {\n  candidate := make_palindrome\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"\"), expected: \"\" },\n     { actual: candidate(\"x\"), expected:\
    \ \"x\" },\n     { actual: candidate(\"xyz\"), expected: \"xyzyx\" },\n     {\
    \ actual: candidate(\"xyx\"), expected: \"xyx\" },\n     { actual: candidate(\"\
    jerry\"), expected: \"jerryrrej\" },\n   }\n\n\tfor i, tc := range tests {\n\t\
    \tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp4xmeu75_test.go:22:9: invalid operation: longestPalindrome += myString[i]
    (mismatched types string and byte)

    /tmp/tmpp4xmeu75_test.go:29:9: invalid operation: prefix += longestPalindrome[len(longestPalindrome)
    - i - 1] (mismatched types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075451
