language: go_test.go
name: HumanEval_68_pluck
results:
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    smalest_value := arr[0]\n    smalest_index := 0\n    for _, value :=\
    \ range arr {\n        if value%2 == 0 {\n            if value < smalest_value\
    \ {\n                smalest_value = value\n                smalest_index = index\n\
    \            }\n        }\n    }\n    return []int{smalest_value, smalest_index}\n\
    }\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdde6p1mv_test.go:46:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    sort.Ints(arr)\n\
    \    evens := make([]int, 0, len(arr))\n    for _, v := range arr {\n        if\
    \ v%2 == 0 {\n            evens = append(evens, v)\n        }\n    }\n    if len(evens)\
    \ == 0 {\n        return []int{}\n    }\n    sort.Ints(evens)\n    smalest_value\
    \ := evens[0]\n    smalest_index := 0\n    for _, v := range evens {\n       \
    \ if v == smalest_value {\n            smalest_index++\n        } else {\n   \
    \         smalest_value = v\n            smalest_index = v\n        }\n    }\n\
    \    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpadockfqo_test.go:37:5: undefined: sort

    /tmp/tmpadockfqo_test.go:47:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074498
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    return arr\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpv095_d20_test.go:59: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n     \
    \   tmpv095_d20_test.go:59: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1)\
    \ %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n     \
    \   tmpv095_d20_test.go:59: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=5)\
    \ %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpv095_d20_test.go:59: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0) %!s(int=5) %!s(int=3)]'\n\
    \    --- FAIL: TestPluck/test_num__5 (0.00s)\n        tmpv095_d20_test.go:59:\
    \ expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=5) %!s(int=4) %!s(int=8) %!s(int=4)\
    \ %!s(int=8)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpv095_d20_test.go:59:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=7) %!s(int=6) %!s(int=7) %!s(int=1)]'\n\
    \    --- FAIL: TestPluck/test_num__7 (0.00s)\n        tmpv095_d20_test.go:59:\
    \ expected '[]', got '[%!s(int=7) %!s(int=9) %!s(int=7) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074499
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    index := 0\n    smalest\
    \ := arr[0]\n    for _, value := range arr {\n        if value%2 == 0 {\n    \
    \        if value < smalest{\n                smalest = value\n              \
    \  index = index + 1\n            }\n        }\n    }\n    return []int{smalest,\
    \ index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv89uu6cp_test.go:35:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074498
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, 0)\n    arr3 := make([]int, 0)\n    arr4 := make([]int,\
    \ 0)\n    arr5 := make([]int, 0)\n    arr6 := make([]int, 0)\n    arr7 := make([]int,\
    \ 0)\n    arr8 := make([]int, 0)\n    arr9 := make([]int, 0)\n    arr10 := make([]int,\
    \ 0)\n    arr11 := make([]int, 0)\n    arr12 := make([]int, 0)\n    arr13 := make([]int,\
    \ 0)\n    arr14 := make([]int, 0)\n    arr15 := make([]int, 0)\n    arr16 := make([]int,\
    \ 0)\n    arr17 := make([]int, 0)\n    arr18 := make([]int, 0)\n    arr19 := make([]int,\
    \ 0)\n    arr20 := make([]int, 0)\n    arr21 := make([]int, 0)\n    arr22 := make([]int,\
    \ 0)\n    arr23 := make([]int, 0)\n    arr24 := make([]int, 0)\n    arr25 := make([]int,\
    \ 0)\n    arr26 := make([]int, 0)\n    arr27 := make([]int, 0)\n    arr28 := make([]int,\
    \ 0)\n    arr29 := make([]int, 0)\n    arr30 := make([]int, 0)\n    arr31 := make([]int,\
    \ 0)\n    arr32 := make([]int, 0)\n    arr33 := make([]int, 0)\n    arr34 := make([]int,\
    \ 0)\n    arr35 := make([]int, 0)\n    arr36 := make([]int, 0)\n    arr37 := make([]int,\
    \ 0)\n    arr38 := make([]int, 0)\n    arr39 := make([]int, 0)\n    arr40 := make([]int,\
    \ 0)\n    arr41 := make([]int, 0)\n    arr42 := make([]int, 0)\n    arr43 := make([]int,\
    \ 0)\n    arr44 := make([]int, 0)\n    arr45 := make([]int, 0)\n    arr46 := make([]int,\
    \ 0)\n    arr47 := make([]int, 0)\n    arr48 := make([]int, 0)\n    arr49 := make([]int,\
    \ 0)\n    arr50 := make([]int, 0)\n    arr51 := make([]int, 0)\n    \nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzmw9xwos_test.go:85:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    evens := make([]int,\
    \ 0)\n    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n   \
    \         evens = append(evens, v)\n            index = index + 1\n        }\n\
    \    }\n    if len(evens) == 0 {\n        return []int{}\n    }\n    sort.Sort(sort.IntSlice(evens))\n\
    \    return evens\n}\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmdt9lbj7_test.go:49:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    return arr\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpv095_d20_test.go:59: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n     \
    \   tmpv095_d20_test.go:59: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1)\
    \ %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n     \
    \   tmpv095_d20_test.go:59: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=5)\
    \ %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpv095_d20_test.go:59: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0) %!s(int=5) %!s(int=3)]'\n\
    \    --- FAIL: TestPluck/test_num__5 (0.00s)\n        tmpv095_d20_test.go:59:\
    \ expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=5) %!s(int=4) %!s(int=8) %!s(int=4)\
    \ %!s(int=8)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpv095_d20_test.go:59:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=7) %!s(int=6) %!s(int=7) %!s(int=1)]'\n\
    \    --- FAIL: TestPluck/test_num__7 (0.00s)\n        tmpv095_d20_test.go:59:\
    \ expected '[]', got '[%!s(int=7) %!s(int=9) %!s(int=7) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074499
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    i := 0\n    j := len(arr)\
    \ - 1\n    k := 0\n    smalest_value := arr[0]\n    smalest_index := 0\n    for\
    \ i < j {\n        if arr[i] % 2 == 0 {\n            if arr[i] < smalest_value\
    \ {\n                smalest_value = arr[i]\n                smalest_index = k\n\
    \            }\n            i++\n        } else {\n            k++\n        }\n\
    \    }\n    if i == j {\n        return []int{smalest_value, smalest_index}\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2y95gifu_test.go:35:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074498
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var result []int\n    var index int\n    for _, v\
    \ := range arr {\n        if v%2 == 0 {\n            result = append(result, v)\n\
    \            index = len(result)-1\n        }\n    }\n    if index == -1 {\n \
    \       return []int{}\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5x1otsex_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074498
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Sort(sort.Reverse(arr))\n    var index\
    \ int = 0\n    var smallestEven int = 0\n    for _, v := range arr {\n       \
    \ if v%2 == 0 {\n            if smallestEven == 0 {\n                smallestEven\
    \ = v\n                index = v\n            } else {\n                if smallestEven\
    \ != v {\n                    smallestEven = v\n                    index = v\n\
    \                }\n            }\n        }\n    }\n    return []int{smallestEven,\
    \ index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmmtjm2gk_test.go:35:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074498
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minIndex int\n    var minVal int\n    for _,\
    \ val := range arr {\n        if val%2 == 0 {\n            if minVal == 0 || val\
    \ < minVal {\n                minVal = val\n                minIndex = arr\n \
    \           }\n        } else {\n            if minVal == 0 || val < minVal {\n\
    \                minVal = val\n                minIndex = arr\n            }\n\
    \        }\n    }\n    if minVal == 0 {\n        return []\n    }\n    result\
    \ = append(result, minVal)\n    result = append(result, minIndex)\n    return\
    \ result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmper_4scvm_test.go:51:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n`\n)\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv8lulbo2_test.go:49:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // Write your code here\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfum02cxn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var minVal int\n    var minIndex int\n    for _,\
    \ val := range arr {\n        if val%2 == 0 {\n            if minVal == 0 || val\
    \ < minVal {\n                minVal = val\n                minIndex = sort.Search(len(arr),\
    \ func(i int) bool {\n                    return arr[i] < minVal\n           \
    \     })\n            }\n        }\n    }\n    if minVal == 0 {\n        return\
    \ []int{}\n    }\n    return []int{minVal, minIndex}\n}\n`\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpo7fz_hni_test.go:52:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := \nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp90di3l4s_test.go:121:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if min > v {\n                min = v\n                index = index\n  \
    \          }\n        } else {\n            if min > v {\n                min\
    \ = v\n                index = index\n            }\n        }\n    }\n    return\
    \ []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpz0m92eee_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpz0m92eee_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmpz0m92eee_test.go:75: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpz0m92eee_test.go:75: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmpz0m92eee_test.go:75: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpz0m92eee_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmpz0m92eee_test.go:75: expected '[]',\
    \ got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074499
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var result []int\n    var minIndex int\n    for _,\
    \ v := range arr {\n        if v%2 == 0 {\n            result = append(result,\
    \ v)\n            if minIndex == 0 || v < result[minIndex] {\n               \
    \ minIndex = v\n            }\n        }\n    }\n    if minIndex == 0 {\n    \
    \    return []int{}\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp28imbvfw_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074498
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var minVal int\n    var minIndex int\n    for _,\
    \ v := range arr {\n        if v%2 == 0 {\n            if minVal == 0 || v < minVal\
    \ {\n                minVal = v\n                minIndex = -1\n            }\n\
    \        } else {\n            if minVal == 0 || v > minVal {\n              \
    \  minVal = v\n                minIndex = -1\n            }\n        }\n    }\n\
    \    if minVal == 0 {\n        return []int{}\n    }\n    return []int{minVal,\
    \ minIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph_2oncu5_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074498
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    index := 0\n    smalest_value := arr[0]\n    for\
    \ _, value := range arr {\n        if value%2 == 0 {\n            if value < smalest_value\
    \ {\n                smalest_value = value\n                index = index + 1\n\
    \            }\n        } else {\n            if value == smalest_value {\n  \
    \              index = index + 1\n            }\n        }\n    }\n    if index\
    \ == 0 {\n        return []int{}\n    }\n    return []int{smalest_value, index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpirpgr5hi_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074498
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, val := range arr {\n        if val%2 == 0 {\n            if val < min {\n\
    \                min = val\n                index = index\n            }\n   \
    \     } else {\n            if min > val {\n                min = val\n      \
    \          index = index\n            }\n        }\n    }\n    result = append(result,\
    \ min)\n    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc0001c4000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc0001c4000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpuwy4nyef_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpuwy4nyef_test.go:64 +0x1b0\n\
    testing.tRunner(0xc000185040, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074499
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_diyk3dq_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if min > v {\n                min = v\n                index = index\n  \
    \          }\n        } else {\n            if min > v {\n                min\
    \ = v\n                index = index\n            }\n        }\n    }\n    return\
    \ []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpz0m92eee_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpz0m92eee_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmpz0m92eee_test.go:75: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpz0m92eee_test.go:75: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmpz0m92eee_test.go:75: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpz0m92eee_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmpz0m92eee_test.go:75: expected '[]',\
    \ got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074499
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0tcnjg1m_test.go:49:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, val := range arr {\n        if val%2 == 0 {\n    \
    \        if val < min {\n                min = val\n                index = index\n\
    \            }\n        } else {\n            if val == min {\n              \
    \  index = index + 1\n            }\n        }\n    }\n    return []int{min, index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpzjeals1t_test.go:74: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpzjeals1t_test.go:74:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestPluck/test_num__4 (0.00s)\n        tmpzjeals1t_test.go:74: expected '[%!s(int=0)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=1)]'\n    --- FAIL: TestPluck/test_num__7\
    \ (0.00s)\n        tmpzjeals1t_test.go:74: expected '[]', got '[%!s(int=7) %!s(int=2)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074500
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := \nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp90di3l4s_test.go:121:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_diyk3dq_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var result []int\n    var index int\n    for _, v\
    \ := range arr {\n        if v%2 == 0 {\n            result = append(result, v)\n\
    \            index = len(result)\n        }\n    }\n    if index == 0 {\n    \
    \    return []\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n\
    \  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeidohobs_test.go:44:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074499
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, 0)\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if min > v {\n                min = v\n                index = arr2\n   \
    \         }\n        } else {\n            if min > v {\n                min =\
    \ v\n                index = arr2\n            }\n        }\n    }\n    return\
    \ []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcptqittl_test.go:42:25: cannot use arr2 (variable of type []int) as type
    int in assignment

    /tmp/tmpcptqittl_test.go:47:25: cannot use arr2 (variable of type []int) as type
    int in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074500
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, val := range arr {\n        if val%2 == 0 {\n            if val < min {\n\
    \                min = val\n                index = index\n            }\n   \
    \     } else {\n            if val == min {\n                index = index + 1\n\
    \            }\n        }\n    }\n    result = append(result, min)\n    result\
    \ = append(result, index)\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpqo7bvqou_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpqo7bvqou_test.go:63 +0x1e5\n\
    testing.tRunner(0xc0001a01a0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074500
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n\
    \    evens := make([]int, 0)\n    for _, v := range arr {\n        if v%2 == 0\
    \ {\n            evens = append(evens, v)\n        }\n    }\n    if len(evens)\
    \ == 0 {\n        return []int{}\n    }\n    smallest := evens[0]\n    smallest\
    \ := sort.Search(len(evens), func(i int) bool {\n        return evens[i] < smallest\n\
    \    })\n    return []int{smallest, sort.Search(len(evens), func(i int) bool {\n\
    \        return evens[i] == smallest\n    })}\n}\n`\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf8jjgdpn_test.go:53:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074499
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbyw5pz8d_test.go:34:5: undefined: sort

    /tmp/tmpbyw5pz8d_test.go:41:33: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074500
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_diyk3dq_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_diyk3dq_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v]++\n\
    \    }\n    sort.Ints(arr)\n    result := make([]int, 0)\n    for _, v := range\
    \ arr {\n        if m[v] % 2 == 0 {\n            result = append(result, v)\n\
    \        }\n    }\n    if len(result) == 0 {\n        return nil\n    }\n    return\
    \ result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7f2wl_uu_test.go:38:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074500
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for i := 1; i < len(arr); i++ {\n        if arr[i] > smalest_value {\n  \
    \          smalest_value = arr[i]\n            smalest_index = i\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaf2522x6_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074500
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = m[v]\
    \ + 1\n    }\n    var result []int\n    for _, v := range m {\n        if v%2\
    \ == 0 {\n            result = append(result, v)\n        }\n    }\n    if len(result)\
    \ == 0 {\n        return []int{}\n    }\n    if len(result) == 1 {\n        return\
    \ result[0]\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n \
    \ candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppw799wxq_test.go:48:16: cannot use result[0] (variable of type int) as
    type []int in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074500
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for i := 1; i < len(arr); i++ {\n        if arr[i] > smalest_value {\n  \
    \          smalest_value = arr[i]\n            smalest_index = i\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaf2522x6_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074500
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // Write your code here.\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzqzsvf_z_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074499
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    smalest_value\
    \ := arr[0]\n    smalest_index := 0\n    for i := 1; i < len(arr); i++ {\n   \
    \     if arr[i] < smalest_value {\n            smalest_value = arr[i]\n      \
    \      smalest_index = i\n        }\n    }\n    return []int{smalest_value, smalest_index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmp45ohegfg_test.go:68: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp45ohegfg_test.go:68:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=1) %!s(int=3)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmp45ohegfg_test.go:68: expected '[]',\
    \ got '[%!s(int=1) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074500
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = m[v]\
    \ + 1\n    }\n    result := make([]int, 0, len(m))\n    for k, v := range m {\n\
    \        if v%2 == 0 {\n            result = append(result, k)\n        }\n  \
    \  }\n    if len(result) == 0 {\n        return []\n    }\n    if len(result)\
    \ == 1 {\n        return result[0]\n    }\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqxo937nm_test.go:45:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074499
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // Write your code here.\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzqzsvf_z_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074499
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, value := range arr {\n        if value%2 == 0 {\n\
    \            if value < min {\n                min = value\n                index\
    \ = index\n            }\n        }\n    }\n    return []int{min, index}\n}\n\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp6i9heczk_test.go:70: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmp6i9heczk_test.go:70:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmp6i9heczk_test.go:70: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmp6i9heczk_test.go:70: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmp6i9heczk_test.go:70: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp6i9heczk_test.go:70:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=6) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmp6i9heczk_test.go:70: expected '[]',\
    \ got '[%!s(int=7) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074501
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var min\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7xdvl18t_test.go:136:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074500
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_diyk3dq_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_diyk3dq_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    min := arr[0]\n    min := 0\n    index\
    \ := 0\n    for i := 0; i < len(arr); i++ {\n        if arr[i] < min {\n     \
    \       min = arr[i]\n            index = i\n        }\n    }\n    arr2[min] =\
    \ index\n    return arr2\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp13tr65l_test.go:36:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074501
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, val := range arr {\n        if val%2 == 0 {\n            if val < min {\n\
    \                min = val\n                index = index\n            }\n   \
    \     } else {\n            if val == min {\n                index = index\n \
    \           }\n        }\n    }\n    result = append(result, min)\n    result\
    \ = append(result, index)\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc00014e000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc00014e000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpezgf9x8y_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpezgf9x8y_test.go:63 +0x1a5\n\
    testing.tRunner(0xc00011b1e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074501
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if min > v {\n                min = v\n                index = index\n  \
    \          }\n        } else {\n            if min > v {\n                min\
    \ = v\n                index = index\n            }\n        }\n    }\n    return\
    \ []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpz0m92eee_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpz0m92eee_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmpz0m92eee_test.go:75: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpz0m92eee_test.go:75: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmpz0m92eee_test.go:75: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpz0m92eee_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmpz0m92eee_test.go:75: expected '[]',\
    \ got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074499
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := []int{}\n    min := arr[0]\n    index := 0\n    for _, v :=\
    \ range arr {\n        if v%2 == 0 {\n            if min > v {\n             \
    \   min = v\n                index = index\n            }\n        } else {\n\
    \            if min > v {\n                min = v\n                index = index\n\
    \            }\n        }\n    }\n    result = append(result, min)\n    result\
    \ = append(result, index)\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000160000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpaq1gvvfh_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpaq1gvvfh_test.go:64 +0x185\n\
    testing.tRunner(0xc000103520, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074501
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var index int\n    var smallestEven int\n    var\
    \ smallestEven int\n    var smallestIndex int\n    for _, val := range arr {\n\
    \        if val%2 == 0 {\n            smallestEven = val\n            smallestIndex\
    \ = index\n        } else {\n            if smallestEven == val {\n          \
    \      smallestEven = val\n                smallestIndex = index\n           \
    \ }\n        }\n        index++\n    }\n    if smallestEven == 0 {\n        return\
    \ []\n    }\n    result = append(result, smallestEven)\n    result = append(result,\
    \ smallestIndex)\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgh1c2ff6_test.go:52:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074500
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := []int{}\n    index := 0\n    smallest := arr[0]\n    for _,\
    \ value := range arr {\n        if value%2 == 0 {\n            if smallest > value\
    \ {\n                smallest = value\n                index = index\n       \
    \     }\n        } else {\n            if smallest == value {\n              \
    \  index = index\n            }\n        }\n    }\n    result = append(result,\
    \ smallest, index)\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n \
    \ candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000160000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpqtvvzz3y_test.go:36\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpqtvvzz3y_test.go:62 +0x131\n\
    testing.tRunner(0xc000103380, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074501
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minVal int\n    var minIndex int\n    for _,\
    \ val := range arr {\n        if val%2 == 0 {\n            if minVal == 0 || val\
    \ < minVal {\n                minVal = val\n                minIndex = arr\n \
    \           }\n        } else {\n            if minVal == 0 || val < minVal {\n\
    \                minVal = val\n                minIndex = arr\n            }\n\
    \        }\n    }\n    if minVal == 0 {\n        return result\n    }\n    return\
    \ result[minIndex]\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyfb7158c_test.go:41:28: cannot use arr (variable of type []int) as type
    int in assignment

    /tmp/tmpyfb7158c_test.go:46:28: cannot use arr (variable of type []int) as type
    int in assignment

    /tmp/tmpyfb7158c_test.go:53:12: cannot use result[minIndex] (variable of type
    int) as type []int in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074501
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    sort.Ints(arr)\n\
    \    smalest_value := arr[0]\n    smalest_index := 0\n    for _, value := range\
    \ arr {\n        if value%2 == 0 {\n            if value < smalest_value {\n \
    \               smalest_value = value\n                smalest_index = sort.Search(len(arr),\
    \ func(i int) bool {\n                    return arr[i] < value\n            \
    \    })\n            }\n        }\n    }\n    return []int{smalest_value, smalest_index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbjjvzv6s_test.go:37:5: undefined: sort

    /tmp/tmpbjjvzv6s_test.go:44:33: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074501
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // Write your code here.\n    sort.Ints(arr)\n    index := 0\n    smalest_value\
    \ := arr[0]\n    for _, value := range arr {\n        if value%2 == 0 {\n    \
    \        if value < smalest_value {\n                smalest_value = value\n \
    \               index = index + 1\n            }\n        }\n    }\n    return\
    \ []int{smalest_value, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoavos6rc_test.go:35:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074501
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0tcnjg1m_test.go:49:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    evens := make([]int, len(arr))\n    evens = append(evens,\
    \ arr...)\n    evens = append(evens, arr...)\n    evens = append(evens, arr...)\n\
    \    evens = append(evens, arr...)\n    evens = append(evens, arr...)\n    evens\
    \ = append(evens, arr...)\n    evens = append(evens, arr...)\n    evens = append(evens,\
    \ arr...)\n    evens = append(evens, arr...)\n    evens = append(evens, arr...)\n\
    \    evens = append(evens, arr...)\n    evens = append(evens, arr...)\n    evens\
    \ = append(evens, arr...)\n    evens = append(evens, arr...)\n    evens = append(evens,\
    \ arr...)\n    evens = append(evens, arr...)\n    evens = append(evens, arr...)\n\
    \    evens = append(evens, arr...)\n    evens = append(evens, arr...)\n    evens\
    \ = append(evens, arr...)\n    evens = append(evens, arr...)\n    evens = append(evens,\
    \ arr...)\n    evens = append(evens, arr...)\n    evens = append(evens, arr...)\n\
    \    evens = append(evens, arr...)\n    evens = append(evens, arr...)\n    evens\
    \ = append(evens, arr...)\n    evens = append(evens, arr...)\n    evens = append(evens,\
    \ arr...)\n    evens = append(evens, arr...)\n    evens = append(evens, arr...)\n\
    \    evens = append(evens, arr...)\n    evens = append(evens, arr...)\n    evens\
    \ = append(evens, arr...)\n    evens = append(evens, arr...)\n    evens = append(evens,\
    \ arr...)\n    evens = append(evens, arr...)\n    evens = append(evens, arr...)\n\
    \    evens = append(evens, arr...)\n    evens = append(evens, arr...)\n    evens\
    \ = append(evens, arr...)\n    evens = append(evens, arr...)\n    evens = append(evens,\
    \ arr...)\n    evens = append(evens, arr...)\n    evens = append(evens, arr...)\n\
    \    evens = append(evens, arr...)\n    evens = append(evens, arr...)\n    evens\
    \ = append(evens, arr...)\n    evens = append(evens, arr...)\n    evens = append(evens,\
    \ arr...)\n    evens = append(evens, arr...)\n    evens = append(evens, arr...)\n\
    \    evens = append(evens, arr...)\n    evens = append(evens, arr...)\n    evens\
    \ = append(evens, arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi3r830g9_test.go:90:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074500
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n                index\
    \ = index\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmp55ku_b4f_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmp55ku_b4f_test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001a0340, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074502
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    smalest_value := arr[0]\n    smalest_index := 0\n    even_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            even_index++\n\
    \            if even_index == smalest_index {\n                smalest_value =\
    \ value\n                smalest_index = even_index\n            }\n        }\
    \ else {\n            even_index = 0\n        }\n    }\n    if even_index == 0\
    \ {\n        return []int{}\n    }\n    return []int{smalest_value, smalest_index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x5124a0, 0xc000160000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x5124a0,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmp841gq1u6_test.go:34\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmp841gq1u6_test.go:63 +0x110\n\
    testing.tRunner(0xc000103380, 0x527d98)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660074502
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if min > v {\n                min = v\n                index = index\n  \
    \          }\n        } else {\n            if min > v {\n                min\
    \ = v\n                index = index\n            }\n        }\n    }\n    return\
    \ []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpz0m92eee_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpz0m92eee_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmpz0m92eee_test.go:75: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpz0m92eee_test.go:75: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmpz0m92eee_test.go:75: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpz0m92eee_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmpz0m92eee_test.go:75: expected '[]',\
    \ got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074499
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_diyk3dq_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    evens := make([]int, 0, len(arr))\n    index := 0\n\
    \    for _, v := range arr {\n        if v%2 == 0 {\n            evens = append(evens,\
    \ v)\n            index++\n        }\n    }\n    if len(evens) == 0 {\n      \
    \  return []int{}\n    }\n    sort.Ints(evens)\n    smallest := evens[0]\n   \
    \ smallest += index\n    if smallest > len(evens) {\n        return []int{}\n\
    \    }\n    return evens[smallest:]\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppbpgp6af_test.go:34:5: undefined: sort

    /tmp/tmppbpgp6af_test.go:46:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074502
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    smallest := arr[0]\n\
    \    smallest := 0\n    index := 0\n    for _, v := range arr {\n        if v%2\
    \ == 0 {\n            if smallest == 0 {\n                smallest = v\n     \
    \           index = index\n            } else {\n                if v < smallest\
    \ {\n                    smallest = v\n                    index = index\n   \
    \             }\n            }\n        }\n    }\n    return []int{smallest, index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv8s49lfg_test.go:38:14: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074502
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    smalest_value := arr[0]\n    smalest_index := 0\n    for _, v := range\
    \ arr {\n        if v%2 == 0 {\n            if v < smalest_value {\n         \
    \       smalest_value = v\n                smalest_index = v\n            }\n\
    \        }\n    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5124a0, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x5124a0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmptax5s4w7_test.go:34\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmptax5s4w7_test.go:56 +0x11b\n\
    testing.tRunner(0xc0001a0340, 0x527d98)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074503
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, 0)\n    arr3 := make([]int, 0)\n    arr4 := make([]int,\
    \ 0)\n    arr5 := make([]int, 0)\n    arr6 := make([]int, 0)\n    arr7 := make([]int,\
    \ 0)\n    arr8 := make([]int, 0)\n    arr9 := make([]int, 0)\n    arr10 := make([]int,\
    \ 0)\n    arr11 := make([]int, 0)\n    arr12 := make([]int, 0)\n    arr13 := make([]int,\
    \ 0)\n    arr14 := make([]int, 0)\n    arr15 := make([]int, 0)\n    arr16 := make([]int,\
    \ 0)\n    arr17 := make([]int, 0)\n    arr18 := make([]int, 0)\n    arr19 := make([]int,\
    \ 0)\n    arr20 := make([]int, 0)\n    arr21 := make([]int, 0)\n    arr22 := make([]int,\
    \ 0)\n    arr23 := make([]int, 0)\n    arr24 := make([]int, 0)\n    arr25 := make([]int,\
    \ 0)\n    arr26 := make([]int, 0)\n    arr27 := make([]int, 0)\n    arr28 := make([]int,\
    \ 0)\n    arr29 := make([]int, 0)\n    arr30 := make([]int, 0)\n    arr31 := make([]int,\
    \ 0)\n    arr32 := make([]int, 0)\n    arr33 := make([]int, 0)\n    arr34 := make([]int,\
    \ 0)\n    arr35 := make([]int, 0)\n    arr36 := make([]int, 0)\n    arr37 := make([]int,\
    \ 0)\n    arr38 := make([]int, 0)\n    arr39 := make([]int, 0)\n    arr40 := make([]int,\
    \ 0)\n    arr41 := make([]int, 0)\n    arr42 := make([]int, 0)\n    arr43 := make([]int,\
    \ 0)\n    arr44 := make([]int, 0)\n    arr45 := make([]int, 0)\n    arr46 := make([]int,\
    \ 0)\n    arr47 := make([]int, 0)\n    arr48 := make([]int, 0)\n    arr49 := make([]int,\
    \ 0)\n    arr50 := make([]int, 0)\n    arr51 := make([]int, 0)\n    \nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzmw9xwos_test.go:85:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var index int\n    var smalest_value int\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            smalest_value = v\n\
    \            index = -1\n            break\n        }\n        if v < smalest_value\
    \ {\n            smalest_value = v\n            index = -1\n        }\n    }\n\
    \    if index == -1 {\n        return []int{}\n    }\n    return []int{smalest_value,\
    \ index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpki31soni_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074503
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if min > v {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if min > v {\n                min = v\n                index\
    \ = index\n            }\n        }\n    }\n    result = append(result, min)\n\
    \    result = append(result, index)\n    return result\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmp55ku_b4f_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmp55ku_b4f_test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001a0340, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074502
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if v < min {\n                min = v\n                index = index\n  \
    \          }\n        } else {\n            if v == min {\n                index++\n\
    \            }\n        }\n    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpb6s43g2z_test.go:74: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpb6s43g2z_test.go:74:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestPluck/test_num__4 (0.00s)\n        tmpb6s43g2z_test.go:74: expected '[%!s(int=0)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=1)]'\n    --- FAIL: TestPluck/test_num__7\
    \ (0.00s)\n        tmpb6s43g2z_test.go:74: expected '[]', got '[%!s(int=7) %!s(int=2)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074503
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr := make([]int, len(arr))\n    arr[0] = arr[len(arr)-1]\n    arr[len(arr)-1]\
    \ = 0\n    for i := 1; i < len(arr); i++ {\n        if arr[i] % 2 == 0 {\n   \
    \         arr[i] = arr[i-1] + 1\n        }\n    }\n    return arr\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0t3t8rsa_test.go:34:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074503
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n`\n)\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv8lulbo2_test.go:49:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for i := 1; i < len(arr); i++ {\n        if arr[i] < smalest_value {\n  \
    \          smalest_value = arr[i]\n            smalest_index = i\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmx4ajd1k_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074503
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var min\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7xdvl18t_test.go:136:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074500
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value % 2 == 0 {\n            if\
    \ value < smalest_value {\n                smalest_value = value\n           \
    \     smalest_index = sort.Search(len(arr), func(i int) bool {\n             \
    \       return arr[i] < value\n                })\n            }\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6se29vol_test.go:34:5: undefined: sort

    /tmp/tmp6se29vol_test.go:41:33: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074503
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for i := 1; i < len(arr); i++ {\n        if arr[i] > smalest_value {\n  \
    \          smalest_value = arr[i]\n            smalest_index = i\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaf2522x6_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074500
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    evens := make([]int,\
    \ len(arr))\n    index := 0\n    for _, v := range arr {\n        if v%2 == 0\
    \ {\n            evens[index] = v\n            index++\n        }\n    }\n   \
    \ if len(evens) == 0 {\n        return []int{}\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(evens)))\n\
    \    return evens\n}\n`\n    )\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi7x0m1y6_test.go:49:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074502
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, val := range arr {\n        if val%2 == 0 {\n    \
    \        if val < min {\n                min = val\n                index = index\n\
    \            }\n        } else {\n            if val == min {\n              \
    \  index = index + 1\n            }\n        }\n    }\n    return []int{min, index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpzjeals1t_test.go:74: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpzjeals1t_test.go:74:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestPluck/test_num__4 (0.00s)\n        tmpzjeals1t_test.go:74: expected '[%!s(int=0)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=1)]'\n    --- FAIL: TestPluck/test_num__7\
    \ (0.00s)\n        tmpzjeals1t_test.go:74: expected '[]', got '[%!s(int=7) %!s(int=2)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074500
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for i := 1; i < len(arr); i++ {\n        if arr[i] < smalest_value {\n  \
    \          smalest_value = arr[i]\n            smalest_index = i\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmx4ajd1k_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074503
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    var result []int\n \
    \   var index int\n    for _, v := range arr {\n        if v%2 == 0 {\n      \
    \      result = append(result, v)\n            index = len(result)\n        }\n\
    \    }\n    if index == 0 {\n        return nil\n    }\n    return append(result,\
    \ arr[index])\n}\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp8fcxftf_test.go:35:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074503
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    i := 0\n    j := len(arr)\
    \ - 1\n    k := 0\n    smalest_value := arr[0]\n    smalest_index := 0\n    for\
    \ i < j {\n        if arr[i] % 2 == 0 {\n            smalest_value = arr[i]\n\
    \            smalest_index = i\n        }\n        i++\n    }\n    for i < j {\n\
    \        if arr[j] % 2 == 0 {\n            smalest_value = arr[j]\n          \
    \  smalest_index = j\n        }\n        j--\n    }\n    if smalest_index == 0\
    \ {\n        return []int{}\n    }\n    return []int{smalest_value, smalest_index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr1c27b7t_test.go:35:5: undefined: sort

    /tmp/tmpr1c27b7t_test.go:38:5: k declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074503
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for i := 1; i < len(arr); i++ {\n        if arr[i] < smalest_value {\n  \
    \          smalest_value = arr[i]\n            smalest_index = i\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n`\n)\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmposrxk7rz_test.go:45:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074502
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if min > v {\n                min = v\n                index = index\n  \
    \          }\n        } else {\n            if min > v {\n                min\
    \ = v\n                index = index\n            }\n        }\n    }\n    return\
    \ []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpz0m92eee_test.go:75: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpz0m92eee_test.go:75:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmpz0m92eee_test.go:75: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpz0m92eee_test.go:75: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmpz0m92eee_test.go:75: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpz0m92eee_test.go:75:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmpz0m92eee_test.go:75: expected '[]',\
    \ got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074499
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    evens := make([]int,\
    \ 0, len(arr))\n    index := 0\n    for _, v := range arr {\n        if v%2 ==\
    \ 0 {\n            evens = append(evens, v)\n            index++\n        }\n\
    \    }\n    if len(evens) == 0 {\n        return []int{}\n    }\n    return evens[:index]\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi8z005dm_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074503
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var result []int\n    var smallestEven int\n    var\
    \ smallestIndex int\n    for _, v := range arr {\n        if v%2 == 0 {\n    \
    \        if smallestEven == 0 {\n                smallestEven = v\n          \
    \      smallestIndex = v\n            } else {\n                if smallestEven\
    \ == v {\n                    smallestEven = v\n                    smallestIndex\
    \ = v\n                } else {\n                    if smallestIndex < v {\n\
    \                        smallestEven = v\n                        smallestIndex\
    \ = v\n                    }\n                }\n            }\n        }\n  \
    \  }\n    if smallestEven == 0 {\n        return nil\n    }\n    result = append(result,\
    \ smallestEven)\n    result = append(result, smallestIndex)\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp16xr85zz_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074503
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // Write your code here.\n    \n    return arr\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmp13f6539k_test.go:59: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n     \
    \   tmp13f6539k_test.go:59: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1)\
    \ %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n     \
    \   tmp13f6539k_test.go:59: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=5)\
    \ %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmp13f6539k_test.go:59: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0) %!s(int=5) %!s(int=3)]'\n\
    \    --- FAIL: TestPluck/test_num__5 (0.00s)\n        tmp13f6539k_test.go:59:\
    \ expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=5) %!s(int=4) %!s(int=8) %!s(int=4)\
    \ %!s(int=8)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp13f6539k_test.go:59:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=7) %!s(int=6) %!s(int=7) %!s(int=1)]'\n\
    \    --- FAIL: TestPluck/test_num__7 (0.00s)\n        tmp13f6539k_test.go:59:\
    \ expected '[]', got '[%!s(int=7) %!s(int=9) %!s(int=7) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074504
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = m[v]\
    \ + 1\n    }\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index\
    \ := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n            if smalest_value\
    \ < v {\n                smalest_value = v\n                smalest_index = m[v]\n\
    \            }\n        }\n    }\n    return []int{smalest_value, smalest_index}\n\
    }\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpezxgnh89_test.go:51:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074503
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var result []int\n    var smallestEven int\n    var\
    \ smallestIndex int\n    for _, v := range arr {\n        if v%2 == 0 {\n    \
    \        if smallestEven == 0 {\n                smallestEven = v\n          \
    \      smallestIndex = v\n            } else {\n                if smallestEven\
    \ == v {\n                    smallestIndex = smallestIndex\n                }\
    \ else {\n                    smallestEven = v\n                    smallestIndex\
    \ = v\n                }\n            }\n        }\n    }\n    if smallestEven\
    \ == 0 {\n        result = append(result, smallestIndex)\n    } else {\n     \
    \   result = append(result, smallestEven)\n    }\n    return result\n}\n`\n)\n\
    \nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4oocgfxb_test.go:60:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074503
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    min := arr[0]\n    i := 0\n    for\
    \ _, val := range arr {\n        if val < min {\n            min = val\n     \
    \       i = 0\n        }\n        if val == min {\n            arr2[i] = val\n\
    \            i++\n        }\n    }\n    return arr2\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014390})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014390})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpr064g9jp_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpr064g9jp_test.go:59 +0x145\n\
    testing.tRunner(0xc0001a0340, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074505
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0tcnjg1m_test.go:49:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var minVal int\n    var minIndex int\n    for _,\
    \ v := range arr {\n        if v%2 == 0 {\n            if minVal == 0 || v < minVal\
    \ {\n                minVal = v\n                minIndex = -1\n            }\n\
    \        } else {\n            if minVal == 0 || v > minVal {\n              \
    \  minVal = v\n                minIndex = -1\n            }\n        }\n    }\n\
    \    if minVal == 0 {\n        return []int{}\n    }\n    return []int{minVal,\
    \ minIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph_2oncu5_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074498
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for i := 1; i < len(arr); i++ {\n        if arr[i] < smalest_value {\n  \
    \          smalest_value = arr[i]\n            smalest_index = i\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmx4ajd1k_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074503
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    smalest_value\
    \ := arr[0]\n    smalest_index := 0\n    for _, value := range arr {\n       \
    \ if value%2 == 0 {\n            if value < smalest_value {\n                smalest_value\
    \ = value\n                smalest_index = index\n            }\n        }\n \
    \   }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo__me5pe_test.go:43:33: undefined: index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074504
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    var result []int\n \
    \   var index int\n    for i := 0; i < len(arr); i++ {\n        if arr[i] % 2\
    \ == 0 {\n            result = append(result, arr[i])\n            index = i\n\
    \        }\n    }\n    if index == 0 {\n        return nil\n    }\n    return\
    \ append([]int{result[0], index}, result...)\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2yv3f6z6_test.go:35:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074504
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, value := range arr {\n        if value%2 == 0 {\n            if value < min\
    \ {\n                min = value\n                index = index\n            }\n\
    \        } else {\n            if min > value {\n                min = value\n\
    \                index = index\n            }\n        }\n    }\n    result =\
    \ append(result, min)\n    result = append(result, index)\n    return result\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpexeab9is_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpexeab9is_test.go:64 +0x1b0\n\
    testing.tRunner(0xc0001a0340, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074505
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_diyk3dq_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    var minVal int\n    var minIndex int\n    var min\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7xdvl18t_test.go:136:9: missing variable type or initialization

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074500
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_diyk3dq_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_diyk3dq_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    var minVal int\n   \
    \ var minIndex int\n    for _, v := range arr {\n        if v%2 == 0 {\n     \
    \       if minVal == 0 || v < minVal {\n                minVal = v\n         \
    \       minIndex = v\n            }\n        }\n    }\n    return []int{minVal,\
    \ minIndex}\n}\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp995b50hg_test.go:48:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074503
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, len(arr))\n    min :=\
    \ 0\n    max := 0\n    for i := 0; i < len(arr); i++ {\n        if arr[i] > max\
    \ {\n            max = arr[i]\n        }\n        if arr[i] < min {\n        \
    \    min = arr[i]\n        }\n    }\n    for i := 0; i < len(arr); i++ {\n   \
    \     if arr[i] > max {\n            max = arr[i]\n        }\n        if arr[i]\
    \ < min {\n            min = arr[i]\n        }\n        if arr[i] % 2 == 0 {\n\
    \            arr2[i] = arr[i]\n        }\n    }\n    arr2 := arr2[:len(arr2)]\n\
    \    arr2 := append(arr2, min)\n    arr2 := append(arr2, max)\n    return arr2\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8952k8p1_test.go:57:10: no new variables on left side of :=

    /tmp/tmp8952k8p1_test.go:58:10: no new variables on left side of :=

    /tmp/tmp8952k8p1_test.go:59:10: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074504
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minVal int\n    var minIndex int\n    var i\
    \ int\n    for i = 0; i < len(arr); i++ {\n        if arr[i] > minVal {\n    \
    \        minVal = arr[i]\n            minIndex = i\n        }\n    }\n    result\
    \ = append(result, minVal)\n    result = append(result, minIndex)\n    return\
    \ result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmppnxawrp2_test.go:69: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmppnxawrp2_test.go:69:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=3) %!s(int=2)]'\n    --- FAIL:\
    \ TestPluck/test_num__2 (0.00s)\n        tmppnxawrp2_test.go:69: expected '[]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmppnxawrp2_test.go:69: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmppnxawrp2_test.go:69:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[%!s(int=5) %!s(int=4)]'\n    --- FAIL:\
    \ TestPluck/test_num__5 (0.00s)\n        tmppnxawrp2_test.go:69: expected '[%!s(int=4)\
    \ %!s(int=1)]', got '[%!s(int=8) %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__6\
    \ (0.00s)\n        tmppnxawrp2_test.go:69: expected '[%!s(int=6) %!s(int=1)]',\
    \ got '[%!s(int=7) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__7 (0.00s)\n\
    \        tmppnxawrp2_test.go:69: expected '[]', got '[%!s(int=9) %!s(int=1)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074505
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, val := range arr {\n        if val%2 == 0 {\n            if val < min {\n\
    \                min = val\n                index = index\n            }\n   \
    \     } else {\n            if val == min {\n                index = index\n \
    \           }\n        }\n    }\n    result = append(result, min)\n    result\
    \ = append(result, index)\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc00014e000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc00014e000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpezgf9x8y_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpezgf9x8y_test.go:63 +0x1a5\n\
    testing.tRunner(0xc00011b1e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074501
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, 0)\n    arr3 := make([]int, 0)\n    arr4 := make([]int,\
    \ 0)\n    arr5 := make([]int, 0)\n    arr6 := make([]int, 0)\n    arr7 := make([]int,\
    \ 0)\n    arr8 := make([]int, 0)\n    arr9 := make([]int, 0)\n    arr10 := make([]int,\
    \ 0)\n    arr11 := make([]int, 0)\n    arr12 := make([]int, 0)\n    arr13 := make([]int,\
    \ 0)\n    arr14 := make([]int, 0)\n    arr15 := make([]int, 0)\n    arr16 := make([]int,\
    \ 0)\n    arr17 := make([]int, 0)\n    arr18 := make([]int, 0)\n    arr19 := make([]int,\
    \ 0)\n    arr20 := make([]int, 0)\n    arr21 := make([]int, 0)\n    arr22 := make([]int,\
    \ 0)\n    arr23 := make([]int, 0)\n    arr24 := make([]int, 0)\n    arr25 := make([]int,\
    \ 0)\n    arr26 := make([]int, 0)\n    arr27 := make([]int, 0)\n    arr28 := make([]int,\
    \ 0)\n    arr29 := make([]int, 0)\n    arr30 := make([]int, 0)\n    arr31 := make([]int,\
    \ 0)\n    arr32 := make([]int, 0)\n    arr33 := make([]int, 0)\n    arr34 := make([]int,\
    \ 0)\n    arr35 := make([]int, 0)\n    arr36 := make([]int, 0)\n    arr37 := make([]int,\
    \ 0)\n    arr38 := make([]int, 0)\n    arr39 := make([]int, 0)\n    arr40 := make([]int,\
    \ 0)\n    arr41 := make([]int, 0)\n    arr42 := make([]int, 0)\n    arr43 := make([]int,\
    \ 0)\n    arr44 := make([]int, 0)\n    arr45 := make([]int, 0)\n    arr46 := make([]int,\
    \ 0)\n    arr47 := make([]int, 0)\n    arr48 := make([]int, 0)\n    arr49 := make([]int,\
    \ 0)\n    arr50 := make([]int, 0)\n    arr51 := make([]int, 0)\n    \nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzmw9xwos_test.go:85:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    evens := make([]int, len(arr))\n    index := 0\n\
    \    for _, v := range arr {\n        if v%2 == 0 {\n            evens[index]\
    \ = v\n            index++\n        }\n    }\n    if len(evens) == 0 {\n     \
    \   return []int{}\n    }\n    sort.Ints(evens)\n    smallest := evens[0]\n  \
    \  smallest := index\n    for _, v := range evens {\n        if v == smallest\
    \ {\n            smallest = index\n        }\n        index++\n    }\n    return\
    \ []int{smallest, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk5epy5mf_test.go:34:5: undefined: sort

    /tmp/tmpk5epy5mf_test.go:46:5: undefined: sort

    /tmp/tmpk5epy5mf_test.go:48:14: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074505
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    m := make(map[int]int)\n    for _, v := range arr {\n        m[v] = m[v]\
    \ + 1\n    }\n    arr2 := make([]int, 0, len(m))\n    for k := range m {\n   \
    \     if m[k] == 1 {\n            arr2 = append(arr2, k)\n        }\n    }\n \
    \   if len(arr2) == 0 {\n        return []int{}\n    }\n    arr3 = make([]int,\
    \ 0, len(arr2))\n    for _, v := range arr2 {\n        arr3 = append(arr3, v)\n\
    \    }\n    return arr3\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppw20zel2_test.go:47:5: undefined: arr3

    /tmp/tmppw20zel2_test.go:49:23: undefined: arr3

    /tmp/tmppw20zel2_test.go:51:12: undefined: arr3

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074505
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := \nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp90di3l4s_test.go:121:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    evens := make([]int, len(arr))\n    index := 0\n\
    \    for i := 0; i < len(arr); i++ {\n        if arr[i] % 2 == 0 {\n         \
    \   evens[index] = arr[i]\n            index++\n        }\n    }\n    if len(evens)\
    \ == 0 {\n        return []\n    }\n    sort.Ints(evens)\n    smallest := evens[0]\n\
    \    smallest += 2\n    smallestIndex := 0\n    for i := 0; i < len(evens); i++\
    \ {\n        if evens[i] < smallest {\n            smallest = evens[i]\n     \
    \       smallestIndex = i\n        }\n    }\n    return []int{smallest, smallestIndex}\n\
    }\n`\n)\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr5wrv9mz_test.go:44:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074504
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    for _, v := range arr {\n        if v%2 == 0 {\n            if minVal\
    \ < v {\n                minVal = v\n                minIndex = v\n          \
    \  }\n        } else {\n            if minVal < v {\n                minVal =\
    \ v\n                minIndex = v\n            }\n        }\n    }\n    return\
    \ []int{minVal, minIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpva5c8t2g_test.go:36:9:\
    \ minVal redeclared in this block\n\t/tmp/tmpva5c8t2g_test.go:34:9: other declaration\
    \ of minVal\n/tmp/tmpva5c8t2g_test.go:37:9: minIndex redeclared in this block\n\
    \t/tmp/tmpva5c8t2g_test.go:35:9: other declaration of minIndex\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074505
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for i := 1; i < len(arr); i++ {\n        if arr[i] < smalest_value {\n  \
    \          smalest_value = arr[i]\n            smalest_index = i\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmx4ajd1k_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074503
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, 0)\n    arr3 := make([]int, 0)\n    arr4 := make([]int,\
    \ 0)\n    arr5 := make([]int, 0)\n    arr6 := make([]int, 0)\n    arr7 := make([]int,\
    \ 0)\n    arr8 := make([]int, 0)\n    arr9 := make([]int, 0)\n    arr10 := make([]int,\
    \ 0)\n    arr11 := make([]int, 0)\n    arr12 := make([]int, 0)\n    arr13 := make([]int,\
    \ 0)\n    arr14 := make([]int, 0)\n    arr15 := make([]int, 0)\n    arr16 := make([]int,\
    \ 0)\n    arr17 := make([]int, 0)\n    arr18 := make([]int, 0)\n    arr19 := make([]int,\
    \ 0)\n    arr20 := make([]int, 0)\n    arr21 := make([]int, 0)\n    arr22 := make([]int,\
    \ 0)\n    arr23 := make([]int, 0)\n    arr24 := make([]int, 0)\n    arr25 := make([]int,\
    \ 0)\n    arr26 := make([]int, 0)\n    arr27 := make([]int, 0)\n    arr28 := make([]int,\
    \ 0)\n    arr29 := make([]int, 0)\n    arr30 := make([]int, 0)\n    arr31 := make([]int,\
    \ 0)\n    arr32 := make([]int, 0)\n    arr33 := make([]int, 0)\n    arr34 := make([]int,\
    \ 0)\n    arr35 := make([]int, 0)\n    arr36 := make([]int, 0)\n    arr37 := make([]int,\
    \ 0)\n    arr38 := make([]int, 0)\n    arr39 := make([]int, 0)\n    arr40 := make([]int,\
    \ 0)\n    arr41 := make([]int, 0)\n    arr42 := make([]int, 0)\n    arr43 := make([]int,\
    \ 0)\n    arr44 := make([]int, 0)\n    arr45 := make([]int, 0)\n    arr46 := make([]int,\
    \ 0)\n    arr47 := make([]int, 0)\n    arr48 := make([]int, 0)\n    arr49 := make([]int,\
    \ 0)\n    arr50 := make([]int, 0)\n    arr51 := make([]int, 0)\n    \nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzmw9xwos_test.go:85:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var result []int\n    var index int\n    for _, v\
    \ := range arr {\n        if v%2 == 0 {\n            result = append(result, v)\n\
    \            index = index + 1\n        }\n    }\n    if index == 0 {\n      \
    \  return nil\n    }\n    return append(result, arr[index-1])\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe1dq7i_3_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074505
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    result := []int{}\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    result = append(result, v)\n            index = index + 1\n        }\n  \
    \  }\n    if index == 0 {\n        return nil\n    }\n    return append(result,\
    \ arr[index-1])\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqbdgm8rm_test.go:35:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074505
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var result []int\n    var minIndex int\n    var minVal\
    \ int\n    for _, v := range arr {\n        if v%2 == 0 {\n            if minVal\
    \ == 0 || v < minVal {\n                minVal = v\n                minIndex =\
    \ v\n            }\n        } else {\n            if minVal == 0 || v > minVal\
    \ {\n                minVal = v\n                minIndex = v\n            }\n\
    \        }\n    }\n    result = append(result, minVal)\n    result = append(result,\
    \ minIndex)\n    return result\n}\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm19s956d_test.go:55:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074504
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n\
    \    smallest := arr[0]\n    smallest := arr[0]\n    smallest := arr[0]\n    smallest\
    \ := arr[0]\n    smallest := arr[0]\n    smallest := \nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp90di3l4s_test.go:121:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    var result []int\n \
    \   i := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n            result\
    \ = append(result, v)\n        }\n    }\n    if result == nil {\n        return\
    \ []\n    }\n    if len(result) == 1 {\n        return result\n    }\n    for\
    \ _, v := range result {\n        if v%2 == 0 {\n            return append([]int{v,\
    \ i}, result...)\n        }\n    }\n    return []int{result[0], 0}\n}\n`\n   \
    \     );\n    }\n}\n\nclass TreeTest extends TestCase{\n    public testPluck(){\n\
    \        assertEquals(\n            [],\n            pluck([])\n        );\n \
    \       assertEquals(\n            [],\n            pluck([1])\n        );\n \
    \       assertEquals(\n            [],\n            pluck([1,2])\n        );\n\
    \        assertEquals(\n            [],\n            pluck([1,2,3])\n        );\n\
    \        assertEquals(\n            [],\n            pluck([1,2,3,4,5])\n    \
    \    );\n        assertEquals(\n            [],\n            pluck([1,2,3,4,5,6])\n\
    \        );\n        assertEquals(\n            [],\n            pluck([1,2,3,4,5,6,7])\n\
    \        );\n        assertEquals(\n            [],\n            pluck([1,2,3,4,5,6,7,8])\n\
    \        );\n        assertEquals(\n            [],\n            pluck([1,2,3,4,5,6,7,8,9])\n\
    \        );\n        assertEquals(\n            [],\n            pluck([1,2,3,4,5,6,7,8,9,10])\n\
    \        );\n        assertEquals(\n            [],\n            pluck([1,2,3,4,5,6,7,8,9,10,11])\n\
    \        );\n        assertEquals(\n            [],\n            pluck([1,2,3,4,5,6,7,8,9,10,11,12])\n\
    \        );\n        assertEquals(\n            [],\n            pluck([1,2,3,4,5,6,7,8,9,10,11,12,13])\n\
    \        );\n        assertEquals(\n            [],\n            pluck([1,2,3,4,5,6,7,8,9,10,11,12,13,14])\n\
    \        );\n        assertEquals(\n            [],\n            pluck([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])\n\
    \        );\n        assertEquals(\n            [],\n            pluck([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16])\n\
    \        );\n        assertEquals(\n            [],\n            pluck([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17])\n\
    \        );\n        assertEquals(\n            [],\n            pluck([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18])\n\
    \        );\n        assertEquals(\n            [],\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppetvufjf_test.go:44:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074505
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    evens := make([]int,\
    \ len(arr))\n    index := 0\n    for _, v := range arr {\n        if v%2 == 0\
    \ {\n            evens[index] = v\n            index++\n        }\n    }\n   \
    \ if len(evens) == 0 {\n        return []int{}\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(evens)))\n\
    \    return evens\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpa2iaz833_test.go:34:5: undefined: sort

    /tmp/tmpa2iaz833_test.go:46:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if v < min {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if v == min {\n                index = index + 1\n          \
    \  }\n        }\n    }\n    result = append(result, min)\n    result = append(result,\
    \ index)\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc0001d6000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpealuanug_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpealuanug_test.go:63 +0x1e5\n\
    testing.tRunner(0xc000199380, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074506
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var result []int\n    var minIndex int\n    var minVal int\n    for _,\
    \ v := range arr {\n        if v%2 == 0 {\n            if minVal == 0 || minVal\
    \ > v {\n                minVal = v\n                minIndex = v\n          \
    \  }\n        } else {\n            if minVal == 0 || minVal > v {\n         \
    \       minVal = v\n                minIndex = v\n            }\n        }\n \
    \   }\n    if minVal == 0 {\n        return []\n    }\n    result = append(result,\
    \ minVal)\n    result = append(result, minIndex)\n    return result\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxem9o04e_test.go:51:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074505
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // Write your code here.\n    sort.Ints(arr)\n    smallest := arr[0]\n\
    \    smallest := 0\n    index := 0\n    for _, val := range arr {\n        if\
    \ val%2 == 0 {\n            if smallest == 0 {\n                smallest = val\n\
    \                index = val\n            } else {\n                if val < smallest\
    \ {\n                    smallest = val\n                    index = val\n   \
    \             }\n            }\n        }\n    }\n    return []int{smallest, index}\n\
    }\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6er9tlcw_test.go:54:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074505
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if v < min {\n                min = v\n                index = index\n  \
    \          }\n        } else {\n            if v == min {\n                index\
    \ = index + 1\n            }\n        }\n    }\n    return []int{min, index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpkces50_l_test.go:74: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpkces50_l_test.go:74:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=1)]'\n    --- FAIL:\
    \ TestPluck/test_num__4 (0.00s)\n        tmpkces50_l_test.go:74: expected '[%!s(int=0)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=1)]'\n    --- FAIL: TestPluck/test_num__7\
    \ (0.00s)\n        tmpkces50_l_test.go:74: expected '[]', got '[%!s(int=7) %!s(int=2)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074506
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbyw5pz8d_test.go:34:5: undefined: sort

    /tmp/tmpbyw5pz8d_test.go:41:33: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074500
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    evens := make([]int,\
    \ 0)\n    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n   \
    \         evens = append(evens, v)\n            index++\n        }\n    }\n  \
    \  if len(evens) == 0 {\n        return []int{}\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(evens)))\n\
    \    smallestEven := evens[0]\n    smallestIndex := index\n    for _, v := range\
    \ evens {\n        if v == smallestEven {\n            smallestEven = v\n    \
    \        smallestIndex = index\n        }\n        index++\n    }\n    return\
    \ []int{smallestEven, smallestIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt39hhp3f_test.go:34:5: undefined: sort

    /tmp/tmpt39hhp3f_test.go:46:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var result []int\n    var index int\n    var smalest_value\
    \ int\n    for _, v := range arr {\n        if v%2 == 0 {\n            smalest_value\
    \ = v\n            index = -1\n        } else {\n            if smalest_value%2\
    \ == 0 {\n                smalest_value = smalest_value / 2\n            } else\
    \ {\n                smalest_value = smalest_value * 2\n            }\n      \
    \      if smalest_value < v {\n                smalest_value = v\n           \
    \     index = -1\n            } else {\n                index = index + 1\n  \
    \          }\n        }\n    }\n    if index == -1 {\n        result = append(result,\
    \ smalest_value)\n    } else {\n        result = append(result, smalest_value,\
    \ index)\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2o86htmy_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    smalest_value := arr[0]\n\
    \    smalest_index := 0\n    for _, value := range arr {\n        if value%2 ==\
    \ 0 {\n            if value < smalest_value {\n                smalest_value =\
    \ value\n                smalest_index = sort.SearchIntSlice(arr[:], value)\n\
    \            }\n        }\n    }\n    return []int{smalest_value, smalest_index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuidsj5s7_test.go:34:5: undefined: sort

    /tmp/tmpuidsj5s7_test.go:41:33: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    return arr\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpgic4ddud_test.go:60: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n     \
    \   tmpgic4ddud_test.go:60: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1)\
    \ %!s(int=2) %!s(int=3)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n     \
    \   tmpgic4ddud_test.go:60: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=5)\
    \ %!s(int=0) %!s(int=3) %!s(int=0) %!s(int=4) %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpgic4ddud_test.go:60: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=1) %!s(int=2) %!s(int=3) %!s(int=0) %!s(int=5) %!s(int=3)]'\n\
    \    --- FAIL: TestPluck/test_num__5 (0.00s)\n        tmpgic4ddud_test.go:60:\
    \ expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=5) %!s(int=4) %!s(int=8) %!s(int=4)\
    \ %!s(int=8)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpgic4ddud_test.go:60:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=7) %!s(int=6) %!s(int=7) %!s(int=1)]'\n\
    \    --- FAIL: TestPluck/test_num__7 (0.00s)\n        tmpgic4ddud_test.go:60:\
    \ expected '[]', got '[%!s(int=7) %!s(int=9) %!s(int=7) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, v := range arr {\n        if v%2 == 0 {\n            if v < smalest_value\
    \ {\n                smalest_value = v\n                smalest_index = sort.SearchInts(arr,\
    \ v)\n            }\n        }\n    }\n    return []int{smalest_value, smalest_index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplm7thxfm_test.go:34:5: undefined: sort

    /tmp/tmplm7thxfm_test.go:41:33: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var result []int\n    var smallestEven int\n    var\
    \ smallestIndex int\n    for _, v := range arr {\n        if v%2 == 0 {\n    \
    \        smallestEven = v\n            smallestIndex = v\n        } else {\n \
    \           if smallestEven == v {\n                smallestEven = v\n       \
    \         smallestIndex = v\n            } else {\n                if smallestIndex\
    \ < v {\n                    smallestEven = v\n                    smallestIndex\
    \ = v\n                }\n            }\n        }\n    }\n    if smallestEven\
    \ != 0 {\n        result = append(result, smallestEven)\n        result = append(result,\
    \ smallestIndex)\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppx9q7mq4_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    evens := make([]int, 0, len(arr))\n    for _, v :=\
    \ range arr {\n        if v%2 == 0 {\n            evens = append(evens, v)\n \
    \       }\n    }\n    if len(evens) == 0 {\n        return []int{}\n    }\n  \
    \  sort.Ints(evens)\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := even\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3k1mv579_test.go:120:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := []int{}\n    min := arr[0]\n    index := 0\n    for _, val\
    \ := range arr {\n        if val%2 == 0 {\n            if val < min {\n      \
    \          min = val\n                index = index\n            }\n        }\
    \ else {\n            if val == min {\n                index = index\n       \
    \     }\n        }\n    }\n    result = append(result, min)\n    result = append(result,\
    \ index)\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpk2jpru_s_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpk2jpru_s_test.go:63 +0x172\n\
    testing.tRunner(0xc0001a0340, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value%2 == 0 {\n            if value\
    \ < smalest_value {\n                smalest_value = value\n                smalest_index\
    \ = sort.Search(len(arr), func(i int) bool {\n                    return arr[i]\
    \ < value\n                })\n            }\n        }\n    }\n    return []int{smalest_value,\
    \ smalest_index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbyw5pz8d_test.go:34:5: undefined: sort

    /tmp/tmpbyw5pz8d_test.go:41:33: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074500
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_diyk3dq_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    index := 0\n    smalest\
    \ := arr[0]\n    for _, v := range arr {\n        if v%2 == 0 {\n            if\
    \ smalest == v {\n                index = index + 1\n            } else {\n  \
    \              smalest = v\n                index = index\n            }\n   \
    \     }\n    }\n    return []int{smalest, index}\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0b01quih_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    sort.Ints(arr)\n\
    \    evens := make([]int, 0, len(arr))\n    index := 0\n    for _, v := range\
    \ arr {\n        if v%2 == 0 {\n            evens = append(evens, v)\n       \
    \     index++\n        }\n    }\n    if len(evens) == 0 {\n        return []int{}\n\
    \    }\n    sort.Ints(evens)\n    smallest := evens[0]\n    smallest += index\n\
    \    smallestIndex := 0\n    for _, v := range evens {\n        if v == smallest\
    \ {\n            smallestIndex++\n        }\n    }\n    return []int{smallest,\
    \ smallestIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe6tkiz4m_test.go:37:5: undefined: sort

    /tmp/tmpe6tkiz4m_test.go:49:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, v := range arr {\n        if v%2 == 0 {\n            if v < smalest_value\
    \ {\n                smalest_value = v\n                smalest_index = sort.SearchInts(arr,\
    \ v)\n            }\n        }\n    }\n    return []int{smalest_value, smalest_index}\n\
    }\n`\n)\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplmjr8njm_test.go:47:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for i := 1; i < len(arr); i++ {\n        if arr[i] < smalest_value {\n  \
    \          smalest_value = arr[i]\n            smalest_index = i\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmx4ajd1k_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074503
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for i := 1; i < len(arr); i++ {\n        if arr[i] > smalest_value {\n  \
    \          smalest_value = arr[i]\n            smalest_index = i\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaf2522x6_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074500
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, val := range arr {\n        if val%2 == 0 {\n    \
    \        min = val\n            index = index + 1\n        }\n    }\n    return\
    \ []int{min, index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpdn5janeq_test.go:68: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n        tmpdn5janeq_test.go:68:\
    \ expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2) %!s(int=4)]'\n    --- FAIL:\
    \ TestPluck/test_num__4 (0.00s)\n        tmpdn5janeq_test.go:68: expected '[%!s(int=0)\
    \ %!s(int=3)]', got '[%!s(int=0) %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__5\
    \ (0.00s)\n        tmpdn5janeq_test.go:68: expected '[%!s(int=4) %!s(int=1)]',\
    \ got '[%!s(int=8) %!s(int=4)]'\n    --- FAIL: TestPluck/test_num__7 (0.00s)\n\
    \        tmpdn5janeq_test.go:68: expected '[]', got '[%!s(int=7) %!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var result []int\n    var index int\n    for _, v\
    \ := range arr {\n        if v%2 == 0 {\n            result = append(result, v)\n\
    \            index = len(result)\n        }\n    }\n    if index == 0 {\n    \
    \    return []\n    }\n    return append(result, arr[index])\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjdqng41f_test.go:44:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minVal int\n    var minIndex int\n    var minVal int\n    var minIndex\
    \ int\n    for _, v := range arr {\n        if v%2 == 0 {\n            if minVal\
    \ == 0 || v < minVal {\n                minVal = v\n                minIndex =\
    \ v\n            }\n        } else {\n            if minVal == 0 || v > minVal\
    \ {\n                minVal = v\n                minIndex = v\n            }\n\
    \        }\n    }\n    return []int{minVal, minIndex}\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp7m5bv3z7_test.go:36:9:\
    \ minVal redeclared in this block\n\t/tmp/tmp7m5bv3z7_test.go:34:9: other declaration\
    \ of minVal\n/tmp/tmp7m5bv3z7_test.go:37:9: minIndex redeclared in this block\n\
    \t/tmp/tmp7m5bv3z7_test.go:35:9: other declaration of minIndex\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, val := range arr {\n        if val%2 == 0 {\n            if val < min {\n\
    \                min = val\n                index = index\n            }\n   \
    \     } else {\n            if val == min {\n                index = index\n \
    \           }\n        }\n    }\n    result = append(result, min)\n    result\
    \ = append(result, index)\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc00014e000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc00014e000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpezgf9x8y_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpezgf9x8y_test.go:63 +0x1a5\n\
    testing.tRunner(0xc00011b1e0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074501
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, v := range arr {\n        if v%2 == 0 {\n        \
    \    if min > v {\n                min = v\n                index = index\n  \
    \          }\n        } else {\n            if min > v {\n                min\
    \ = v\n                index = index\n            }\n        }\n    }\n    return\
    \ []int{min, index}\n}\n`\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpves5wfm8_test.go:54:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    var minVal int\n    var minIndex int\n    for _, v := range arr {\n \
    \       if v%2 == 0 {\n            if minVal == 0 || v < minVal {\n          \
    \      minVal = v\n                minIndex = v\n            }\n        }\n  \
    \  }\n    return []int{minVal, minIndex}\n}\n\nfunc TestPluck(t *testing.T) {\n\
    \  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpjjun164c_test.go:67: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpjjun164c_test.go:67:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2) %!s(int=2)]'\n    --- FAIL:\
    \ TestPluck/test_num__2 (0.00s)\n        tmpjjun164c_test.go:67: expected '[]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__3 (0.00s)\n\
    \        tmpjjun164c_test.go:67: expected '[%!s(int=0) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestPluck/test_num__4 (0.00s)\n        tmpjjun164c_test.go:67:\
    \ expected '[%!s(int=0) %!s(int=3)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__5 (0.00s)\n        tmpjjun164c_test.go:67: expected '[%!s(int=4)\
    \ %!s(int=1)]', got '[%!s(int=4) %!s(int=4)]'\n    --- FAIL: TestPluck/test_num__6\
    \ (0.00s)\n        tmpjjun164c_test.go:67: expected '[%!s(int=6) %!s(int=1)]',\
    \ got '[%!s(int=6) %!s(int=6)]'\n    --- FAIL: TestPluck/test_num__7 (0.00s)\n\
    \        tmpjjun164c_test.go:67: expected '[]', got '[%!s(int=0) %!s(int=0)]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, v := range arr {\n        if v%2 == 0 {\n            if v < min {\n     \
    \           min = v\n                index = index\n            }\n        } else\
    \ {\n            if v == min {\n                index = index + 1\n          \
    \  }\n        }\n    }\n    result = append(result, min)\n    result = append(result,\
    \ index)\n    return result\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate\
    \ := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc0001d6000})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpealuanug_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpealuanug_test.go:63 +0x1e5\n\
    testing.tRunner(0xc000199380, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074506
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    index := 0\n    smalest\
    \ := arr[0]\n    for _, v := range arr {\n        if v%2 == 0 {\n            if\
    \ smalest == 0 || v < smalest-1 {\n                smalest = v\n             \
    \   index = index + 1\n            }\n        }\n    }\n    return []int{smalest,\
    \ index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjq9j7p1n_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // Write your code here.\n    arr2 := make([]int, len(arr))\n    arr3\
    \ := make([]int, len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int,\
    \ len(arr))\n    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n\
    \    arr8 := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10\
    \ := make([]int, len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int,\
    \ len(arr))\n    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n\
    \    arr15 := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17\
    \ := make([]int, len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int,\
    \ len(arr))\n    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n\
    \    arr22 := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24\
    \ := make([]int, len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int,\
    \ len(arr))\n    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n\
    \    arr29 := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31\
    \ := make([]int, len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int,\
    \ len(arr))\n    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n\
    \    arr36 := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38\
    \ := make([]int, len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int,\
    \ len(arr))\n    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n\
    \    arr43 := make([]int, len(\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzqzsvf_z_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074499
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for i := 1; i < len(arr); i++ {\n        if arr[i] < smalest_value {\n  \
    \          smalest_value = arr[i]\n            smalest_index = i\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n`\n    )\n}\n\nfunc\
    \ TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpql9g3bro_test.go:45:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // Write your code here.\n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfzz_u3ag_test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    arr2 := make([]int, 0)\n    arr3 := make([]int,\
    \ 0)\n    arr4 := make([]int, 0)\n    arr5 := make([]int, 0)\n    arr6 := make([]int,\
    \ 0)\n    arr7 := make([]int, 0)\n    arr8 := make([]int, 0)\n    arr9 := make([]int,\
    \ 0)\n    arr10 := make([]int, 0)\n    arr11 := make([]int, 0)\n    arr12 := make([]int,\
    \ 0)\n    arr13 := make([]int, 0)\n    arr14 := make([]int, 0)\n    arr15 := make([]int,\
    \ 0)\n    arr16 := make([]int, 0)\n    arr17 := make([]int, 0)\n    arr18 := make([]int,\
    \ 0)\n    arr19 := make([]int, 0)\n    arr20 := make([]int, 0)\n    arr21 := make([]int,\
    \ 0)\n    arr22 := make([]int, 0)\n    arr23 := make([]int, 0)\n    arr24 := make([]int,\
    \ 0)\n    arr25 := make([]int, 0)\n    arr26 := make([]int, 0)\n    arr27 := make([]int,\
    \ 0)\n    arr28 := make([]int, 0)\n    arr29 := make([]int, 0)\n    arr30 := make([]int,\
    \ 0)\n    arr31 := make([]int, 0)\n    arr32 := make([]int, 0)\n    arr33 := make([]int,\
    \ 0)\n    arr34 := make([]int, 0)\n    arr35 := make([]int, 0)\n    arr36 := make([]int,\
    \ 0)\n    arr37 := make([]int, 0)\n    arr38 := make([]int, 0)\n    arr39 := make([]int,\
    \ 0)\n    arr40 := make([]int, 0)\n    arr41 := make([]int, 0)\n    arr42 := make([]int,\
    \ 0)\n    arr43 := make([]int, 0)\n    arr44 := make([]int, 0)\n    arr45 := make([]int,\
    \ 0)\n    arr46 := make([]int, 0)\n    arr47 := make([]int, 0)\n    arr48 := make([]int,\
    \ 0)\n    arr49 := make([]int, 0)\n    arr50 := make([]int, 0)\n    arr51 := make(\n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxy3m2vb0_test.go:85:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    min := arr[0]\n\
    \    index := 0\n    for _, val := range arr {\n        if val%2 == 0 {\n    \
    \        if val < min {\n                min = val\n                index = index\n\
    \            }\n        }\n    }\n    return []int{min, index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__0 (0.00s)\n\
    \        tmpsutbid0k_test.go:70: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=2)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n        tmpsutbid0k_test.go:70:\
    \ expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__3 (0.00s)\n        tmpsutbid0k_test.go:70: expected '[%!s(int=0)\
    \ %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__4\
    \ (0.00s)\n        tmpsutbid0k_test.go:70: expected '[%!s(int=0) %!s(int=3)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__5 (0.00s)\n\
    \        tmpsutbid0k_test.go:70: expected '[%!s(int=4) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmpsutbid0k_test.go:70:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=6) %!s(int=0)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmpsutbid0k_test.go:70: expected '[]',\
    \ got '[%!s(int=7) %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    evens := make([]int,\
    \ 0, len(arr))\n    for _, v := range arr {\n        if v%2 == 0 {\n         \
    \   evens = append(evens, v)\n        }\n    }\n    if len(evens) == 0 {\n   \
    \     return []int{}\n    }\n    smallest := evens[0]\n    smallest := sort.Search(len(evens),\
    \ func(i int) bool {\n        return evens[i] < smallest\n    })\n    return []int{smallest,\
    \ sort.Search(len(evens), func(i int) bool {\n        return evens[i] == smallest\n\
    \    })}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkklnivzx_test.go:34:5: undefined: sort

    /tmp/tmpkklnivzx_test.go:45:14: no new variables on left side of :=

    /tmp/tmpkklnivzx_test.go:45:17: undefined: sort

    /tmp/tmpkklnivzx_test.go:48:28: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    index := 0\n    smalest := arr[0]\n    for _, v :=\
    \ range arr {\n        if v%2 == 0 {\n            if smalest != v {\n        \
    \        smalest = v\n                index = index + 1\n            }\n     \
    \   } else {\n            if smalest == v {\n                index = index + 1\n\
    \            }\n        }\n    }\n    if index == 0 {\n        return []int{}\n\
    \    }\n    return []int{smalest, index}\n}\n\nfunc TestPluck(t *testing.T) {\n\
    \  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4, 2,\
    \ 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n  \
    \   { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n \
    \    { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n\
    \     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n  \
    \   { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     { actual:\
    \ candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0x_djj4l_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    if len(arr) == 0 {\n        return []int{}\n    }\n    smalest_value\
    \ := arr[0]\n    smalest_index := 0\n    for i := 1; i < len(arr); i++ {\n   \
    \     if arr[i] < smalest_value {\n            smalest_value = arr[i]\n      \
    \      smalest_index = i\n        }\n    }\n    return []int{smalest_value, smalest_index}\n\
    }\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\n    --- FAIL: TestPluck/test_num__1 (0.00s)\n\
    \        tmp45ohegfg_test.go:68: expected '[%!s(int=2) %!s(int=1)]', got '[%!s(int=1)\
    \ %!s(int=0)]'\n    --- FAIL: TestPluck/test_num__6 (0.00s)\n        tmp45ohegfg_test.go:68:\
    \ expected '[%!s(int=6) %!s(int=1)]', got '[%!s(int=1) %!s(int=3)]'\n    --- FAIL:\
    \ TestPluck/test_num__7 (0.00s)\n        tmp45ohegfg_test.go:68: expected '[]',\
    \ got '[%!s(int=1) %!s(int=3)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074500
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for i := 1; i < len(arr); i++ {\n        if arr[i] < smalest_value {\n  \
    \          smalest_value = arr[i]\n            smalest_index = i\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmx4ajd1k_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074503
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for _, value := range arr {\n        if value % 2 == 0 {\n            if\
    \ value < smalest_value {\n                smalest_value = value\n           \
    \     smalest_index = sort.Search(len(arr), func(i int) bool {\n             \
    \       return arr[i] < value\n                })\n            }\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n`\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjsvnrun4_test.go:49:1: raw string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    evens := make([]int, 0, len(arr))\n    for _, v :=\
    \ range arr {\n        if v%2 == 0 {\n            evens = append(evens, v)\n \
    \       }\n    }\n    if len(evens) == 0 {\n        return []int{}\n    }\n  \
    \  sort.Ints(evens)\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := evens[0]\n    smallest := evens[0]\n    smallest := evens[0]\n    smallest\
    \ := even\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3k1mv579_test.go:120:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074506
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    smalest_value := arr[0]\n    smalest_index := 0\n\
    \    for i := 1; i < len(arr); i++ {\n        if arr[i] < smalest_value {\n  \
    \          smalest_value = arr[i]\n            smalest_index = i\n        }\n\
    \    }\n    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmx4ajd1k_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074503
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    evens := make([]int, len(arr))\n    for i, v := range\
    \ arr {\n        if v%2 == 0 {\n            evens[i] = v\n        }\n    }\n \
    \   if len(evens) == 0 {\n        return []\n    }\n    min := evens[0]\n    idx\
    \ := 0\n    for i, v := range evens {\n        if v == min {\n            idx\
    \ = i\n        }\n    }\n    return []int{min, idx}\n}\n`\n\nfunc TestPluck(t\
    \ *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjhqq3f0v_test.go:42:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    result := make([]int, 0)\n    min := arr[0]\n    index := 0\n    for\
    \ _, val := range arr {\n        if val%2 == 0 {\n            if val < min {\n\
    \                min = val\n                index = index\n            }\n   \
    \     } else {\n            if val == min {\n                index = index + 1\n\
    \            }\n        }\n    }\n    result = append(result, min)\n    result\
    \ = append(result, index)\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestPluck (0.00s)\npanic: runtime error: index out of range [0]\
    \ with length 0 [recovered]\n\tpanic: runtime error: index out of range [0] with\
    \ length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.pluck(...)\n\t/tmp/tmpqo7bvqou_test.go:35\n\
    command-line-arguments_test.TestPluck(0x0?)\n\t/tmp/tmpqo7bvqou_test.go:63 +0x1e5\n\
    testing.tRunner(0xc0001a01a0, 0x527d38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074500
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    var index int\n    var\
    \ smallest_value int\n    for _, value := range arr {\n        if value%2 == 0\
    \ {\n            if smallest_value == 0 || value < smallest_value {\n        \
    \        smallest_value = value\n                index = -1\n            } else\
    \ {\n                index = index + 1\n            }\n        }\n    }\n    if\
    \ smallest_value == 0 {\n        return []\n    }\n    return []int{smallest_value,\
    \ index}\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n   \
    \  { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbazjd9e__test.go:49:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074507
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    sort.Ints(arr)\n    var result []int\n    var index int\n    for _, v\
    \ := range arr {\n        if v%2 == 0 {\n            result = append(result, v)\n\
    \            index = len(result)-1\n        }\n    }\n    if index == -1 {\n \
    \       return []int{}\n    }\n    return result\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5x1otsex_test.go:34:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074498
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    smalest_value := arr[0]\n    smalest_index := 0\n    smalest_value_found\
    \ := false\n    for _, value := range arr {\n        if value%2 == 0 {\n     \
    \       if smalest_value_found == false {\n                smalest_value_found\
    \ = true\n                smalest_value = value\n                smalest_index\
    \ = len(arr) - 1 - i\n            } else {\n                if value < smalest_value\
    \ {\n                    smalest_value = value\n                    smalest_index\
    \ = len(arr) - 1 - i\n                }\n            }\n        }\n        i++\n\
    \    }\n    if smalest_value_found == false {\n        return []int{}\n    }\n\
    \    return []int{smalest_value, smalest_index}\n}\n\nfunc TestPluck(t *testing.T)\
    \ {\n  candidate := pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{4,\
    \ 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}),\
    \ expected: []int{2, 1} },\n     { actual: candidate([]int{}), expected: []int{}\
    \ },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1}\
    \ },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3}\
    \ },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n\
    \     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n     {\
    \ actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpurp5o4bl_test.go:42:48: undefined: i

    /tmp/tmpurp5o4bl_test.go:46:52: undefined: i

    /tmp/tmpurp5o4bl_test.go:50:9: undefined: i

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074507
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    func TestPluck(t *testing.T) {\n  candidate := pluck\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate([]int{4, 2, 3}), expected: []int{2, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n     { actual: candidate([]int{}),\
    \ expected: []int{} },\n     { actual: candidate([]int{5, 0, 3, 0, 4, 2}), expected:\
    \ []int{0, 1} },\n     { actual: candidate([]int{1, 2, 3, 0, 5, 3}), expected:\
    \ []int{0, 3} },\n     { actual: candidate([]int{5, 4, 8, 4, 8}), expected: []int{4,\
    \ 1} },\n     { actual: candidate([]int{7, 6, 7, 1}), expected: []int{6, 1} },\n\
    \     { actual: candidate([]int{7, 9, 7, 1}), expected: []int{} },\n   }\n\n\t\
    for i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp25t3hml__test.go:289:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 1
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    arr2 := make([]int, len(arr))\n    arr3 := make([]int, len(arr))\n  \
    \  arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n    arr6\
    \ := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8 := make([]int,\
    \ len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int, len(arr))\n\
    \    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n    arr13\
    \ := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15 := make([]int,\
    \ len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int, len(arr))\n\
    \    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n    arr20\
    \ := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22 := make([]int,\
    \ len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int, len(arr))\n\
    \    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n    arr27\
    \ := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29 := make([]int,\
    \ len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int, len(arr))\n\
    \    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n    arr34\
    \ := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36 := make([]int,\
    \ len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int, len(arr))\n\
    \    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n    arr41\
    \ := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43 := make([]int,\
    \ len(arr))\n    arr\nfunc TestPluck(t *testing.T) {\n  candidate := pluck\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2, 1} },\n\
    \     { actual: candidate([]int{}), expected: []int{} },\n     { actual: candidate([]int{5,\
    \ 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual: candidate([]int{1,\
    \ 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual: candidate([]int{5,\
    \ 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7, 6,\
    \ 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7, 1}),\
    \ expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqatvpvcn_test.go:77:6: expected ''('', found TestPluck

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074497
- exit_code: 2
  program: "package pluck_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ \"Given a list representing a branch of a tree that has non-negative integer\
    \ nodes\n// your task is to pluck one of the nodes and return it.\n// The plucked\
    \ node should be the node with the smallest even value.\n// If multiple nodes\
    \ with the same smallest even value are found return the node that has smallest\
    \ index.\n// The plucked node should be returned in a list, [ smalest_value, its\
    \ index ],\n// If there are no even values or the given list is empty, return\
    \ [].\n// Example 1:\n// >>> pluck([]int{4, 2, 3})\n// []int{2, 1}\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // >>> pluck([]int{1, 2, 3})\n// []int{2, 1}\n// Explanation: 2 has the smallest\
    \ even value, and 2 has the smallest index.\n// Example 3:\n// >>> pluck([]int{})\n\
    // PATCH list\n// Example 4:\n// >>> pluck([]int{5, 0, 3, 0, 4, 2})\n// []int{0,\
    \ 1}\n// Explanation: 0 is the smallest value, but  there are two zeros,\n// so\
    \ we will choose the first zero, which has the smallest index.\n// Constraints:\n\
    // * 1 <= nodes.length <= 10000\n// * 0 <= node.value\nfunc pluck(arr []int) []int\
    \ {\n    // write your code here\n    sort.Ints(arr)\n    var result []int\n \
    \   var index int\n    for _, v := range arr {\n        if v%2 == 0 {\n      \
    \      result = append(result, v)\n            index = len(result)\n        }\n\
    \    }\n    if index == 0 {\n        return nil\n    }\n    return append([]int{result[0],\
    \ index}, result[1:]...)\n}\n\nfunc TestPluck(t *testing.T) {\n  candidate :=\
    \ pluck\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{4, 2, 3}), expected:\
    \ []int{2, 1} },\n     { actual: candidate([]int{1, 2, 3}), expected: []int{2,\
    \ 1} },\n     { actual: candidate([]int{}), expected: []int{} },\n     { actual:\
    \ candidate([]int{5, 0, 3, 0, 4, 2}), expected: []int{0, 1} },\n     { actual:\
    \ candidate([]int{1, 2, 3, 0, 5, 3}), expected: []int{0, 3} },\n     { actual:\
    \ candidate([]int{5, 4, 8, 4, 8}), expected: []int{4, 1} },\n     { actual: candidate([]int{7,\
    \ 6, 7, 1}), expected: []int{6, 1} },\n     { actual: candidate([]int{7, 9, 7,\
    \ 1}), expected: []int{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4t1jv8mp_test.go:35:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074507
