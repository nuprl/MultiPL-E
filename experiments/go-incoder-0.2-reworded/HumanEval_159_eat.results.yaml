language: go_test.go
name: HumanEval_159_eat
results:
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return nil\n   \
    \ }\n    carrots := 0\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    return\
    \ []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpiyu5pv3q_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpiyu5pv3q_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpiyu5pv3q_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpiyu5pv3q_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpiyu5pv3q_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpiyu5pv3q_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 && need == 0 && remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 && need == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 && remaining == 0 {\n        return []int{0, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining {\n\
    \        return []int{0, 0}\n    }\n    if number == need && remaining == 0 {\n\
    \        return []int{0, 0}\n    }\n    if number == need && remaining > 0 {\n\
    \        return []int{0, 0}\n    }\n    if number == remaining && need == 0 {\n\
    \        return []int{0, 0}\n    }\n    if number == remaining && need > 0 {\n\
    \        return []int{0, 0}\n    }\n    if number == remaining && need == 0 &&\
    \ remaining > 0 {\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ && need == 0 && remaining == 0 {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining && need > 0 && remaining > 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining && need > 0 && remaining == 0 {\n    \
    \    return []int{0, 0}\n    }\n    if number == remaining && need == 0 && remaining\
    \ > 0 {\n        return []int{0, 0}\n    }\n    if number == remaining && need\
    \ > 0 && remaining == 0 {\n        return []int{0, 0}\n    }\n    if number ==\
    \ remaining && need == 0 && remaining == 0 {\n        return []int{0, 0}\n   \
    \ }\n    if number == remaining && need > 0 && remaining > 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == remaining && need > 0 && remaining == 0\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining && need ==\
    \ 0 && remaining > 0 {\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ && need == 0 && remaining == 0 {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining && need > 0 && remaining > 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining && need > 0 && remaining == 0 {\n    \
    \    return []int{0, 0}\n    }\n    if number == remaining && need == 0 && remaining\
    \ > 0 {\n        return []int{0, 0}\n    }\n    if number == remaining && need\
    \ == 0 && remaining == 0 {\n        return []int{0, 0}\n    }\n    if number ==\
    \ remaining && need > 0 && remaining > 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == remaining && need > 0 && remaining \nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt_lwpdfs_test.go:117:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < need {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > need {\n        result[0] = need\n        result[1] = number\n    \
    \    return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number >\
    \ remaining {\n        result[0] = number\n        result[1] = remaining\n   \
    \     return result\n    }\n    if number == remaining {\n        result[0] =\
    \ number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number < remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number < remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number < remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number < remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number < remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > remaining {\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp42fm4i_1_test.go:170:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number == 0 {\n        result[0] = remaining\n        result[1]\
    \ = remaining\n    } else {\n        result[0] = number\n        result[1] = need\n\
    \    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpd1ly261f_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpd1ly261f_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpd1ly261f_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpd1ly261f_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpd1ly261f_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpd1ly261f_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n\
    \        return result\n    }\n    if need == 0 {\n        result[0] = number\n\
    \        result[1] = 0\n        return result\n    }\n    if remaining == 0 {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number < need {\n        result[0]\
    \ = need\n        result[1] = number\n        return result\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number > remaining {\n        result[0] = number\n   \
    \     result[1] = remaining\n        return result\n    }\n    if number < remaining\
    \ {\n        result[0] = remaining\n        result[1] = number\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = remaining\n        result[1] = number\n        return\
    \ result\n    }\n    if number < remaining {\n        result[0] = number\n   \
    \     result[1] = remaining\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > remaining {\n        result[0] = remaining\n\
    \        result[1] = number\n        return result\n    }\n    if number < remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = remaining\n        result[1] = number\n        return\
    \ result\n    }\n    if number < remaining {\n        result[0] = number\n   \
    \     result[1] = remaining\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > remaining {\n        result[0] = remaining\n\
    \        result[1] = number\n        return result\n    }\n    if number < remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = remaining\n        result[1] = number\n        return\
    \ result\n    }\n    if number < remaining {\n        result[0] = number\n   \
    \     result[1] = remaining\n        return result\n    }\n    if number == remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number > remaining {\n        result[0] = remaining\n\
    \        result[1] = number\n        return result\n    }\n    if number < remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number == remaining {\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj0n8d7x8_test.go:170:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if remaining\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if remaining == need {\n    \
    \    return []int{number, 0}\n    }\n    if remaining > need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number < remaining {\n        return []int{0, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number == remaining {\n  \
    \      return []int{number, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number == remaining {\n  \
    \      return []int{number, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number == remaining {\n  \
    \      return []int{number, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number == remaining {\n        return []\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa4t_qf_i_test.go:141:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n\
    \    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots\
    \ / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots\
    \ = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n\
    \    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n\
    \    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots / 1000\n\
    \    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots = carrots\
    \ / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n    carrots\
    \ = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots % 1000\n\
    \    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 1000\n    carrots = carrots / 1000\n    carrots = carrots + 1\n\
    \    carrots = carrots % \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7yyyqw1q_test.go:94:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number-need\n\
    \    } else {\n        carrots = need\n    }\n    if remaining > carrots {\n \
    \       carrots = remaining\n    }\n    return []int{carrots, 0}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpdsnxpk_7_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpdsnxpk_7_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpdsnxpk_7_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpdsnxpk_7_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpdsnxpk_7_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    return []int{carrots, carrots - carrots\
    \ - need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpkolfqe7u_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=-6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpkolfqe7u_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=-8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpkolfqe7u_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=-10)]'\n    --- FAIL:\
    \ TestEat/test_num__3 (0.00s)\n        tmpkolfqe7u_test.go:66: expected '[%!s(int=7)\
    \ %!s(int=0)]', got '[%!s(int=18) %!s(int=-11)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpkolfqe7u_test.go:66: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=16) %!s(int=-5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n\
    \        tmpkolfqe7u_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10)\
    \ %!s(int=-5)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp788qtbse_test.go:109:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    return []int{carrots, carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp3wq9syai_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp3wq9syai_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp3wq9syai_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp3wq9syai_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp3wq9syai_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp3wq9syai_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > remaining {\n        carrots =\
    \ number-remaining\n    } else {\n        carrots = remaining\n    }\n    if need\
    \ > carrots {\n        carrots = need\n    }\n    return []int{carrots, carrots-need}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp7bai4zli_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp7bai4zli_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp7bai4zli_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp7bai4zli_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp7bai4zli_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    return []int{carrots, carrots - carrots}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_m03um5c_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_m03um5c_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp_m03um5c_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp_m03um5c_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp_m03um5c_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_m03um5c_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int, 2)\n\
    \    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n        return\
    \ result\n    }\n    if number < need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    carrots := 0\n    if number > remaining\
    \ {\n        carrots = number - remaining\n        result[0] = number\n      \
    \  result[1] = carrots\n        return result\n    }\n    carrots = number - need\n\
    \    result[0] = carrots\n    result[1] = number\n    return result\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpc84y9ftb_test.go:80: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpc84y9ftb_test.go:80:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpc84y9ftb_test.go:80: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpc84y9ftb_test.go:80: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpc84y9ftb_test.go:80: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpc84y9ftb_test.go:80:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int, 2)\n\
    \    if remaining == 0 {\n        result[0] = number\n        result[1] = need\n\
    \    } else {\n        result[0] = number\n        result[1] = remaining\n   \
    \ }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp7_szfi1e_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp7_szfi1e_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp7_szfi1e_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp7_szfi1e_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp7_szfi1e_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp7_szfi1e_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > 0 {\n        carrots += number\n\
    \    }\n    if need > 0 {\n        carrots += need\n    }\n    if carrots > remaining\
    \ {\n        carrots = remaining\n    }\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    \n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprhe_atyv_test.go:98:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > remaining {\n        carrots =\
    \ number\n    } else {\n        carrots = remaining\n    }\n    if carrots > need\
    \ {\n        carrots = need\n    }\n    if carrots == 0 {\n        return []int{0,\
    \ 0}\n    }\n    carrots -= need\n    carrots = carrots % 10\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 10\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 10\n    carrots = carrots + 1\n    carrots = carrots % 10\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 10\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 10\n    carrots = carrots + 1\n    carrots = carrots % 10\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 10\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 10\n    carrots = carrots + 1\n    carrots = carrots % 10\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 10\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 10\n    carrots = carrots + 1\n    carrots = carrots % 10\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 10\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 10\n    carrots = carrots + 1\n    carrots = carrots % 10\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 10\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 10\n    carrots = carrots + 1\n    carrots = carrots % 10\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 10\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 10\n    carrots = carrots + 1\n    carrots = carrots % 10\n    carrots = carrots\
    \ + 1\n    carrots = carrots \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpp8ksracy_test.go:96:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if remaining\
    \ < need {\n        return []int{0, 0}\n    }\n    if number < need {\n      \
    \  return []int{number, 0}\n    }\n    result := []int{number, 0}\n    carrots\
    \ := 0\n    for i := 0; i < number; i++ {\n        carrots += i\n    }\n    for\
    \ i := 0; i < need; i++ {\n        carrots += i\n    }\n    for i := 0; i < remaining;\
    \ i++ {\n        carrots += i\n    }\n    for i := 0; i < number; i++ {\n    \
    \    carrots -= i\n    }\n    for i := 0; i < need; i++ {\n        carrots -=\
    \ i\n    }\n    for i := 0; i < remaining; i++ {\n        carrots -= i\n    }\n\
    \    for i := 0; i < number; i++ {\n        carrots += i\n    }\n    for i :=\
    \ 0; i < need; i++ {\n        carrots += i\n    }\n    for i := 0; i < remaining;\
    \ i++ {\n        carrots += i\n    }\n    for i := 0; i < number; i++ {\n    \
    \    carrots -= i\n    }\n    for i := 0; i < need; i++ {\n        carrots -=\
    \ i\n    }\n    for i := 0; i < remaining; i++ {\n        carrots -= i\n    }\n\
    \    for i := 0; i < number; i++ {\n        carrots += i\n    }\n    for i :=\
    \ 0; i < need; i++ {\n        carrots += i\n    }\n    for i := 0; i < remaining;\
    \ i++ {\n        carrots += i\n    }\n    for i := 0; i < number; i++ {\n    \
    \    carrots -= i\n    }\n    for i := 0; i < need; i++ {\n        carrots -=\
    \ i\n    }\n    for i := 0; i < remaining; i++ {\n        carrots -= i\n    }\n\
    \    for i := 0; i < number; i++ {\n        carrots += i\n    }\n    for i :=\
    \ 0; i < need; i++ {\n        carrots += i\n    }\n    for i := 0; i < remaining;\
    \ i++ {\n        carrots += i\n    }\n    for i := 0; i < number; i++ {\n    \
    \    carrots -= i\n    }\n    for i := 0; i < need; i++ {\n        carrots -=\
    \ i\n    }\n    for i := 0; i < remaining; i++ \nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd3xcs71p_test.go:118:36: expected ''{'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number > 1000 || need > 1000 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n\
    \    if need == 0 {\n        return []int{number, 0}\n    }\n    if remaining\
    \ == 0 {\n        return []int{number, 0}\n    }\n    if number > need {\n   \
    \     return []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n  \
    \  if number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number > remaining {\n \
    \       return []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7kn0rwa6_test.go:143:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number == 0 {\n        result[0] = remaining\n   \
    \     result[1] = remaining\n    } else {\n        result[0] = number\n      \
    \  result[1] = need\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpc5oekacs_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpc5oekacs_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpc5oekacs_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpc5oekacs_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpc5oekacs_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpc5oekacs_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    carrots = carrots - number\n    carrots = carrots - need\n    carrots\
    \ = carrots - remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n  \
    \  return []int{carrots, carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpuliet8p7_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpuliet8p7_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpuliet8p7_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpuliet8p7_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpuliet8p7_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpuliet8p7_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code in JavaScript (Node.js 8.9.4)\n    // let carrots = number\n\
    \    // let need = need\n    // let remaining = remaining\n    // let result =\
    \ []\n    // while carrots > 0 && need > 0 && remaining > 0 {\n    //     carrots\
    \ -= need\n    //     need += remaining\n    //     remaining -= carrots\n   \
    \ //     result.push(carrots)\n    // }\n    // return result\n    var carrots\
    \ = number\n    var need = need\n    var remaining = remaining\n    var result\
    \ = []\n    while carrots > 0 && need > 0 && remaining > 0 {\n        carrots\
    \ -= need\n        need += remaining\n        remaining -= carrots\n        result.push(carrots)\n\
    \    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjivjtk6q_test.go:50:20: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if remaining == 0 {\n     \
    \   return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, number}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number < need\
    \ {\n        return []int{0, number}\n    }\n    if number == need {\n       \
    \ return []int{number, 0}\n    }\n    if number < remaining {\n        return\
    \ []int{0, number}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, number}\n    }\n\
    \    if number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, number}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number < need {\n        return\
    \ []int{0, number}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number < remaining {\n        return []int{0, number}\n  \
    \  }\n    if number == remaining {\n        return []int{number, 0}\n    }\n \
    \   if number > need {\n        return []int{0, number}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number == remaining {\n  \
    \      return []int{number, 0}\n    }\n    if number < need {\n        return\
    \ []int{0, number}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number < remaining {\n        return []int{0, number}\n  \
    \  }\n    if number == remaining {\n        return []int{number, 0}\n    }\n \
    \   if number > need {\n        return []int{0, number}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number == remaining {\n  \
    \      return []int{number, 0}\n    }\n    if number < need {\n        return\
    \ []int{0, number}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number < remaining {\n        return []int{0, number}\n  \
    \  }\n    if number == remaining {\n        return []int{number, 0}\n    }\n \
    \   if number > need {\n        return []int{0, number}\n    }\n    if number\
    \ == need {\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprc27i084_test.go:142:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph157ga60_test.go:141:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return nil\n   \
    \ }\n    result := make([]int, 2)\n    result[0] = number\n    result[1] = remaining\n\
    \    if number > remaining {\n        result[0] = number - remaining\n    }\n\
    \    if need > remaining {\n        result[1] = need - remaining\n    }\n    return\
    \ result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp96yui0jd_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp96yui0jd_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp96yui0jd_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp96yui0jd_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp96yui0jd_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp96yui0jd_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=3) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number-need\n\
    \    } else {\n        carrots = need\n    }\n    if remaining > 0 {\n       \
    \ carrots = carrots + remaining\n    }\n    return []int{carrots, carrots-number}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpm5_za1qt_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=16)\
    \ %!s(int=11)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpm5_za1qt_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=17) %!s(int=13)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpm5_za1qt_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=20) %!s(int=19)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpm5_za1qt_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=16) %!s(int=14)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpm5_za1qt_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=12)\
    \ %!s(int=8)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpm5_za1qt_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=6) %!s(int=2)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots = number\n    carrots = carrots - need\n\
    \    carrots = carrots + remaining\n    carrots = carrots + 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots - 1\n    carrots = carrots - 1\n    carrots = carrots\
    \ - 1\n    carrots = carrots - 1\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe8vxa2nl_test.go:94:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number-need\n\
    \    } else {\n        carrots = need\n    }\n    if carrots > remaining {\n \
    \       carrots = remaining\n    }\n    return []int{carrots, 0}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps21ekjty_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps21ekjty_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmps21ekjty_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmps21ekjty_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmps21ekjty_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmps21ekjty_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number-need\n\
    \    } else {\n        carrots = need\n    }\n    if carrots > remaining {\n \
    \       carrots = remaining\n    }\n    return []int{carrots, 0}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps21ekjty_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps21ekjty_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmps21ekjty_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmps21ekjty_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmps21ekjty_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmps21ekjty_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n  \
    \  if carrots < 0 {\n        carrots = 0\n    }\n    return []int{carrots, carrots}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmphh3v5j95_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmphh3v5j95_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmphh3v5j95_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmphh3v5j95_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmphh3v5j95_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmphh3v5j95_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > need {\n        carrots = number\n    } else {\n        carrots = need\n \
    \   }\n    if carrots > remaining {\n        carrots = remaining\n    }\n    return\
    \ []int{carrots, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpn5ap4eka_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpn5ap4eka_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpn5ap4eka_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpn5ap4eka_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpn5ap4eka_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpn5ap4eka_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    if remaining < need {\n   \
    \     meals = need\n    } else {\n        meals = remaining\n    }\n    if meals\
    \ > 0 {\n        carrots = meals\n    }\n    if carrots > 0 {\n        carrots\
    \ = carrots + number\n    }\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    if carrots < 0 {\n        carrots = 0\n    }\n    return []int{carrots,\
    \ carrots - carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp7zhqyyqs_test.go:78: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp7zhqyyqs_test.go:78:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__3 (0.00s)\n        tmp7zhqyyqs_test.go:78: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[%!s(int=13) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp7zhqyyqs_test.go:78: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n\
    \        tmp7zhqyyqs_test.go:78: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=9)\
    \ %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    if remaining > 0 {\n        carrots = remaining\n        meals = 1\n\
    \    }\n    if number > need {\n        carrots = number\n        meals = 1\n\
    \    }\n    if carrots == 0 {\n        carrots = need\n        meals = 1\n   \
    \ }\n    result := make([]int, 2)\n    result[0] = carrots\n    result[1] = meals\n\
    \    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpuc9swq8a_test.go:76: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpuc9swq8a_test.go:76:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpuc9swq8a_test.go:76: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpuc9swq8a_test.go:76: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpuc9swq8a_test.go:76: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpuc9swq8a_test.go:76:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    for i := 0; i < number; i++\
    \ {\n        carrots += i\n    }\n    for i := 0; i < need; i++ {\n        meals\
    \ += i\n    }\n    for i := 0; i < remaining; i++ {\n        carrots += i\n  \
    \  }\n    if carrots < 1000 {\n        return []int{carrots, 0}\n    }\n    meals\
    \ -= carrots\n    carrots -= meals\n    if carrots < 1000 {\n        return []int{carrots,\
    \ 0}\n    }\n    meals -= carrots\n    carrots -= meals\n    if carrots < 1000\
    \ {\n        return []int{carrots, 0}\n    }\n    meals -= carrots\n    carrots\
    \ -= meals\n    if carrots < 1000 {\n        return []int{carrots, 0}\n    }\n\
    \    meals -= carrots\n    carrots -= meals\n    if carrots < 1000 {\n       \
    \ return []int{carrots, 0}\n    }\n    meals -= carrots\n    carrots -= meals\n\
    \    if carrots < 1000 {\n        return []int{carrots, 0}\n    }\n    meals -=\
    \ carrots\n    carrots -= meals\n    if carrots < 1000 {\n        return []int{carrots,\
    \ 0}\n    }\n    meals -= carrots\n    carrots -= meals\n    if carrots < 1000\
    \ {\n        return []int{carrots, 0}\n    }\n    meals -= carrots\n    carrots\
    \ -= meals\n    if carrots < 1000 {\n        return []int{carrots, 0}\n    }\n\
    \    meals -= carrots\n    carrots -= meals\n    if carrots < 1000 {\n       \
    \ return []int{carrots, 0}\n    }\n    meals -= carrots\n    carrots -= meals\n\
    \    if carrots < 1000 {\n        return []int{carrots, 0}\n    }\n    meals -=\
    \ carrots\n    carrots -= meals\n    if carrots < 1000 {\n        return []int{carrots,\
    \ 0}\n    }\n    meals -= carrots\n    carrots -= meals\n    if carrots < 1000\
    \ {\n        return []int{carrots, 0}\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpueh_k4bc_test.go:111:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{}\n    }\n    result := make([]int, 2)\n    carrots\
    \ := 0\n    result [0] = carrots\n    result [1] = remaining\n    if carrots >=\
    \ need {\n        carrots -= need\n        result [0] = carrots\n    } else {\n\
    \        carrots = remaining\n        result [0] = carrots\n        result [1]\
    \ = 0\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp8ye64j1z_test.go:71: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp8ye64j1z_test.go:71:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp8ye64j1z_test.go:71: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp8ye64j1z_test.go:71: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp8ye64j1z_test.go:71: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp8ye64j1z_test.go:71:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    for i := 0; i < number; i++ {\n        carrots += i\n    }\n    for i\
    \ := 0; i < need; i++ {\n        carrots += i\n    }\n    for i := 0; i < remaining;\
    \ i++ {\n        carrots += i\n    }\n    meals = carrots - need\n    carrots\
    \ = meals\n    meals = carrots - need\n    carrots = meals\n    meals = carrots\
    \ - need\n    carrots = meals\n    meals = carrots - need\n    carrots = meals\n\
    \    meals = carrots - need\n    carrots = meals\n    meals = carrots - need\n\
    \    carrots = meals\n    meals = carrots - need\n    carrots = meals\n    meals\
    \ = carrots - need\n    carrots = meals\n    meals = carrots - need\n    carrots\
    \ = meals\n    meals = carrots - need\n    carrots = meals\n    meals = carrots\
    \ - need\n    carrots = meals\n    meals = carrots - need\n    carrots = meals\n\
    \    meals = carrots - need\n    carrots = meals\n    meals = carrots - need\n\
    \    carrots = meals\n    meals = carrots - need\n    carrots = meals\n    meals\
    \ = carrots - need\n    carrots = meals\n    meals = carrots - need\n    carrots\
    \ = meals\n    meals = carrots - need\n    carrots = meals\n    meals = carrots\
    \ - need\n    carrots = meals\n    meals = carrots - need\n    carrots = meals\n\
    \    meals = carrots - need\n    carrots = meals\n    meals = carrots - need\n\
    \    carrots = meals\n    meals = carrots - need\n    carrots = meals\n    meals\
    \ = carrots - need\n    carrots = meals\n    meals = carrots - need\n    carrots\
    \ = meals\n    meals = carrots - need\n    carrots = \nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpny92g2w6_test.go:101:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > need {\n        carrots = number-need\n    } else {\n        carrots = need\n\
    \    }\n    if carrots > remaining {\n        carrots = remaining\n    }\n   \
    \ return []int{carrots, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_j2ful81_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_j2ful81_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp_j2ful81_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp_j2ful81_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp_j2ful81_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_j2ful81_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    if number > need {\n        meals = number\n        carrots = need\n\
    \    } else {\n        meals = need\n        carrots = remaining\n    }\n    carrots\
    \ -= meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n   \
    \ carrots = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots\
    \ + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots\
    \ = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n\
    \    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots\
    \ + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots\
    \ = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n\
    \    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots\
    \ + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots\
    \ = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n\
    \    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots\
    \ + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots\
    \ = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n\
    \    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots\
    \ + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n    carrots\
    \ = carrots + meals\n    carrots = carrots + meals\n    carrots = carrots + meals\n\
    \    carrots = car\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpaegtdi40_test.go:91:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    carrots = number - need\n    if\
    \ carrots < 0 {\n        carrots = 0\n    }\n    if carrots > remaining {\n  \
    \      carrots = remaining\n    }\n    return []int{carrots, remaining}\n}\n</cell>\n\
    <text>\nProblem 3\nWrite a function that takes a string and returns the number\
    \ of words in the string.\nThe string may contain punctuation marks and spaces.\n\
    The function should ignore punctuation and spaces.\nThe function should ignore\
    \ leading or trailing spaces.\nThe function should ignore empty strings.\nThe\
    \ function should ignore cases where there are fewer than two words.\nThe function\
    \ should ignore cases where there are more than three words.\nThe function should\
    \ ignore cases where there are more than four words.\nThe function should ignore\
    \ cases where there are more than five words.\nThe function should ignore cases\
    \ where there are more than six words.\nThe function should ignore cases where\
    \ there are more than seven words.\nThe function should ignore cases where there\
    \ are more than eight words.\nThe function should ignore cases where there are\
    \ more than nine words.\nThe function should ignore cases where there are more\
    \ than ten words.\nThe function should ignore cases where there are more than\
    \ eleven words.\nThe function should ignore cases where there are more than twelve\
    \ words.\nThe function should ignore cases where there are more than thirteen\
    \ words.\nThe function should ignore cases where there are more than fourteen\
    \ words.\nThe function should ignore cases where there are more than fifteen words.\n\
    The function should ignore cases where there are more than sixteen words.\nThe\
    \ function should ignore cases where there are more than seventeen words.\nThe\
    \ function should ignore cases where there are more than eighteen words.\nThe\
    \ function should ignore cases where there are more than nineteen words.\nThe\
    \ function should ignore cases where there are more than twenty words.\nThe function\
    \ should ignore cases where there are more than twenty one words.\nThe function\
    \ should ignore cases where there are more than twenty two words.\nThe function\
    \ should ignore cases where there are more than twenty three words.\nThe function\
    \ should ignore cases where there are more than twenty four words.\nThe function\
    \ should ignore cases where there are more than twenty five words.\nThe function\
    \ should ignore cases where there are more than twenty six words.\nThe function\
    \ should ignore cases where there are more than twenty seven words.\nThe function\
    \ should ignore cases where there are more than twenty eight words.\nThe function\
    \ should ignore cases where there are more than twenty nine words.\nThe function\
    \ should ignore cases where there are more than twenty ten words.\nThe function\
    \ should ignore cases where there are more than twent\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9gpxkfu9_test.go:46:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    if number < 0 {\n        return\
    \ []int{0, 0}\n    }\n    if need < 0 {\n        return []int{0, 0}\n    }\n \
    \   if remaining < 0 {\n        return []int{0, 0}\n    }\n    if number == 0\
    \ {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if need >\
    \ remaining {\n        return []int{0, 0}\n    }\n    if number == need {\n  \
    \      return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n\
    \    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining {\n\
    \        return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ need > remaining {\n        return []int{0, 0}\n    }\n    if number == need\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n\
    \    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb0apoh42_test.go:146:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number-need\n\
    \    } else {\n        carrots = need\n    }\n    if carrots > remaining {\n \
    \       carrots = remaining\n    }\n    carrots = carrots + number\n    return\
    \ []int{carrots, carrots-number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpeiv6udsm_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpeiv6udsm_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpeiv6udsm_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=11) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpeiv6udsm_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=7) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpeiv6udsm_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpeiv6udsm_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    result := make([]int, 2)\n    carrots := 0\n    if number > need\
    \ {\n        carrots = number-need\n        result[0] = carrots\n        result[1]\
    \ = remaining\n    } else {\n        carrots = need\n        result[0] = remaining\n\
    \        result[1] = carrots\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp1gcvfg1b_test.go:70: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp1gcvfg1b_test.go:70:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp1gcvfg1b_test.go:70: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp1gcvfg1b_test.go:70: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp1gcvfg1b_test.go:70: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp1gcvfg1b_test.go:70:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == 0 {\n        result[0] = 0\n        result[1] = 0\n        return result\n\
    \    }\n    if need == 0 {\n        result[0] = 0\n        result[1] = 0\n   \
    \     return result\n    }\n    if remaining == 0 {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if need == remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > need && number >\
    \ remaining {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if need > number && need > remaining {\n        result[0]\
    \ = need\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number > remaining && number > need {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining && need >\
    \ number {\n        result[0] = need\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number == need && number == remaining {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == remaining && number == need {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need == remaining && need\
    \ == number {\n        result[0] = need\n        result[1] = remaining\n     \
    \   return result\n    }\n    if number > need && number > remaining && number\
    \ > need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if need > number && need > remaining && need > number {\n\
    \        result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > remaining && number > need && number > remaining {\n \
    \       result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if need > remaining && need > number && need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == need && number == remaining && number == need {\n    \
    \    result[0] = number\n        result[1] = need\n        return result\n   \
    \ }\n    if number == remaining && number == need && number == remaining {\n \
    \       result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if need == remaining && need == \nfunc TestEat(t *testing.T) {\n \
    \ candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_uteiad__test.go:151:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    if number > need {\n      \
    \  carrots = number\n        meals = need\n    } else {\n        carrots = need\n\
    \        meals = number\n    }\n    meals -= carrots\n    remaining -= carrots\n\
    \    if remaining <= 0 {\n        remaining = 0\n    }\n    carrots -= remaining\n\
    \    if carrots <= 0 {\n        carrots = 0\n    }\n    return []int{carrots,\
    \ remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp75b3adg4_test.go:77: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=2)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp75b3adg4_test.go:77:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=7) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp75b3adg4_test.go:77: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp75b3adg4_test.go:77: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp75b3adg4_test.go:77: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=3)\
    \ %!s(int=2)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number-need\n\
    \    } else {\n        carrots = need\n    }\n    if carrots > remaining {\n \
    \       carrots = remaining\n    }\n    return []int{carrots, 0}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps21ekjty_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps21ekjty_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmps21ekjty_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmps21ekjty_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmps21ekjty_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmps21ekjty_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n  \
    \  if carrots < 0 {\n        carrots = 0\n    }\n    return []int{carrots, carrots}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmphh3v5j95_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmphh3v5j95_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmphh3v5j95_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmphh3v5j95_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmphh3v5j95_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmphh3v5j95_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 && need == 0 && remaining == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 && need == 0 {\n        return []int{0, 0}\n \
    \   }\n    if number == 0 && remaining == 0 {\n        return []int{0, 0}\n  \
    \  }\n    if number == 0 && need > remaining {\n        return []int{0, 0}\n \
    \   }\n    if number > 0 && need > remaining {\n        return []int{0, 0}\n \
    \   }\n    if number > 0 && remaining > 0 {\n        return []int{0, 0}\n    }\n\
    \    if number > 0 && need == 0 && remaining == 0 {\n        return []int{0, 0}\n\
    \    }\n    if number > 0 && need == 0 {\n        return []int{0, 0}\n    }\n\
    \    if number > 0 && remaining == 0 {\n        return []int{0, 0}\n    }\n  \
    \  if number > 0 && need > remaining {\n        return []int{0, 0}\n    }\n  \
    \  if number > 0 && need == 0 && remaining > 0 {\n        return []int{0, 0}\n\
    \    }\n    if number > 0 && need > remaining {\n        return []int{0, 0}\n\
    \    }\n    if number > 0 && remaining == 0 {\n        return []int{0, 0}\n  \
    \  }\n    if number > 0 && need == 0 && remaining > 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number > 0 && need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number > 0 && need == 0 && remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > 0 && need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number > 0 && remaining > 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number > 0 && need == 0 && remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > 0 && need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number > 0 && need == 0 && remaining > 0 {\n    \
    \    return []int{0, 0}\n    }\n    if number > 0 && need > remaining {\n    \
    \    return []int{0, 0}\n    }\n    if number > 0 && remaining == 0 {\n      \
    \  return []int{0, 0}\n    }\n    if number > 0 && need == 0 && remaining > 0\
    \ {\n        return []int{0, 0}\n    }\n    if number > 0 && need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number > 0 && need == 0 && remaining\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number > 0 && need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number > 0 && remaining > 0 {\n\
    \        return []int{0, 0}\n    }\n    if number > 0 && need == 0 && remaining\
    \ \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzr4upz20_test.go:123:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    carrots = carrots - number\n    carrots = carrots - need\n    carrots\
    \ = carrots - remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n  \
    \  return []int{carrots, carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpuliet8p7_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpuliet8p7_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpuliet8p7_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpuliet8p7_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpuliet8p7_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpuliet8p7_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    if number > 1000 || need > 1000 || remaining\
    \ > 1000 {\n        fmt.Println(\"Invalid input\")\n    }\n    if number == 0\
    \ {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{number, 0}\n    }\n    if need > remaining {\n     \
    \   return []int{0, 0}\n    }\n    if number > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == need {\n     \
    \   return []int{number, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number > remaining {\n        return []int{number, 0}\n    }\n\
    \    if need > remaining {\n        return []int{0, 0}\n    }\n    if number >\
    \ 1000 {\n        return []int{0, 0}\n    }\n    if need > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining > 1000 {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number > remaining {\n \
    \       return []int{number, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number > 1000 {\n        return []int{0, 0}\n   \
    \ }\n    if need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == need {\n     \
    \   return []int{number, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number > remaining {\n        return []int{number, 0}\n    }\n\
    \    if need > remaining {\n        return []int{0, 0}\n    }\n    if number >\
    \ 1000 {\n        return []int{0, 0}\n    }\n    if need > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining > 1000 {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number == \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf7nyonkn_test.go:143:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if need\
    \ == 0 {\n        return []int{number, 0}\n    }\n    if remaining == 0 {\n  \
    \      return []int{number, 0}\n    }\n    if number < need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number == remaining {\n\
    \        return []int{number, 0}\n    }\n    if number > remaining {\n       \
    \ return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number == remaining {\n\
    \        return []int{number, 0}\n    }\n    if number > remaining {\n       \
    \ return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number == \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnv920wvu_test.go:144:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots = carrots\
    \ % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots =\
    \ carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n  \
    \  carrots = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots\
    \ + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots =\
    \ carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n    carrots\
    \ = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots / 100\n  \
    \  carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots /\
    \ 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots = carrots\
    \ / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots =\
    \ carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n    carrots\
    \ = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots % 100\n  \
    \  carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots %\
    \ 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots = carrots\
    \ % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots =\
    \ carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n    carrots\
    \ = carrots % 100\n    carrots = carrots / 100\n    carrots = carrots + 1\n  \
    \  carrots = carrots % \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplj3bi75r_test.go:91:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp788qtbse_test.go:109:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075195
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := []int{0, 0}\n   \
    \ if number == 0 {\n        return result\n    }\n    if number < need {\n   \
    \     return result\n    }\n    if number > remaining {\n        return result\n\
    \    }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > need {\n        return\
    \ result\n    }\n    carrots := 0\n    carrots = number - need\n    result[0]\
    \ = number\n    result[1] = carrots\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpblc8sygj_test.go:81: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpblc8sygj_test.go:81:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpblc8sygj_test.go:81: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpblc8sygj_test.go:81: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpblc8sygj_test.go:81: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpblc8sygj_test.go:81:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if need\
    \ == 0 {\n        return []int{number, 0}\n    }\n    if remaining == 0 {\n  \
    \      return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number == need {\n     \
    \   return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpc9zm0o20_test.go:144:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := []int{0, 0}\n   \
    \ carrots := 0\n    if remaining > 0 {\n        carrots = remaining\n    }\n \
    \   if carrots > 0 {\n        result[0] = carrots\n    }\n    if carrots > need\
    \ {\n        result[1] = carrots - need\n    }\n    return result\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpqznkc2tn_test.go:70: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpqznkc2tn_test.go:70:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpqznkc2tn_test.go:70: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpqznkc2tn_test.go:70: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpqznkc2tn_test.go:70: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpqznkc2tn_test.go:70:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    if number > need {\n      \
    \  meals = number\n        carrots = need\n    } else {\n        meals = need\n\
    \        carrots = number\n    }\n    if carrots > remaining {\n        carrots\
    \ = remaining\n    }\n    result := make([]int, 2)\n    result[0] = carrots\n\
    \    result[1] = carrots - meals\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpa_xo8_wl_test.go:74: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=-1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpa_xo8_wl_test.go:74:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=-4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpa_xo8_wl_test.go:74: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=-9)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpa_xo8_wl_test.go:74: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=-9)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpa_xo8_wl_test.go:74: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=-1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpa_xo8_wl_test.go:74:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=-4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{}\n    }\n    carrots := 0\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots += number\n    car\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyken26cq_test.go:113:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number == 0 {\n        result[0] = 0\n        result[1]\
    \ = 0\n        return result\n    }\n    if number > 0 && need > 0 && remaining\
    \ > 0 {\n        result[0] = number\n        result[1] = remaining\n    }\n  \
    \  return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpm00kiq0h_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpm00kiq0h_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpm00kiq0h_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpm00kiq0h_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpm00kiq0h_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpm00kiq0h_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number-need\n\
    \    } else {\n        carrots = need\n    }\n    if carrots > remaining {\n \
    \       carrots = remaining\n    }\n    return []int{carrots, 0}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps21ekjty_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps21ekjty_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmps21ekjty_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmps21ekjty_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmps21ekjty_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmps21ekjty_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return nil\n   \
    \ }\n    result := make([]int, 2)\n    result[0] = number\n    result[1] = remaining\n\
    \    if number == 0 {\n        return nil\n    }\n    if number < need {\n   \
    \     result[0] = number\n        result[1] = 0\n    }\n    if number > need {\n\
    \        result[0] = need\n        result[1] = number - need\n    }\n    return\
    \ result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpnfruu9q0_test.go:73: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpnfruu9q0_test.go:73:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpnfruu9q0_test.go:73: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpnfruu9q0_test.go:73: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpnfruu9q0_test.go:73: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpnfruu9q0_test.go:73:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return nil\n   \
    \ }\n    carrots := 0\n    if number > remaining {\n        carrots = number-remaining\n\
    \    } else {\n        carrots = remaining\n    }\n    if carrots > need {\n \
    \       carrots = need\n    }\n    return []int{carrots, 0}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp0cnj25vf_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0cnj25vf_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp0cnj25vf_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp0cnj25vf_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp0cnj25vf_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp0cnj25vf_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=3) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number ==\
    \ 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number == need\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number == need {\n     \
    \   return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpobiq7p4e_test.go:144:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    if number < 0 {\n        return\
    \ []int{0, 0}\n    }\n    if need < 0 {\n        return []int{0, 0}\n    }\n \
    \   if remaining < 0 {\n        return []int{0, 0}\n    }\n    if number == 0\
    \ {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if need ==\
    \ 0 {\n        return []int{0, 0}\n    }\n    if remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n\
    \    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        return []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if need == 0 {\n        return []int{0, 0}\n    }\n    if remaining\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number == 0\
    \ {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if need ==\
    \ 0 {\n        return []int{0, 0}\n    }\n    if remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n\
    \    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3497_hff_test.go:149:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int, 2)\n\
    \    if number < need {\n        result[0] = 0\n        result[1] = remaining\n\
    \    } else {\n        result[0] = need\n        result[1] = number\n    }\n \
    \   return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp3d_z9lf__test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp3d_z9lf__test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp3d_z9lf__test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp3d_z9lf__test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp3d_z9lf__test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp3d_z9lf__test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    return []int{carrots, carrots - carrots\
    \ - need}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpkolfqe7u_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=-6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpkolfqe7u_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=-8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpkolfqe7u_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=-10)]'\n    --- FAIL:\
    \ TestEat/test_num__3 (0.00s)\n        tmpkolfqe7u_test.go:66: expected '[%!s(int=7)\
    \ %!s(int=0)]', got '[%!s(int=18) %!s(int=-11)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmpkolfqe7u_test.go:66: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=16) %!s(int=-5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n\
    \        tmpkolfqe7u_test.go:66: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10)\
    \ %!s(int=-5)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    for i := 0; i < number; i++\
    \ {\n        carrots += i\n    }\n    for i := 0; i < need; i++ {\n        carrots\
    \ += i\n    }\n    for i := 0; i < remaining; i++ {\n        carrots += i\n  \
    \  }\n    meals = carrots - need\n    carrots = carrots - meals\n    carrots =\
    \ carrots - meals\n    carrots = carrots - meals\n    carrots = carrots - meals\n\
    \    carrots = carrots - meals\n    carrots = carrots - meals\n    carrots = carrots\
    \ - meals\n    carrots = carrots - meals\n    carrots = carrots - meals\n    carrots\
    \ = carrots - meals\n    carrots = carrots - meals\n    carrots = carrots - meals\n\
    \    carrots = carrots - meals\n    carrots = carrots - meals\n    carrots = carrots\
    \ - meals\n    carrots = carrots - meals\n    carrots = carrots - meals\n    carrots\
    \ = carrots - meals\n    carrots = carrots - meals\n    carrots = carrots - meals\n\
    \    carrots = carrots - meals\n    carrots = carrots - meals\n    carrots = carrots\
    \ - meals\n    carrots = carrots - meals\n    carrots = carrots - meals\n    carrots\
    \ = carrots - meals\n    carrots = carrots - meals\n    carrots = carrots - meals\n\
    \    carrots = carrots - meals\n    carrots = carrots - meals\n    carrots = carrots\
    \ - meals\n    carrots = carrots - meals\n    carrots = carrots - meals\n    carrots\
    \ = carrots - meals\n    carrots = carrots - meals\n    carrots = carrots - meals\n\
    \    carrots = carrots - meals\n    carrots = carrots - meals\n    carrots = carrots\
    \ - meals\n    carrots = carrots - meals\n    carrots = carrots - meals\n    carrot\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwtvt18le_test.go:92:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075199
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == 0 {\n        result[0] = 0\n        result[1] = 0\n        return result\n\
    \    }\n    if remaining == 0 {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ < need {\n        result[0] = number\n        result[1] = remaining\n      \
    \  return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = number\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number < remaining {\n        result[0] = remaining\n\
    \        result[1] = number\n        return result\n    }\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2yivucbj_test.go:75:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075199
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number-need\n\
    \    } else {\n        carrots = need\n    }\n    if carrots > remaining {\n \
    \       carrots = remaining\n    }\n    return []int{carrots, 0}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps21ekjty_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps21ekjty_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmps21ekjty_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmps21ekjty_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmps21ekjty_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmps21ekjty_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number\n\
    \    } else {\n        carrots = need\n    }\n    if carrots > remaining {\n \
    \       carrots = remaining\n    }\n    return []int{carrots, 0}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp9g8kn5ty_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp9g8kn5ty_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp9g8kn5ty_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp9g8kn5ty_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp9g8kn5ty_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp9g8kn5ty_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots =\
    \ number\n    if carrots > need {\n        carrots = need\n    }\n    if carrots\
    \ < remaining {\n        carrots = remaining\n    }\n    if carrots == 0 {\n \
    \       return []int{0, 0}\n    }\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz8_n2n1q_test.go:97:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075199
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n\
    \        return result\n    }\n    if need == 0 {\n        result[0] = number\n\
    \        result[1] = 0\n        return result\n    }\n    if remaining == 0 {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if need > number\
    \ && need > remaining {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if need > number && need > remaining {\n  \
    \      result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ && number > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if need > number && need > remaining {\n  \
    \      result[0] = need\n        result[1] = number\n        return result\n \
    \   }\n    if need > number && need > remaining {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if number >\
    \ need && number > remaining {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > need && number > remaining\
    \ {\n        result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if need > number && need > remaining {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n    if need > number\
    \ && need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > need && number > remaining {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if need > number\
    \ && need > remaining {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if need > number && need > remaining {\n  \
    \      result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if number > need && number > remaining {\n        result[0] = number\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq9cu1s14_test.go:151:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075199
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return nil\n    }\n    carrots := 0\n    if number < need\
    \ {\n        carrots = number\n    } else {\n        carrots = need\n    }\n \
    \   if remaining > 0 {\n        carrots = carrots + remaining\n    }\n    return\
    \ []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpzdq5pt_7_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=15)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpzdq5pt_7_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=13) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpzdq5pt_7_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=11) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpzdq5pt_7_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=7) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpzdq5pt_7_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=11)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpzdq5pt_7_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number-need\n\
    \    } else {\n        carrots = need\n    }\n    if remaining > carrots {\n \
    \       carrots = remaining\n    }\n    return []int{carrots, 0}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpdsnxpk_7_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpdsnxpk_7_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpdsnxpk_7_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpdsnxpk_7_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpdsnxpk_7_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n\
    \        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need == 0 {\n        result[0] = number\n        result[1] = 0\n        return\
    \ result\n    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need > remaining {\n        result[0] = need\n       \
    \ result[1] = remaining\n        return result\n    }\n    if number > need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number > need {\n        result[0] = number\n        result[1] =\
    \ need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need > remaining {\n        result[0] = need\n       \
    \ result[1] = remaining\n        return result\n    }\n    if number > need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number > need {\n        result[0] = number\n        result[1] =\
    \ need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need > remaining \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpprjptesq_test.go:170:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075199
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    return []int{carrots, carrots - carrots + need}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpkcoztvxs_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpkcoztvxs_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpkcoztvxs_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpkcoztvxs_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpkcoztvxs_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpkcoztvxs_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    carrots += number\n    meals += need\n    if carrots > remaining {\n\
    \        carrots = remaining\n    }\n    meals += carrots\n    if meals > 1000\
    \ {\n        meals = 1000\n    }\n    carrots -= meals\n    meals -= carrots\n\
    \    return []int{meals, carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp4pt3u_fw_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=17)\
    \ %!s(int=-6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp4pt3u_fw_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=20) %!s(int=-8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp4pt3u_fw_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=-10)]'\n    --- FAIL:\
    \ TestEat/test_num__3 (0.00s)\n        tmp4pt3u_fw_test.go:72: expected '[%!s(int=7)\
    \ %!s(int=0)]', got '[%!s(int=24) %!s(int=-11)]'\n    --- FAIL: TestEat/test_num__4\
    \ (0.00s)\n        tmp4pt3u_fw_test.go:72: expected '[%!s(int=9) %!s(int=2)]',\
    \ got '[%!s(int=14) %!s(int=-5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n\
    \        tmp4pt3u_fw_test.go:72: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=11)\
    \ %!s(int=-5)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    if number < 0 {\n        return []int{0,\
    \ 0}\n    }\n    if need < 0 {\n        return []int{0, 0}\n    }\n    if remaining\
    \ < 0 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if need == 0 {\n        return []int{0, 0}\n    }\n\
    \    if remaining == 0 {\n        return []int{number, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining {\n\
    \        return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ need > remaining {\n        return []int{0, 0}\n    }\n    if number == need\
    \ {\n        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n\
    \    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > need {\n\
    \        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining {\n\
    \        return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{0, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number \nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd0mwyjyd_test.go:146:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    carrots = carrots - number\n    carrots = carrots - need\n    carrots\
    \ = carrots - remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n  \
    \  return []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpipiuijcr_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpipiuijcr_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpipiuijcr_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpipiuijcr_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpipiuijcr_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpipiuijcr_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > remaining {\n        carrots =\
    \ number\n    } else {\n        carrots = remaining\n    }\n    carrots = carrots\
    \ + need\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots =\
    \ carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    car\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp269h5hzw_test.go:96:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 || number > 1000 {\n        return nil\n    }\n    if\
    \ need < 0 || need > 1000 {\n        return nil\n    }\n    if remaining < 0 ||\
    \ remaining > 1000 {\n        return nil\n    }\n    if number == 0 {\n      \
    \  return nil\n    }\n    if need == 0 {\n        return nil\n    }\n    if remaining\
    \ == 0 {\n        return nil\n    }\n    if number > need {\n        return nil\n\
    \    }\n    if number == need {\n        return nil\n    }\n    if number > remaining\
    \ {\n        return nil\n    }\n    if number == remaining {\n        return nil\n\
    \    }\n    if number > 1000 {\n        return nil\n    }\n    if need > 1000\
    \ {\n        return nil\n    }\n    if remaining > 1000 {\n        return nil\n\
    \    }\n    if number > 1000 {\n        return nil\n    }\n    if need > 1000\
    \ {\n        return nil\n    }\n    if remaining > 1000 {\n        return nil\n\
    \    }\n    if number > 1000 {\n        return nil\n    }\n    if need > 1000\
    \ {\n        return nil\n    }\n    if remaining > 1000 {\n        return nil\n\
    \    }\n    if number > 1000 {\n        return nil\n    }\n    if need > 1000\
    \ {\n        return nil\n    }\n    if remaining > 1000 {\n        return nil\n\
    \    }\n    if number > 1000 {\n        return nil\n    }\n    if need > 1000\
    \ {\n        return nil\n    }\n    if remaining > 1000 {\n        return nil\n\
    \    }\n    if number > 1000 {\n        return nil\n    }\n    if need > 1000\
    \ {\n        return nil\n    }\n    if remaining > 1000 {\n        return nil\n\
    \    }\n    if number > 1000 {\n        return nil\n    }\n    if need > 1000\
    \ {\n        return nil\n    }\n    if remaining > 1000 {\n        return nil\n\
    \    }\n    if number > 1000 {\n        return nil\n    }\n    if need > 1000\
    \ {\n        return nil\n    }\n    if remaining > 1000 {\n        return nil\n\
    \    }\n    if number > 1000 {\n        return nil\n    }\n    if need > 1000\
    \ {\n        return nil\n    }\n    if remaining > 1000 {\n        return nil\n\
    \    }\n    if number > 1000 {\n        return nil\n    }\n    if need > 1000\
    \ {\n        return nil\n    }\n    if remaining > 1000 {\n        return nil\n\
    \    }\n    if number > 1000 {\n        return nil\n    }\n    if need > 1000\
    \ {\n        return nil\n    }\n    if remaining > 1000 {\n        return nil\n\
    \    }\n    if number > 1000 {\n        return nil\n    }\n    if need > 1000\
    \ {\n        return nil\n    }\n    if remaining > 100\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9d8ga96v_test.go:172:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    if number < 0 {\n        return\
    \ []int{0, 0}\n    }\n    if need < 0 {\n        return []int{0, 0}\n    }\n \
    \   if remaining < 0 {\n        return []int{0, 0}\n    }\n    if number == 0\
    \ {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if need >\
    \ remaining {\n        return []int{0, 0}\n    }\n    if number == need {\n  \
    \      return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need + 1 {\n        return []int{number,\
    \ 0}\n    }\n    if number > need + 1 {\n        return []int{0, 0}\n    }\n \
    \   if number == need + 2 {\n        return []int{number, 0}\n    }\n    if number\
    \ > need + 2 {\n        return []int{0, 0}\n    }\n    if number == need + 3 {\n\
    \        return []int{number, 0}\n    }\n    if number > need + 3 {\n        return\
    \ []int{0, 0}\n    }\n    if number == need + 4 {\n        return []int{number,\
    \ 0}\n    }\n    if number > need + 4 {\n        return []int{0, 0}\n    }\n \
    \   if number == need + 5 {\n        return []int{number, 0}\n    }\n    if number\
    \ > need + 5 {\n        return []int{0, 0}\n    }\n    if number == need + 6 {\n\
    \        return []int{number, 0}\n    }\n    if number > need + 6 {\n        return\
    \ []int{0, 0}\n    }\n    if number == need + 7 {\n        return []int{number,\
    \ 0}\n    }\n    if number > need + 7 {\n        return []int{0, 0}\n    }\n \
    \   if number == need + 8 {\n        return []int{number, 0}\n    }\n    if number\
    \ > need + 8 {\n        return []int{0, 0}\n    }\n    if number == need + 9 {\n\
    \        return []int{number, 0}\n    }\n    if number > need + 9 {\n        return\
    \ []int{0, 0}\n    }\n    if number == need + 10 {\n        return []int{number,\
    \ 0}\n    }\n    if number > need + 10 {\n        return []int{0, 0}\n    }\n\
    \    if number == need + 11 {\n        return []int{number, 0}\n    }\n    if\
    \ number > need + 11 {\n        return []int{0, 0}\n    }\n    if number == need\
    \ + 12 {\n        return []int{number, 0}\n    }\n    if number > need + 12\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwz7mnen__test.go:137:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n \
    \       carrots = 1000\n    }\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n  \
    \  if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n       \
    \ carrots = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    if\
    \ carrots < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n       \
    \ carrots = 1000\n    }\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots -=\
    \ number\n    carrots -= need\n    carrots -= remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    if carrots > 1000 {\n        carrots = 1000\n\
    \    }\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    if carrots > 1000 {\n \
    \       carrots = 1000\n    }\n    carrots -= number\n    carrots -= need\n  \
    \  carrots -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n  \
    \  if carrots > 1000 {\n        carrots = 1000\n    }\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5twhqcal_test.go:129:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    if remaining > 0 {\n        carrots = remaining\n        meals = number\n\
    \    }\n    if carrots > 0 {\n        meals = meals + 1\n    }\n    if meals >\
    \ need {\n        meals = need\n    }\n    if meals > 0 {\n        carrots = carrots\
    \ - meals\n    }\n    if carrots > 0 {\n        carrots = carrots + 1\n    }\n\
    \    return []int{carrots, carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpv8cv2_lc_test.go:77: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpv8cv2_lc_test.go:77:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=5) %!s(int=5)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpv8cv2_lc_test.go:77: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=9) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpv8cv2_lc_test.go:77: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=3) %!s(int=3)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpv8cv2_lc_test.go:77: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=3)\
    \ %!s(int=3)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpv8cv2_lc_test.go:77:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=-4) %!s(int=-4)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots =\
    \ number\n    carrots = carrots - need\n    carrots = carrots - remaining\n  \
    \  carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n\
    \    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots +\
    \ 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp79mpfrvo_test.go:93:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number > 1000 || need > 1000 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n\
    \    if remaining < need {\n        return []int{0, 0}\n    }\n    if number <\
    \ need {\n        carrots = number\n    } else {\n        carrots = need\n   \
    \ }\n    carrots = carrots - remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n    carrots\
    \ = carrots + 1\n    carrots = carrots + 1\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    carrots = carrots + 1\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    carrots = carrots + 1\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    carrots = carrots + 1\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    carrots = carrots + 1\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    carrots = carrots + 1\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    carrots = carrots + 1\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    carrots = carrots + 1\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    carrots = carrots + 1\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    carrots = carrots + 1\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    carrots = carrots + 1\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    carrots = carrots + 1\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    carrots = carrots + 1\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    carrots = carrots + 1\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    carrots = carrots + 1\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    carrots = carrots + 1\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    carrots = car\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcx71b_hi_test.go:123:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    carrots = number - need\n    if\
    \ carrots < 0 {\n        carrots = 0\n    }\n    if carrots > remaining {\n  \
    \      carrots = remaining\n    }\n    return []int{carrots, remaining}\n}\n</code>\n\
    <|/ a dscore=0 |>\n<| c |>\nThis doesn't work when `need` is greater than `remaining`\n\
    <|/ c |>\n<| c |>\nI see what you mean. I'll fix it.\n<|/ c |>\n<| c |>\nI fixed\
    \ it. I just added a test case to show that it works.\n<|/ c |>\n<| c |>\nI added\
    \ a test case to show that it works.\n<|/ c |>\n<| c |>\nI added a test case to\
    \ show that it works.\n<|/ c |>\n<| a tags=algorithm,dynamic-programming,recursion,go\
    \ |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjkk58jpz_test.go:46:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if remaining\
    \ > 0 {\n        carrots = remaining\n    }\n    meals := []int{0, 0}\n    if\
    \ number > need {\n        meals[0] = number\n        meals[1] = need\n    } else\
    \ {\n        meals[0] = need\n        meals[1] = number\n    }\n    for i := 0;\
    \ i < len(meals); i++ {\n        carrots += meals[i]\n    }\n    if carrots >\
    \ 0 {\n        meals[0] = carrots\n    }\n    return meals\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpauyghv9n_test.go:77: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpauyghv9n_test.go:77:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpauyghv9n_test.go:77: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpauyghv9n_test.go:77: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpauyghv9n_test.go:77: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpauyghv9n_test.go:77:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    meals := 0\n    for i := 0; i < number; i++ {\n        carrots += i\n   \
    \ }\n    for i := 0; i < need; i++ {\n        meals += i\n    }\n    if carrots\
    \ < remaining {\n        carrots = remaining\n    }\n    if meals < remaining\
    \ {\n        meals = remaining\n    }\n    if carrots == 0 {\n        carrots\
    \ = remaining\n    }\n    if meals == 0 {\n        meals = remaining\n    }\n\
    \    if carrots > 0 {\n        carrots = carrots - 1\n    }\n    if meals > 0\
    \ {\n        meals = meals - 1\n    }\n    if carrots == 0 {\n        carrots\
    \ = remaining\n    }\n    if meals == 0 {\n        meals = remaining\n    }\n\
    \    if carrots > 0 {\n        carrots = carrots - 1\n    }\n    if meals > 0\
    \ {\n        meals = meals - 1\n    }\n    if carrots == 0 {\n        carrots\
    \ = remaining\n    }\n    if meals == 0 {\n        meals = remaining\n    }\n\
    \    if carrots > 0 {\n        carrots = carrots - 1\n    }\n    if meals > 0\
    \ {\n        meals = meals - 1\n    }\n    if carrots == 0 {\n        carrots\
    \ = remaining\n    }\n    if meals == 0 {\n        meals = remaining\n    }\n\
    \    if carrots > 0 {\n        carrots = carrots - 1\n    }\n    if meals > 0\
    \ {\n        meals = meals - 1\n    }\n    if carrots == 0 {\n        carrots\
    \ = remaining\n    }\n    if meals == 0 {\n        meals = remaining\n    }\n\
    \    if carrots > 0 {\n        carrots = carrots - 1\n    }\n    if meals > 0\
    \ {\n        meals = meals - 1\n    }\n    if carrots == 0 {\n        carrots\
    \ = remaining\n    }\n    if meals == 0 {\n        meals = remaining\n    }\n\
    \    if carrots > 0 {\n        carrots = carrots - 1\n    }\n    if meals > 0\
    \ {\n        meals = meals - 1\n    }\n    if carrots == 0 {\n        carrot\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpksba8ab2_test.go:132:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int, 2)\n\
    \    if remaining < need {\n        result[0] = 0\n        result[1] = 0\n   \
    \     return result\n    }\n    carrots := 0\n    carrots = number - need\n  \
    \  if carrots > 0 {\n        result[0] = carrots\n        result[1] = 0\n    }\
    \ else {\n        result[0] = 0\n        result[1] = remaining\n    }\n    return\
    \ result\n}\n</code>\n<|/ a tags=algorithm,dynamic-programming |>\n<| c |>\nI\
    \ like your solution, however I believe it can be simplified a bit. Instead of\
    \ having a `carrot` variable and an `eating` variable you can just have `carrot`\
    \ and `eating` as parameters and return `carrot` and `eating` as results. Also\
    \ instead of `if carrots > 0` you can just do `if carrots == 0`.\n<|/ c |>\n<|\
    \ c |>\nYes, you are right. Thanks for your suggestion.\n<|/ c |>\n<| c |>\nThanks\
    \ for your solution. Can you please explain how you came up with that solution?\
    \ I am new to dynamic programming and I am not able to understand how you came\
    \ up with that solution.\n<|/ c |>\n<| c |>\nI used the concept of memoization.\
    \ Basically, you have a function `eat` that takes three parameters: the number\
    \ of carrots you have eaten, the number of carrots you need to eat, and the remaining\
    \ carrots in stock. Since you only need to know the number of carrots left after\
    \ your meals, you can store this value in a variable `remaining`. Then, whenever\
    \ you call `eat`, you only need to check the value of `remaining` against the\
    \ value you already have stored in `remaining`. If `remaining` equals the value\
    \ you already have stored in `remaining`, then you know that you have eaten all\
    \ the carrots you have left. Otherwise, you can subtract `need` from `remaining`\
    \ and call `eat` again, storing the result in the variable `remaining`. Hope this\
    \ helps!\n<|/ c |>\n<| c |>\nThanks for your explanation. I am still not able\
    \ to understand how you came up with that solution. Can you please explain how\
    \ you came up with that solution?\n<|/ c |>\n<| a tags=algorithm,dynamic-programming\
    \ |>\n<code>\ndef eat(need, carrots):\n    carrots = carrots - need\n    if carrots\
    \ < 0:\n        return 0, 0\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4u78kmtj_test.go:55:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || number < 0 {\n        return []int{0, 0}\n    }\n    if need\
    \ > 1000 || need < 0 {\n        return []int{0, 0}\n    }\n    if remaining >\
    \ 1000 || remaining < 0 {\n        return []int{0, 0}\n    }\n    carrots := 0\n\
    \    if number > need {\n        carrots = number-need\n    } else {\n       \
    \ carrots = need\n    }\n    if carrots > remaining {\n        carrots = remaining\n\
    \    }\n    carrots = carrots + number\n    return []int{carrots, carrots-number}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp82clwe10_test.go:75: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=11)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp82clwe10_test.go:75:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=12) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp82clwe10_test.go:75: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=11) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp82clwe10_test.go:75: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=7) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp82clwe10_test.go:75: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=9)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp82clwe10_test.go:75:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{}\n    }\n    result := make([]int, 2)\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots -= remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    result[0] = carrots\n \
    \   result[1] = remaining\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpm_f1c1ym_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpm_f1c1ym_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpm_f1c1ym_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpm_f1c1ym_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpm_f1c1ym_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpm_f1c1ym_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075202
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ < need {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n        return\
    \ result\n    }\n    if remaining == 0 {\n        result[0] = number\n       \
    \ result[1] = need\n        return result\n    }\n    if number > remaining {\n\
    \        result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if need > remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if number > remaining\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if need > remaining {\n        result[0] = need\n       \
    \ result[1] = remaining\n        return result\n    }\n    if number > need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number > need {\n        result[0] = number\n        result[1] =\
    \ need\n        return result\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > need {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number == need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number == remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > remaining {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if need > remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == need {\n        result[0] = number\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8ehk9rsz_test.go:171:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return nil\n   \
    \ }\n    result := make([]int, 2)\n    result[0] = number\n    result[1] = remaining\n\
    \    if number < need {\n        result[0] = need\n        result[1] = remaining\n\
    \    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpk493wvsu_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpk493wvsu_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpk493wvsu_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpk493wvsu_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpk493wvsu_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpk493wvsu_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075202
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 && need == 0 && remaining == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 && need == 0 {\n        return []int{0, remaining}\n\
    \    }\n    if number == 0 && remaining == 0 {\n        return []int{need, 0}\n\
    \    }\n    if need == 0 {\n        return []int{number, remaining}\n    }\n \
    \   if remaining == 0 {\n        return []int{number, need}\n    }\n    if number\
    \ > need {\n        return []int{number, need}\n    }\n    if number > remaining\
    \ {\n        return []int{number, remaining}\n    }\n    if need > remaining {\n\
    \        return []int{need, remaining}\n    }\n    if number > need && need >\
    \ remaining {\n        return []int{number, need}\n    }\n    if number > remaining\
    \ && remaining > need {\n        return []int{number, remaining}\n    }\n    if\
    \ number > need && need > remaining {\n        return []int{number, need}\n  \
    \  }\n    if number > remaining && remaining > need {\n        return []int{number,\
    \ remaining}\n    }\n    if number > need && need > remaining {\n        return\
    \ []int{number, need}\n    }\n    if number > remaining && remaining > need {\n\
    \        return []int{number, remaining}\n    }\n    if number > need && need\
    \ > remaining {\n        return []int{number, need}\n    }\n    if number > remaining\
    \ && remaining > need {\n        return []int{number, remaining}\n    }\n    if\
    \ number > need && need > remaining {\n        return []int{number, need}\n  \
    \  }\n    if number > remaining && remaining > need {\n        return []int{number,\
    \ remaining}\n    }\n    if number > need && need > remaining {\n        return\
    \ []int{number, need}\n    }\n    if number > remaining && remaining > need {\n\
    \        return []int{number, remaining}\n    }\n    if number > need && need\
    \ > remaining {\n        return []int{number, need}\n    }\n    if number > remaining\
    \ && remaining > need {\n        return []int{number, remaining}\n    }\n    if\
    \ number > need && need > remaining {\n        return []int{number, need}\n  \
    \  }\n    if number > remaining && remaining > need {\n        return []int{number,\
    \ remaining}\n    }\n    if number > need && need > remaining {\n        return\
    \ []int{number, need}\n    }\n    if number > remaining && remaining > need {\n\
    \        return []int{number, remaining}\n    }\n    if number > need && need\
    \ > remaining {\n        return []int{number, need}\n    }\n    if number > remaining\
    \ \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz49c_33z_test.go:120:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number-need\n\
    \    } else {\n        carrots = need\n    }\n    if carrots > remaining {\n \
    \       carrots = remaining\n    }\n    return []int{carrots, 0}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmps21ekjty_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmps21ekjty_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmps21ekjty_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmps21ekjty_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmps21ekjty_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmps21ekjty_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075197
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number-need\n\
    \    } else {\n        carrots = need\n    }\n    if carrots > remaining {\n \
    \       carrots = remaining\n    }\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    return []int{carrots, carrots}\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp50hxl029_test.go:70: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=8)\
    \ %!s(int=8)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp50hxl029_test.go:70:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=10) %!s(int=10)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp50hxl029_test.go:70: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=12) %!s(int=12)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp50hxl029_test.go:70: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=7) %!s(int=7)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp50hxl029_test.go:70: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp50hxl029_test.go:70:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=3) %!s(int=3)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075202
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 || number > 1000 {\n        return nil\n    }\n    if\
    \ need < 0 || need > 1000 {\n        return nil\n    }\n    if remaining < 0 ||\
    \ remaining > 1000 {\n        return nil\n    }\n    if number == 0 {\n      \
    \  return nil\n    }\n    if remaining == 0 {\n        return make([]int, 0, number)\n\
    \    }\n    if number > need {\n        return nil\n    }\n    if number > remaining\
    \ {\n        carrots = number\n    } else {\n        carrots = remaining\n   \
    \ }\n    return make([]int, 0, number+carrots)\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp8nx1ij8h_test.go:80: expected '[%!s(int=11) %!s(int=4)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp8nx1ij8h_test.go:80: expected\
    \ '[%!s(int=12) %!s(int=1)]', got '[]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n\
    \        tmp8nx1ij8h_test.go:80: expected '[%!s(int=11) %!s(int=0)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__3 (0.00s)\n        tmp8nx1ij8h_test.go:80: expected\
    \ '[%!s(int=7) %!s(int=0)]', got '[]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp8nx1ij8h_test.go:80: expected '[%!s(int=9) %!s(int=2)]', got '[]'\n\
    \    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp8nx1ij8h_test.go:80: expected\
    \ '[%!s(int=5) %!s(int=0)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660075202
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number == 0 {\n        result[0] = 0\n        result[1] = 0\n\
    \        return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = 0\n        return result\n    }\n    if number > need {\n\
    \        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number < need {\n        result[0] = need\n        result[1] =\
    \ number\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if number > remaining {\n        result[0] = remaining\n        result[1]\
    \ = number\n        return result\n    }\n    if number < remaining {\n      \
    \  result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp98xl3rjk_test.go:74:1: missing return

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075202
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number\n\
    \    } else {\n        carrots = need\n    }\n    if carrots > remaining {\n \
    \       carrots = remaining\n    }\n    carrots = carrots + number\n    carrots\
    \ = carrots - need\n    carrots = carrots + number\n    carrots = carrots - need\n\
    \    carrots = carrots + number\n    carrots = carrots - need\n    carrots = carrots\
    \ + number\n    carrots = carrots - need\n    carrots = carrots + number\n   \
    \ carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = car\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnn55_0di_test.go:97:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    carrots = carrots - number\n    carrots = carrots - need\n    carrots\
    \ = carrots - remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n  \
    \  return []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpipiuijcr_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpipiuijcr_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpipiuijcr_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpipiuijcr_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpipiuijcr_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpipiuijcr_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if remaining\
    \ < need {\n        return []int{0, 0}\n    }\n    if number < need {\n      \
    \  return []int{number, 0}\n    }\n    carrots := 0\n    carrots += number\n \
    \   carrots += need\n    carrots += remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots += number\n    carrots\
    \ += need\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpat_5hoet_test.go:117:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need < 0 || need > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        result[0] = remaining\n        result[1]\
    \ = need\n        return result\n    }\n    if need == 0 {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ remaining == 0 {\n        result[0] = number\n        result[1] = need\n   \
    \     return result\n    }\n    if number > need {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if number > remaining {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need > remaining {\n     \
    \   fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number ==\
    \ need {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = need\n        return result\n    }\n    if number > need {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ > remaining {\n        fmt.Println(\"Invalid input\")\n        return nil\n\
    \    }\n    if need > remaining {\n        fmt.Println(\"Invalid input\")\n  \
    \      return nil\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ remaining {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number > need {\n        fmt.Println(\"Invalid input\"\
    )\n        return nil\n    }\n    if number > remaining {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if need > remaining {\n     \
    \   fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number ==\
    \ need {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = need\n        return result\n    }\n    if number > need {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ > remaining {\n        fmt.Println(\"Invalid input\")\n        return nil\n\
    \    }\n    if need > remaining {\n        fmt.Println(\"Invalid input\")\n  \
    \      return nil\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ remaining {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number > need {\n        fmt.Println(\"Invalid input\"\
    )\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4ux6uf5z_test.go:154:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > remaining {\n        carrots =\
    \ number-remaining\n    } else {\n        carrots = remaining\n    }\n    if carrots\
    \ > need {\n        carrots = need\n    }\n    if carrots == 0 {\n        carrots\
    \ = 1\n    }\n    return []int{carrots, 0}\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpn_kfd8xn_test.go:71: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpn_kfd8xn_test.go:71:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpn_kfd8xn_test.go:71: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpn_kfd8xn_test.go:71: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpn_kfd8xn_test.go:71: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpn_kfd8xn_test.go:71:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=3) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075202
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots += number\n    carrots += need\n\
    \    carrots -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    return []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpb2g4yxll_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpb2g4yxll_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpb2g4yxll_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpb2g4yxll_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpb2g4yxll_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpb2g4yxll_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075202
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0hiq1d6j_test.go:108:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n        return nil\n    }\n    if number == 0 {\n        result[0] = remaining\n\
    \        result[1] = remaining\n    } else {\n        result[0] = number\n   \
    \     result[1] = need\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpoibqe6vv_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpoibqe6vv_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpoibqe6vv_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpoibqe6vv_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpoibqe6vv_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpoibqe6vv_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075202
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots = number - need\n    if carrots < 0\
    \ {\n        carrots = 0\n    }\n    carrots = carrots + remaining\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    return []int{carrots, carrots -\
    \ carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpzh93z8m2_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpzh93z8m2_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpzh93z8m2_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpzh93z8m2_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpzh93z8m2_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpzh93z8m2_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075202
- exit_code: 2
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    for i := 0; i < number; i++ {\n        carrots += eatCarrot()\n    }\n\
    \    meals = number-carrots\n    for i := 0; i < need; i++ {\n        carrots\
    \ += eatCarrot()\n    }\n    remaining -= carrots\n    if remaining <= 0 {\n \
    \       remaining = 0\n    }\n    return []int{meals, remaining}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpudtjye4__test.go:41:20: undefined: eatCarrot

    /tmp/tmpudtjye4__test.go:45:20: undefined: eatCarrot

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075202
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > remaining {\n        carrots = number\n    } else {\n        carrots = remaining\n\
    \    }\n    carrots = carrots + need\n    carrots = carrots + number\n    carrots\
    \ = carrots + number\n    carrots = carrots + number\n    carrots = carrots +\
    \ number\n    carrots = carrots + number\n    carrots = carrots + number\n   \
    \ carrots = carrots + number\n    carrots = carrots + number\n    carrots = carrots\
    \ + number\n    carrots = carrots + number\n    carrots = carrots + number\n \
    \   carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    carrots = carrots + number\n    carrots = carrots + number\n\
    \    carrots = carrots + number\n    carrots = carrots + number\n    carrots =\
    \ carrots + number\n    car\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu51abppj_test.go:95:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0hiq1d6j_test.go:108:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return nil\n    }\n    if need < 0 ||\
    \ need > 1000 {\n        return nil\n    }\n    if remaining < 0 || remaining\
    \ > 1000 {\n        return nil\n    }\n    result := make([]int, 2)\n    if number\
    \ == 0 {\n        result[0] = 0\n        result[1] = 0\n        return result\n\
    \    }\n    if remaining == 0 {\n        result[0] = number\n        result[1]\
    \ = 0\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number < need {\n        result[0] = need\n        result[1] = number\n    \
    \    return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = number\n        return result\n    }\n    if number > need\
    \ {\n        result[0] = number\n        result[1] = remaining\n        return\
    \ result\n    }\n    if number < need {\n        result[0] = need\n        result[1]\
    \ = number\n        return result\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = number\n        return result\n    }\n    if number\
    \ > need {\n        result[0] = number\n        result[1] = remaining\n      \
    \  return result\n    }\n    if number < need {\n        result[0] = need\n  \
    \      result[1] = number\n        return result\n    }\n    if number == need\
    \ {\n        result[0] = number\n        result[1] = number\n        return result\n\
    \    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < need {\n        result[0]\
    \ = need\n        result[1] = number\n        return result\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = number\n        return\
    \ result\n    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < need {\n        result[0]\
    \ = need\n        result[1] = number\n        return result\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = number\n        return\
    \ result\n    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < need {\n        result[0]\
    \ = need\n        result[1] = number\n        return result\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = number\n        return\
    \ result\n    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < need {\n        result[0]\
    \ = need\n        result[1] = number\n        return result\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = number\n        return\
    \ result\n    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number < need {\n        result[0]\
    \ = need\n        result[1] = number\n        return result\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = number\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppjr_bqoe_test.go:173:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots = number - need\n    if carrots < 0\
    \ {\n        carrots = 0\n    }\n    if carrots > remaining {\n        carrots\
    \ = remaining\n    }\n    carrots = carrots + 1\n    carrots = carrots + 1\n \
    \   carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots +\
    \ 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrot\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdxev1l88_test.go:96:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return nil\n    }\n    result := make([]int, 2)\n    if number\
    \ > need {\n        result[0] = number\n        result[1] = need\n    } else {\n\
    \        result[0] = need\n        result[1] = number\n    }\n    if number >\
    \ remaining {\n        result[0] = number\n        result[1] = remaining\n   \
    \ }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmphwh_qlj7_test.go:71: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmphwh_qlj7_test.go:71:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmphwh_qlj7_test.go:71: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmphwh_qlj7_test.go:71: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmphwh_qlj7_test.go:71: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmphwh_qlj7_test.go:71:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == 0 {\n        result[0] = remaining\n        result[1] = need\n        return\
    \ result\n    }\n    if need == 0 {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if remaining == 0 {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number > need {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = remaining\n        result[1] = number\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number > need && need > remaining {\n  \
    \      result[0] = number\n        result[1] = need\n        return result\n \
    \   }\n    if number > remaining && remaining > need {\n        result[0] = remaining\n\
    \        result[1] = number\n        return result\n    }\n    if number > need\
    \ && need > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > remaining && remaining > need {\n\
    \        result[0] = remaining\n        result[1] = number\n        return result\n\
    \    }\n    if number > need && need > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > remaining\
    \ && remaining > need {\n        result[0] = remaining\n        result[1] = number\n\
    \        return result\n    }\n    if number > need && need > remaining {\n  \
    \      result[0] = number\n        result[1] = need\n        return result\n \
    \   }\n    if number > remaining && remaining > need {\n        result[0] = remaining\n\
    \        result[1] = number\n        return result\n    }\n    if number > need\
    \ && need > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > remaining && remaining > need {\n\
    \        result[0] = remaining\n        result[1] = number\n        return result\n\
    \    }\n    if number > need && need > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > remaining\
    \ && remaining > need {\n        result[0] = remaining\n        result[1] = number\n\
    \        return result\n    }\n    if number > need && need > remaining {\n  \
    \      result[0] = number\n        result[1] = need\n        return result\n \
    \   }\n    if number > remaining && remaining > need {\n        result[0] = remaining\n\
    \        result[1] = number\n        return result\n    }\n    if number > need\
    \ && need > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if number > remaining && remaining > need {\n\
    \        result[0] = remaining\n        result[1] = number\n        return result\n\
    \    }\n    if number > need && need > remaining {\n        result[0] = number\n\
    \        result[1] = need\n        return result\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwj4oww2n_test.go:154:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075202
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ < need {\n        carrots = number\n    } else {\n        carrots = need\n \
    \   }\n    if carrots > remaining {\n        carrots = remaining\n    }\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = carrots + number\n    carrots = carrots - need\n    carrots = carrots + number\n\
    \    carrots = carrots - need\n    carrots = carrots + number\n    carrots = carrots\
    \ - need\n    carrots = carrots + number\n    carrots = carrots - need\n    carrots\
    \ = car\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp118g6ybo_test.go:96:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075202
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > remaining {\n        carrots = number-remaining\n    } else {\n        carrots\
    \ = remaining\n    }\n    if carrots > need {\n        carrots = need\n    }\n\
    \    if carrots == 0 {\n        return []int{0, 0}\n    }\n    carrots -= need\n\
    \    carrots += number\n    carrots %= 100\n    if carrots == 0 {\n        return\
    \ []int{0, 0}\n    }\n    carrots -= number\n    carrots %= 100\n    if carrots\
    \ == 0 {\n        return []int{0, 0}\n    }\n    carrots -= need\n    carrots\
    \ %= 100\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n    carrots\
    \ -= number\n    carrots %= 100\n    if carrots == 0 {\n        return []int{0,\
    \ 0}\n    }\n    carrots -= need\n    carrots %= 100\n    if carrots == 0 {\n\
    \        return []int{0, 0}\n    }\n    carrots -= number\n    carrots %= 100\n\
    \    if carrots == 0 {\n        return []int{0, 0}\n    }\n    carrots -= need\n\
    \    carrots %= 100\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n\
    \    carrots -= number\n    carrots %= 100\n    if carrots == 0 {\n        return\
    \ []int{0, 0}\n    }\n    carrots -= need\n    carrots %= 100\n    if carrots\
    \ == 0 {\n        return []int{0, 0}\n    }\n    carrots -= number\n    carrots\
    \ %= 100\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n    carrots\
    \ -= need\n    carrots %= 100\n    if carrots == 0 {\n        return []int{0,\
    \ 0}\n    }\n    carrots -= number\n    carrots %= 100\n    if carrots == 0 {\n\
    \        return []int{0, 0}\n    }\n    carrots -= need\n    carrots %= 100\n\
    \    if carrots == 0 {\n        return []int{0, 0}\n    }\n    carrots -= number\n\
    \    carrots %= 100\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n\
    \    carrots -= need\n    carrots %= 100\n    if carrots == 0 {\n        return\
    \ []int{\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxezp1olq_test.go:125:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075202
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number < 0 || number > 1000 || need < 0 || need >\
    \ 1000 || remaining < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\"\
    )\n        return nil\n    }\n    if number == 0 {\n        result[0] = need\n\
    \        result[1] = remaining\n        return result\n    }\n    if remaining\
    \ == 0 {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > remaining {\n        result[0]\
    \ = remaining\n        result[1] = number\n        return result\n    }\n    if\
    \ need > remaining {\n        result[0] = need\n        result[1] = remaining\n\
    \        return result\n    }\n    if number == need {\n        result[0] = number\n\
    \        result[1] = remaining\n        return result\n    }\n    if number ==\
    \ remaining {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number > need && number > remaining {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if need\
    \ > number && need > remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if remaining > number && remaining\
    \ > need {\n        result[0] = remaining\n        result[1] = need\n        return\
    \ result\n    }\n    if number == need && remaining == 0 {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == remaining && need == 0 {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number > need && number > remaining\
    \ && need > remaining {\n        result[0] = number\n        result[1] = need\n\
    \        return result\n    }\n    if need > number && need > remaining && remaining\
    \ > need {\n        result[0] = need\n        result[1] = remaining\n        return\
    \ result\n    }\n    if remaining > number && remaining > need && need > remaining\
    \ {\n        result[0] = remaining\n        result[1] = need\n        return result\n\
    \    }\n    if number == need && remaining == 0 && need == 0 {\n        result[0]\
    \ = number\n        result[1] = remaining\n        return result\n    }\n    if\
    \ number == remaining && need == 0 && remaining == 0 {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ && number > remaining && need > remaining && remaining > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if need\
    \ > number && need > remaining && remaining > need && need > remaining {\n   \
    \     result[0] = need\n        result[1] = remaining\n        return result\n\
    \    }\n    if remaining > number && remaining > need && need > remaining && remaining\
    \ > need {\n        result[0] = remaining\n        result[1] = need\n        return\
    \ result\n    }\n    if number == need && remaining == 0 && need == 0 && remaining\
    \ == 0 {\n        result[0] = number\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp48aj3hby_test.go:143:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075202
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 || number > 1000 || need < 0 || need > 1000 || remaining\
    \ < 0 || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        return nil\n    }\n    if remaining\
    \ == 0 {\n        return append([]int{number, need}, 0)\n    }\n    if number\
    \ > need {\n        fmt.Println(\"Invalid input\")\n        return nil\n    }\n\
    \    if number == need {\n        return append([]int{number, need}, 0)\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"Invalid input\")\n       \
    \ return nil\n    }\n    if number == remaining {\n        return append([]int{number,\
    \ need}, 0)\n    }\n    if number > need {\n        fmt.Println(\"Invalid input\"\
    )\n        return nil\n    }\n    if number == need {\n        return append([]int{number,\
    \ need}, 0)\n    }\n    if number > remaining {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if number == remaining {\n        return\
    \ append([]int{number, need}, 0)\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ return append([]int{number, need}, 0)\n    }\n    if number > remaining {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == remaining {\n        return append([]int{number, need}, 0)\n    }\n    if\
    \ number > need {\n        fmt.Println(\"Invalid input\")\n        return nil\n\
    \    }\n    if number == need {\n        return append([]int{number, need}, 0)\n\
    \    }\n    if number > remaining {\n        fmt.Println(\"Invalid input\")\n\
    \        return nil\n    }\n    if number == remaining {\n        return append([]int{number,\
    \ need}, 0)\n    }\n    if number > need {\n        fmt.Println(\"Invalid input\"\
    )\n        return nil\n    }\n    if number == need {\n        return append([]int{number,\
    \ need}, 0)\n    }\n    if number > remaining {\n        fmt.Println(\"Invalid\
    \ input\")\n        return nil\n    }\n    if number == remaining {\n        return\
    \ append([]int{number, need}, 0)\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n        return nil\n    }\n    if number == need {\n       \
    \ return append([]int{number, need}, 0)\n    }\n    if number > remaining {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == remaining {\n        return append([]int{number, need}, 0)\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr5a5jdgd_test.go:130:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075202
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number > 1000 || need > 1000 || remaining > 1000 {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        carrots = number\n\
    \    } else {\n        carrots = remaining\n    }\n    if carrots > need {\n \
    \       carrots = need\n    }\n    if carrots == 0 {\n        return []int{0,\
    \ 0}\n    }\n    carrots = carrots - need\n    carrots = carrots + number\n  \
    \  carrots = carrots + need\n    carrots = carrots - number\n    carrots = carrots\
    \ + number\n    carrots = carrots + need\n    carrots = carrots - number\n   \
    \ carrots = carrots + number\n    carrots = carrots + need\n    carrots = carrots\
    \ - number\n    carrots = carrots + number\n    carrots = carrots + need\n   \
    \ carrots = carrots - number\n    carrots = carrots + number\n    carrots = carrots\
    \ + need\n    carrots = carrots - number\n    carrots = carrots + number\n   \
    \ carrots = carrots + need\n    carrots = carrots - number\n    carrots = carrots\
    \ + number\n    carrots = carrots + need\n    carrots = carrots - number\n   \
    \ carrots = carrots + number\n    carrots = carrots + need\n    carrots = carrots\
    \ - number\n    carrots = carrots + number\n    carrots = carrots + need\n   \
    \ carrots = carrots - number\n    carrots = carrots + number\n    carrots = carrots\
    \ + need\n    carrots = carrots - number\n    carrots = carrots + number\n   \
    \ carrots = carrots + need\n    carrots = carrots - number\n    carrots = carrots\
    \ + number\n    carrots = carrots + need\n    carrots = carrots - number\n   \
    \ carrots = carrots + number\n    carrots = carrots + need\n    carrots = carrots\
    \ - number\n    carrots = carrots + number\n    carrots = carrots + need\n   \
    \ carrots = carrots - number\n    carrots = carrots + number\n    carrots = carrots\
    \ + need\n    carrots = carrots - number\n    carrots = carrots + number\n   \
    \ carrots = carrots + need\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpuc1khu2f_test.go:99:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075202
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph157ga60_test.go:141:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    carrots\
    \ := 0\n    result [0] = carrots\n    result [1] = remaining\n    if carrots >=\
    \ need {\n        carrots -= need\n        result [0] = carrots\n    } else {\n\
    \        carrots = remaining\n        result [0] = carrots\n        result [1]\
    \ = 0\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpg47c8ann_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpg47c8ann_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpg47c8ann_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpg47c8ann_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpg47c8ann_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpg47c8ann_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    if number < 0 || number > 1000 {\n        return []int{0, 0}\n   \
    \ }\n    if need < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n   \
    \ if remaining < 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n\
    \        return []int{number, 0}\n    }\n    if remaining == 0 {\n        return\
    \ []int{0, number}\n    }\n    if number > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n  \
    \  if number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        carrots = number-need\n    }\n    if need > number {\n   \
    \     carrots = need-number\n    }\n    if carrots == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if carrots > remaining {\n        carrots = remaining\n    }\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    return []int{carrots, 0}\n\
    }\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpfzpzkex4_test.go:98: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpfzpzkex4_test.go:98:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpfzpzkex4_test.go:98: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpfzpzkex4_test.go:98: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpfzpzkex4_test.go:98: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=1)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpfzpzkex4_test.go:98:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    result := []int{0, 0}\n    carrots := 0\n    for i := 0; i <\
    \ number; i++ {\n        carrots += need\n        result[0] += carrots\n     \
    \   carrots -= remaining\n        result[1] += carrots\n    }\n    return result\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpdori45om_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=-10)\
    \ %!s(int=-60)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpdori45om_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=26) %!s(int=-10)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpdori45om_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpdori45om_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=28) %!s(int=18)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpdori45om_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=8)\
    \ %!s(int=-20)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpdori45om_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=44) %!s(int=40)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == 0 {\n        result[0] = remaining\n        result[1] = remaining\n    }\
    \ else {\n        result[0] = number\n        result[1] = need\n    }\n    return\
    \ result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpv3y8vg_5_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpv3y8vg_5_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpv3y8vg_5_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpv3y8vg_5_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpv3y8vg_5_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpv3y8vg_5_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    carrots = number\n    meals = need\n    carrots = carrots - meals\n \
    \   carrots = carrots - remaining\n    carrots = carrots + meals\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + meals\n    carrots = carrots\
    \ + remaining\n    carrots = carrots + meals\n    carrots = carrots + remaining\n\
    \    carrots = carrots + meals\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + meals\n    carrots = carrots + remaining\n    carrots = carrots\
    \ + meals\n    carrots = carrots + remaining\n    carrots = carrots + meals\n\
    \    carrots = carrots + remaining\n    carrots = carrots + meals\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + meals\n    carrots = carrots\
    \ + remaining\n    carrots = carrots + meals\n    carrots = carrots + remaining\n\
    \    carrots = carrots + meals\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + meals\n    carrots = carrots + remaining\n    carrots = carrots\
    \ + meals\n    carrots = carrots + remaining\n    carrots = carrots + meals\n\
    \    carrots = carrots + remaining\n    carrots = carrots + meals\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + meals\n    carrots = carrots\
    \ + remaining\n    carrots = carrots + meals\n    carrots = carrots + remaining\n\
    \    carrots = carrots + meals\n    carrots = carrots + remaining\n    carrots\
    \ = carrots + meals\n    carrots = carrots + remaining\n    carrots = carrots\
    \ + meals\n    carrots = carrots + remaining\n    carrots = carrots + meals\n\
    \    carrots = carrots + remaining\n    carrots = carrots + meals\n    carrots\
    \ = carrots + remaining\n    carrots = carrots + meals\n    carrots = carrots\
    \ + remaining\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwwxs3xl8_test.go:90:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075203
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    if carrots > 1000 {\n        carrots = 1000\n    }\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    return []int{carrots, carrots - carrots + need}\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpkcoztvxs_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=6)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpkcoztvxs_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=8)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpkcoztvxs_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpkcoztvxs_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpkcoztvxs_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpkcoztvxs_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075200
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || number < 0 || need > 1000 || need < 0 || remaining > 1000 ||\
    \ remaining < 0 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if\
    \ number > need {\n        carrots = number-need\n    } else {\n        carrots\
    \ = need\n    }\n    if carrots > remaining {\n        carrots = remaining\n \
    \   }\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrots = carrots + 1\n    carrots = carrots + 1\n    carrots = carrots\
    \ + 1\n    carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz3fsdu54_test.go:96:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075203
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 && need == 0 && remaining == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 && need == 0 {\n        return []int{0, 0}\n \
    \   }\n    if number == 0 && remaining == 0 {\n        return []int{0, 0}\n  \
    \  }\n    if number > 0 && need > 0 && remaining > 0 {\n        carrots := 0\n\
    \        if number > need {\n            carrots = number-need\n        } else\
    \ {\n            carrots = need\n        }\n        if carrots > remaining {\n\
    \            carrots = remaining\n        }\n        if carrots == 0 {\n     \
    \       carrots = 1\n        }\n        return []int{carrots, 0}\n    }\n    if\
    \ number > 0 && need > 0 && remaining > 0 {\n        carrots := 0\n        if\
    \ number > need {\n            carrots = number-need\n        } else {\n     \
    \       carrots = need\n        }\n        if carrots > remaining {\n        \
    \    carrots = remaining\n        }\n        if carrots == 0 {\n            carrots\
    \ = 1\n        }\n        return []int{carrots, 0}\n    }\n    if number > 0 &&\
    \ need > 0 {\n        carrots := 0\n        if number > need {\n            carrots\
    \ = number-need\n        } else {\n            carrots = need\n        }\n   \
    \     if carrots == 0 {\n            carrots = 1\n        }\n        return []int{carrots,\
    \ 0}\n    }\n    if number > 0 && remaining > 0 {\n        carrots := 0\n    \
    \    if number > remaining {\n            carrots = number-remaining\n       \
    \ } else {\n            carrots = remaining\n        }\n        if carrots ==\
    \ 0 {\n            carrots = 1\n        }\n        return []int{carrots, 0}\n\
    \    }\n    if number > 0 {\n        carrots := 0\n        if number > remaining\
    \ {\n            carrots = number-remaining\n        } else {\n            carrots\
    \ = remaining\n        }\n        if carrots == 0 {\n            carrots = 1\n\
    \        }\n        return []int{carrots, 0}\n    }\n    if number > 0 {\n   \
    \     carrots := 0\n        if number > remaining {\n            carrots = number-remaining\n\
    \        } else {\n            carrots = remaining\n        }\n        if carrots\
    \ == 0 {\n            carrots = 1\n        }\n        return []int{carrots, 0}\n\
    \    }\n    if number > 0 {\n        carrots := 0\n        if number > remaining\
    \ {\n            carrots = number-remaining\n        } else {\n            carrots\
    \ = remaining\n        }\n        if carrots == \nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz9pjuxpc_test.go:133:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075203
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 && need == 0 && remaining == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 && need == 0 {\n        return []int{0, 0}\n \
    \   }\n    if number == 0 && remaining == 0 {\n        return []int{0, 0}\n  \
    \  }\n    if number == 0 && need > remaining {\n        return []int{0, 0}\n \
    \   }\n    if number > 0 && need > remaining {\n        return []int{0, 0}\n \
    \   }\n    if number > 0 && remaining > 0 {\n        return []int{0, 0}\n    }\n\
    \    if number > 0 && need == remaining {\n        return []int{0, 0}\n    }\n\
    \    if number > 0 && need == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ > 0 && remaining == 0 {\n        return []int{0, 0}\n    }\n    if number >\
    \ 0 && need > remaining {\n        return []int{0, 0}\n    }\n    if number >\
    \ 0 && remaining > 0 {\n        return []int{0, 0}\n    }\n    if number > 0 &&\
    \ need == remaining {\n        return []int{0, 0}\n    }\n    if number > 0 &&\
    \ need == 0 {\n        return []int{0, 0}\n    }\n    if number > 0 && remaining\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number > 0 && need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number > 0 && remaining > 0 {\n\
    \        return []int{0, 0}\n    }\n    if number > 0 && need == remaining {\n\
    \        return []int{0, 0}\n    }\n    if number > 0 && need == 0 {\n       \
    \ return []int{0, 0}\n    }\n    if number > 0 && remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > 0 && need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number > 0 && remaining > 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number > 0 && need == remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number > 0 && need == 0 {\n        return []int{0, 0}\n  \
    \  }\n    if number > 0 && remaining == 0 {\n        return []int{0, 0}\n    }\n\
    \    if number > 0 && need > remaining {\n        return []int{0, 0}\n    }\n\
    \    if number > 0 && remaining > 0 {\n        return []int{0, 0}\n    }\n   \
    \ if number > 0 && need == remaining {\n        return []int{0, 0}\n    }\n  \
    \  if number > 0 && need == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ > 0 && remaining == 0 {\n        return []int{0, 0}\n    }\n    if number >\
    \ 0 && need > remaining {\n        return []int{0, 0}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmponawdhi6_test.go:128:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075203
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    if carrots < 0 {\n        carrots = 0\n    }\n    return []int{carrots,\
    \ carrots - carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp4sxd8l1y_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp4sxd8l1y_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp4sxd8l1y_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp4sxd8l1y_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp4sxd8l1y_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp4sxd8l1y_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    if carrots == 0 {\n        carrots = 1000\n    }\n    return []int{carrots,\
    \ carrots - number}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpkzrpe9bi_test.go:67: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=16)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpkzrpe9bi_test.go:67:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=17)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpkzrpe9bi_test.go:67: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=20)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpkzrpe9bi_test.go:67: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=16)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpkzrpe9bi_test.go:67: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=12)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpkzrpe9bi_test.go:67:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=6)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if remaining\
    \ > 0 {\n        carrots = remaining\n    }\n    if number > need {\n        carrots\
    \ = number-need\n    }\n    if carrots == 0 {\n        carrots = number\n    }\n\
    \    return []int{carrots, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp5pjzzdjp_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp5pjzzdjp_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp5pjzzdjp_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp5pjzzdjp_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp5pjzzdjp_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp5pjzzdjp_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > need {\n        carrots = number-need\n    } else {\n        carrots = need\n\
    \    }\n    if carrots > remaining {\n        carrots = remaining\n    }\n   \
    \ return []int{carrots, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_j2ful81_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_j2ful81_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp_j2ful81_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp_j2ful81_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp_j2ful81_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_j2ful81_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 && need == 0 && remaining == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 && need == 0 {\n        return []int{0, 0}\n \
    \   }\n    if number == 0 && remaining == 0 {\n        return []int{0, 0}\n  \
    \  }\n    if number == 0 && need > remaining {\n        return []int{0, 0}\n \
    \   }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots =\
    \ number\n    carrots = carrots + need\n    carrots = carrots - remaining\n  \
    \  carrots = carrots + 1\n    return []int{carrots, carrots - 1}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp4iu_p9vg_test.go:82: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=2)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp4iu_p9vg_test.go:82:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=3)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp4iu_p9vg_test.go:82: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=2) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp4iu_p9vg_test.go:82: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp4iu_p9vg_test.go:82: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=3)\
    \ %!s(int=2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp4iu_p9vg_test.go:82:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n\
    \    }\n    if number < need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{0, number}\n    }\n    result := []int{0,\
    \ 0}\n    carrots := 0\n    for i := 0; i < number; i++ {\n        carrots +=\
    \ 2\n        result[0] += carrots\n        carrots -= 2\n    }\n    for i := 0;\
    \ i < need; i++ {\n        carrots += 2\n        result[1] += carrots\n      \
    \  carrots -= 2\n    }\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpoa44bz8j_test.go:83: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpoa44bz8j_test.go:83:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpoa44bz8j_test.go:83: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpoa44bz8j_test.go:83: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpoa44bz8j_test.go:83: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpoa44bz8j_test.go:83:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    carrots = carrots - number\n    carrots = carrots - need\n    carrots\
    \ = carrots - remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n  \
    \  return []int{carrots, carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpuliet8p7_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpuliet8p7_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpuliet8p7_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpuliet8p7_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpuliet8p7_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpuliet8p7_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075196
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    for carrots < number {\n  \
    \      if meals == 0 {\n            meals = need\n        } else {\n         \
    \   meals -= need\n        }\n        carrots += meals\n    }\n    if carrots\
    \ < remaining {\n        carrots = remaining\n    }\n    return []int{carrots,\
    \ 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmplf40wrcj_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmplf40wrcj_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmplf40wrcj_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmplf40wrcj_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmplf40wrcj_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 && need == 0 && remaining == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 && need == 0 {\n        return []int{0, 0}\n \
    \   }\n    if number == 0 && remaining == 0 {\n        return []int{0, 0}\n  \
    \  }\n    if number > 0 && need > 0 && remaining > 0 {\n        if number > need\
    \ {\n            number -= need\n        }\n        if number > remaining {\n\
    \            number -= remaining\n        }\n        if need > remaining {\n \
    \           need -= remaining\n        }\n        if number == 0 {\n         \
    \   return []int{0, 0}\n        }\n        if need == 0 {\n            return\
    \ []int{number, 0}\n        }\n        if remaining == 0 {\n            return\
    \ []int{number, need}\n        }\n    }\n    if number > 0 && need > 0 && remaining\
    \ > 0 {\n        if number > need {\n            number -= need\n        }\n \
    \       if number > remaining {\n            number -= remaining\n        }\n\
    \        if need > remaining {\n            need -= remaining\n        }\n   \
    \     if number == 0 {\n            return []int{0, 0}\n        }\n        if\
    \ need == 0 {\n            return []int{number, 0}\n        }\n        if remaining\
    \ == 0 {\n            return []int{number, need}\n        }\n    }\n    if number\
    \ > 0 && need > 0 && remaining == 0 {\n        if need > number {\n          \
    \  need -= number\n        }\n        if need == 0 {\n            return []int{0,\
    \ 0}\n        }\n        if number == 0 {\n            return []int{number, 0}\n\
    \        }\n        if need == number {\n            return []int{number, 0}\n\
    \        }\n    }\n    if number > 0 && need > 0 && remaining == 0 {\n       \
    \ if need > number {\n            need -= number\n        }\n        if need ==\
    \ 0 {\n            return []int{0, 0}\n        }\n        if number == 0 {\n \
    \           return []int{number, 0}\n        }\n        if need == number {\n\
    \            return []int{number, 0}\n        }\n    }\n    if number > 0 && need\
    \ == 0 && remaining > 0 {\n        if need > number {\n            need -= number\n\
    \        }\n        if need == 0 {\n            return []int{0, 0}\n        }\n\
    \        if number == 0 {\n            return []int{number, 0}\n        }\n  \
    \      if need == number {\n            return []int{number, 0}\n        }\n \
    \   }\n    if number > 0 && need == 0 && remaining == 0 {\n        if need > number\
    \ {\n            need -= number\n        }\n        if need == 0 {\n         \
    \   return []int{0, 0}\n        }\n        if number == 0 {\n            return\
    \ []int{number, 0}\n        }\n        if need == number {\n            return\
    \ []int{number, \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgtj8i3qy_test.go:141:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    carrots = carrots - number\n    carrots = carrots - need\n    carrots\
    \ = carrots - remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n  \
    \  return []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpipiuijcr_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpipiuijcr_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpipiuijcr_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpipiuijcr_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpipiuijcr_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpipiuijcr_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{}\n    }\n    carrots := 0\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrot\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpeiz_owjw_test.go:108:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == 0 {\n        result[0] = 0\n        result[1] = 0\n        return result\n\
    \    }\n    if need == 0 {\n        result[0] = number\n        result[1] = 0\n\
    \        return result\n    }\n    if remaining == 0 {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number > need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if need == remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > remaining {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if need > remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ remaining\n        return result\n    }\n    if need == remaining {\n      \
    \  result[0] = need\n        result[1] = remaining\n        return result\n  \
    \  }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if need == remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number > remaining {\n   \
    \     result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if need > remaining {\n        result[0] = need\n        result[1]\
    \ = remaining\n        return result\n    }\n    if number == need {\n       \
    \ result[0] = number\n        result[1] = need\n        return result\n    }\n\
    \    if number == remaining {\n        result[0] = number\n        result[1] =\
    \ remaining\n        return result\n    }\n    if need == remaining {\n      \
    \  result[0] = need\n        result[1] = remaining\n        return result\n  \
    \  }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == need {\n        result[0] = number\n        result\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa_kyf4fw_test.go:173:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int,\
    \ 2)\n    result[0] = number\n    result[1] = remaining\n    if number == 0 {\n\
    \        return result\n    }\n    if number > need {\n        return result\n\
    \    }\n    if number < need {\n        return result\n    }\n    if number ==\
    \ need {\n        return result\n    }\n    if number > remaining {\n        return\
    \ result\n    }\n    if number < remaining {\n        return result\n    }\n \
    \   if number == remaining {\n        return result\n    }\n    return result\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpev9_44t8_test.go:89: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpev9_44t8_test.go:89:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpev9_44t8_test.go:89: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpev9_44t8_test.go:89: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpev9_44t8_test.go:89: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpev9_44t8_test.go:89:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > need {\n        carrots = number-need\n\
    \    } else {\n        carrots = need\n    }\n    if carrots > remaining {\n \
    \       carrots = remaining\n    }\n    carrots = carrots + number\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    return []int{carrots,\
    \ carrots-carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp57c3io0u_test.go:71: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=27)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp57c3io0u_test.go:71:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=29) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp57c3io0u_test.go:71: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=31) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp57c3io0u_test.go:71: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=23) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp57c3io0u_test.go:71: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp57c3io0u_test.go:71:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=11) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int, 2)\n\
    \    carrots := 0\n    if number > need {\n        carrots = number\n        number\
    \ = need\n        need = remaining\n        remaining = carrots\n    }\n    if\
    \ number > remaining {\n        carrots = number\n        number = remaining\n\
    \        remaining = carrots\n    }\n    result[0] = number\n    result[1] = remaining\n\
    \    return result\n}\n</cell>\n<text>\nProblem 3\nWrite a function that takes\
    \ in a string and returns the number of words in the string.\n\nExamples:\n>>>\
    \ count_words(\"The quick brown fox jumps over the lazy dog\")\n7\n>>> count_words(\"\
    The quick brown fox jumps over the lazy dog\")\n0\n>>> count_words(\"The quick\
    \ brown fox jumps over the lazy dog\")\n0\n>>> count_words(\"The quick brown fox\
    \ jumps over the lazy dog\")\n0\n>>> count_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n0\n>>> count_words(\"The quick brown fox jumps over the lazy\
    \ dog\")\n0\n>>> count_words(\"The quick brown fox jumps over the lazy dog\")\n\
    0\n>>> count_words(\"The quick brown fox jumps over the lazy dog\")\n0\n>>> count_words(\"\
    The quick brown fox jumps over the lazy dog\")\n0\n>>> count_words(\"The quick\
    \ brown fox jumps over the lazy dog\")\n0\n>>> count_words(\"The quick brown fox\
    \ jumps over the lazy dog\")\n0\n>>> count_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n0\n>>> count_words(\"The quick brown fox jumps over the lazy\
    \ dog\")\n0\n>>> count_words(\"The quick brown fox jumps over the lazy dog\")\n\
    0\n>>> count_words(\"The quick brown fox jumps over the lazy dog\")\n0\n>>> count_words(\"\
    The quick brown fox jumps over the lazy dog\")\n0\n>>> count_words(\"The quick\
    \ brown fox jumps over the lazy dog\")\n0\n>>> count_words(\"The quick brown fox\
    \ jumps over the lazy dog\")\n0\n>>> count_words(\"The quick brown fox jumps over\
    \ the lazy dog\")\n0\n>>> count_words(\"The quick brown fox jumps over the \n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9brkdxws_test.go:55:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    result := []int{0, 0}\n    if remaining <= 0 {\n        return\
    \ result\n    }\n    if number <= need {\n        result[0] = number\n       \
    \ return result\n    }\n    carrots := 0\n    if number > need {\n        carrots\
    \ = number - need\n    }\n    carrots = carrots + remaining\n    result[0] = carrots\n\
    \    result[1] = number-carrots\n    return result\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpj49pbfzu_test.go:74: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpj49pbfzu_test.go:74:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpj49pbfzu_test.go:74: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpj49pbfzu_test.go:74: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpj49pbfzu_test.go:74: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpj49pbfzu_test.go:74:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n\
    \    carrots = carrots + number\n    carrots = carrots + need\n    carrots = carrots\
    \ + remaining\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    carrots\
    \ = carrots - number\n    carrots = carrots - need\n    carrots = carrots - remaining\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots = carrots + number\n\
    \    carrots = carrots + need\n    carrots = carrots + remaining\n    if carrots\
    \ > 1000 {\n        carrots = 1000\n    }\n    carrots = carrots - number\n  \
    \  carrots = carrots - need\n    carrots = carrots - remaining\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    carrots = carrots + number\n    carrots\
    \ = carrots + need\n    carrots = carrots + remaining\n    if carrots > 1000 {\n\
    \        carrots = 1000\n    }\n    carrots = carrots - number\n    carrots =\
    \ carrots - need\n    carrots = carrots - remaining\n    if carrots < 0 {\n  \
    \      carrots = 0\n    }\n    carrots = carrots + number\n    carrots = carrots\
    \ + need\n    carrots = carrots + remaining\n    if carrots > 1000 {\n       \
    \ carrots = 1000\n    }\n    carrots = carrots - number\n    carrots = carrots\
    \ - need\n    carrots = carrots - remaining\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots = carrots + number\n    carrots = carrots + need\n \
    \   carrots = carrots + remaining\n    if carrots > 1000 {\n        carrots =\
    \ 1000\n    }\n    carrots = carrots - number\n    carrots = carrots - need\n\
    \    carrots = carrots - remaining\n    if carrots < 0 {\n        carrots = 0\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5gun649a_test.go:110:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075204
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > remaining {\n        carrots =\
    \ number\n    } else {\n        carrots = remaining\n    }\n    if carrots > need\
    \ {\n        carrots = need\n    }\n    return []int{carrots, 0}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpba4sbhqf_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpba4sbhqf_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpba4sbhqf_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpba4sbhqf_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpba4sbhqf_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpba4sbhqf_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    if number > need {\n        meals = number\n        carrots = need\n\
    \    } else {\n        meals = need\n        carrots = remaining\n    }\n    carrots\
    \ -= meals\n    if carrots < 0 {\n        carrots = 0\n    }\n    result := []int{carrots,\
    \ carrots}\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpn5al812i_test.go:73: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=4)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpn5al812i_test.go:73:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=1) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpn5al812i_test.go:73: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpn5al812i_test.go:73: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpn5al812i_test.go:73: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpn5al812i_test.go:73:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > need {\n        carrots = number-need\n    } else {\n        carrots = need\n\
    \    }\n    if carrots > remaining {\n        carrots = remaining\n    }\n   \
    \ return []int{carrots, 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_j2ful81_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp_j2ful81_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp_j2ful81_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp_j2ful81_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp_j2ful81_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp_j2ful81_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075198
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ < need {\n        carrots = number\n    } else {\n        carrots = need\n \
    \   }\n    if carrots > remaining {\n        carrots = remaining\n    }\n    carrots\
    \ = carrots + number\n    return []int{carrots, carrots - number}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpq9ozzkw4_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=5)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpq9ozzkw4_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=4)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpq9ozzkw4_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=2) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpq9ozzkw4_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=4) %!s(int=2)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpq9ozzkw4_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=8)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpq9ozzkw4_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots = number - need\n    if carrots > remaining\
    \ {\n        carrots = remaining\n    }\n    return []int{carrots, 0}\n}\n\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpcxvq4ddo_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=-1)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpcxvq4ddo_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=-4) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpcxvq4ddo_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=-9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpcxvq4ddo_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=-9) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpcxvq4ddo_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=-1)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpcxvq4ddo_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=-1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075206
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := []int{0, 0}\n   \
    \ carrots := 0\n    if remaining > 0 {\n        carrots = remaining\n    }\n \
    \   if carrots > 0 {\n        result[0] = carrots\n    }\n    if carrots > 0 {\n\
    \        result[1] = carrots - need\n    }\n    return result\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpn6xewytc_test.go:70: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpn6xewytc_test.go:70:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpn6xewytc_test.go:70: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpn6xewytc_test.go:70: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=-6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpn6xewytc_test.go:70: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpn6xewytc_test.go:70:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=-4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075206
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{}\n    }\n    result := make([]int, 2)\n    if\
    \ remaining < need {\n        result[0] = 0\n        result[1] = remaining\n \
    \       return result\n    }\n    carrots := 0\n    carrots = number - need\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots = carrots + 1\n\
    \    result[0] = carrots\n    result[1] = remaining\n    return result\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp3wn6o2o__test.go:73: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp3wn6o2o__test.go:73:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=1) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp3wn6o2o__test.go:73: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp3wn6o2o__test.go:73: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp3wn6o2o__test.go:73: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=1)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp3wn6o2o__test.go:73:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075206
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if remaining == 0 {\n     \
    \   return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    carrots := 0\n    if number > remaining {\n        carrots = number - remaining\n\
    \    }\n    carrots = carrots + need\n    if carrots > remaining {\n        carrots\
    \ = carrots - remaining\n    }\n    carrots = carrots + number\n    if carrots\
    \ > remaining {\n        carrots = carrots - remaining\n    }\n    return []int{carrots,\
    \ remaining}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpd5ocl2u9_test.go:80: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpd5ocl2u9_test.go:80:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpd5ocl2u9_test.go:80: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpd5ocl2u9_test.go:80: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=3) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpd5ocl2u9_test.go:80: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpd5ocl2u9_test.go:80:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075206
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    return []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpk91c6w9v_test.go:69: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=21)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpk91c6w9v_test.go:69:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=21) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpk91c6w9v_test.go:69: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=21) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpk91c6w9v_test.go:69: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpk91c6w9v_test.go:69: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=16)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpk91c6w9v_test.go:69:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075206
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjgqtmlim_test.go:108:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 && need == 0 && remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number < need {\n        return []int{0, 0}\n   \
    \ }\n    if number > remaining {\n        return []int{0, number}\n    }\n   \
    \ if number == need && need == remaining {\n        return []int{0, number}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{number, 0}\n    }\n    if number == 0 {\n   \
    \     return []int{number, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{number, number}\n    }\n    if number == remaining {\n        return []int{number,\
    \ number}\n    }\n    if number < need {\n        return []int{number, number}\n\
    \    }\n    if number == need {\n        return []int{number, number}\n    }\n\
    \    if number == remaining {\n        return []int{number, number}\n    }\n \
    \   if number > need {\n        return []int{number, number}\n    }\n    if number\
    \ == 0 {\n        return []int{number, number}\n    }\n    if number > remaining\
    \ {\n        return []int{number, number}\n    }\n    if number == remaining {\n\
    \        return []int{number, number}\n    }\n    if number < need {\n       \
    \ return []int{number, number}\n    }\n    if number == need {\n        return\
    \ []int{number, number}\n    }\n    if number == remaining {\n        return []int{number,\
    \ number}\n    }\n    if number > need {\n        return []int{number, number}\n\
    \    }\n    if number == 0 {\n        return []int{number, number}\n    }\n  \
    \  if number > remaining {\n        return []int{number, number}\n    }\n    if\
    \ number == remaining {\n        return []int{number, number}\n    }\n    if number\
    \ < need {\n        return []int{number, number}\n    }\n    if number == need\
    \ {\n        return []int{number, number}\n    }\n    if number == remaining {\n\
    \        return []int{number, number}\n    }\n    if number > need {\n       \
    \ return []int{number, number}\n    }\n    if number == 0 {\n        return []int{number,\
    \ number}\n    }\n    if number > remaining {\n        return []int{number, number}\n\
    \    }\n    if number == remaining {\n        return []int{number, number}\n \
    \   }\n    if number < need {\n        return []int{number, number}\n    }\n \
    \   if number == need {\n        return []int{number, number}\n    }\n    if number\
    \ == remaining {\n        return []int{number, number}\n    }\n    if number >\
    \ need {\n        return []int{\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcheg26oy_test.go:142:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 {\n        return []int{need, remaining}\n   \
    \ }\n    if remaining == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number > remaining {\n \
    \       return []int{0, 0}\n    }\n    if number < need {\n        return []int{0,\
    \ 0}\n    }\n    if number < remaining {\n        return []int{number, 0}\n  \
    \  }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{number, 0}\n    }\n    if number < need\
    \ {\n        return []int{number, 0}\n    }\n    if number < remaining {\n   \
    \     return []int{number, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{number, 0}\n    }\n\
    \    if number < need {\n        return []int{number, 0}\n    }\n    if number\
    \ < remaining {\n        return []int{number, 0}\n    }\n    if number == need\
    \ {\n        return []int{number, 0}\n    }\n    if number == remaining {\n  \
    \      return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{number, 0}\n    }\n    if number < need {\n        return []int{number,\
    \ 0}\n    }\n    if number < remaining {\n        return []int{number, 0}\n  \
    \  }\n    if number == need {\n        return []int{number, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{number, 0}\n    }\n    if number < need {\n \
    \       return []int{number, 0}\n    }\n    if number < remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{number, 0}\n    }\n    if\
    \ number < need {\n        return []int{number, 0}\n    }\n    if number < remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number == need {\n       \
    \ return []int{number, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{number,\
    \ 0}\n    }\n    if number < need {\n        return []int{number, 0}\n    }\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp21z8pbc1_test.go:143:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > need {\n        carrots = number-need\n    } else {\n        carrots = remaining\n\
    \    }\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n    carrots\
    \ -= need\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots += number\n\
    \    if carrots > remaining {\n        carrots = remaining\n    }\n    if carrots\
    \ == 0 {\n        return []int{0, 0}\n    }\n    carrots -= need\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    carrots += number\n    if carrots > remaining\
    \ {\n        carrots = remaining\n    }\n    if carrots == 0 {\n        return\
    \ []int{0, 0}\n    }\n    carrots -= need\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots += number\n    if carrots > remaining {\n        carrots\
    \ = remaining\n    }\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n\
    \    carrots -= need\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ += number\n    if carrots > remaining {\n        carrots = remaining\n    }\n\
    \    if carrots == 0 {\n        return []int{0, 0}\n    }\n    carrots -= need\n\
    \    if carrots < 0 {\n        carrots = 0\n    }\n    carrots += number\n   \
    \ if carrots > remaining {\n        carrots = remaining\n    }\n    if carrots\
    \ == 0 {\n        return []int{0, 0}\n    }\n    carrots -= need\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    carrots += number\n    if carrots > remaining\
    \ {\n        carrots = remaining\n    }\n    if carrots == 0 {\n        return\
    \ []int{0, 0}\n    }\n    carrots -= need\n    if carrots < 0 {\n        carrots\
    \ = 0\n    }\n    carrots += number\n    if carrots > remaining {\n        carrots\
    \ = remaining\n    }\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n\
    \    carrots -= need\n    if carrots < 0 {\n        carrots = 0\n    }\n    carrots\
    \ += number\n    if carrots > remaining {\n        carrots = remaining\n    }\n\
    \    if carrots == 0 {\n        return []int{0, \nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv5o_o7jd_test.go:134:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    for i := 0; i < number; i++ {\n        carrots += i\n    }\n    for i\
    \ := 0; i < need; i++ {\n        meals += i\n    }\n    for i := 0; i < remaining;\
    \ i++ {\n        carrots += i\n    }\n    if carrots > 1000 {\n        carrots\
    \ = 1000\n    }\n    if meals > 1000 {\n        meals = 1000\n    }\n    if carrots\
    \ == 0 {\n        carrots = 1000\n    }\n    if meals == 0 {\n        meals =\
    \ 1000\n    }\n    if carrots == 1000 {\n        carrots = 0\n    }\n    if meals\
    \ == 1000 {\n        meals = 0\n    }\n    if carrots > 0 {\n        carrots =\
    \ carrots - 1\n    }\n    if meals > 0 {\n        meals = meals - 1\n    }\n \
    \   if carrots == 0 {\n        carrots = 1000\n    }\n    if meals == 0 {\n  \
    \      meals = 1000\n    }\n    if carrots == 1000 {\n        carrots = 0\n  \
    \  }\n    if meals == 1000 {\n        meals = 0\n    }\n    if carrots > 0 {\n\
    \        carrots = carrots - 1\n    }\n    if meals > 0 {\n        meals = meals\
    \ - 1\n    }\n    if carrots == 0 {\n        carrots = 1000\n    }\n    if meals\
    \ == 0 {\n        meals = 1000\n    }\n    if carrots == 1000 {\n        carrots\
    \ = 0\n    }\n    if meals == 1000 {\n        meals = 0\n    }\n    if carrots\
    \ > 0 {\n        carrots = carrots - 1\n    }\n    if meals > 0 {\n        meals\
    \ = meals - 1\n    }\n    if carrots == 0 {\n        carrots = 1000\n    }\n \
    \   if meals == 0 {\n        meals = 1000\n    }\n    if carrots == 1000 {\n \
    \       carrots = 0\n    }\n    if meals == 1000 {\n        meals = 0\n    }\n\
    \    if carrots > 0 {\n        carrots = carrots - 1\n    }\n    if meals > 0\
    \ {\n        meals = meals - 1\n    }\n    if carrots == 0 {\n        carrots\
    \ = 1000\n    }\n    if meals == 0 {\n        meal\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp03ty7xrw_test.go:132:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0hiq1d6j_test.go:108:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    result := make([]int, 2)\n    carrots := 0\n    if number > 0\
    \ {\n        carrots = number\n    }\n    if need > 0 {\n        carrots = carrots\
    \ + need\n    }\n    if carrots > remaining {\n        carrots = remaining\n \
    \   }\n    result[0] = carrots\n    result[1] = carrots - need\n    return result\n\
    }\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp0cvilafc_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp0cvilafc_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp0cvilafc_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp0cvilafc_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=-6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp0cvilafc_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp0cvilafc_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=1) %!s(int=-4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075206
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return nil\n   \
    \ }\n    result := make([]int, 2)\n    carrots := 0\n    if number > need {\n\
    \        carrots = number-need\n        result[0] = carrots\n        result[1]\
    \ = remaining\n    } else {\n        carrots = need\n        result[0] = need\n\
    \        result[1] = remaining\n    }\n    return result\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpxyzrnf0g_test.go:70: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpxyzrnf0g_test.go:70:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpxyzrnf0g_test.go:70: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpxyzrnf0g_test.go:70: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpxyzrnf0g_test.go:70: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpxyzrnf0g_test.go:70:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    for i := 0; i < number; i++\
    \ {\n        carrots += i\n    }\n    for i := 0; i < need; i++ {\n        meals\
    \ += i\n    }\n    for i := 0; i < remaining; i++ {\n        carrots += i\n  \
    \  }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    if meals > 1000\
    \ {\n        meals = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    if meals < 0 {\n        meals = 0\n    }\n    if carrots == 0 {\n\
    \        carrots = 1000\n    }\n    if meals == 0 {\n        meals = 1000\n  \
    \  }\n    if carrots > remaining {\n        carrots = remaining\n    }\n    if\
    \ meals > remaining {\n        meals = remaining\n    }\n    if carrots == 0 {\n\
    \        carrots = 1000\n    }\n    if meals == 0 {\n        meals = 1000\n  \
    \  }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    if meals > 1000\
    \ {\n        meals = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    if meals < 0 {\n        meals = 0\n    }\n    if carrots == 0 {\n\
    \        carrots = 1000\n    }\n    if meals == 0 {\n        meals = 1000\n  \
    \  }\n    if carrots > remaining {\n        carrots = remaining\n    }\n    if\
    \ meals > remaining {\n        meals = remaining\n    }\n    if carrots == 0 {\n\
    \        carrots = 1000\n    }\n    if meals == 0 {\n        meals = 1000\n  \
    \  }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    if meals > 1000\
    \ {\n        meals = 1000\n    }\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    if meals < 0 {\n        meals = 0\n    }\n    if carrots == 0 {\n\
    \        carrots = 1000\n    }\n    if meals == 0 {\n        meals = 1000\n  \
    \  }\n    if carrots > remaining {\n        carrots = remaining\n    }\n    if\
    \ meals > remaining {\n        meals = remaining\n    }\n    if carrots == 0 {\n\
    \        carrots = 1000\n    }\n    if meals == 0 {\n        meals = \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5nt3mct5_test.go:138:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    carrots = carrots - number\n    carrots\
    \ = carrots - need\n    carrots = carrots - remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    return []int{carrots, carrots}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpqf0ugayc_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpqf0ugayc_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpqf0ugayc_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpqf0ugayc_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpqf0ugayc_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpqf0ugayc_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := []int{0, 0}\n   \
    \ if number == 0 {\n        return result\n    }\n    if remaining < need {\n\
    \        return result\n    }\n    if number > remaining {\n        return result\n\
    \    }\n    if number < need {\n        return result\n    }\n    carrots := 0\n\
    \    for i := 0; i < number; i++ {\n        carrots += i\n    }\n    carrots +=\
    \ number\n    carrots -= need\n    result[0] = carrots\n    carrots -= remaining\n\
    \    result[1] = carrots\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpje9yejss_test.go:81: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpje9yejss_test.go:81:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpje9yejss_test.go:81: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpje9yejss_test.go:81: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpje9yejss_test.go:81: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpje9yejss_test.go:81:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 && need == 0 && remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 && need == 0 && remaining > 0 {\n   \
    \     return []int{0, remaining}\n    }\n    if number == 0 && need > 0 && remaining\
    \ == 0 {\n        return []int{need, 0}\n    }\n    if number == 0 && need > 0\
    \ && remaining > 0 {\n        return []int{need, remaining}\n    }\n    if number\
    \ > 0 && need == 0 && remaining == 0 {\n        return []int{number, 0}\n    }\n\
    \    if number > 0 && need == 0 && remaining > 0 {\n        return []int{number,\
    \ remaining}\n    }\n    if number > 0 && need > 0 && remaining == 0 {\n     \
    \   return []int{number, need}\n    }\n    if number > 0 && need > 0 && remaining\
    \ > 0 {\n        return []int{number, need, remaining}\n    }\n    return []int{0,\
    \ 0}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp_arkn0bo_test.go:86: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=6) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n      \
    \  tmp_arkn0bo_test.go:86: expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4)\
    \ %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestEat/test_num__2 (0.00s)\n       \
    \ tmp_arkn0bo_test.go:86: expected '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1)\
    \ %!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3 (0.00s)\n     \
    \   tmp_arkn0bo_test.go:86: expected '[%!s(int=7) %!s(int=0)]', got '[%!s(int=2)\
    \ %!s(int=11) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n      \
    \  tmp_arkn0bo_test.go:86: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=5) %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n       \
    \ tmp_arkn0bo_test.go:86: expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4)\
    \ %!s(int=5) %!s(int=1)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    if number > 1000 || need > 1000\
    \ || remaining > 1000 {\n        fmt.Println(\"Invalid input\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        return nil\n    }\n    if remaining\
    \ < need {\n        fmt.Println(\"Not enough carrots to complete the day's meals\"\
    )\n        return nil\n    }\n    if number > remaining {\n        fmt.Println(\"\
    Not enough carrots to complete the day's meals\")\n        return nil\n    }\n\
    \    if number == need {\n        return nil\n    }\n    if number > need {\n\
    \        fmt.Println(\"Not enough carrots to complete the day's meals\")\n   \
    \     return nil\n    }\n    if number > remaining {\n        fmt.Println(\"Not\
    \ enough carrots to complete the day's meals\")\n        return nil\n    }\n \
    \   if number == remaining {\n        return nil\n    }\n    if number > remaining\
    \ {\n        fmt.Println(\"Not enough carrots to complete the day's meals\")\n\
    \        return nil\n    }\n    if number == 0 {\n        return nil\n    }\n\
    \    if number > 0 {\n        fmt.Println(\"Not enough carrots to complete the\
    \ day's meals\")\n        return nil\n    }\n    if number == 0 {\n        return\
    \ nil\n    }\n    if number > 0 {\n        fmt.Println(\"Not enough carrots to\
    \ complete the day's meals\")\n        return nil\n    }\n    if number == 0 {\n\
    \        return nil\n    }\n    if number > 0 {\n        fmt.Println(\"Not enough\
    \ carrots to complete the day's meals\")\n        return nil\n    }\n    if number\
    \ == 0 {\n        return nil\n    }\n    if number > 0 {\n        fmt.Println(\"\
    Not enough carrots to complete the day's meals\")\n        return nil\n    }\n\
    \    if number == 0 {\n        return nil\n    }\n    if number > 0 {\n      \
    \  fmt.Println(\"Not enough carrots to complete the day's meals\")\n        return\
    \ nil\n    }\n    if number == 0 {\n        return nil\n    }\n    if number >\
    \ 0 {\n        fmt.Println(\"Not enough carrots to complete the day's meals\"\
    )\n        return nil\n    }\n    if number == 0 {\n        return nil\n    }\n\
    \    if number > 0 {\n        fmt.Println(\"Not enough carrots to complete the\
    \ day's meals\")\n        return nil\n    }\n    if number == 0 {\n        return\
    \ nil\n    }\n    if number > 0 {\n        fmt.Println(\"Not enough carrots to\
    \ complete the day's meals\")\n        return nil\n    }\n    if number == 0 {\n\
    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp64v0rmrl_test.go:128:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number ==\
    \ 0 && need == 0 && remaining == 0 {\n        return []int{0, 0}\n    }\n    if\
    \ number == 0 && need == 0 {\n        return []int{0, 0}\n    }\n    if number\
    \ == 0 && remaining == 0 {\n        return []int{0, 0}\n    }\n    if need ==\
    \ 0 {\n        return []int{number, remaining}\n    }\n    if remaining == 0 {\n\
    \        return []int{number, need}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number == remaining {\n      \
    \  return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number == remaining {\n      \
    \  return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number == remaining {\n      \
    \  return []int{number, 0}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4dayrlma_test.go:141:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return []int{0, 0}\n    }\n    if need\
    \ < 0 || need > 1000 {\n        return []int{0, 0}\n    }\n    if remaining <\
    \ 0 || remaining > 1000 {\n        return []int{0, 0}\n    }\n    if number ==\
    \ 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{number, 0}\n    }\n    if need > remaining {\n     \
    \   return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > remaining {\n        return []int{0, 0}\n    }\n    if\
    \ need > remaining {\n        return []int{0, 0}\n    }\n    if number == need\
    \ {\n        return []int{number, 0}\n    }\n    if number == remaining {\n  \
    \      return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{number,\
    \ 0}\n    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n  \
    \  if number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{number, 0}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{number, 0}\n    }\n    if need > remaining {\n     \
    \   return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{number, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdsykd15m_test.go:144:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    result := make([]int, 2)\n\
    \    result[0] = number\n    result[1] = remaining\n    if number == 0 {\n   \
    \     return result\n    }\n    if remaining == 0 {\n        return result\n \
    \   }\n    if number > need {\n        return result\n    }\n    if number > remaining\
    \ {\n        return result\n    }\n    if number > 0 {\n        result[0] = number\
    \ - need\n        result[1] = remaining\n    }\n    return result\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpko9zxdk6_test.go:78: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=-1)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpko9zxdk6_test.go:78:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=-4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpko9zxdk6_test.go:78: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=-9) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpko9zxdk6_test.go:78: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=-9) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpko9zxdk6_test.go:78: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=-1)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpko9zxdk6_test.go:78:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > remaining {\n        carrots = number\n    } else {\n        carrots = remaining\n\
    \    }\n    meals := []int{0, 0}\n    if carrots > 0 {\n        meals[0] = carrots\n\
    \        carrots -= meals[0]\n    }\n    if carrots > 0 {\n        meals[1] =\
    \ carrots\n        carrots -= meals[1]\n    }\n    return meals\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpgvfsky8__test.go:74: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpgvfsky8__test.go:74:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpgvfsky8__test.go:74: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpgvfsky8__test.go:74: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpgvfsky8__test.go:74: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpgvfsky8__test.go:74:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 && need == 0 && remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number < need {\n        return []int{0, 0}\n   \
    \ }\n    if number == need && remaining == 0 {\n        return []int{number, 0}\n\
    \    }\n    if number == need && remaining > 0 {\n        return []int{number,\
    \ remaining - number}\n    }\n    if number > need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need && remaining == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == need && remaining > 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 && need == 0 && remaining > 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 && need > 0 && remaining == 0 {\n   \
    \     return []int{0, 0}\n    }\n    if number == 0 && need > 0 && remaining >\
    \ 0 {\n        return []int{0, 0}\n    }\n    if number == 0 && need > 0 && remaining\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number > 0 && need == 0 &&\
    \ remaining == 0 {\n        return []int{0, 0}\n    }\n    if number > 0 && need\
    \ > 0 && remaining == 0 {\n        return []int{0, 0}\n    }\n    if number >\
    \ 0 && need > 0 && remaining > 0 {\n        return []int{0, 0}\n    }\n    if\
    \ number > 0 && need > 0 && remaining == 0 {\n        return []int{0, 0}\n   \
    \ }\n    if number > 0 && need > 0 && remaining > 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number > 0 && need > 0 && remaining == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if number > 0 && need > 0 && remaining > 0 {\n     \
    \   return []int{0, 0}\n    }\n    if number > 0 && need > 0 && remaining == 0\
    \ {\n        return []int{0, 0}\n    }\n    if number > 0 && need > 0 && remaining\
    \ > 0 {\n        return []int{0, 0}\n    }\n    if number > 0 && need > 0 && remaining\
    \ == 0 {\n        return []int{0, 0}\n    }\n    if number > 0 && need > 0 &&\
    \ remaining > 0 {\n        return []int{0, 0}\n    }\n    if number > 0 && need\
    \ > 0 && remaining == 0 {\n        return []int{0, 0}\n    }\n    if number >\
    \ 0 && need > 0 && remaining > 0 {\n        return []int{0, 0}\n    }\n    if\
    \ number > 0 && need > 0 && remaining == 0 {\n        return []int{0, 0}\n   \
    \ }\n    if number > 0 && need > 0 && remaining > 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number > 0 && need > 0 && remaining == 0 {\n        return\
    \ []\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl37a5ter_test.go:117:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots -= remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    return []int{carrots, carrots - number}\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp317v358b_test.go:66: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=1)\
    \ %!s(int=-4)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp317v358b_test.go:66:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=3) %!s(int=-1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp317v358b_test.go:66: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp317v358b_test.go:66: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=8) %!s(int=6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmp317v358b_test.go:66: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=2)\
    \ %!s(int=-2)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp317v358b_test.go:66:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining < need {\n        return []int{0, 0}\n\
    \    }\n    if number == need {\n        return []int{number, 0}\n    }\n    carrots\
    \ := 0\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    carrots += number\n\
    \    carrots += need\n    carrots += remaining\n    carrots += number\n    carrots\
    \ += need\n    carrots += remaining\n    carrots += number\n    carrots += need\n\
    \    carrots += remaining\n    carrots += number\n    carrots += need\n    carrots\
    \ += remaining\n    carrots += number\n    carrots += need\n    carrots += remaining\n\
    \    carrots += number\n    carrots += need\n    carrots += remaining\n    carrots\
    \ += number\n    carrots += need\n    carrots += remaining\n    \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbc26ue1b_test.go:121:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n        return nil\n    }\n    if number\
    \ == 0 {\n        result[0] = 0\n        result[1] = 0\n        return result\n\
    \    }\n    if need == 0 {\n        result[0] = number\n        result[1] = 0\n\
    \        return result\n    }\n    if remaining == 0 {\n        result[0] = number\n\
    \        result[1] = need\n        return result\n    }\n    if number < need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number > remaining {\n        result[0] = number\n        result[1]\
    \ = remaining\n        return result\n    }\n    if need > remaining {\n     \
    \   result[0] = need\n        result[1] = remaining\n        return result\n \
    \   }\n    if number == need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number == remaining {\n       \
    \ result[0] = number\n        result[1] = remaining\n        return result\n \
    \   }\n    if need > number {\n        result[0] = need\n        result[1] = number\n\
    \        return result\n    }\n    if need < number {\n        result[0] = remaining\n\
    \        result[1] = number\n        return result\n    }\n    if number > need\
    \ {\n        result[0] = number\n        result[1] = need\n        return result\n\
    \    }\n    if number < need {\n        result[0] = need\n        result[1] =\
    \ number\n        return result\n    }\n    if number == need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ == remaining {\n        result[0] = number\n        result[1] = remaining\n\
    \        return result\n    }\n    if need > number {\n        result[0] = need\n\
    \        result[1] = number\n        return result\n    }\n    if need < number\
    \ {\n        result[0] = remaining\n        result[1] = number\n        return\
    \ result\n    }\n    if number > need {\n        result[0] = number\n        result[1]\
    \ = need\n        return result\n    }\n    if number < need {\n        result[0]\
    \ = need\n        result[1] = number\n        return result\n    }\n    if number\
    \ == need {\n        result[0] = number\n        result[1] = need\n        return\
    \ result\n    }\n    if number == remaining {\n        result[0] = number\n  \
    \      result[1] = remaining\n        return result\n    }\n    if need > number\
    \ {\n        result[0] = need\n        result[1] = number\n        return result\n\
    \    }\n    if need < number {\n        result[0] = remaining\n        result[1]\
    \ = number\n        return result\n    }\n    if number > need {\n        result[0]\
    \ = number\n        result[1] = need\n        return result\n    }\n    if number\
    \ < need {\n        result[0] = need\n        result[1] = number\n        return\
    \ result\n    }\n    if number == need {\n        result[0] = number\n       \
    \ result[1] = need\n        return result\n    }\n    if number == remaining {\n\
    \        result[0] = number\n        result[1] = remaining\n        return result\n\
    \    }\n    if need > number {\n        result[0] = need\n        result\nfunc\
    \ TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5ze1qcuj_test.go:173:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == remaining {\n       \
    \ return []int{number, 0}\n    }\n    if number < remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number == need {\n        return []int{number, 0}\n    }\n    if number < need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number < remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number < need {\n\
    \        return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number < remaining {\n        return []int{0, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number == need {\n\
    \        return []int{number, 0}\n    }\n    if number < need {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number < remaining {\n        return []int{0, 0}\n    }\n    if\
    \ number == remaining {\n        return []int{number, 0}\n    }\n    if number\
    \ > need {\n        return []int{0, 0}\n    }\n    if number == need {\n     \
    \   return []int{number, 0}\n    }\n    if number < need {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number < remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number < need {\n        return []\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppklnapvj_test.go:141:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    for i := 0; i < number; i++\
    \ {\n        carrots += i\n    }\n    for i := 0; i < need; i++ {\n        meals\
    \ += i\n    }\n    carrots -= meals\n    if carrots < 0 {\n        carrots = 0\n\
    \    }\n    return []int{carrots, remaining}\n}\n\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpzk26q5fk_test.go:71: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpzk26q5fk_test.go:71:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpzk26q5fk_test.go:71: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpzk26q5fk_test.go:71: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpzk26q5fk_test.go:71: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpzk26q5fk_test.go:71:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    meals :=\
    \ 0\n    if number > need {\n        carrots = number\n        meals = need\n\
    \    } else {\n        carrots = need\n        meals = number\n    }\n    carrots\
    \ -= remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n    meals -=\
    \ carrots\n    if meals < 0 {\n        meals = 0\n    }\n    return []int{meals,\
    \ carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n\
    \     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual:\
    \ candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmph8atrynt_test.go:76: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmph8atrynt_test.go:76:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmph8atrynt_test.go:76: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmph8atrynt_test.go:76: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=6)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmph8atrynt_test.go:76: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmph8atrynt_test.go:76:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=4)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ write your code here\n    carrots := 0\n    if number < 0 {\n        return\
    \ []int{0, 0}\n    }\n    if need < 0 {\n        return []int{0, 0}\n    }\n \
    \   if remaining < 0 {\n        return []int{0, 0}\n    }\n    if number == 0\
    \ {\n        return []int{0, 0}\n    }\n    if need == 0 {\n        return []int{number,\
    \ 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n    }\n\
    \    if number > remaining {\n        return []int{0, 0}\n    }\n    if need >\
    \ remaining {\n        return []int{0, 0}\n    }\n    if number == need {\n  \
    \      return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n\
    \    if need > 0 {\n        if number > need {\n            return []int{0, 0}\n\
    \        }\n        if number == need {\n            return []int{number, 0}\n\
    \        }\n        if number > need {\n            return []int{0, 0}\n     \
    \   }\n    }\n    if number > 0 {\n        if number == need {\n            return\
    \ []int{number, 0}\n        }\n        if number > need {\n            return\
    \ []int{0, 0}\n        }\n    }\n    if number > 0 {\n        if number == need\
    \ {\n            return []int{number, 0}\n        }\n        if number > need\
    \ {\n            return []int{0, 0}\n        }\n    }\n    if number > 0 {\n \
    \       if number == need {\n            return []int{number, 0}\n        }\n\
    \        if number > need {\n            return []int{0, 0}\n        }\n    }\n\
    \    if number > 0 {\n        if number == need {\n            return []int{number,\
    \ 0}\n        }\n        if number > need {\n            return []int{0, 0}\n\
    \        }\n    }\n    if number > 0 {\n        if number == need {\n        \
    \    return []int{number, 0}\n        }\n        if number > need {\n        \
    \    return []int{0, 0}\n        }\n    }\n    if number > 0 {\n        if number\
    \ == need {\n            return []int{number, 0}\n        }\n        if number\
    \ > need {\n            return []int{0, 0}\n        }\n    }\n    if number >\
    \ 0 {\n        if number == need {\n            return []int{number, 0}\n    \
    \    }\n        if number > need {\n            return []int{0, 0}\n        }\n\
    \    }\n    if number > 0 {\n        if number == need {\n            return []int{number,\
    \ 0}\n        }\n        if number > need {\n            return []int{0, 0}\n\
    \        }\n    }\n    if number > 0 {\n        if number == need {\n        \
    \    return []int{number, 0}\n        }\n        if number > need {\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_vb6opym_test.go:150:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075207
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 && need == 0 && remaining == 0 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 {\n        return []int{need, remaining}\n   \
    \ }\n    if need == 0 {\n        return []int{number, remaining}\n    }\n    if\
    \ remaining == 0 {\n        return []int{number, need}\n    }\n    if number >\
    \ need {\n        return []int{0, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n\
    \    }\n    if number == remaining {\n        return []int{number, need}\n   \
    \ }\n    if need == remaining {\n        return []int{number, need}\n    }\n \
    \   if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n\
    \    }\n    if number == remaining {\n        return []int{number, need}\n   \
    \ }\n    if need == remaining {\n        return []int{number, need}\n    }\n \
    \   if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n\
    \    }\n    if number == remaining {\n        return []int{number, need}\n   \
    \ }\n    if need == remaining {\n        return []int{number, need}\n    }\n \
    \   if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n\
    \    }\n    if number == remaining {\n        return []int{number, need}\n   \
    \ }\n    if need == remaining {\n        return []int{number, need}\n    }\n \
    \   if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, remaining}\n\
    \    }\n    if number == remaining {\n        return []int{number, need}\n   \
    \ }\n    if need == remaining {\n        return []int{number, \nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6simxfru_test.go:139:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    if carrots > 1000\
    \ {\n        carrots = 1000\n    }\n    carrots = carrots - number\n    carrots\
    \ = carrots - need\n    carrots = carrots - remaining\n    if carrots < 0 {\n\
    \        carrots = 0\n    }\n    return []int{carrots, carrots}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpqf0ugayc_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpqf0ugayc_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpqf0ugayc_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpqf0ugayc_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpqf0ugayc_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpqf0ugayc_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots = number\n    carrots = carrots - need\n\
    \    carrots = carrots - remaining\n    carrots = carrots + 1\n    return []int{carrots,\
    \ carrots - carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpmy51lwft_test.go:64: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=-10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpmy51lwft_test.go:64:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=-12) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpmy51lwft_test.go:64: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=-18) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpmy51lwft_test.go:64: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=-13) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpmy51lwft_test.go:64: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=-7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpmy51lwft_test.go:64:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=-1) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    carrots += number\n    carrots += need\n  \
    \  carrots += remaining\n    if carrots > 1000 {\n        carrots = 1000\n   \
    \ }\n    carrots = carrots - number\n    carrots = carrots - need\n    carrots\
    \ = carrots - remaining\n    if carrots < 0 {\n        carrots = 0\n    }\n  \
    \  return []int{carrots, carrots - carrots}\n}\n\nfunc TestEat(t *testing.T) {\n\
    \  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected:\
    \ []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n\
    \     { actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual:\
    \ candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5,\
    \ 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5,\
    \ 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num\
    \ % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) !=\
    \ fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
    , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpipiuijcr_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpipiuijcr_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpipiuijcr_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpipiuijcr_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpipiuijcr_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpipiuijcr_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > need {\n        carrots = number-need\n    } else {\n        carrots = need\n\
    \    }\n    if remaining > carrots {\n        carrots = remaining\n    }\n   \
    \ return []int{carrots, carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpio371y4d_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpio371y4d_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpio371y4d_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpio371y4d_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=11) %!s(int=11)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpio371y4d_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpio371y4d_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=5) %!s(int=5)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 {\n        return []int{need, remaining}\n   \
    \ }\n    if need == 0 {\n        return []int{number, remaining}\n    }\n    if\
    \ remaining == 0 {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{number, 0}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{number, 0}\n    }\n    if need > remaining {\n     \
    \   return []int{0, 0}\n    }\n    if number == need {\n        return []int{number,\
    \ 0}\n    }\n    if number == remaining {\n        return []int{number, 0}\n \
    \   }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ > remaining {\n        return []int{number, 0}\n    }\n    if need > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if number == need {\n        return\
    \ []int{number, 0}\n    }\n    if number == remaining {\n        return []int{number,\
    \ 0}\n    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if\
    \ number > remaining {\n        return []int{number, 0}\n    }\n    if need >\
    \ remaining {\n        return []int{0, 0}\n    }\n    if number == need {\n  \
    \      return []int{number, 0}\n    }\n    if number == remaining {\n        return\
    \ []int{number, 0}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number > remaining {\n        return []int{number, 0}\n    }\n\
    \    if need > remaining {\n        return []int{0, 0}\n    }\n    if number ==\
    \ need {\n        return []int{number, 0}\n    }\n    if number == remaining {\n\
    \        return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{number,\
    \ 0}\n    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n  \
    \  if number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{number, 0}\n    }\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph52_yxg9_test.go:143:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || need < 0 || remaining < 0 {\n        return []int{0, 0}\n    }\n\
    \    if number == 0 {\n        return []int{0, 0}\n    }\n    if need == 0 {\n\
    \        return []int{number, 0}\n    }\n    if remaining == 0 {\n        return\
    \ []int{0, number}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number > remaining {\n        return []int{number, 0}\n    }\n\
    \    if number == need {\n        return []int{number, 0}\n    }\n    if number\
    \ == remaining {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number == need {\n       \
    \ return []int{0, number}\n    }\n    if number == remaining {\n        return\
    \ []int{0, number}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, number}\n    }\n\
    \    if number == need {\n        return []int{0, number}\n    }\n    if number\
    \ == remaining {\n        return []int{0, number}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, number}\n    }\n    if number == need {\n        return []int{0, number}\n\
    \    }\n    if number == remaining {\n        return []int{0, number}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number == need {\n       \
    \ return []int{0, number}\n    }\n    if number == remaining {\n        return\
    \ []int{0, number}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number > remaining {\n        return []int{0, number}\n    }\n\
    \    if number == need {\n        return []int{0, number}\n    }\n    if number\
    \ == remaining {\n        return []int{0, number}\n    }\n    if number > need\
    \ {\n        return []int{0, 0}\n    }\n    if number > remaining {\n        return\
    \ []int{0, number}\n    }\n    if number == need {\n        return []int{0, number}\n\
    \    }\n    if number == remaining {\n        return []int{0, number}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number == need {\n       \
    \ return []int{0, number}\n    }\n    if number == remaining {\n        return\
    \ []int{0, number}\n    }\n    if number > need {\n        return []int{0, 0}\n\
    \    }\n    if number > remaining {\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp48zv620k_test.go:145:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 {\n        return nil\n    }\n    if need < 0 ||\
    \ need > 1000 {\n        return nil\n    }\n    if remaining < 0 || remaining\
    \ > 1000 {\n        return nil\n    }\n    result := make([]int, 2)\n    result[0]\
    \ = number\n    result[1] = remaining\n    return result\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpm2srvfxr_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=5)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpm2srvfxr_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=4) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpm2srvfxr_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=1) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpm2srvfxr_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpm2srvfxr_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=4)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpm2srvfxr_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > remaining {\n        carrots =\
    \ number-remaining\n    } else {\n        carrots = remaining\n    }\n    if carrots\
    \ > need {\n        carrots = need\n    }\n    return []int{carrots, 0}\n}\n\n\
    func TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4,\
    \ 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected:\
    \ []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n\
    \     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4,\
    \ 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpjao9pt51_test.go:68: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=6)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpjao9pt51_test.go:68:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=8) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpjao9pt51_test.go:68: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpjao9pt51_test.go:68: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpjao9pt51_test.go:68: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=5)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpjao9pt51_test.go:68:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=3) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    if number\
    \ > remaining {\n        carrots = number\n    } else {\n        carrots = remaining\n\
    \    }\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n    if carrots\
    \ > need {\n        carrots = need\n    }\n    carrots = carrots - need\n    if\
    \ carrots == 0 {\n        return []int{0, 0}\n    }\n    carrots = carrots + number\n\
    \    if carrots == 0 {\n        return []int{0, 0}\n    }\n    carrots = carrots\
    \ - number\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n    carrots\
    \ = carrots + number\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n\
    \    carrots = carrots - number\n    if carrots == 0 {\n        return []int{0,\
    \ 0}\n    }\n    carrots = carrots + number\n    if carrots == 0 {\n        return\
    \ []int{0, 0}\n    }\n    carrots = carrots - number\n    if carrots == 0 {\n\
    \        return []int{0, 0}\n    }\n    carrots = carrots + number\n    if carrots\
    \ == 0 {\n        return []int{0, 0}\n    }\n    carrots = carrots - number\n\
    \    if carrots == 0 {\n        return []int{0, 0}\n    }\n    carrots = carrots\
    \ + number\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n    carrots\
    \ = carrots - number\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n\
    \    carrots = carrots + number\n    if carrots == 0 {\n        return []int{0,\
    \ 0}\n    }\n    carrots = carrots - number\n    if carrots == 0 {\n        return\
    \ []int{0, 0}\n    }\n    carrots = carrots + number\n    if carrots == 0 {\n\
    \        return []int{0, 0}\n    }\n    carrots = carrots - number\n    if carrots\
    \ == 0 {\n        return []int{0, 0}\n    }\n    carrots = carrots + number\n\
    \    if carrots == 0 {\n        return []int{0, 0}\n    }\n    carrots = carrots\
    \ - number\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n    carrots\
    \ = carrots + number\n    if carrots == 0 {\n        return []int{0, 0}\n    }\n\
    \    carrots = carrots - number\n\nfunc TestEat(t *testing.T) {\n  candidate :=\
    \ eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwmjh_1ke_test.go:124:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    if number == 0 {\n        return []int{0, 0}\n    }\n    if need\
    \ == 0 {\n        return []int{number, 0}\n    }\n    if remaining == 0 {\n  \
    \      return []int{number, 0}\n    }\n    if number > need {\n        return\
    \ []int{0, 0}\n    }\n    if number > remaining {\n        return []int{0, 0}\n\
    \    }\n    if need > remaining {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number == remaining\
    \ {\n        return []int{number, 0}\n    }\n    if number > remaining {\n   \
    \     return []int{0, 0}\n    }\n    if need > remaining {\n        return []int{0,\
    \ 0}\n    }\n    if number == need {\n        return []int{number, 0}\n    }\n\
    \    if number == remaining {\n        return []int{number, 0}\n    }\n    if\
    \ number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == need {\n        return []int{number, 0}\n\
    \    }\n    if number == remaining {\n        return []int{number, 0}\n    }\n\
    \    if number > need {\n        return []int{0, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, 0}\n    }\n    if need > remaining {\n        return\
    \ []int{0, 0}\n    }\n    if number == \nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiap234nu_test.go:144:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return nil\n    }\n    result := make([]int, 2)\n    carrots\
    \ := 0\n    for i := 0; i < number; i++ {\n        carrots += i\n    }\n    for\
    \ i := 0; i < need; i++ {\n        carrots += i\n    }\n    for i := 0; i < remaining;\
    \ i++ {\n        carrots += i\n    }\n    result[0] = carrots\n    result[1] =\
    \ carrots - need\n    return result\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmp6mr08onw_test.go:72: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=70)\
    \ %!s(int=64)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmp6mr08onw_test.go:72:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=70) %!s(int=62)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmp6mr08onw_test.go:72: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=90) %!s(int=80)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmp6mr08onw_test.go:72: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=66) %!s(int=55)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmp6mr08onw_test.go:72: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=37)\
    \ %!s(int=32)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmp6mr08onw_test.go:72:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=16) %!s(int=11)]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    //\
    \ Your code here\n    carrots := 0\n    carrots = number - need\n    if carrots\
    \ < 0 {\n        carrots = 0\n    }\n    if carrots > remaining {\n        carrots\
    \ = remaining\n    }\n    return []int{carrots, remaining}\n}\n\nfunc TestEat(t\
    \ *testing.T) {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5,\
    \ 6, 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmph35di01z_test.go:65: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=0)\
    \ %!s(int=10)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmph35di01z_test.go:65:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=0) %!s(int=9)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmph35di01z_test.go:65: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=0) %!s(int=10)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmph35di01z_test.go:65: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=0) %!s(int=5)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmph35di01z_test.go:65: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=0)\
    \ %!s(int=7)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmph35di01z_test.go:65:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=0) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    result\
    \ := make([]int, 2)\n    if number > 1000 || need > 1000 || remaining > 1000 {\n\
    \        fmt.Println(\"Invalid input\")\n    }\n    if number == 0 && need ==\
    \ 0 && remaining == 0 {\n        return nil\n    }\n    if number > need {\n \
    \       fmt.Println(\"Invalid input\")\n    }\n    if number > remaining {\n \
    \       fmt.Println(\"Invalid input\")\n    }\n    if number == 0 && need == 0\
    \ && remaining == 0 {\n        return nil\n    }\n    if number > need {\n   \
    \     fmt.Println(\"Invalid input\")\n    }\n    if number > remaining {\n   \
    \     fmt.Println(\"Invalid input\")\n    }\n    if number == 0 && need == 0 &&\
    \ remaining == 0 {\n        return nil\n    }\n    if number > need {\n      \
    \  fmt.Println(\"Invalid input\")\n    }\n    if number > remaining {\n      \
    \  fmt.Println(\"Invalid input\")\n    }\n    if number == 0 && need == 0 && remaining\
    \ == 0 {\n        return nil\n    }\n    if number > need {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    if number > remaining {\n        fmt.Println(\"Invalid\
    \ input\")\n    }\n    if number == 0 && need == 0 && remaining == 0 {\n     \
    \   return nil\n    }\n    if number > need {\n        fmt.Println(\"Invalid input\"\
    )\n    }\n    if number > remaining {\n        fmt.Println(\"Invalid input\")\n\
    \    }\n    if number == 0 && need == 0 && remaining == 0 {\n        return nil\n\
    \    }\n    if number > need {\n        fmt.Println(\"Invalid input\")\n    }\n\
    \    if number > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n\
    \    if number == 0 && need == 0 && remaining == 0 {\n        return nil\n   \
    \ }\n    if number > need {\n        fmt.Println(\"Invalid input\")\n    }\n \
    \   if number > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n \
    \   if number == 0 && need == 0 && remaining == 0 {\n        return nil\n    }\n\
    \    if number > need {\n        fmt.Println(\"Invalid input\")\n    }\n    if\
    \ number > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n    if\
    \ number == 0 && need == 0 && remaining == 0 {\n        return nil\n    }\n  \
    \  if number > need {\n        fmt.Println(\"Invalid input\")\n    }\n    if number\
    \ > remaining {\n        fmt.Println(\"Invalid input\")\n    }\n    if number\
    \ == 0 && need == 0 && remaining == 0 {\n        return nil\n    }\n    if number\
    \ > need {\n        fmt.Println(\"Invalid input\")\n    }\n    if number > remaining\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp43_qlm3b_test.go:129:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    carrots -= remaining\n    carrots -= number\n    carrots\
    \ -= need\n    carrots -= remaining\n    carrots -= number\n    carrots -= need\n\
    \    carrots -= remaining\n    carrots -= number\n    carrots -= need\n    carrots\
    \ -= remaining\n    carrots -= number\n    carrots -= need\n    carrots -= remaining\n\
    \    carrots -= number\n    carrots -= need\n    carrots -= remaining\n    carrots\
    \ -= number\n    carrots -= need\n    carrots -= remaining\n    carrots -= number\n\
    \    carrots -= need\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjgqtmlim_test.go:108:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    meals := 0\n    for i := 0; i < number; i++\
    \ {\n        carrots += i\n    }\n    for i := 0; i < need; i++ {\n        carrots\
    \ += i\n    }\n    for i := 0; i < remaining; i++ {\n        carrots += i\n  \
    \  }\n    if carrots > 1000 {\n        carrots = 1000\n    }\n    meals = carrots\
    \ / 2\n    carrots %= 2\n    if carrots == 0 {\n        carrots = 1\n    }\n \
    \   return []int{meals, carrots}\n}\n\nfunc TestEat(t *testing.T) {\n  candidate\
    \ := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpcyki4lxm_test.go:78: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=35)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpcyki4lxm_test.go:78:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=35) %!s(int=1)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpcyki4lxm_test.go:78: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=45) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpcyki4lxm_test.go:78: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=33) %!s(int=1)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n\
    \        tmpcyki4lxm_test.go:78: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=18)\
    \ %!s(int=1)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpcyki4lxm_test.go:78:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=8) %!s(int=1)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    if number == 0 {\n        return\
    \ []int{0, 0}\n    }\n    if remaining == 0 {\n        return []int{number, 0}\n\
    \    }\n    if number > need {\n        return []int{0, 0}\n    }\n    if number\
    \ == need {\n        return []int{number, 0}\n    }\n    if number > remaining\
    \ {\n        return []int{0, number}\n    }\n    if number == remaining {\n  \
    \      return []int{number, number}\n    }\n    if number > need {\n        return\
    \ []int{0, number}\n    }\n    if number == need {\n        return []int{number,\
    \ number}\n    }\n    if number > remaining {\n        return []int{0, number}\n\
    \    }\n    if number == remaining {\n        return []int{number, number}\n \
    \   }\n    if number > need {\n        return []int{0, number}\n    }\n    if\
    \ number == need {\n        return []int{number, number}\n    }\n    if number\
    \ > remaining {\n        return []int{0, number}\n    }\n    if number == remaining\
    \ {\n        return []int{number, number}\n    }\n    if number > need {\n   \
    \     return []int{0, number}\n    }\n    if number == need {\n        return\
    \ []int{number, number}\n    }\n    if number > remaining {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining {\n        return []int{number, number}\n\
    \    }\n    if number > need {\n        return []int{0, number}\n    }\n    if\
    \ number == need {\n        return []int{number, number}\n    }\n    if number\
    \ > remaining {\n        return []int{0, number}\n    }\n    if number == remaining\
    \ {\n        return []int{number, number}\n    }\n    if number > need {\n   \
    \     return []int{0, number}\n    }\n    if number == need {\n        return\
    \ []int{number, number}\n    }\n    if number > remaining {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining {\n        return []int{number, number}\n\
    \    }\n    if number > need {\n        return []int{0, number}\n    }\n    if\
    \ number == need {\n        return []int{number, number}\n    }\n    if number\
    \ > remaining {\n        return []int{0, number}\n    }\n    if number == remaining\
    \ {\n        return []int{number, number}\n    }\n    if number > need {\n   \
    \     return []int{0, number}\n    }\n    if number == need {\n        return\
    \ []int{number, number}\n    }\n    if number > remaining {\n        return []int{0,\
    \ number}\n    }\n    if number == remaining {\n        return []int{number, number}\n\
    \    }\n    if number > need {\n        return []\nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw3ljc6zk_test.go:141:18: expected type, found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{}\n\
    \    }\n    if number == 0 {\n        return []int{need, remaining}\n    }\n \
    \   if need == 0 {\n        return []int{number, remaining}\n    }\n    if remaining\
    \ == 0 {\n        return []int{number, need}\n    }\n    if number > need {\n\
    \        return []int{number, need}\n    }\n    if number > remaining {\n    \
    \    return []int{number, remaining}\n    }\n    if need > remaining {\n     \
    \   return []int{need, remaining}\n    }\n    if number == need && number == remaining\
    \ {\n        return []int{number, number}\n    }\n    if number == need {\n  \
    \      return []int{number, need}\n    }\n    if number == remaining {\n     \
    \   return []int{number, remaining}\n    }\n    if need == remaining {\n     \
    \   return []int{need, need}\n    }\n    if need == number {\n        return []int{need,\
    \ need}\n    }\n    if remaining == number {\n        return []int{need, need}\n\
    \    }\n    if need == remaining {\n        return []int{need, need}\n    }\n\
    \    if number == remaining {\n        return []int{number, number}\n    }\n \
    \   if need == number {\n        return []int{need, need}\n    }\n    if number\
    \ == need {\n        return []int{number, number}\n    }\n    if number == remaining\
    \ {\n        return []int{number, number}\n    }\n    if need == number {\n  \
    \      return []int{need, need}\n    }\n    if number == need {\n        return\
    \ []int{number, number}\n    }\n    if number == remaining {\n        return []int{number,\
    \ number}\n    }\n    if need == number {\n        return []int{need, need}\n\
    \    }\n    if number == need {\n        return []int{number, number}\n    }\n\
    \    if number == remaining {\n        return []int{number, number}\n    }\n \
    \   if need == number {\n        return []int{need, need}\n    }\n    if number\
    \ == need {\n        return []int{number, number}\n    }\n    if number == remaining\
    \ {\n        return []int{number, number}\n    }\n    if need == number {\n  \
    \      return []int{need, need}\n    }\n    if number == need {\n        return\
    \ []int{number, number}\n    }\n    if number == remaining {\n        return []int{number,\
    \ number}\n    }\n    if need == number {\n        return []int{need, need}\n\
    \    }\n    if number == need {\n        return []int{number, number}\n    }\n\
    \    if number == remaining {\n        return []int{number, number}\n    }\n \
    \   if need == number {\n        return []int{need, \nfunc TestEat(t *testing.T)\
    \ {\n  candidate := eat\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5, 6,\
    \ 10), expected: []int{11, 4} },\n     { actual: candidate(4, 8, 9), expected:\
    \ []int{12, 1} },\n     { actual: candidate(1, 10, 10), expected: []int{11, 0}\
    \ },\n     { actual: candidate(2, 11, 5), expected: []int{7, 0} },\n     { actual:\
    \ candidate(4, 5, 7), expected: []int{9, 2} },\n     { actual: candidate(4, 5,\
    \ 1), expected: []int{5, 0} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplocw8s5i_test.go:136:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number < 0 || number > 1000 || need < 0 || need > 1000 || remaining < 0 || remaining\
    \ > 1000 {\n        return []int{0, 0}\n    }\n    carrots := 0\n    carrots +=\
    \ number\n    carrots += need\n    carrots += remaining\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots\
    \ %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n   \
    \ carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n\
    \    carrots %= 1000\n    carrots %= 1000\n    carrots %= 1000\n    carrots %=\
    \ 1000\n    \nfunc TestEat(t *testing.T) {\n  candidate := eat\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5, 6, 10), expected: []int{11, 4} },\n     { actual:\
    \ candidate(4, 8, 9), expected: []int{12, 1} },\n     { actual: candidate(1, 10,\
    \ 10), expected: []int{11, 0} },\n     { actual: candidate(2, 11, 5), expected:\
    \ []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected: []int{9, 2} },\n\
    \     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n   }\n\n\tfor i,\
    \ tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0hiq1d6j_test.go:108:6: expected ''('', found TestEat

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075201
- exit_code: 1
  program: "package eat_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// You're\
    \ a hungry rabbit, and you already have eaten a certain number of carrots,\n//\
    \ but now you need to eat more carrots to complete the day's meals.\n// you should\
    \ return a list of [ total number of eaten carrots after your meals,\n// the number\
    \ of carrots left after your meals ]\n// if there are not enough remaining carrots,\
    \ you will eat all remaining carrots, but will still be hungry.\n// Example:\n\
    // >>> eat(5, 6, 10)\n// []int{11, 4}\n// >>> eat(4, 8, 9)\n// []int{12, 1}\n\
    // >>> eat(1, 10, 10)\n// []int{11, 0}\n// >>> eat(2, 11, 5)\n// []int{7, 0}\n\
    // Variables:\n// @number : integer\n// the number of carrots that you have eaten.\n\
    // @need : integer\n// the number of carrots that you need to eat.\n// @remaining\
    \ : integer\n// the number of remaining carrots thet exist in stock\n// Constrain:\n\
    // * 0 <= number <= 1000\n// * 0 <= need <= 1000\n// * 0 <= remaining <= 1000\n\
    // Have fun :)\nfunc eat(number int, need int, remaining int) []int {\n    if\
    \ number > 1000 || need > 1000 || remaining > 1000 {\n        return []int{0,\
    \ 0}\n    }\n    carrots := 0\n    if number > remaining {\n        carrots =\
    \ number\n    } else {\n        carrots = remaining\n    }\n    meals := []int{0,\
    \ 0}\n    if carrots > 0 {\n        meals[0] = carrots\n        carrots -= meals[0]\n\
    \    }\n    if carrots > 0 {\n        meals[1] = carrots\n        carrots -= meals[1]\n\
    \    }\n    return meals\n}\n\nfunc TestEat(t *testing.T) {\n  candidate := eat\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5, 6, 10), expected: []int{11,\
    \ 4} },\n     { actual: candidate(4, 8, 9), expected: []int{12, 1} },\n     {\
    \ actual: candidate(1, 10, 10), expected: []int{11, 0} },\n     { actual: candidate(2,\
    \ 11, 5), expected: []int{7, 0} },\n     { actual: candidate(4, 5, 7), expected:\
    \ []int{9, 2} },\n     { actual: candidate(4, 5, 1), expected: []int{5, 0} },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestEat (0.00s)\n    --- FAIL: TestEat/test_num__0 (0.00s)\n\
    \        tmpgw_327c9_test.go:74: expected '[%!s(int=11) %!s(int=4)]', got '[%!s(int=10)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__1 (0.00s)\n        tmpgw_327c9_test.go:74:\
    \ expected '[%!s(int=12) %!s(int=1)]', got '[%!s(int=9) %!s(int=0)]'\n    ---\
    \ FAIL: TestEat/test_num__2 (0.00s)\n        tmpgw_327c9_test.go:74: expected\
    \ '[%!s(int=11) %!s(int=0)]', got '[%!s(int=10) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__3\
    \ (0.00s)\n        tmpgw_327c9_test.go:74: expected '[%!s(int=7) %!s(int=0)]',\
    \ got '[%!s(int=5) %!s(int=0)]'\n    --- FAIL: TestEat/test_num__4 (0.00s)\n \
    \       tmpgw_327c9_test.go:74: expected '[%!s(int=9) %!s(int=2)]', got '[%!s(int=7)\
    \ %!s(int=0)]'\n    --- FAIL: TestEat/test_num__5 (0.00s)\n        tmpgw_327c9_test.go:74:\
    \ expected '[%!s(int=5) %!s(int=0)]', got '[%!s(int=4) %!s(int=0)]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075209
