name: HumanEval_127_intersection
language: go_test.go
prompt: "package intersection_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
  // You are given two intervals,\n// where each interval is a pair of integers. For\
  \ example, interval = (start, end) = (1, 2).\n// The given intervals are closed\
  \ which means that the interval (start, end)\n// includes both start and end.\n\
  // For each given interval, it is assumed that its start is less or equal its end.\n\
  // Your task is to determine whether the length of intersection of these two \n\
  // intervals is a prime number.\n// Example, the intersection of the intervals (1,\
  \ 3), (2, 4) is (2, 3)\n// which its length is 1, which not a prime number.\n//\
  \ If the length of the intersection is a prime number, return \"YES\",\n// otherwise,\
  \ return \"NO\".\n// If the two intervals don't intersect, return \"NO\".\n// [input/output]\
  \ samples:\n// >>> intersection([]interface{}{1, 2}, []interface{}{2, 3})\n// \"\
  NO\"\n// >>> intersection([]interface{}{-1, 1}, []interface{}{0, 4})\n// \"NO\"\n\
  // >>> intersection([]interface{}{-3, -1}, []interface{}{-5, 5})\n// \"YES\"\nfunc\
  \ intersection(interval1 []interface{}, interval2 []interface{}) string {\n"
tests: "func TestIntersection(t *testing.T) {\n  candidate := intersection\n\ttype\
  \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
  \ := []test{\n     { actual: candidate([]interface{}{1, 2}, []interface{}{2, 3}),\
  \ expected: \"NO\" },\n     { actual: candidate([]interface{}{-1, 1}, []interface{}{0,\
  \ 4}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-3, -1}, []interface{}{-5,\
  \ 5}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-2, 2}, []interface{}{-4,\
  \ 0}), expected: \"YES\" },\n     { actual: candidate([]interface{}{-11, 2}, []interface{}{-1,\
  \ -1}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{3,\
  \ 5}), expected: \"NO\" },\n     { actual: candidate([]interface{}{1, 2}, []interface{}{1,\
  \ 2}), expected: \"NO\" },\n     { actual: candidate([]interface{}{-2, -2}, []interface{}{-3,\
  \ -2}), expected: \"NO\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
  test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
  \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\"\
  , tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if len(interval1) != len(interval2) {\n        return \"NO\"\n\
    \    }\n    \n    interval1Start := interval1[0].(float64)\n    interval1End :=\
    \ interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n    interval2End\
    \ := interval2[1].(float64)\n    \n    if interval1Start > interval2End {\n  \
    \      return \"NO\"\n    }\n    if interval1End < interval2Start {\n        return\
    \ \"NO\"\n    }\n    \n    intersection := interval1Start + interval1End - interval2Start\
    \ - interval2End\n    \n    if intersection <= 0 {\n        return \"NO\"\n  \
    \  }\n    \n    if isPrime(intersection) {\n        return \"YES\"\n    }\n  \
    \  \n    return \"NO\"\n}\n", "    \n    // Write your code here\n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    ", "    if len(interval1) != len(interval2) {\n       \
    \ return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n \
    \   interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    intersectionStart := interval1Start\n \
    \   intersectionEnd := interval1End\n    \n    for i := 1; i < len(interval1);\
    \ i++ {\n        interval1Start := interval1[i].(float64)\n        interval1End\
    \ := interval1[i+1].(float64)\n        \n        if interval1Start > interval2End\
    \ {\n            return \"NO\"\n        }\n        if interval1End < interval2Start\
    \ {\n            return \"NO\"\n        }\n        \n        if interval1Start\
    \ <= intersectionEnd && interval1End >= intersectionStart {\n            intersectionEnd\
    \ = interval1End\n        }\n        if interval1Start <= intersectionStart &&\
    \ interval1End >= intersectionEnd {\n            intersectionStart = interval1Start\n\
    \        }\n    }\n    \n    if intersectionEnd <= intersectionStart {\n     \
    \   return \"NO\"\n    }\n    \n    if isPrime(intersectionEnd - intersectionStart)\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n", "    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    interval1Start\
    \ := interval1[0].(float64)\n    interval1End := interval1[1].(float64)\n    interval2Start\
    \ := interval2[0].(float64)\n    interval2End := interval2[1].(float64)\n    \n\
    \    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start := interval1[i].(float64)\n\
    \        interval1End := interval1[i+1].(float64)\n        \n        if interval1Start\
    \ > interval1End {\n            return \"NO\"\n        }\n        \n        if\
    \ interval2Start > interval2End {\n            return \"NO\"\n        }\n    \
    \    \n        if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n        }\n        \n        if interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n            intersectionStart = interval1End\n\
    \            intersectionEnd = interval1End\n        }\n        \n        if interval1Start\
    \ >= interval2Start && interval1End <= interval2End {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1End\n        }\n  \
    \  }\n    \n    if intersectionStart > intersectionEnd {\n        return \"NO\"\
    \n    }\n    \n    if intersectionStart <= intersectionEnd {\n        return \"\
    YES\"\n    }\n    \n    return \"NO\"\n}\n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n\
    \    interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    intersectionStart := interval1Start\n\
    \    intersectionEnd := interval1End\n    \n    for interval1Start < interval1End\
    \ && interval2Start < interval2End {\n        if interval1Start <= interval2Start\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n        }\n        if interval1End <= interval2End {\n     \
    \       intersectionEnd = interval1End\n        }\n        interval1Start += interval1Step\n\
    \        interval2Start += interval2Step\n    }\n    \n    if interval1Start <\
    \ interval1End {\n        intersectionStart = interval1Start\n        intersectionEnd\
    \ = interval1End\n    }\n    if interval2Start < interval2End {\n        intersectionEnd\
    \ = interval2Start\n        intersectionStart = interval2End\n    }\n    \n  \
    \  if intersectionStart > intersectionEnd {\n        return \"NO\"\n    }\n  \
    \  \n    if intersectionStart < interval1Start || intersectionEnd > interval2End\
    \ {\n        return \"NO\"\n    }\n    \n    if intersectionStart <= intersectionEnd\
    \ {\n        if intersectionStart <= interval1Start {\n            return \"YES\"\
    \n        }\n        if intersectionEnd <= interval2End {\n            return\
    \ \"YES\"\n        }\n    }\n    \n    return \"NO\"\n}\n", "    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "    var interval1Start, interval1End\
    \ int\n    var interval2Start, interval2End int\n    var intersectionLength int\n\
    \    var isPrime bool\n\n    if len(interval1) != len(interval2) {\n        return\
    \ \"NO\"\n    }\n\n    for i := 0; i < len(interval1); i++ {\n        interval1Start\
    \ = interval1[i].(int)\n        interval1End = interval1Start + interval1[i].(int)\n\
    \        interval2Start = interval2[i].(int)\n        interval2End = interval2Start\
    \ + interval2[i].(int)\n\n        if interval1Start > interval1End {\n       \
    \     return \"NO\"\n        }\n\n        if interval2Start > interval2End {\n\
    \            return \"NO\"\n        }\n\n        if interval1Start <= interval2Start\
    \ && interval1End >= interval2End {\n            intersectionLength = interval1End\
    \ - interval1Start\n            if isPrime(intersectionLength) {\n           \
    \     return \"YES\"\n            }\n        }\n    }\n\n    return \"NO\"\n}\n",
  "    if len(interval1) != len(interval2) {\n        return \"NO\"\n    }\n    \n\
    \    interval1Start := interval1[0].(float64)\n    interval1End := interval1[1].(float64)\n\
    \    interval2Start := interval2[0].(float64)\n    interval2End := interval2[1].(float64)\n\
    \    \n    intersectionStart := interval1Start\n    intersectionEnd := interval1End\n\
    \    \n    for i := 1; i < len(interval1); i++ {\n        interval1Start := interval1[i].(float64)\n\
    \        interval1End := interval1[i+1].(float64)\n        \n        if interval1Start\
    \ > interval1End {\n            return \"NO\"\n        }\n        \n        if\
    \ interval2Start > interval2End {\n            return \"NO\"\n        }\n    \
    \    \n        if interval1Start <= interval2Start && interval1End >= interval2End\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n        }\n        \n        if interval1Start <= interval2End\
    \ && interval1End >= interval2Start {\n            intersectionStart = interval1End\n\
    \            intersectionEnd = interval1End\n        }\n        \n        if interval1Start\
    \ <= interval2Start && interval1End <= interval2End {\n            intersectionStart\
    \ = interval1Start\n            intersectionEnd = interval1End\n        }\n  \
    \      \n        if interval1Start >= interval2Start && interval1End <= interval2End\
    \ {\n            intersectionStart = interval1Start\n            intersectionEnd\
    \ = interval1End\n        }\n        \n        if interval1Start >= interval2Start\
    \ && interval1End >= interval2End {\n            intersectionStart = interval1Start\n\
    \            intersectionEnd = interval1End\n        }\n    }\n    \n    if intersectionStart\
    \ <= intersectionEnd {\n        return \"YES\"\n    }\n    \n    return \"NO\"\
    \n}\n", "    if len(interval1) != len(interval2) {\n        return \"NO\"\n  \
    \  }\n    \n    interval1Start := interval1[0].(int)\n    interval1End := interval1[1].(int)\n\
    \    interval2Start := interval2[0].(int)\n    interval2End := interval2[1].(int)\n\
    \    \n    if interval1Start > interval2End {\n        return \"NO\"\n    }\n\
    \    \n    if interval1End < interval2Start {\n        return \"NO\"\n    }\n\
    \    \n    interval1Length := interval1End - interval1Start\n    interval2Length\
    \ := interval2End - interval2Start\n    \n    if interval1Length == 0 || interval2Length\
    \ == 0 {\n        return \"NO\"\n    }\n    \n    if interval1Length == interval2Length\
    \ {\n        if interval1Start <= interval2Start {\n            return \"NO\"\n\
    \        }\n        return \"YES\"\n    }\n    \n    if interval1Length < interval2Length\
    \ {\n        interval1Start += interval1Length\n        interval1End += interval1Length\n\
    \    }\n    \n    if interval1Length > interval2Length {\n        interval2Start\
    \ += interval2Length\n        interval2End += interval2Length\n    }\n    \n \
    \   if interval1Start > interval2End {\n        return \"NO\"\n    }\n    \n \
    \   if interval1End < interval2Start {\n        return \"NO\"\n    }\n    \n \
    \   if interval1Start <= interval2Start {\n        return \"YES\"\n    }\n   \
    \ \n    return \"NO\"\n}\n", "    \n    interval1_start := interval1[0].(float64)\n\
    \    interval1_end := interval1[1].(float64)\n    interval2_start := interval2[0].(float64)\n\
    \    interval2_end := interval2[1].(float64)\n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n", "    if len(interval1) != len(interval2) {\n     \
    \   return \"NO\"\n    }\n    \n    interval1 := make([]int, len(interval1))\n\
    \    interval2 := make([]int, len(interval2))\n    \n    for i := range interval1\
    \ {\n        interval1[i] = int(interval1[i])\n    }\n    for i := range interval2\
    \ {\n        interval2[i] = int(interval2[i])\n    }\n    \n    result := make([]int,\
    \ len(interval1))\n    \n    for i := range interval1 {\n        for j := range\
    \ interval2 {\n            if interval1[i] < interval2[j] {\n                result[i]\
    \ = interval1[i]\n                break\n            }\n            if interval1[i]\
    \ > interval2[j] {\n                result[i] = interval2[j]\n               \
    \ break\n            }\n        }\n    }\n    \n    if len(result) == 0 {\n  \
    \      return \"NO\"\n    }\n    \n    for i := range result {\n        if result[i]\
    \ == 0 {\n            return \"NO\"\n        }\n    }\n    \n    if isPrime(result[0])\
    \ {\n        return \"YES\"\n    }\n    \n    return \"NO\"\n}\n", "    if len(interval1)\
    \ != len(interval2) {\n        return \"NO\"\n    }\n    \n    interval1Start\
    \ := interval1[0].(float64)\n    interval1End := interval1[1].(float64)\n    interval2Start\
    \ := interval2[0].(float64)\n    interval2End := interval2[1].(float64)\n    \n\
    \    if interval1Start > interval1End || interval2Start > interval2End {\n   \
    \     return \"NO\"\n    }\n    \n    interval1Length := interval1End - interval1Start\n\
    \    interval2Length := interval2End - interval2Start\n    \n    if interval1Length\
    \ == 0 || interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    intersectionLength\
    \ := interval1Length * interval2Length\n    \n    if intersectionLength == 0 {\n\
    \        return \"NO\"\n    }\n    \n    if isPrime(intersectionLength) {\n  \
    \      return \"YES\"\n    }\n    \n    return \"NO\"\n}\n", "    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "    var result string\n    if len(interval1)\
    \ > len(interval2) {\n        result = intersection(interval2, interval1)\n  \
    \  } else {\n        result = intersection(interval1, interval2)\n    }\n    if\
    \ result == \"YES\" {\n        return \"YES\"\n    }\n    if result == \"NO\"\
    \ {\n        return \"NO\"\n    }\n    return \"NO\"\n}\n", "    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1Start, interval1End := interval1[0].([]interface{})[0],\
    \ interval1[0].([]interface{})[1]\n    interval2Start, interval2End := interval2[0].([]interface{})[0],\
    \ interval2[0].([]interface{})[1]\n    \n    if interval1Start > interval2End\
    \ {\n        return \"NO\"\n    }\n    if interval1End < interval2Start {\n  \
    \      return \"NO\"\n    }\n    \n    result := 0\n    \n    for i := 0; i <\
    \ len(interval1); i++ {\n        if interval1Start <= interval1[i].([]interface{})[1]\
    \ && interval1[i].([]interface{})[1] < interval1End {\n            result += interval1[i].([]interface{})[1]\
    \ - interval1[i].([]interface{})[0]\n        }\n    }\n    \n    for i := 0; i\
    \ < len(interval2); i++ {\n        if interval2Start <= interval2[i].([]interface{})[1]\
    \ && interval2[i].([]interface{})[1] < interval2End {\n            result += interval2[i].([]interface{})[1]\
    \ - interval2[i].([]interface{})[0]\n        }\n    }\n    \n    if result % 2\
    \ == 0 {\n        return \"YES\"\n    }\n    return \"NO\"\n}\n", "    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n", "    if len(interval1) != len(interval2)\
    \ {\n        return \"NO\"\n    }\n    \n    interval1Start := interval1[0].(float64)\n\
    \    interval1End := interval1[1].(float64)\n    interval2Start := interval2[0].(float64)\n\
    \    interval2End := interval2[1].(float64)\n    \n    if interval1Start > interval1End\
    \ {\n        interval1Start, interval1End = interval1End, interval1Start\n   \
    \ }\n    if interval2Start > interval2End {\n        interval2Start, interval2End\
    \ = interval2End, interval2Start\n    }\n    \n    interval1Length := interval1End\
    \ - interval1Start\n    interval2Length := interval2End - interval2Start\n   \
    \ \n    if interval1Length == 0 || interval2Length == 0 {\n        return \"NO\"\
    \n    }\n    \n    intersectionLength := interval1Length * interval2Length\n \
    \   \n    if intersectionLength == 0 {\n        return \"NO\"\n    }\n    \n \
    \   if interval1Length == interval2Length {\n        if interval1Start <= interval2Start\
    \ {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n   \
    \ \n    if interval1Length > interval2Length {\n        interval1Length, interval2Length\
    \ = interval2Length, interval1Length\n    }\n    \n    if interval1Length % 2\
    \ == 0 {\n        interval1Length /= 2\n    }\n    if interval2Length % 2 == 0\
    \ {\n        interval2Length /= 2\n    }\n    \n    if interval1Length == interval2Length\
    \ {\n        if interval1Start <= interval2Start {\n            return \"YES\"\
    \n        }\n        return \"NO\"\n    }\n    \n    if interval1Length > interval2Length\
    \ {\n        interval1Length, interval2Length = interval2Length, interval1Length\n\
    \    }\n    \n    if interval1Length == 0 {\n        return \"NO\"\n    }\n  \
    \  \n    if interval2Length == 0 {\n        return \"NO\"\n    }\n    \n    if\
    \ interval1Length == interval2Length {\n        if interval1Start <= interval2Start\
    \ {\n            return \"YES\"\n        }\n        return \"NO\"\n    }\n   \
    \ \n    if interval1Length > interval2Length {\n        interval1Length, interval2Length\
    \ = interval2Length, interval1Length\n    }\n    \n    if interval1Length == 0\
    \ {\n        return \"NO\"\n    }\n    \n    if interval2Length == 0 {\n     \
    \   return \"NO\"\n    }\n    \n    if interval1Length == interval2Length {\n\
    \        if interval1Start <= interval2Start {\n            return \"YES\"\n \
    \       }", "    \n    // Your code here\n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    "]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
