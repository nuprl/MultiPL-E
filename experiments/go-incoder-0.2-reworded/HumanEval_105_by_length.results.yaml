language: go_test.go
name: HumanEval_105_by_length
results:
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)/2]\n    for\
    \ i := 0; i < len(arr); i++ {\n        if arr[i] < 1 || arr[i] > 9 {\n       \
    \     continue\n        }\n        arr[i], arr[len(arr)-i-1] = arr[len(arr)-i-1],\
    \ arr[i]\n    }\n    arr := reverse(arr)\n    arr := []string{}\n    for _, i\
    \ := range arr {\n        arr = append(arr, fmt.Sprintf(\"%s\", i))\n    }\n \
    \   return arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0dp_b30v_test.go:21:5: undefined: sort

    /tmp/tmp0dp_b30v_test.go:22:9: no new variables on left side of :=

    /tmp/tmp0dp_b30v_test.go:29:9: no new variables on left side of :=

    /tmp/tmp0dp_b30v_test.go:29:12: undefined: reverse

    /tmp/tmp0dp_b30v_test.go:30:9: no new variables on left side of :=

    /tmp/tmp0dp_b30v_test.go:30:12: cannot use []string{} (value of type []string)
    as type []int in assignment

    /tmp/tmp0dp_b30v_test.go:32:27: cannot use fmt.Sprintf("%s", i) (value of type
    string) as type int in argument to append

    /tmp/tmp0dp_b30v_test.go:34:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            arr2[i] = \"One\"\
    \n        } else if arr[i] >= 10 && arr[i] <= 99 {\n            arr2[i] = \"Two\"\
    \n        } else if arr[i] >= 100 && arr[i] <= 999 {\n            arr2[i] = \"\
    Three\"\n        } else if arr[i] >= 1000 && arr[i] <= 9999 {\n            arr2[i]\
    \ = \"Four\"\n        } else if arr[i] >= 10000 && arr[i] <= 99999 {\n       \
    \     arr2[i] = \"Five\"\n        } else if arr[i] >= 100000 && arr[i] <= 999999\
    \ {\n            arr2[i] = \"Six\"\n        } else if arr[i] >= 1000000 && arr[i]\
    \ <= 9999999 {\n            arr2[i] = \"Seven\"\n        } else if arr[i] >= 10000000\
    \ && arr[i] <= 99999999 {\n            arr2[i] = \"Eight\"\n        } else if\
    \ arr[i] >= 100000000 && arr[i] <= 999999999 {\n            arr2[i] = \"Nine\"\
    \n        }\n    }\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n\
    \  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[One One One One One One One One]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[One]', got '[One  Two]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmp21whjqzt_test.go:63:\
    \ expected '[Three Two One]', got '[One  One One]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[Nine Eight Four]', got '[One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075206
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return nil\n    }\n    arr2\
    \ := make([]string, len(arr))\n    for i := range arr {\n        if arr[i] >=\
    \ 1 && arr[i] <= 9 {\n            arr2[i] = \"One\"\n        } else if arr[i]\
    \ >= 10 && arr[i] <= 99 {\n            arr2[i] = \"Two\"\n        } else if arr[i]\
    \ >= 100 && arr[i] <= 999 {\n            arr2[i] = \"Three\"\n        } else if\
    \ arr[i] >= 1000 && arr[i] <= 9999 {\n            arr2[i] = \"Four\"\n       \
    \ } else if arr[i] >= 10000 && arr[i] <= 99999 {\n            arr2[i] = \"Five\"\
    \n        } else if arr[i] >= 100000 && arr[i] <= 999999 {\n            arr2[i]\
    \ = \"Six\"\n        } else if arr[i] >= 1000000 && arr[i] <= 9999999 {\n    \
    \        arr2[i] = \"Seven\"\n        } else if arr[i] >= 10000000 && arr[i] <=\
    \ 99999999 {\n            arr2[i] = \"Eight\"\n        } else if arr[i] >= 100000000\
    \ && arr[i] <= 999999999 {\n            arr2[i] = \"Nine\"\n        } else {\n\
    \            arr2[i] = \"?\"\n        }\n    }\n    arr2 = append(arr2[:len(arr)-1],\
    \ arr2...)\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp5e_65t8p_test.go:69: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[One One One One One One One One One One One One One One\
    \ One]'\n    --- FAIL: TestBy_Length/test_num__2 (0.00s)\n        tmp5e_65t8p_test.go:69:\
    \ expected '[One]', got '[One ? One ? Two]'\n    --- FAIL: TestBy_Length/test_num__3\
    \ (0.00s)\n        tmp5e_65t8p_test.go:69: expected '[Three Two One]', got '[One\
    \ ? One One ? One One]'\n    --- FAIL: TestBy_Length/test_num__4 (0.00s)\n   \
    \     tmp5e_65t8p_test.go:69: expected '[Nine Eight Four]', got '[One One One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075206
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            result[i] = fmt.Sprintf(\"\
    %s\", arr[arr[i]-1])\n        } else {\n            result[i] = \"\"\n       \
    \ }\n    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpab0uq4mh_test.go:24:25: fmt.Sprintf format %s has arg arr[arr[i]-1] of
    wrong type int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075206
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            result[i] = \"One\"\
    \n        } else if arr[i] >= 10 && arr[i] <= 99 {\n            result[i] = \"\
    Two\"\n        } else if arr[i] >= 100 && arr[i] <= 999 {\n            result[i]\
    \ = \"Three\"\n        } else if arr[i] >= 1000 && arr[i] <= 9999 {\n        \
    \    result[i] = \"Four\"\n        } else if arr[i] >= 10000 && arr[i] <= 99999\
    \ {\n            result[i] = \"Five\"\n        } else if arr[i] >= 100000 && arr[i]\
    \ <= 999999 {\n            result[i] = \"Six\"\n        } else if arr[i] >= 1000000\
    \ && arr[i] <= 9999999 {\n            result[i] = \"Seven\"\n        } else if\
    \ arr[i] >= 10000000 && arr[i] <= 99999999 {\n            result[i] = \"Eight\"\
    \n        } else if arr[i] >= 100000000 && arr[i] <= 999999999 {\n           \
    \ result[i] = \"Nine\"\n        }\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp25ia5xw__test.go:63: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[One One One One One One One One]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmp25ia5xw__test.go:63: expected '[One]', got '[One  Two]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmp25ia5xw__test.go:63:\
    \ expected '[Three Two One]', got '[One  One One]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmp25ia5xw__test.go:63: expected '[Nine Eight Four]', got '[One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075206
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    for i := 0; i < len(arr); i++ {\n        arr3[i] = arr[i]\n \
    \   }\n    sort.Ints(arr3)\n    for i := 0; i < len(arr); i++ {\n        if arr3[i]\
    \ >= 1 && arr3[i] <= 9 {\n            arr2[i] = fmt.Sprintf(\"%s\", arr3[i])\n\
    \        } else {\n            arr2[i] = \"One\"\n        }\n    }\n    for i\
    \ := 0; i < len(arr); i++ {\n        arr2[i] = arr2[i][1:]\n    }\n    return\
    \ arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfrr6t6qr_test.go:26:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    if len(arr) == 0 {\n       \
    \ return result\n    }\n    sort.Ints(arr)\n    for _, v := range arr {\n    \
    \    if v >= 1 && v <= 9 {\n            result = append(result, fmt.Sprintf(\"\
    %s\", v))\n        } else {\n            result = append(result, \"One\")\n  \
    \      }\n    }\n    for _, v := range arr {\n        if v >= 10 && v <= 99 {\n\
    \            result = append(result, fmt.Sprintf(\"%s\", v))\n        } else {\n\
    \            result = append(result, \"Two\")\n        }\n    }\n    for _, v\
    \ := range arr {\n        if v >= 100 && v <= 999 {\n            result = append(result,\
    \ fmt.Sprintf(\"%s\", v))\n        } else {\n            result = append(result,\
    \ \"Three\")\n        }\n    }\n    for _, v := range arr {\n        if v >= 1000\
    \ && v <= 9999 {\n            result = append(result, fmt.Sprintf(\"%s\", v))\n\
    \        } else {\n            result = append(result, \"Four\")\n        }\n\
    \    }\n    for _, v := range arr {\n        if v >= 10000 && v <= 99999 {\n \
    \           result = append(result, fmt.Sprintf(\"%s\", v))\n        } else {\n\
    \            result = append(result, \"Five\")\n        }\n    }\n    for _, v\
    \ := range arr {\n        if v >= 100000 && v <= 999999 {\n            result\
    \ = append(result, fmt.Sprintf(\"%s\", v))\n        } else {\n            result\
    \ = append(result, \"Six\")\n        }\n    }\n    for _, v := range arr {\n \
    \       if v >= 1000000 && v <= 9999999 {\n            result = append(result,\
    \ fmt.Sprintf(\"%s\", v))\n        } else {\n            result = append(result,\
    \ \"Seven\")\n        }\n    }\n    for _, v := range arr {\n        if v >= 10000000\
    \ && v <= 99999999 {\n            result = append(result, fmt.Sprintf(\"%s\",\
    \ v))\n        } else {\n            result = append(result, \"Eight\")\n    \
    \    }\n    }\n    for _, v := range arr {\n        if v >= 100000000 && v <=\
    \ 999999999 {\n            result = append(result, fmt.Sprintf(\"%s\", v))\n \
    \       } else {\n            result = append(result, \"Nine\")\n        }\n \
    \   }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2yklta54_test.go:25:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := []string{}\n    for _, v := range arr {\n \
    \       if v >= 1 && v <= 9 {\n            result = append(result, fmt.Sprintf(\"\
    %v\", v))\n        } else {\n            result = append(result, \"One\")\n  \
    \      }\n    }\n    for i := len(result) - 1; i >= 0; i-- {\n        result[i]\
    \ = result[i][:1] + result[i][1:]\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmpxz8x30mg_test.go:52: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 3]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmpxz8x30mg_test.go:52: expected '[One]', got '[1 One One]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmpxz8x30mg_test.go:52:\
    \ expected '[Three Two One]', got '[1 One 3 2]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmpxz8x30mg_test.go:52: expected '[Nine Eight Four]', got '[9\
    \ 4 8]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075206
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return nil\n    }\n    sort.Ints(arr)\n\
    \    arr := arr[:len(arr)-1]\n    arr := append([]string{\"One\"}, arr...)\n \
    \   arr := append([]string{\"Two\"}, arr...)\n    arr := append([]string{\"Three\"\
    }, arr...)\n    arr := append([]string{\"Four\"}, arr...)\n    arr := append([]string{\"\
    Five\"}, arr...)\n    arr := append([]string{\"Six\"}, arr...)\n    arr := append([]string{\"\
    Seven\"}, arr...)\n    arr := append([]string{\"Eight\"}, arr...)\n    arr :=\
    \ append([]string{\"Nine\"}, arr...)\n    return arr\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaqmwsic4_test.go:24:5:\
    \ undefined: sort\n/tmp/tmpaqmwsic4_test.go:25:9: no new variables on left side\
    \ of :=\n/tmp/tmpaqmwsic4_test.go:26:9: no new variables on left side of :=\n\
    /tmp/tmpaqmwsic4_test.go:26:12: cannot use append([]string{\u2026}, arr...) (value\
    \ of type []string) as type []int in assignment\n/tmp/tmpaqmwsic4_test.go:26:36:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmpaqmwsic4_test.go:27:9: no new variables on left side of :=\n/tmp/tmpaqmwsic4_test.go:27:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpaqmwsic4_test.go:27:36: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpaqmwsic4_test.go:28:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpaqmwsic4_test.go:28:38: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpaqmwsic4_test.go:28:12:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    for i, v := range arr {\n        if v < 1 || v > 9 {\n      \
    \      continue\n        }\n        arr3[i] = v\n    }\n    sort.Ints(arr3)\n\
    \    for i := range arr3 {\n        arr2[i] = names[arr3[i]]\n    }\n    for i\
    \ := range arr2 {\n        arr2[i] = strings.Replace(arr2[i], \"One\", \"1\",\
    \ -1)\n        arr2[i] = strings.Replace(arr2[i], \"Two\", \"2\", -1)\n      \
    \  arr2[i] = strings.Replace(arr2[i], \"Three\", \"3\", -1)\n        arr2[i] =\
    \ strings.Replace(arr2[i], \"Four\", \"4\", -1)\n        arr2[i] = strings.Replace(arr2[i],\
    \ \"Five\", \"5\", -1)\n        arr2[i] = strings.Replace(arr2[i], \"Six\", \"\
    6\", -1)\n        arr2[i] = strings.Replace(arr2[i], \"Seven\", \"7\", -1)\n \
    \       arr2[i] = strings.Replace(arr2[i], \"Eight\", \"8\", -1)\n        arr2[i]\
    \ = strings.Replace(arr2[i], \"Nine\", \"9\", -1)\n    }\n    return arr2\n}\n\
    \nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdqnpg675_test.go:29:5: undefined: sort

    /tmp/tmpdqnpg675_test.go:31:19: undefined: names

    /tmp/tmpdqnpg675_test.go:34:19: undefined: strings

    /tmp/tmpdqnpg675_test.go:35:19: undefined: strings

    /tmp/tmpdqnpg675_test.go:36:19: undefined: strings

    /tmp/tmpdqnpg675_test.go:37:19: undefined: strings

    /tmp/tmpdqnpg675_test.go:38:19: undefined: strings

    /tmp/tmpdqnpg675_test.go:39:19: undefined: strings

    /tmp/tmpdqnpg675_test.go:40:19: undefined: strings

    /tmp/tmpdqnpg675_test.go:41:19: undefined: strings

    /tmp/tmpdqnpg675_test.go:41:19: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    if len(arr) == 0 {\n       \
    \ return result\n    }\n    for _, v := range arr {\n        if v >= 1 && v <=\
    \ 9 {\n            result = append(result, fmt.Sprintf(\"%v\", v))\n        }\
    \ else {\n            result = append(result, \"One\")\n        }\n    }\n   \
    \ for i := len(result) - 1; i >= 0; i-- {\n        result[i] = reverse(result[i])\n\
    \    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcem4gq_k_test.go:33:21: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr := append(arr, \"One\"\
    , \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    )\n    arr := append(arr, \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"\
    Six\", \"Seven\", \"Eight\", \"Nine\")\n    arr := append(arr, \"One\", \"Two\"\
    , \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n  \
    \  arr := append(arr, \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\
    , \"Seven\", \"Eight\", \"Nine\")\n    arr := append(arr, \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n    arr\
    \ := append(arr, \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"\
    Seven\", \"Eight\", \"Nine\")\n    arr := append(arr, \"One\", \"Two\", \"Three\"\
    , \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n    arr := append(arr,\
    \ \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\"\
    , \"Nine\")\n    arr := append(arr, \"One\", \"Two\", \"Three\", \"Four\", \"\
    Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n    arr := append(arr, \"One\"\
    , \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    )\n    arr := append(arr, \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"\
    Six\", \"Seven\", \"Eight\", \"Nine\")\n    arr := append(arr, \"One\", \"Two\"\
    , \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n  \
    \  arr := append(arr, \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\"\
    , \"Seven\", \"Eight\", \"Nine\")\n    arr := append(arr, \"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n    arr\
    \ := append(arr, \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"\
    Seven\", \"Eight\", \"Nine\")\n    arr := append(arr, \"One\", \"Two\", \"Three\"\
    , \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n    arr := \n\
    func TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdoedf_3a_test.go:43:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    for i := range arr {\n        if arr[i] < 1 || arr[i] > 9 {\n\
    \            continue\n        }\n        arr2[len(arr2)-i-1] = fmt.Sprintf(\"\
    %v\", arr[i])\n    }\n    for i := range arr2 {\n        arr3[len(arr3)-i-1] =\
    \ arr2[i]\n    }\n    arr4 = make([]string, len(arr3))\n    for i := range arr3\
    \ {\n        arr4[len(arr4)-i-1] = map[int]string{\n            1: \"One\",\n\
    \            2: \"Two\",\n            3: \"Three\",\n            4: \"Four\",\n\
    \            5: \"Five\",\n            6: \"Six\",\n            7: \"Seven\",\n\
    \            8: \"Eight\",\n            9: \"Nine\",\n        }[arr3[i]]\n   \
    \ }\n    return arr4\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate :=\
    \ by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6b1qkz4n_test.go:30:31: cannot use arr2[i] (variable of type string) as
    type int in assignment

    /tmp/tmp6b1qkz4n_test.go:32:5: undefined: arr4

    /tmp/tmp6b1qkz4n_test.go:34:9: undefined: arr4

    /tmp/tmp6b1qkz4n_test.go:46:12: undefined: arr4

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr\
    \ := append(arr, 9) // add 9 to end\n    arr := append(arr, 0) // add 0 to beginning\n\
    \    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr,\
    \ []int{10, 11, 12, 13, 14, 15, 16, 17, 18, 19}...)\n    arr := append(arr, []int{20,\
    \ 21, 22, 23, 24, 25, 26, 27, 28, 29}...)\n    arr := append(arr, []int{30, 31,\
    \ 32, 33, 34, 35, 36, 37, 38, 39}...)\n    arr := append(arr, []int{40, 41, 42,\
    \ 43, 44, 45, 46, 47, 48, 49}...)\n    arr := append(arr, []int{50, 51, 52, 53,\
    \ 54, 55, 56, 57, 58, 59}...)\n    arr := append(arr, []int{60, 61, 62, 63, 64,\
    \ 65, 66, 67, 68, 69}...)\n    arr := append(arr, []int{70, 71, 72, 73, 74, 75,\
    \ 76, 77, 78, 79}...)\n    arr := append(arr, []int{80, 81, 82, 83, 84, 85, 86,\
    \ 87, 88, 89}...)\n    arr := append(arr, []int{90, 91, 92, 93, 94, 95, 96, 97,\
    \ 98, 99}...)\n    arr := append(arr, []int{100, 101, 102, 103, 104, 105, 106,\
    \ 107, 108, 109}...)\n    arr := append(arr, []int{110, 111, 112, 113, 114, 115,\
    \ 116, 117, 118, 119}...)\n    arr := append(arr, []int{120, 121, 122, 123, 124,\
    \ 125, 126, 127, 128, 129}...)\n    arr := append(arr, []int{130, 131, 132, 133,\
    \ 134, 135, 136, 137, 138, 139}...)\n    arr := append(arr, []int{140, 141, 142,\
    \ 143, 144, 145, 146, 147, 148, 149}...)\n    arr := append(arr, []int{150, 151,\
    \ 152, 153, 154, 155, 156, 157, 158, 159}...)\n    arr := append(arr, []int{160,\
    \ 161, 162, 163, 164, 165, 166, 167, 168, 169}...)\n    arr := append(arr, []int{170,\
    \ 171, 17\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbnzs2u4p_test.go:42:42: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return nil\n    }\n    arr\
    \ := make([]int, len(arr))\n    for i := range arr {\n        arr[i] = arr[i]\
    \ + 1\n    }\n    sort.Ints(arr)\n    arr[len(arr)-1]--\n    arr := reverse(arr)\n\
    \    arr := replaceDigit(arr)\n    return arr\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmrad7ti7_test.go:24:9: no new variables on left side of :=

    /tmp/tmpmrad7ti7_test.go:28:5: undefined: sort

    /tmp/tmpmrad7ti7_test.go:30:9: no new variables on left side of :=

    /tmp/tmpmrad7ti7_test.go:30:12: undefined: reverse

    /tmp/tmpmrad7ti7_test.go:31:9: no new variables on left side of :=

    /tmp/tmpmrad7ti7_test.go:31:12: undefined: replaceDigit

    /tmp/tmpmrad7ti7_test.go:32:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    for i := range arr\
    \ {\n        arr[i] = arr[i]\n    }\n    sort.Ints(arr)\n    arr[len(arr)-1]--\n\
    \    reverse(arr)\n    arr := make([]string, len(arr))\n    for i := range arr\
    \ {\n        arr[i] = names[arr[i]]\n    }\n    return arr\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9fgx2ilp_test.go:21:9: no new variables on left side of :=

    /tmp/tmp9fgx2ilp_test.go:25:5: undefined: sort

    /tmp/tmp9fgx2ilp_test.go:27:5: undefined: reverse

    /tmp/tmp9fgx2ilp_test.go:28:9: no new variables on left side of :=

    /tmp/tmp9fgx2ilp_test.go:28:12: cannot use make([]string, len(arr)) (value of
    type []string) as type []int in assignment

    /tmp/tmp9fgx2ilp_test.go:30:18: undefined: names

    /tmp/tmp9fgx2ilp_test.go:32:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            arr2[i] = \"One\"\
    \n        } else if arr[i] >= 10 && arr[i] <= 99 {\n            arr2[i] = \"Two\"\
    \n        } else if arr[i] >= 100 && arr[i] <= 999 {\n            arr2[i] = \"\
    Three\"\n        } else if arr[i] >= 1000 && arr[i] <= 9999 {\n            arr2[i]\
    \ = \"Four\"\n        } else if arr[i] >= 10000 && arr[i] <= 99999 {\n       \
    \     arr2[i] = \"Five\"\n        } else if arr[i] >= 100000 && arr[i] <= 999999\
    \ {\n            arr2[i] = \"Six\"\n        } else if arr[i] >= 1000000 && arr[i]\
    \ <= 9999999 {\n            arr2[i] = \"Seven\"\n        } else if arr[i] >= 10000000\
    \ && arr[i] <= 99999999 {\n            arr2[i] = \"Eight\"\n        } else if\
    \ arr[i] >= 100000000 && arr[i] <= 999999999 {\n            arr2[i] = \"Nine\"\
    \n        }\n    }\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n\
    \  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[One One One One One One One One]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[One]', got '[One  Two]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmp21whjqzt_test.go:63:\
    \ expected '[Three Two One]', got '[One  One One]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[Nine Eight Four]', got '[One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075206
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return nil\n    }\n    arr2\
    \ := make([]int, len(arr))\n    for i := range arr2 {\n        arr2[i] = arr[i]\n\
    \    }\n    sort.Ints(arr2)\n    arr2 = reverse(arr2)\n    arr2 = replaceDigit(arr2)\n\
    \    arr2 := []string{}\n    for _, v := range arr2 {\n        arr2 = append(arr2,\
    \ fmt.Sprintf(\"%v\", v))\n    }\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb6eajfob_test.go:28:5: undefined: sort

    /tmp/tmpb6eajfob_test.go:29:12: undefined: reverse

    /tmp/tmpb6eajfob_test.go:30:12: undefined: replaceDigit

    /tmp/tmpb6eajfob_test.go:31:10: no new variables on left side of :=

    /tmp/tmpb6eajfob_test.go:31:13: cannot use []string{} (value of type []string)
    as type []int in assignment

    /tmp/tmpb6eajfob_test.go:33:29: cannot use fmt.Sprintf("%v", v) (value of type
    string) as type int in argument to append

    /tmp/tmpb6eajfob_test.go:35:12: cannot use arr2 (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            arr2[i] = \"One\"\
    \n        } else if arr[i] >= 10 && arr[i] <= 99 {\n            arr2[i] = \"Two\"\
    \n        } else if arr[i] >= 100 && arr[i] <= 999 {\n            arr2[i] = \"\
    Three\"\n        } else if arr[i] >= 1000 && arr[i] <= 9999 {\n            arr2[i]\
    \ = \"Four\"\n        } else if arr[i] >= 10000 && arr[i] <= 99999 {\n       \
    \     arr2[i] = \"Five\"\n        } else if arr[i] >= 100000 && arr[i] <= 999999\
    \ {\n            arr2[i] = \"Six\"\n        } else if arr[i] >= 1000000 && arr[i]\
    \ <= 9999999 {\n            arr2[i] = \"Seven\"\n        } else if arr[i] >= 10000000\
    \ && arr[i] <= 99999999 {\n            arr2[i] = \"Eight\"\n        } else if\
    \ arr[i] >= 100000000 && arr[i] <= 999999999 {\n            arr2[i] = \"Nine\"\
    \n        }\n    }\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n\
    \  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[One One One One One One One One]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[One]', got '[One  Two]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmp21whjqzt_test.go:63:\
    \ expected '[Three Two One]', got '[One  One One]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[Nine Eight Four]', got '[One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075206
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := []string{}\n    if len(arr) == 0 {\n      \
    \  return result\n    }\n    max := 9\n    for _, v := range arr {\n        if\
    \ v < 1 || v > max {\n            continue\n        }\n        result := append(result,\
    \ fmt.Sprintf(\"%v\", v))\n        max -= 1\n    }\n    for i := len(result) -\
    \ 1; i >= 0; i-- {\n        result[i] = \"One\"\n    }\n    return result\n}\n\
    \nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdseabls9_test.go:30:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            arr2[i] = \"One\"\
    \n        } else if arr[i] >= 10 && arr[i] <= 99 {\n            arr2[i] = \"Two\"\
    \n        } else if arr[i] >= 100 && arr[i] <= 999 {\n            arr2[i] = \"\
    Three\"\n        } else if arr[i] >= 1000 && arr[i] <= 9999 {\n            arr2[i]\
    \ = \"Four\"\n        } else if arr[i] >= 10000 && arr[i] <= 99999 {\n       \
    \     arr2[i] = \"Five\"\n        } else if arr[i] >= 100000 && arr[i] <= 999999\
    \ {\n            arr2[i] = \"Six\"\n        } else if arr[i] >= 1000000 && arr[i]\
    \ <= 9999999 {\n            arr2[i] = \"Seven\"\n        } else if arr[i] >= 10000000\
    \ && arr[i] <= 99999999 {\n            arr2[i] = \"Eight\"\n        } else if\
    \ arr[i] >= 100000000 && arr[i] <= 999999999 {\n            arr2[i] = \"Nine\"\
    \n        } else {\n            arr2[i] = fmt.Sprintf(\"%d\", arr[i])\n      \
    \  }\n    }\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp92ztj0f3_test.go:65: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[One One One One One One One One]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmp92ztj0f3_test.go:65: expected '[One]', got '[One -1 Two]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmp92ztj0f3_test.go:65:\
    \ expected '[Three Two One]', got '[One -1 One One]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmp92ztj0f3_test.go:65: expected '[Nine Eight Four]', got '[One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075206
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := []string{}\n    for _, num := range arr {\n\
    \        if num >= 1 && num <= 9 {\n            result = append(result, fmt.Sprintf(\"\
    %v\", num))\n        } else {\n            result = append(result, \"One\")\n\
    \        }\n    }\n    for i := 0; i < len(result)-1; i++ {\n        result[i],\
    \ result[i+1] = result[i+1], result[i]\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp79x1xyyh_test.go:52: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[1 1 4 5 8 2 3 2]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmp79x1xyyh_test.go:52: expected '[One]', got '[One One 1]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmp79x1xyyh_test.go:52:\
    \ expected '[Three Two One]', got '[One 3 2 1]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmp79x1xyyh_test.go:52: expected '[Nine Eight Four]', got '[4\
    \ 8 9]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075206
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    for _, v := range arr {\n  \
    \      if v >= 1 && v <= 9 {\n            result = append(result, fmt.Sprintf(\"\
    %v\", v))\n        } else {\n            result = append(result, \"One\")\n  \
    \      }\n    }\n    for i := len(result) - 1; i >= 0; i-- {\n        result[i]\
    \ = reverse(result[i])\n    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcxyiv32n_test.go:30:21: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    for i := range arr\
    \ {\n        arr[i] = arr[i]\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n\
    \    arr := make([]string, len(arr))\n    for i := range arr {\n        arr[i]\
    \ = \"One\"\n        if arr[i] > 9 {\n            arr[i] = fmt.Sprintf(\"%v\"\
    , arr[i]-10)\n        }\n    }\n    return arr\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg5da8cuz_test.go:21:9: no new variables on left side of :=

    /tmp/tmpg5da8cuz_test.go:25:5: undefined: sort

    /tmp/tmpg5da8cuz_test.go:26:9: no new variables on left side of :=

    /tmp/tmpg5da8cuz_test.go:26:12: cannot use make([]string, len(arr)) (value of
    type []string) as type []int in assignment

    /tmp/tmpg5da8cuz_test.go:28:18: cannot use "One" (untyped string constant) as
    int value in assignment

    /tmp/tmpg5da8cuz_test.go:30:22: cannot use fmt.Sprintf("%v", arr[i] - 10) (value
    of type string) as type int in assignment

    /tmp/tmpg5da8cuz_test.go:33:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return nil\n    }\n    arr\
    \ := arr[:len(arr)/2]\n    arr[len(arr)/2:] = reverse(arr[len(arr)/2:])\n    arr\
    \ := arr[:len(arr)/2]\n    arr := append([]string{\"One\", \"Two\", \"Three\"\
    , \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"}, arr...)\n    return\
    \ arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpeymyypez_test.go:24:9:\
    \ no new variables on left side of :=\n/tmp/tmpeymyypez_test.go:25:24: undefined:\
    \ reverse\n/tmp/tmpeymyypez_test.go:26:9: no new variables on left side of :=\n\
    /tmp/tmpeymyypez_test.go:27:9: no new variables on left side of :=\n/tmp/tmpeymyypez_test.go:27:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpeymyypez_test.go:27:101: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpeymyypez_test.go:28:12:\
    \ cannot use arr (variable of type []int) as type []string in return statement\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n\
    \    arr := arr[:len(arr)-1]\n    arr := append([]string{}, One, Two, Three, Four,\
    \ Five, Six, Seven, Eight, Nine...)\n    for _, i := range arr {\n        if i\
    \ >= 1 && i <= 9 {\n            arr[len(arr)-1] = arr[len(arr)-1] + One[i]\n \
    \       }\n    }\n    return arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg072olqy_test.go:21:9: no new variables on left side of :=

    /tmp/tmpg072olqy_test.go:22:5: undefined: sort

    /tmp/tmpg072olqy_test.go:23:9: no new variables on left side of :=

    /tmp/tmpg072olqy_test.go:24:31: undefined: One

    /tmp/tmpg072olqy_test.go:24:36: undefined: Two

    /tmp/tmpg072olqy_test.go:24:41: undefined: Three

    /tmp/tmpg072olqy_test.go:24:48: undefined: Four

    /tmp/tmpg072olqy_test.go:24:54: undefined: Five

    /tmp/tmpg072olqy_test.go:24:60: undefined: Six

    /tmp/tmpg072olqy_test.go:24:65: undefined: Seven

    /tmp/tmpg072olqy_test.go:24:65: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075207
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    i := 0\n    for\
    \ _, v := range arr {\n        if v < 1 || v > 9 {\n            continue\n   \
    \     }\n        result[i] = names[v]\n        i++\n    }\n    return result\n\
    }\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbyodpk2c_test.go:27:21: undefined: names

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075207
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    for i, v := range arr {\n        if v < 1 || v > 9 {\n      \
    \      continue\n        }\n        arr3[i] = v\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(arr3)))\n\
    \    for i, v := range arr3 {\n        arr2[i] = names[v]\n    }\n    return arr2\n\
    }\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwaf6r27t_test.go:29:5: undefined: sort

    /tmp/tmpwaf6r27t_test.go:31:19: undefined: names

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return nil\n    }\n    sort.Ints(arr)\n\
    \    arr := arr[:len(arr)-1]\n    arr := append([]string{\"One\"}, arr...)\n \
    \   arr := append([]string{\"Two\"}, arr...)\n    arr := append([]string{\"Three\"\
    }, arr...)\n    arr := append([]string{\"Four\"}, arr...)\n    arr := append([]string{\"\
    Five\"}, arr...)\n    arr := append([]string{\"Six\"}, arr...)\n    arr := append([]string{\"\
    Seven\"}, arr...)\n    arr := append([]string{\"Eight\"}, arr...)\n    arr :=\
    \ append([]string{\"Nine\"}, arr...)\n    return arr\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaqmwsic4_test.go:24:5:\
    \ undefined: sort\n/tmp/tmpaqmwsic4_test.go:25:9: no new variables on left side\
    \ of :=\n/tmp/tmpaqmwsic4_test.go:26:9: no new variables on left side of :=\n\
    /tmp/tmpaqmwsic4_test.go:26:12: cannot use append([]string{\u2026}, arr...) (value\
    \ of type []string) as type []int in assignment\n/tmp/tmpaqmwsic4_test.go:26:36:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmpaqmwsic4_test.go:27:9: no new variables on left side of :=\n/tmp/tmpaqmwsic4_test.go:27:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpaqmwsic4_test.go:27:36: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpaqmwsic4_test.go:28:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpaqmwsic4_test.go:28:38: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpaqmwsic4_test.go:28:12:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    for i := range arr {\n        arr3[i] = arr[i]\n    }\n    sort.Ints(arr3)\n\
    \    for i := range arr3 {\n        if arr3[i] >= 1 && arr3[i] <= 9 {\n      \
    \      arr2[i] = fmt.Sprintf(\"%s\", arr3[i])\n        } else {\n            arr2[i]\
    \ = fmt.Sprintf(\"%s\", arr3[i])\n        }\n    }\n    for i := range arr2 {\n\
    \        arr2[i] = arr2[i][1:]\n    }\n    for i := range arr2 {\n        arr2[i]\
    \ = arr2[i][:1]\n    }\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6j31zvm2_test.go:26:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n\
    \    arr := reverse(arr)\n    arr := replaceDigit(arr)\n    return arr\n}\n\n\
    func TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgmsnpyoz_test.go:21:9: no new variables on left side of :=

    /tmp/tmpgmsnpyoz_test.go:22:5: undefined: sort

    /tmp/tmpgmsnpyoz_test.go:23:9: no new variables on left side of :=

    /tmp/tmpgmsnpyoz_test.go:23:12: undefined: reverse

    /tmp/tmpgmsnpyoz_test.go:24:9: no new variables on left side of :=

    /tmp/tmpgmsnpyoz_test.go:24:12: undefined: replaceDigit

    /tmp/tmpgmsnpyoz_test.go:25:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    if len(arr) == 0 {\n       \
    \ return result\n    }\n    sort.Ints(arr)\n    for _, v := range arr {\n    \
    \    if v < 1 || v > 9 {\n            continue\n        }\n        result = append(result,\
    \ fmt.Sprintf(\"%s\", map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\", 4:\
    \ \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}[v]))\n\
    \    }\n    for _, v := range result {\n        result = append(result, v)\n \
    \   }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyp3pn722_test.go:25:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    i := 0\n    for\
    \ _, v := range arr {\n        if v >= 1 && v <= 9 {\n            result[i] =\
    \ fmt.Sprintf(\"%s\", v)\n        } else {\n            result[i] = fmt.Sprintf(\"\
    %s\", v)\n        }\n        i++\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmp3d8ygy59_test.go:25:25: fmt.Sprintf format %s has arg v of wrong type
    int

    /tmp/tmp3d8ygy59_test.go:27:25: fmt.Sprintf format %s has arg v of wrong type
    int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n\
    \    arr[len(arr)-1]--\n    reverse(arr[:len(arr)-1])\n    arr := append([]string{},\
    \ One, Two, Three, Four, Five, Six, Seven, Eight, Nine...)\n    for _, i := range\
    \ arr {\n        arr[i] = fmt.Sprintf(\"%v\", i)\n    }\n    return arr\n}\n\n\
    func TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg8ssr3c7_test.go:21:9: no new variables on left side of :=

    /tmp/tmpg8ssr3c7_test.go:22:5: undefined: sort

    /tmp/tmpg8ssr3c7_test.go:24:5: undefined: reverse

    /tmp/tmpg8ssr3c7_test.go:25:31: undefined: One

    /tmp/tmpg8ssr3c7_test.go:25:36: undefined: Two

    /tmp/tmpg8ssr3c7_test.go:25:41: undefined: Three

    /tmp/tmpg8ssr3c7_test.go:25:48: undefined: Four

    /tmp/tmpg8ssr3c7_test.go:25:54: undefined: Five

    /tmp/tmpg8ssr3c7_test.go:25:60: undefined: Six

    /tmp/tmpg8ssr3c7_test.go:25:65: undefined: Seven

    /tmp/tmpg8ssr3c7_test.go:25:65: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr\
    \ := append([]string{\"One\"}, arr...)\n    arr := append([]string{\"Two\"}, arr...)\n\
    \    arr := append([]string{\"Three\"}, arr...)\n    arr := append([]string{\"\
    Four\"}, arr...)\n    arr := append([]string{\"Five\"}, arr...)\n    arr := append([]string{\"\
    Six\"}, arr...)\n    arr := append([]string{\"Seven\"}, arr...)\n    arr := append([]string{\"\
    Eight\"}, arr...)\n    arr := append([]string{\"Nine\"}, arr...)\n    return arr\n\
    }\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpufxui3fi_test.go:21:5:\
    \ undefined: sort\n/tmp/tmpufxui3fi_test.go:22:9: no new variables on left side\
    \ of :=\n/tmp/tmpufxui3fi_test.go:23:9: no new variables on left side of :=\n\
    /tmp/tmpufxui3fi_test.go:23:12: cannot use append([]string{\u2026}, arr...) (value\
    \ of type []string) as type []int in assignment\n/tmp/tmpufxui3fi_test.go:23:36:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmpufxui3fi_test.go:24:9: no new variables on left side of :=\n/tmp/tmpufxui3fi_test.go:24:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpufxui3fi_test.go:24:36: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpufxui3fi_test.go:25:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpufxui3fi_test.go:25:38: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpufxui3fi_test.go:25:12:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    for _, v := range arr {\n  \
    \      if v >= 1 && v <= 9 {\n            result = append(result, fmt.Sprintf(\"\
    %v\", v))\n        } else {\n            result = append(result, \"One\")\n  \
    \      }\n    }\n    for _, v := range result {\n        result = append(result,\
    \ fmt.Sprintf(\"%v\", v))\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp3djhmx64_test.go:52: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 3 2 1 1 4 5 8 2 3]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmp3djhmx64_test.go:52: expected '[One]', got '[1 One One 1\
    \ One One]'\n    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmp3djhmx64_test.go:52:\
    \ expected '[Three Two One]', got '[1 One 3 2 1 One 3 2]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmp3djhmx64_test.go:52: expected '[Nine Eight Four]', got '[9\
    \ 4 8 9 4 8]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr2 := make([]int, len(arr))\n    for i := range arr2 {\n        if arr[i]\
    \ > 9 {\n            arr2[i] = 0\n        } else {\n            arr2[i] = arr[i]\n\
    \        }\n    }\n    sort.Ints(arr2)\n    arr3 = make([]string, len(arr))\n\
    \    for i := range arr3 {\n        if arr2[i] > 9 {\n            arr3[i] = \"\
    Nine\"\n        } else {\n            arr3[i] = \"One\"\n        }\n    }\n  \
    \  for i := range arr2 {\n        if arr2[i] > 9 {\n            arr3[i] = arr3[i]\
    \ + \"s\"\n        }\n    }\n    return arr3\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_9iv710c_test.go:32:5: undefined: sort

    /tmp/tmp_9iv710c_test.go:33:5: undefined: arr3

    /tmp/tmp_9iv710c_test.go:34:20: undefined: arr3

    /tmp/tmp_9iv710c_test.go:36:13: undefined: arr3

    /tmp/tmp_9iv710c_test.go:38:13: undefined: arr3

    /tmp/tmp_9iv710c_test.go:43:23: undefined: arr3

    /tmp/tmp_9iv710c_test.go:46:12: undefined: arr3

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := []string{}\n    length := len(arr)\n    if\
    \ length == 0 {\n        return result\n    }\n    for i := 0; i < length; i++\
    \ {\n        if arr[i] < 1 || arr[i] > 9 {\n            continue\n        }\n\
    \        result := append(result, fmt.Sprintf(\"%s\", map[int]string{\n      \
    \      1: \"One\",\n            2: \"Two\",\n            3: \"Three\",\n     \
    \       4: \"Four\",\n            5: \"Five\",\n            6: \"Six\",\n    \
    \        7: \"Seven\",\n            8: \"Eight\",\n            9: \"Nine\",\n\
    \        }[arr[i]]))\n    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppmdb6wrv_test.go:30:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr\
    \ := append([]string{\"One\"}, arr...)\n    arr := append([]string{\"Two\"}, arr...)\n\
    \    arr := append([]string{\"Three\"}, arr...)\n    arr := append([]string{\"\
    Four\"}, arr...)\n    arr := append([]string{\"Five\"}, arr...)\n    arr := append([]string{\"\
    Six\"}, arr...)\n    arr := append([]string{\"Seven\"}, arr...)\n    arr := append([]string{\"\
    Eight\"}, arr...)\n    arr := append([]string{\"Nine\"}, arr...)\n    return arr\n\
    }\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpufxui3fi_test.go:21:5:\
    \ undefined: sort\n/tmp/tmpufxui3fi_test.go:22:9: no new variables on left side\
    \ of :=\n/tmp/tmpufxui3fi_test.go:23:9: no new variables on left side of :=\n\
    /tmp/tmpufxui3fi_test.go:23:12: cannot use append([]string{\u2026}, arr...) (value\
    \ of type []string) as type []int in assignment\n/tmp/tmpufxui3fi_test.go:23:36:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmpufxui3fi_test.go:24:9: no new variables on left side of :=\n/tmp/tmpufxui3fi_test.go:24:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpufxui3fi_test.go:24:36: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpufxui3fi_test.go:25:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpufxui3fi_test.go:25:38: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpufxui3fi_test.go:25:12:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            arr2[i] = \"One\"\
    \n        } else if arr[i] >= 10 && arr[i] <= 99 {\n            arr2[i] = \"Two\"\
    \n        } else if arr[i] >= 100 && arr[i] <= 999 {\n            arr2[i] = \"\
    Three\"\n        } else if arr[i] >= 1000 && arr[i] <= 9999 {\n            arr2[i]\
    \ = \"Four\"\n        } else if arr[i] >= 10000 && arr[i] <= 99999 {\n       \
    \     arr2[i] = \"Five\"\n        } else if arr[i] >= 100000 && arr[i] <= 999999\
    \ {\n            arr2[i] = \"Six\"\n        } else if arr[i] >= 1000000 && arr[i]\
    \ <= 9999999 {\n            arr2[i] = \"Seven\"\n        } else if arr[i] >= 10000000\
    \ && arr[i] <= 99999999 {\n            arr2[i] = \"Eight\"\n        } else if\
    \ arr[i] >= 100000000 && arr[i] <= 999999999 {\n            arr2[i] = \"Nine\"\
    \n        } else {\n            fmt.Printf(\"%v\\n\", arr[i])\n        }\n   \
    \ }\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate :=\
    \ by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "-1\n-1\n--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmpl36ne5lr_test.go:65: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[One One One One One One One One]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmpl36ne5lr_test.go:65: expected '[One]', got '[One  Two]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmpl36ne5lr_test.go:65:\
    \ expected '[Three Two One]', got '[One  One One]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmpl36ne5lr_test.go:65: expected '[Nine Eight Four]', got '[One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    for _, v := range arr {\n  \
    \      if v >= 1 && v <= 9 {\n            result = append(result, fmt.Sprintf(\"\
    %v\", v))\n        } else {\n            result = append(result, \"One\")\n  \
    \      }\n    }\n    for i := len(result) - 1; i >= 0; i-- {\n        if result[i]\
    \ == \"One\" {\n            result[i] = \"One\"\n            break\n        }\n\
    \    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp68_2drz1_test.go:55: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 3]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmp68_2drz1_test.go:55: expected '[One]', got '[1 One One]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmp68_2drz1_test.go:55:\
    \ expected '[Three Two One]', got '[1 One 3 2]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmp68_2drz1_test.go:55: expected '[Nine Eight Four]', got '[9\
    \ 4 8]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n\
    \    arr := reverse(arr)\n    arr := replaceDigits(arr)\n    return arr\n}\n\n\
    func TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu75gx0c__test.go:21:9: no new variables on left side of :=

    /tmp/tmpu75gx0c__test.go:22:5: undefined: sort

    /tmp/tmpu75gx0c__test.go:23:9: no new variables on left side of :=

    /tmp/tmpu75gx0c__test.go:23:12: undefined: reverse

    /tmp/tmpu75gx0c__test.go:24:9: no new variables on left side of :=

    /tmp/tmpu75gx0c__test.go:24:12: undefined: replaceDigits

    /tmp/tmpu75gx0c__test.go:25:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    for _, v := range arr {\n  \
    \      if v >= 1 && v <= 9 {\n            result = append(result, fmt.Sprintf(\"\
    %s\", v))\n        } else {\n            result = append(result, \"One\")\n  \
    \      }\n    }\n    for i := 0; i < len(result); i++ {\n        result[i] = result[i][1:]\n\
    \    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmp61p2g7cv_test.go:24:37: fmt.Sprintf format %s has arg v of wrong type
    int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    if len(arr) == 0 {\n       \
    \ return result\n    }\n    sort.Ints(arr)\n    result := make([]string, len(arr))\n\
    \    for i := range arr {\n        if arr[i] > 9 {\n            arr[i] = arr[i]\
    \ - 10\n        }\n        result[i] = names[arr[i]]\n    }\n    for i := range\
    \ result {\n        result[i] = reverse(result[i])\n    }\n    return result\n\
    }\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpc6m9ebb8_test.go:25:5: undefined: sort

    /tmp/tmpc6m9ebb8_test.go:26:12: no new variables on left side of :=

    /tmp/tmpc6m9ebb8_test.go:31:21: undefined: names

    /tmp/tmpc6m9ebb8_test.go:34:21: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075209
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    for _, v := range arr {\n  \
    \      if v >= 1 && v <= 9 {\n            result = append(result, fmt.Sprintf(\"\
    %v\", v))\n        } else {\n            result = append(result, \"One\")\n  \
    \      }\n    }\n    for _, v := range result {\n        result = append(result,\
    \ fmt.Sprintf(\"%v\", v))\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp3djhmx64_test.go:52: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 3 2 1 1 4 5 8 2 3]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmp3djhmx64_test.go:52: expected '[One]', got '[1 One One 1\
    \ One One]'\n    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmp3djhmx64_test.go:52:\
    \ expected '[Three Two One]', got '[1 One 3 2 1 One 3 2]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmp3djhmx64_test.go:52: expected '[Nine Eight Four]', got '[9\
    \ 4 8 9 4 8]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n    arr := append([]int{},\
    \ arr...)\n    sort.Ints(arr)\n    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n\
    \    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n    arr := append([]int{},\
    \ arr...)\n    sort.Ints(arr)\n    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n\
    \    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n    arr := append([]int{},\
    \ arr...)\n    sort.Ints(arr)\n    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n\
    \    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n    arr := append([]int{},\
    \ arr...)\n    sort.Ints(arr)\n    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n\
    \    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n    arr := append([]int{},\
    \ arr...)\n    sort.Ints(arr)\n    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n\
    \    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n    arr := append([]int{},\
    \ arr...)\n    sort.Ints(arr)\n    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n\
    \    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n    arr := append([]int{},\
    \ arr...)\n    sort.Ints(arr)\n    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n\
    \    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n    arr := append([]int{},\
    \ arr...)\n    sort.Ints(arr)\n    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n\
    \    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n    arr := append([]int{},\
    \ arr...)\n    sort.Ints(arr)\n    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n\
    \    arr := append([]int{}, arr...)\n    sort.Int\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9odhekrf_test.go:80:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr := append([]string{\"\
    One\"}, arr...)\n    arr := append([]string{\"Two\"}, arr...)\n    arr := append([]string{\"\
    Three\"}, arr...)\n    arr := append([]string{\"Four\"}, arr...)\n    arr := append([]string{\"\
    Five\"}, arr...)\n    arr := append([]string{\"Six\"}, arr...)\n    arr := append([]string{\"\
    Seven\"}, arr...)\n    arr := append([]string{\"Eight\"}, arr...)\n    arr :=\
    \ append([]string{\"Nine\"}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    return arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpif25jcrz_test.go:24:5:\
    \ undefined: sort\n/tmp/tmpif25jcrz_test.go:25:9: no new variables on left side\
    \ of :=\n/tmp/tmpif25jcrz_test.go:26:9: no new variables on left side of :=\n\
    /tmp/tmpif25jcrz_test.go:26:12: cannot use append([]string{\u2026}, arr...) (value\
    \ of type []string) as type []int in assignment\n/tmp/tmpif25jcrz_test.go:26:36:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmpif25jcrz_test.go:27:9: no new variables on left side of :=\n/tmp/tmpif25jcrz_test.go:27:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpif25jcrz_test.go:27:36: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpif25jcrz_test.go:28:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpif25jcrz_test.go:28:38: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpif25jcrz_test.go:28:12:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075209
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    for _, v := range arr {\n  \
    \      if v > 9 {\n            v = v - 10\n        }\n        if v < 1 {\n   \
    \         v = v + 10\n        }\n        result = append(result, fmt.Sprintf(\"\
    %v\", v))\n    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n\
    \  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmpsnl84x9e_test.go:51: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 3]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmpsnl84x9e_test.go:51: expected '[One]', got '[1 9 45]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmpsnl84x9e_test.go:51:\
    \ expected '[Three Two One]', got '[1 9 3 2]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmpsnl84x9e_test.go:51: expected '[Nine Eight Four]', got '[9\
    \ 4 8]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075209
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := []string{}\n    if len(arr) == 0 {\n      \
    \  return result\n    }\n    min := arr[0]\n    max := arr[len(arr)-1]\n    for\
    \ _, v := range arr {\n        if v < min || v > max {\n            continue\n\
    \        }\n        str = fmt.Sprintf(\"%v\", v)\n        str = strings.Replace(str,\
    \ \"1\", \"One\", -1)\n        str = strings.Replace(str, \"2\", \"Two\", -1)\n\
    \        str = strings.Replace(str, \"3\", \"Three\", -1)\n        str = strings.Replace(str,\
    \ \"4\", \"Four\", -1)\n        str = strings.Replace(str, \"5\", \"Five\", -1)\n\
    \        str = strings.Replace(str, \"6\", \"Six\", -1)\n        str = strings.Replace(str,\
    \ \"7\", \"Seven\", -1)\n        str = strings.Replace(str, \"8\", \"Eight\",\
    \ -1)\n        str = strings.Replace(str, \"9\", \"Nine\", -1)\n        result\
    \ = append(result, str)\n    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphdqzi30i_test.go:31:9: undefined: str

    /tmp/tmphdqzi30i_test.go:32:15: undefined: strings

    /tmp/tmphdqzi30i_test.go:32:31: undefined: str

    /tmp/tmphdqzi30i_test.go:33:15: undefined: strings

    /tmp/tmphdqzi30i_test.go:33:31: undefined: str

    /tmp/tmphdqzi30i_test.go:34:15: undefined: strings

    /tmp/tmphdqzi30i_test.go:34:31: undefined: str

    /tmp/tmphdqzi30i_test.go:35:15: undefined: strings

    /tmp/tmphdqzi30i_test.go:35:31: undefined: str

    /tmp/tmphdqzi30i_test.go:36:15: undefined: strings

    /tmp/tmphdqzi30i_test.go:36:15: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075209
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr\
    \ := append([]string{\"One\"}, arr...)\n    arr := append([]string{\"Two\"}, arr...)\n\
    \    arr := append([]string{\"Three\"}, arr...)\n    arr := append([]string{\"\
    Four\"}, arr...)\n    arr := append([]string{\"Five\"}, arr...)\n    arr := append([]string{\"\
    Six\"}, arr...)\n    arr := append([]string{\"Seven\"}, arr...)\n    arr := append([]string{\"\
    Eight\"}, arr...)\n    arr := append([]string{\"Nine\"}, arr...)\n    arr := append([]string{},\
    \ arr...)\n    return arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0l67i2om_test.go:21:5:\
    \ undefined: sort\n/tmp/tmp0l67i2om_test.go:22:9: no new variables on left side\
    \ of :=\n/tmp/tmp0l67i2om_test.go:23:9: no new variables on left side of :=\n\
    /tmp/tmp0l67i2om_test.go:23:12: cannot use append([]string{\u2026}, arr...) (value\
    \ of type []string) as type []int in assignment\n/tmp/tmp0l67i2om_test.go:23:36:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmp0l67i2om_test.go:24:9: no new variables on left side of :=\n/tmp/tmp0l67i2om_test.go:24:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmp0l67i2om_test.go:24:36: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmp0l67i2om_test.go:25:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmp0l67i2om_test.go:25:38: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmp0l67i2om_test.go:25:12:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075209
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    i := 0\n    for\
    \ _, v := range arr {\n        if v < 1 || v > 9 {\n            continue\n   \
    \     }\n        result[i] = fmt.Sprintf(\"%v\", v)\n        i++\n    }\n    for\
    \ i := 0; i < len(result); i++ {\n        result[i] = \"One\"\n    }\n    return\
    \ result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmprm0172jh_test.go:53: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[One One One One One One One One]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmprm0172jh_test.go:53: expected '[One]', got '[One One One]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmprm0172jh_test.go:53:\
    \ expected '[Three Two One]', got '[One One One One]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmprm0172jh_test.go:53: expected '[Nine Eight Four]', got '[One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075209
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            arr2[i] = \"One\"\
    \n        } else if arr[i] >= 10 && arr[i] <= 99 {\n            arr2[i] = \"Two\"\
    \n        } else if arr[i] >= 100 && arr[i] <= 999 {\n            arr2[i] = \"\
    Three\"\n        } else if arr[i] >= 1000 && arr[i] <= 9999 {\n            arr2[i]\
    \ = \"Four\"\n        } else if arr[i] >= 10000 && arr[i] <= 99999 {\n       \
    \     arr2[i] = \"Five\"\n        } else if arr[i] >= 100000 && arr[i] <= 999999\
    \ {\n            arr2[i] = \"Six\"\n        } else if arr[i] >= 1000000 && arr[i]\
    \ <= 9999999 {\n            arr2[i] = \"Seven\"\n        } else if arr[i] >= 10000000\
    \ && arr[i] <= 99999999 {\n            arr2[i] = \"Eight\"\n        } else if\
    \ arr[i] >= 100000000 && arr[i] <= 999999999 {\n            arr2[i] = \"Nine\"\
    \n        }\n    }\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n\
    \  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[One One One One One One One One]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[One]', got '[One  Two]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmp21whjqzt_test.go:63:\
    \ expected '[Three Two One]', got '[One  One One]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[Nine Eight Four]', got '[One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075206
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    if len(arr) == 0 {\n       \
    \ return result\n    }\n    sort.Ints(arr)\n    result := make([]string, len(arr))\n\
    \    for i := range arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n         \
    \   result[i] = \"One\"\n        } else if arr[i] >= 10 && arr[i] <= 99 {\n  \
    \          result[i] = \"Two\"\n        } else if arr[i] >= 100 && arr[i] <= 999\
    \ {\n            result[i] = \"Three\"\n        } else if arr[i] >= 1000 && arr[i]\
    \ <= 9999 {\n            result[i] = \"Four\"\n        } else if arr[i] >= 10000\
    \ && arr[i] <= 99999 {\n            result[i] = \"Five\"\n        } else if arr[i]\
    \ >= 100000 && arr[i] <= 999999 {\n            result[i] = \"Six\"\n        }\
    \ else if arr[i] >= 1000000 && arr[i] <= 9999999 {\n            result[i] = \"\
    Seven\"\n        } else if arr[i] >= 10000000 && arr[i] <= 99999999 {\n      \
    \      result[i] = \"Eight\"\n        } else if arr[i] >= 100000000 && arr[i]\
    \ <= 999999999 {\n            result[i] = \"Nine\"\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfuvp0uhp_test.go:25:5: undefined: sort

    /tmp/tmpfuvp0uhp_test.go:26:12: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075209
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n\
    \    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    \nfunc TestBy_Length(t *testing.T) {\n \
    \ candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpz499qb8z_test.go:79:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075209
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr2 := make([]int, len(arr))\n    for i := range arr2 {\n        arr2[i]\
    \ = arr[i]\n    }\n    sort.Ints(arr2)\n    arr2 = reverse(arr2)\n    arr2 = replaceDigit(arr2)\n\
    \    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpndoeuut7_test.go:28:5: undefined: sort

    /tmp/tmpndoeuut7_test.go:29:12: undefined: reverse

    /tmp/tmpndoeuut7_test.go:30:12: undefined: replaceDigit

    /tmp/tmpndoeuut7_test.go:31:12: cannot use arr2 (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075210
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            result[i] = \"One\"\
    \n        } else if arr[i] >= 10 && arr[i] <= 99 {\n            result[i] = \"\
    Two\"\n        } else if arr[i] >= 100 && arr[i] <= 999 {\n            result[i]\
    \ = \"Three\"\n        } else if arr[i] >= 1000 && arr[i] <= 9999 {\n        \
    \    result[i] = \"Four\"\n        } else if arr[i] >= 10000 && arr[i] <= 99999\
    \ {\n            result[i] = \"Five\"\n        } else if arr[i] >= 100000 && arr[i]\
    \ <= 999999 {\n            result[i] = \"Six\"\n        } else if arr[i] >= 1000000\
    \ && arr[i] <= 9999999 {\n            result[i] = \"Seven\"\n        } else if\
    \ arr[i] >= 10000000 && arr[i] <= 99999999 {\n            result[i] = \"Eight\"\
    \n        } else if arr[i] >= 100000000 && arr[i] <= 999999999 {\n           \
    \ result[i] = \"Nine\"\n        } else {\n            result[i] = fmt.Sprintf(\"\
    %v\", arr[i])\n        }\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmpsabo7clv_test.go:65: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[One One One One One One One One]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmpsabo7clv_test.go:65: expected '[One]', got '[One -1 Two]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmpsabo7clv_test.go:65:\
    \ expected '[Three Two One]', got '[One -1 One One]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmpsabo7clv_test.go:65: expected '[Nine Eight Four]', got '[One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075210
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    for _, v := range arr {\n  \
    \      if v >= 1 && v <= 9 {\n            result = append(result, fmt.Sprintf(\"\
    %v\", v))\n        } else {\n            result = append(result, \"One\")\n  \
    \      }\n    }\n    for i := len(result) - 1; i >= 0; i-- {\n        result[i]\
    \ = result[i][:1] + result[i][1:]\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmpdbz4hlrl_test.go:52: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 3]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmpdbz4hlrl_test.go:52: expected '[One]', got '[1 One One]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmpdbz4hlrl_test.go:52:\
    \ expected '[Three Two One]', got '[1 One 3 2]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmpdbz4hlrl_test.go:52: expected '[Nine Eight Four]', got '[9\
    \ 4 8]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075210
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr\
    \ := append([]string{\"One\"}, arr...)\n    arr := append([]string{\"Two\"}, arr...)\n\
    \    arr := append([]string{\"Three\"}, arr...)\n    arr := append([]string{\"\
    Four\"}, arr...)\n    arr := append([]string{\"Five\"}, arr...)\n    arr := append([]string{\"\
    Six\"}, arr...)\n    arr := append([]string{\"Seven\"}, arr...)\n    arr := append([]string{\"\
    Eight\"}, arr...)\n    arr := append([]string{\"Nine\"}, arr...)\n    arr := append([]string{},\
    \ arr...)\n    return arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0l67i2om_test.go:21:5:\
    \ undefined: sort\n/tmp/tmp0l67i2om_test.go:22:9: no new variables on left side\
    \ of :=\n/tmp/tmp0l67i2om_test.go:23:9: no new variables on left side of :=\n\
    /tmp/tmp0l67i2om_test.go:23:12: cannot use append([]string{\u2026}, arr...) (value\
    \ of type []string) as type []int in assignment\n/tmp/tmp0l67i2om_test.go:23:36:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmp0l67i2om_test.go:24:9: no new variables on left side of :=\n/tmp/tmp0l67i2om_test.go:24:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmp0l67i2om_test.go:24:36: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmp0l67i2om_test.go:25:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmp0l67i2om_test.go:25:38: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmp0l67i2om_test.go:25:12:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075209
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := []string{}\n    if len(arr) == 0 {\n      \
    \  return result\n    }\n    min := arr[0]\n    max := arr[len(arr)-1]\n    for\
    \ i := 0; i < len(arr); i++ {\n        if arr[i] < min || arr[i] > max {\n   \
    \         continue\n        }\n        result := append(result, fmt.Sprintf(\"\
    %v\", arr[i]))\n    }\n    for i := len(arr) - 1; i >= 0; i-- {\n        result\
    \ := append(result, fmt.Sprintf(\"%v\", arr[i]))\n    }\n    return result\n}\n\
    \nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppp5f9tko_test.go:31:9: result declared but not used

    /tmp/tmppp5f9tko_test.go:34:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075210
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    for _, v := range arr {\n  \
    \      if v < 1 || v > 9 {\n            continue\n        }\n        result =\
    \ append(result, fmt.Sprintf(\"%v\", v))\n    }\n    for _, v := range result\
    \ {\n        result[len(result)-1] = map[string]string{\"One\": \"1\", \"Two\"\
    : \"2\", \"Three\": \"3\", \"Four\": \"4\", \"Five\": \"5\", \"Six\": \"6\", \"\
    Seven\": \"7\", \"Eight\": \"8\", \"Nine\": \"9\"}[v]\n    }\n    return result\n\
    }\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp7z9ht_qo_test.go:51: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 ]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmp7z9ht_qo_test.go:51: expected '[One]', got '[]'\n    ---\
    \ FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmp7z9ht_qo_test.go:51: expected\
    \ '[Three Two One]', got '[1 3 ]'\n    --- FAIL: TestBy_Length/test_num__4 (0.00s)\n\
    \        tmp7z9ht_qo_test.go:51: expected '[Nine Eight Four]', got '[9 4 ]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075210
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr2 := make([]int, len(arr))\n    for i := range arr2 {\n        arr2[i]\
    \ = arr[i]\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(arr2)))\n    arr3\
    \ = make([]string, len(arr))\n    for i := range arr3 {\n        arr3[i] = map[int]string{\n\
    \            1: \"One\",\n            2: \"Two\",\n            3: \"Three\",\n\
    \            4: \"Four\",\n            5: \"Five\",\n            6: \"Six\",\n\
    \            7: \"Seven\",\n            8: \"Eight\",\n            9: \"Nine\"\
    ,\n        }[arr2[i]]\n    }\n    return arr3\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0vvwgsqk_test.go:28:5: undefined: sort

    /tmp/tmp0vvwgsqk_test.go:29:5: undefined: arr3

    /tmp/tmp0vvwgsqk_test.go:30:20: undefined: arr3

    /tmp/tmp0vvwgsqk_test.go:31:9: undefined: arr3

    /tmp/tmp0vvwgsqk_test.go:43:12: undefined: arr3

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075210
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    i := 0\n    for\
    \ _, v := range arr {\n        if v < 1 || v > 9 {\n            continue\n   \
    \     }\n        j := int(v)\n        result[i] = names[j]\n        i++\n    }\n\
    \    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp63dqzv1k_test.go:28:21: undefined: names

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075210
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    i := 0\n    for\
    \ _, v := range arr {\n        if v >= 1 && v <= 9 {\n            result[i] =\
    \ \"One\"\n        } else if v >= 10 && v <= 99 {\n            result[i] = \"\
    Two\"\n        } else if v >= 100 && v <= 999 {\n            result[i] = \"Three\"\
    \n        } else if v >= 1000 && v <= 9999 {\n            result[i] = \"Four\"\
    \n        } else if v >= 10000 && v <= 99999 {\n            result[i] = \"Five\"\
    \n        } else if v >= 100000 && v <= 999999 {\n            result[i] = \"Six\"\
    \n        } else if v >= 1000000 && v <= 9999999 {\n            result[i] = \"\
    Seven\"\n        } else if v >= 10000000 && v <= 99999999 {\n            result[i]\
    \ = \"Eight\"\n        } else if v >= 100000000 && v <= 999999999 {\n        \
    \    result[i] = \"Nine\"\n        } else {\n            result[i] = fmt.Sprintf(\"\
    %v\", v)\n        }\n        i++\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmptmyym60e_test.go:67: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[One One One One One One One One]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmptmyym60e_test.go:67: expected '[One]', got '[One -1 Two]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmptmyym60e_test.go:67:\
    \ expected '[Three Two One]', got '[One -1 One One]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmptmyym60e_test.go:67: expected '[Nine Eight Four]', got '[One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075210
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr2 := make([]int, len(arr))\n    arr2 := arr2[:len(arr)]\n    for i :=\
    \ 0; i < len(arr); i++ {\n        if arr[i] < 1 || arr[i] > 9 {\n            continue\n\
    \        }\n        arr2[len(arr2)-i-1] = arr[i]\n    }\n    arr2 := reverse(arr2)\n\
    \    arr2 := arr2[:len(arr)]\n    for i := 0; i < len(arr); i++ {\n        arr2[len(arr2)-i-1]\
    \ = name[arr2[i]]\n    }\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphtuaiemp_test.go:25:10: no new variables on left side of :=

    /tmp/tmphtuaiemp_test.go:32:10: no new variables on left side of :=

    /tmp/tmphtuaiemp_test.go:32:13: undefined: reverse

    /tmp/tmphtuaiemp_test.go:33:10: no new variables on left side of :=

    /tmp/tmphtuaiemp_test.go:35:31: undefined: name

    /tmp/tmphtuaiemp_test.go:37:12: cannot use arr2 (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075210
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := []string{}\n    for _, v := range arr {\n \
    \       if v >= 1 && v <= 9 {\n            v = 10 - v\n        }\n        result\
    \ = append(result, fmt.Sprintf(\"%v\", v))\n    }\n    for _, v := range result\
    \ {\n        if v == \"10\" {\n            result = append(result, \"One\")\n\
    \        }\n        if v == \"11\" {\n            result = append(result, \"Two\"\
    )\n        }\n        if v == \"12\" {\n            result = append(result, \"\
    Three\")\n        }\n        if v == \"13\" {\n            result = append(result,\
    \ \"Four\")\n        }\n        if v == \"14\" {\n            result = append(result,\
    \ \"Five\")\n        }\n        if v == \"15\" {\n            result = append(result,\
    \ \"Six\")\n        }\n        if v == \"16\" {\n            result = append(result,\
    \ \"Seven\")\n        }\n        if v == \"17\" {\n            result = append(result,\
    \ \"Eight\")\n        }\n        if v == \"18\" {\n            result = append(result,\
    \ \"Nine\")\n        }\n        if v == \"19\" {\n            result = append(result,\
    \ \"Ten\")\n        }\n        if v == \"20\" {\n            result = append(result,\
    \ \"Eleven\")\n        }\n        if v == \"21\" {\n            result = append(result,\
    \ \"Twelve\")\n        }\n        if v == \"22\" {\n            result = append(result,\
    \ \"Thirteen\")\n        }\n        if v == \"23\" {\n            result = append(result,\
    \ \"Fourteen\")\n        }\n        if v == \"24\" {\n            result = append(result,\
    \ \"Fifteen\")\n        }\n        if v == \"25\" {\n            result = append(result,\
    \ \"Sixteen\")\n        }\n        if v == \"26\" {\n            result = append(result,\
    \ \"Seventeen\")\n        }\n        if v == \"27\" {\n            result = append(result,\
    \ \"Eighteen\")\n        }\n        if v == \"28\" {\n            result = append(result,\
    \ \"Nineteen\")\n        }\n        if v == \"29\" {\n            result = append(result,\
    \ \"Twenty\")\n        }\n        if v == \"30\" {\n            result = append(result,\
    \ \"Thirty\")\n        }\n        if v == \"31\" {\n            result = append(result,\
    \ \"Forty\")\n        }\n        if v == \"32\" {\n            result = append(result,\
    \ \"Fifty\")\n        }\n        if v == \"33\" {\n            result = append(result,\
    \ \"Sixty\")\n        }\n        if v == \"34\" {\n            result = append(result,\
    \ \"Seventy\")\n        }\n        if v == \"35\" {\n            result = append(result,\
    \ \"Eighty\")\n        }\n        if v == \"36\" {\n            result = append(result,\
    \ \"Nine\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq9gnkj_b_test.go:108:37: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075209
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr2 := make([]int, len(arr))\n    for i := range arr2 {\n        arr2[i]\
    \ = arr[i]\n    }\n    sort.Ints(arr2)\n    arr2 = reverse(arr2)\n    arr2 = replaceDigit(arr2)\n\
    \    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpndoeuut7_test.go:28:5: undefined: sort

    /tmp/tmpndoeuut7_test.go:29:12: undefined: reverse

    /tmp/tmpndoeuut7_test.go:30:12: undefined: replaceDigit

    /tmp/tmpndoeuut7_test.go:31:12: cannot use arr2 (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075210
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr\
    \ := append([]string{\"One\"}, arr...)\n    arr := append([]string{\"Two\"}, arr...)\n\
    \    arr := append([]string{\"Three\"}, arr...)\n    arr := append([]string{\"\
    Four\"}, arr...)\n    arr := append([]string{\"Five\"}, arr...)\n    arr := append([]string{\"\
    Six\"}, arr...)\n    arr := append([]string{\"Seven\"}, arr...)\n    arr := append([]string{\"\
    Eight\"}, arr...)\n    arr := append([]string{\"Nine\"}, arr...)\n    return arr\n\
    }\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpufxui3fi_test.go:21:5:\
    \ undefined: sort\n/tmp/tmpufxui3fi_test.go:22:9: no new variables on left side\
    \ of :=\n/tmp/tmpufxui3fi_test.go:23:9: no new variables on left side of :=\n\
    /tmp/tmpufxui3fi_test.go:23:12: cannot use append([]string{\u2026}, arr...) (value\
    \ of type []string) as type []int in assignment\n/tmp/tmpufxui3fi_test.go:23:36:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmpufxui3fi_test.go:24:9: no new variables on left side of :=\n/tmp/tmpufxui3fi_test.go:24:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpufxui3fi_test.go:24:36: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpufxui3fi_test.go:25:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpufxui3fi_test.go:25:38: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpufxui3fi_test.go:25:12:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    i := 0\n    for\
    \ _, v := range arr {\n        if v >= 1 && v <= 9 {\n            result[i] =\
    \ fmt.Sprintf(\"%v\", v)\n        } else {\n            result[i] = \"One\"\n\
    \        }\n        i++\n    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmpj_aeedse_test.go:51: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 3]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmpj_aeedse_test.go:51: expected '[One]', got '[1 One One]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmpj_aeedse_test.go:51:\
    \ expected '[Three Two One]', got '[1 One 3 2]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmpj_aeedse_test.go:51: expected '[Nine Eight Four]', got '[9\
    \ 4 8]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075211
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \n    arr := arr[:len(arr)/2]\n    arr.reverse()\n    arr := arr[:len(arr)/2]\n\
    \    arr := append([]string{\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"\
    Six\", \"Seven\", \"Eight\", \"Nine\"}, arr...)\n\n    return arr\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmph4vflxw5_test.go:25:9:\
    \ no new variables on left side of :=\n/tmp/tmph4vflxw5_test.go:26:9: arr.reverse\
    \ undefined (type []int has no field or method reverse)\n/tmp/tmph4vflxw5_test.go:27:9:\
    \ no new variables on left side of :=\n/tmp/tmph4vflxw5_test.go:28:9: no new variables\
    \ on left side of :=\n/tmp/tmph4vflxw5_test.go:28:12: cannot use append([]string{\u2026\
    }, arr...) (value of type []string) as type []int in assignment\n/tmp/tmph4vflxw5_test.go:28:101:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmph4vflxw5_test.go:30:12: cannot use arr (variable of type []int) as type\
    \ []string in return statement\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075211
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            arr2[i] = \"One\"\
    \n        } else if arr[i] >= 10 && arr[i] <= 99 {\n            arr2[i] = \"Two\"\
    \n        } else if arr[i] >= 100 && arr[i] <= 999 {\n            arr2[i] = \"\
    Three\"\n        } else if arr[i] >= 1000 && arr[i] <= 9999 {\n            arr2[i]\
    \ = \"Four\"\n        } else if arr[i] >= 10000 && arr[i] <= 99999 {\n       \
    \     arr2[i] = \"Five\"\n        } else if arr[i] >= 100000 && arr[i] <= 999999\
    \ {\n            arr2[i] = \"Six\"\n        } else if arr[i] >= 1000000 && arr[i]\
    \ <= 9999999 {\n            arr2[i] = \"Seven\"\n        } else if arr[i] >= 10000000\
    \ && arr[i] <= 99999999 {\n            arr2[i] = \"Eight\"\n        } else if\
    \ arr[i] >= 100000000 && arr[i] <= 999999999 {\n            arr2[i] = \"Nine\"\
    \n        }\n    }\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n\
    \  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[One One One One One One One One]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[One]', got '[One  Two]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmp21whjqzt_test.go:63:\
    \ expected '[Three Two One]', got '[One  One One]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[Nine Eight Four]', got '[One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075206
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    sort.Ints(arr)\n\
    \    for i := range arr {\n        if arr[i] < 1 || arr[i] > 9 {\n           \
    \ continue\n        }\n        j := len(result)-1\n        for ; arr[i] > 0; arr[i]--\
    \ {\n            result[j] = name[arr[i]]\n            j--\n        }\n    }\n\
    \    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx8qx5q98_test.go:22:5: undefined: sort

    /tmp/tmpx8qx5q98_test.go:29:25: undefined: name

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075211
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := []string{}\n    for _, v := range arr {\n \
    \       if v >= 1 && v <= 9 {\n            v = 10 - v\n        }\n        result\
    \ = append(result, fmt.Sprintf(\"%v\", v))\n    }\n    return result\n}\n\nfunc\
    \ TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmpmnxqgq3e_test.go:48: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[8 9 9 6 5 2 8 7]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmpmnxqgq3e_test.go:48: expected '[One]', got '[9 -1 55]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmpmnxqgq3e_test.go:48:\
    \ expected '[Three Two One]', got '[9 -1 7 8]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmpmnxqgq3e_test.go:48: expected '[Nine Eight Four]', got '[1\
    \ 6 2]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075211
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    for i := range arr\
    \ {\n        arr[i] = arr[i]\n    }\n    sort.Ints(arr)\n    arr := reverse(arr)\n\
    \    arr := replaceDigit(arr)\n    return arr\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg9xq2psx_test.go:21:9: no new variables on left side of :=

    /tmp/tmpg9xq2psx_test.go:25:5: undefined: sort

    /tmp/tmpg9xq2psx_test.go:26:9: no new variables on left side of :=

    /tmp/tmpg9xq2psx_test.go:26:12: undefined: reverse

    /tmp/tmpg9xq2psx_test.go:27:9: no new variables on left side of :=

    /tmp/tmpg9xq2psx_test.go:27:12: undefined: replaceDigit

    /tmp/tmpg9xq2psx_test.go:28:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075211
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    for i := range arr\
    \ {\n        arr[i] = arr[i]\n    }\n    sort.Ints(arr)\n    arr[len(arr)-1] =\
    \ arr[len(arr)-1] - 1\n    for i := range arr {\n        if arr[i] < 1 || arr[i]\
    \ > 9 {\n            continue\n        }\n        arr[i] = name[arr[i]]\n    }\n\
    \    return arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphwnzwg_n_test.go:21:9: no new variables on left side of :=

    /tmp/tmphwnzwg_n_test.go:25:5: undefined: sort

    /tmp/tmphwnzwg_n_test.go:31:18: undefined: name

    /tmp/tmphwnzwg_n_test.go:33:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075211
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            arr2[i] = \"One\"\
    \n        } else if arr[i] >= 10 && arr[i] <= 99 {\n            arr2[i] = \"Two\"\
    \n        } else if arr[i] >= 100 && arr[i] <= 999 {\n            arr2[i] = \"\
    Three\"\n        } else if arr[i] >= 1000 && arr[i] <= 9999 {\n            arr2[i]\
    \ = \"Four\"\n        } else if arr[i] >= 10000 && arr[i] <= 99999 {\n       \
    \     arr2[i] = \"Five\"\n        } else if arr[i] >= 100000 && arr[i] <= 999999\
    \ {\n            arr2[i] = \"Six\"\n        } else if arr[i] >= 1000000 && arr[i]\
    \ <= 9999999 {\n            arr2[i] = \"Seven\"\n        } else if arr[i] >= 10000000\
    \ && arr[i] <= 99999999 {\n            arr2[i] = \"Eight\"\n        } else if\
    \ arr[i] >= 100000000 && arr[i] <= 999999999 {\n            arr2[i] = \"Nine\"\
    \n        } else {\n            fmt.Println(\"strange number in by_length function\"\
    )\n        }\n    }\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n\
    \  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "strange number in by_length function\nstrange number in by_length function\n\
    --- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0 (0.00s)\n\
    \        tmpz7p83a3__test.go:65: expected '[Eight Five Four Three Two Two One\
    \ One]', got '[One One One One One One One One]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmpz7p83a3__test.go:65: expected '[One]', got '[One  Two]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmpz7p83a3__test.go:65:\
    \ expected '[Three Two One]', got '[One  One One]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmpz7p83a3__test.go:65: expected '[Nine Eight Four]', got '[One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075211
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    copy(arr, arr)\n  \
    \  sort.Sort(sort.Reverse(arr))\n    arr := arr[:len(arr)-1]\n    arr := append(arr,\
    \ 9)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr\
    \ := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, \nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_p957xbl_test.go:78:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075210
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \n    arr := make([]int, len(arr))\n    for i := range arr {\n        arr[i] =\
    \ arr[i] + 1\n    }\n    sort.Ints(arr)\n    arr[len(arr)-1]--\n    reverse(arr)\n\
    \n    result := make([]string, len(arr))\n    for i := range arr {\n        result[i]\
    \ = names[arr[i]]\n    }\n\n    return result\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplgzh0spt_test.go:25:9: no new variables on left side of :=

    /tmp/tmplgzh0spt_test.go:29:5: undefined: sort

    /tmp/tmplgzh0spt_test.go:31:5: undefined: reverse

    /tmp/tmplgzh0spt_test.go:35:21: undefined: names

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075211
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    for i, v := range arr {\n        if v > 9 {\n            arr3[i]\
    \ = v\n        } else {\n            arr3[i] = v - 10\n        }\n    }\n    sort.Ints(arr3)\n\
    \    for i, v := range arr3 {\n        arr2[i] = names[v]\n    }\n    for i, v\
    \ := range arr2 {\n        arr2[i] = fmt.Sprintf(\"%v\", v)\n    }\n    return\
    \ arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5cnt01tl_test.go:30:5: undefined: sort

    /tmp/tmp5cnt01tl_test.go:32:19: undefined: names

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075211
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr2 := make([]int, len(arr))\n    for i := 0; i < len(arr); i++ {\n    \
    \    if arr[i] >= 1 && arr[i] <= 9 {\n            arr2[i] = arr[i]\n        }\
    \ else {\n            arr2[i] = -1\n        }\n    }\n    sort.Ints(arr2)\n  \
    \  arr3 = make([]string, len(arr))\n    for i := 0; i < len(arr); i++ {\n    \
    \    if arr2[i] >= 1 {\n            arr3[i] = \"One\"\n        } else if arr2[i]\
    \ >= 2 {\n            arr3[i] = \"Two\"\n        } else if arr2[i] >= 3 {\n  \
    \          arr3[i] = \"Three\"\n        } else if arr2[i] >= 4 {\n           \
    \ arr3[i] = \"Four\"\n        } else if arr2[i] >= 5 {\n            arr3[i] =\
    \ \"Five\"\n        } else if arr2[i] >= 6 {\n            arr3[i] = \"Six\"\n\
    \        } else if arr2[i] >= 7 {\n            arr3[i] = \"Seven\"\n        }\
    \ else if arr2[i] >= 8 {\n            arr3[i] = \"Eight\"\n        } else if arr2[i]\
    \ >= 9 {\n            arr3[i] = \"Nine\"\n        } else {\n            arr3[i]\
    \ = \"\"\n        }\n    }\n    return arr3\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy81icmum_test.go:32:5: undefined: sort

    /tmp/tmpy81icmum_test.go:33:5: undefined: arr3

    /tmp/tmpy81icmum_test.go:36:13: undefined: arr3

    /tmp/tmpy81icmum_test.go:38:13: undefined: arr3

    /tmp/tmpy81icmum_test.go:40:13: undefined: arr3

    /tmp/tmpy81icmum_test.go:42:13: undefined: arr3

    /tmp/tmpy81icmum_test.go:44:13: undefined: arr3

    /tmp/tmpy81icmum_test.go:46:13: undefined: arr3

    /tmp/tmpy81icmum_test.go:48:13: undefined: arr3

    /tmp/tmpy81icmum_test.go:50:13: undefined: arr3

    /tmp/tmpy81icmum_test.go:50:13: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075211
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    for i := range arr\
    \ {\n        arr[i] = arr[i]\n    }\n    sort.Ints(arr)\n    arr := reverse(arr)\n\
    \    arr := replaceDigit(arr)\n    return arr\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg9xq2psx_test.go:21:9: no new variables on left side of :=

    /tmp/tmpg9xq2psx_test.go:25:5: undefined: sort

    /tmp/tmpg9xq2psx_test.go:26:9: no new variables on left side of :=

    /tmp/tmpg9xq2psx_test.go:26:12: undefined: reverse

    /tmp/tmpg9xq2psx_test.go:27:9: no new variables on left side of :=

    /tmp/tmpg9xq2psx_test.go:27:12: undefined: replaceDigit

    /tmp/tmpg9xq2psx_test.go:28:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075211
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] < 1 || arr[i] > 9 {\n            continue\n       \
    \ }\n        arr2[len(arr2)-i-1] = name[arr[i]-1]\n    }\n    return arr2\n}\n\
    \nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9dbrdvdh_test.go:26:31: undefined: name

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075211
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    for i := range arr\
    \ {\n        arr[i] = arr[i]\n    }\n    sort.Sort(sort.Reverse(arr))\n    arr\
    \ := reverse(arr)\n    arr := replaceDigits(arr)\n    return arr\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqj4dy15h_test.go:21:9: no new variables on left side of :=

    /tmp/tmpqj4dy15h_test.go:25:5: undefined: sort

    /tmp/tmpqj4dy15h_test.go:26:9: no new variables on left side of :=

    /tmp/tmpqj4dy15h_test.go:26:12: undefined: reverse

    /tmp/tmpqj4dy15h_test.go:27:9: no new variables on left side of :=

    /tmp/tmpqj4dy15h_test.go:27:12: undefined: replaceDigits

    /tmp/tmpqj4dy15h_test.go:28:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075212
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr := arr[:len(arr)/2]\n    arr2 := make([]int, len(arr))\n    for i :=\
    \ 0; i < len(arr); i++ {\n        arr2[i] = arr[i]\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(arr2)))\n\
    \    arr2 := make([]string, len(arr))\n    for i := 0; i < len(arr); i++ {\n \
    \       arr2[i] = names[arr2[i]]\n    }\n    return arr2\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp07qyojhy_test.go:24:9: no new variables on left side of :=

    /tmp/tmp07qyojhy_test.go:29:5: undefined: sort

    /tmp/tmp07qyojhy_test.go:30:10: no new variables on left side of :=

    /tmp/tmp07qyojhy_test.go:30:13: cannot use make([]string, len(arr)) (value of
    type []string) as type []int in assignment

    /tmp/tmp07qyojhy_test.go:32:19: undefined: names

    /tmp/tmp07qyojhy_test.go:34:12: cannot use arr2 (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075212
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    i := 0\n    for\
    \ _, v := range arr {\n        if v < 1 || v > 9 {\n            continue\n   \
    \     }\n        result[i] = fmt.Sprintf(\"%v\", v)\n        i++\n    }\n    for\
    \ _, v := range result {\n        result[i] = result[i][1:]\n    }\n    return\
    \ result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpks7ub2rc_test.go:30:12: v declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075212
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    for i := range arr {\n        if arr[i] < 1 || arr[i] > 9 {\n\
    \            continue\n        }\n        arr2[arr[i]-1] = fmt.Sprintf(\"%v\"\
    , i)\n    }\n    for i := range arr2 {\n        arr3[arr2[i]-1] = i\n    }\n \
    \   for i := range arr3 {\n        if arr3[i] < 1 {\n            continue\n  \
    \      }\n        arr2[arr3[i]-1] = fmt.Sprintf(\"%v\", i)\n    }\n    return\
    \ arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp27t8cyu1_test.go:30:14: invalid operation: arr2[i] - 1 (mismatched types
    string and untyped int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075212
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return nil\n    }\n    arr2\
    \ := make([]int, len(arr))\n    for i := 0; i < len(arr); i++ {\n        arr2[i]\
    \ = arr[i]\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(arr2)))\n    arr3\
    \ = make([]string, len(arr))\n    for i := 0; i < len(arr); i++ {\n        arr3[i]\
    \ = map[int]string{\n            1: \"One\",\n            2: \"Two\",\n      \
    \      3: \"Three\",\n            4: \"Four\",\n            5: \"Five\",\n   \
    \         6: \"Six\",\n            7: \"Seven\",\n            8: \"Eight\",\n\
    \            9: \"Nine\",\n        }[arr2[i]]\n    }\n    return arr3\n}\n\nfunc\
    \ TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8_zfige1_test.go:28:5: undefined: sort

    /tmp/tmp8_zfige1_test.go:29:5: undefined: arr3

    /tmp/tmp8_zfige1_test.go:31:9: undefined: arr3

    /tmp/tmp8_zfige1_test.go:43:12: undefined: arr3

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075212
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    if len(arr) == 0 {\n       \
    \ return result\n    }\n    sort.Ints(arr)\n    for _, v := range arr {\n    \
    \    if v < 1 || v > 9 {\n            continue\n        }\n        result = append(result,\
    \ fmt.Sprintf(\"%v\", v))\n    }\n    for _, v := range result {\n        result\
    \ = append(result, \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"\
    Seven\", \"Eight\", \"Nine\")[v]\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyrud38tt_test.go:25:5: undefined: sort

    /tmp/tmpyrud38tt_test.go:33:18: cannot use append(result, "One", "Two", "Three",
    "Four", "Five", "Six", "Seven", "Eight", "Nine")[v] (variable of type string)
    as type []string in assignment

    /tmp/tmpyrud38tt_test.go:33:105: invalid argument: index v (variable of type string)
    must be integer

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075212
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := arr[:0]\n    for _, v := range arr {\n       \
    \ if v >= 1 && v <= 9 {\n            arr = append(arr, fmt.Sprintf(\"%s\", v))\n\
    \        }\n    }\n    arr := arr[:len(arr)-1]\n    for _, v := range arr {\n\
    \        if v == \"One\" {\n            arr[len(arr)-1] = \"One\"\n        } else\
    \ if v == \"Two\" {\n            arr[len(arr)-1] = \"Two\"\n        } else if\
    \ v == \"Three\" {\n            arr[len(arr)-1] = \"Three\"\n        } else if\
    \ v == \"Four\" {\n            arr[len(arr)-1] = \"Four\"\n        } else if v\
    \ == \"Five\" {\n            arr[len(arr)-1] = \"Five\"\n        } else if v ==\
    \ \"Six\" {\n            arr[len(arr)-1] = \"Six\"\n        } else if v == \"\
    Seven\" {\n            arr[len(arr)-1] = \"Seven\"\n        } else if v == \"\
    Eight\" {\n            arr[len(arr)-1] = \"Eight\"\n        } else if v == \"\
    Nine\" {\n            arr[len(arr)-1] = \"Nine\"\n        }\n    }\n    return\
    \ arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcr3gjmrq_test.go:21:9: no new variables on left side of :=

    /tmp/tmpcr3gjmrq_test.go:24:31: cannot use fmt.Sprintf("%s", v) (value of type
    string) as type int in argument to append

    /tmp/tmpcr3gjmrq_test.go:27:9: no new variables on left side of :=

    /tmp/tmpcr3gjmrq_test.go:29:17: invalid operation: v == "One" (mismatched types
    int and untyped string)

    /tmp/tmpcr3gjmrq_test.go:30:31: cannot use "One" (untyped string constant) as
    int value in assignment

    /tmp/tmpcr3gjmrq_test.go:31:24: invalid operation: v == "Two" (mismatched types
    int and untyped string)

    /tmp/tmpcr3gjmrq_test.go:32:31: cannot use "Two" (untyped string constant) as
    int value in assignment

    /tmp/tmpcr3gjmrq_test.go:33:24: invalid operation: v == "Three" (mismatched types
    int and untyped string)

    /tmp/tmpcr3gjmrq_test.go:34:31: cannot use "Three" (untyped string constant) as
    int value in assignment

    /tmp/tmpcr3gjmrq_test.go:35:24: invalid operation: v == "Four" (mismatched types
    int and untyped string)

    /tmp/tmpcr3gjmrq_test.go:35:24: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075212
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr\
    \ := append([]string{\"One\"}, arr...)\n    arr := append([]string{\"Two\"}, arr...)\n\
    \    arr := append([]string{\"Three\"}, arr...)\n    arr := append([]string{\"\
    Four\"}, arr...)\n    arr := append([]string{\"Five\"}, arr...)\n    arr := append([]string{\"\
    Six\"}, arr...)\n    arr := append([]string{\"Seven\"}, arr...)\n    arr := append([]string{\"\
    Eight\"}, arr...)\n    arr := append([]string{\"Nine\"}, arr...)\n    return arr\n\
    }\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpufxui3fi_test.go:21:5:\
    \ undefined: sort\n/tmp/tmpufxui3fi_test.go:22:9: no new variables on left side\
    \ of :=\n/tmp/tmpufxui3fi_test.go:23:9: no new variables on left side of :=\n\
    /tmp/tmpufxui3fi_test.go:23:12: cannot use append([]string{\u2026}, arr...) (value\
    \ of type []string) as type []int in assignment\n/tmp/tmpufxui3fi_test.go:23:36:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmpufxui3fi_test.go:24:9: no new variables on left side of :=\n/tmp/tmpufxui3fi_test.go:24:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpufxui3fi_test.go:24:36: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpufxui3fi_test.go:25:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpufxui3fi_test.go:25:38: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpufxui3fi_test.go:25:12:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    i := 0\n    for\
    \ _, v := range arr {\n        if v < 1 || v > 9 {\n            continue\n   \
    \     }\n        result[i] = fmt.Sprintf(\"%v\", v)\n        i++\n    }\n    for\
    \ i := 0; i < len(result); i++ {\n        result[i], result[len(result)-i-1] =\
    \ result[len(result)-i-1], result[i]\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp8g3ewyag_test.go:53: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 3]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmp8g3ewyag_test.go:53: expected '[One]', got '[1  ]'\n   \
    \ --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmp8g3ewyag_test.go:53:\
    \ expected '[Three Two One]', got '[1 3 2 ]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmp8g3ewyag_test.go:53: expected '[Nine Eight Four]', got '[9\
    \ 4 8]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075213
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    i := 0\n    for\
    \ _, v := range arr {\n        if v >= 1 && v <= 9 {\n            result[i] =\
    \ fmt.Sprintf(\"%s\", v)\n        } else {\n            result[i] = \"One\"\n\
    \        }\n        i++\n    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpzstezt2u_test.go:25:25: fmt.Sprintf format %s has arg v of wrong type
    int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075213
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    if len(arr) == 0 {\n       \
    \ return result\n    }\n    for _, v := range arr {\n        if v < 1 || v > 9\
    \ {\n            continue\n        }\n        result := []string{\"One\", \"Two\"\
    , \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"}\n  \
    \      result := append(result, result[v-1])\n    }\n    return result\n}\n\n\
    func TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp05fdo4ql_test.go:30:16: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075213
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr2 := make([]int, len(arr))\n    arr2[0] = arr[0]\n    for i := 1; i <\
    \ len(arr); i++ {\n        if arr[i] > 9 {\n            arr2[i] = arr[i]\n   \
    \     } else {\n            arr2[i] = arr[i] + 10\n        }\n    }\n    arr3\
    \ = make([]string, len(arr2))\n    for i := 0; i < len(arr2); i++ {\n        arr3[i]\
    \ = \"One\"\n        if arr2[i] > 9 {\n            arr3[i] = \"Two\"\n       \
    \     if arr2[i] > 19 {\n                arr3[i] = \"Three\"\n               \
    \ if arr2[i] > 29 {\n                    arr3[i] = \"Four\"\n                \
    \    if arr2[i] > 39 {\n                        arr3[i] = \"Five\"\n         \
    \               if arr2[i] > 49 {\n                            arr3[i] = \"Six\"\
    \n                            if arr2[i] > 59 {\n                            \
    \    arr3[i] = \"Seven\"\n                                if arr2[i] > 69 {\n\
    \                                    arr3[i] = \"Eight\"\n                   \
    \                 if arr2[i] > 79 {\n                                        arr3[i]\
    \ = \"Nine\"\n                                    }\n                        \
    \        }\n                            }\n                        }\n       \
    \             }\n                }\n            }\n        }\n    }\n    return\
    \ arr3\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd28u658t_test.go:33:5: undefined: arr3

    /tmp/tmpd28u658t_test.go:35:9: undefined: arr3

    /tmp/tmpd28u658t_test.go:37:13: undefined: arr3

    /tmp/tmpd28u658t_test.go:39:17: undefined: arr3

    /tmp/tmpd28u658t_test.go:41:21: undefined: arr3

    /tmp/tmpd28u658t_test.go:43:25: undefined: arr3

    /tmp/tmpd28u658t_test.go:45:29: undefined: arr3

    /tmp/tmpd28u658t_test.go:47:33: undefined: arr3

    /tmp/tmpd28u658t_test.go:49:37: undefined: arr3

    /tmp/tmpd28u658t_test.go:51:41: undefined: arr3

    /tmp/tmpd28u658t_test.go:51:41: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075213
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    for i := range\
    \ arr2 {\n        if arr[i] < 1 || arr[i] > 9 {\n            continue\n      \
    \  }\n        arr2[i] = names[arr[i]]\n    }\n    arr2 = reverse(arr2)\n    for\
    \ i := range arr2 {\n        arr2[i] = fmt.Sprintf(\"%v\", arr2[i])\n    }\n \
    \   return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0kx_mo27_test.go:26:19: undefined: names

    /tmp/tmp0kx_mo27_test.go:28:12: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075213
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return nil\n    }\n    sort.Ints(arr)\n\
    \    arr := arr[:len(arr)-1]\n    for i := range arr {\n        arr[i] = names[arr[i]]\n\
    \    }\n    return arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate :=\
    \ by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy463fy24_test.go:24:5: undefined: sort

    /tmp/tmpy463fy24_test.go:25:9: no new variables on left side of :=

    /tmp/tmpy463fy24_test.go:27:18: undefined: names

    /tmp/tmpy463fy24_test.go:29:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075213
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    for i := 0; i < len(arr);\
    \ i++ {\n        arr[i] = arr[i] + 1\n    }\n    sort.Sort(sort.Reverse(arr))\n\
    \    arr := make([]string, len(arr))\n    for i := 0; i < len(arr); i++ {\n  \
    \      arr[i] = \"One\"\n        if arr[i] > 9 {\n            arr[i] = fmt.Sprintf(\"\
    %v\", arr[i] - 10)\n        }\n    }\n    return arr\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmbhlerwt_test.go:21:9: no new variables on left side of :=

    /tmp/tmpmbhlerwt_test.go:25:5: undefined: sort

    /tmp/tmpmbhlerwt_test.go:26:9: no new variables on left side of :=

    /tmp/tmpmbhlerwt_test.go:26:12: cannot use make([]string, len(arr)) (value of
    type []string) as type []int in assignment

    /tmp/tmpmbhlerwt_test.go:28:18: cannot use "One" (untyped string constant) as
    int value in assignment

    /tmp/tmpmbhlerwt_test.go:30:22: cannot use fmt.Sprintf("%v", arr[i] - 10) (value
    of type string) as type int in assignment

    /tmp/tmpmbhlerwt_test.go:33:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075213
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    for _, v := range arr {\n  \
    \      if v >= 1 && v <= 9 {\n            result = append(result, fmt.Sprintf(\"\
    %s\", v))\n        } else {\n            result = append(result, \"One\")\n  \
    \      }\n    }\n    for i := len(result) - 1; i >= 0; i-- {\n        result[i]\
    \ = result[i][:1] + result[i][1:]\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpittwdn1k_test.go:24:37: fmt.Sprintf format %s has arg v of wrong type
    int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075214
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    if len(arr) == 0 {\n       \
    \ return result\n    }\n    sort.Ints(arr)\n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            result = append(result,\
    \ fmt.Sprintf(\"%v\", arr[i]))\n        }\n    }\n    for i := 0; i < len(result);\
    \ i++ {\n        result[i] = reverse(result[i])\n    }\n    return result\n}\n\
    \nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1tuqx44d_test.go:25:5: undefined: sort

    /tmp/tmp1tuqx44d_test.go:32:21: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075213
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    for i := 0; i < len(arr); i++ {\n        arr3[i] = arr[i]\n \
    \   }\n    sort.Sort(sort.Reverse(sort.IntSlice(arr3)))\n    for i := 0; i < len(arr);\
    \ i++ {\n        if arr3[i] >= 1 && arr3[i] <= 9 {\n            arr2[i] = fmt.Sprintf(\"\
    %s\", arr3[i])\n        } else {\n            arr2[i] = fmt.Sprintf(\"%s\", arr3[i])\n\
    \        }\n    }\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n\
    \  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl7wo6vhc_test.go:26:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075213
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := []string{}\n    for _, v := range arr {\n \
    \       if v >= 1 && v <= 9 {\n            result = append(result, fmt.Sprintf(\"\
    %s\", v))\n        } else {\n            result = append(result, \"One\")\n  \
    \      }\n    }\n    for _, v := range result {\n        result = append(result,\
    \ fmt.Sprintf(\"%s\", v))\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpgiszvqtu_test.go:24:37: fmt.Sprintf format %s has arg v of wrong type
    int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075214
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := arr[:0]\n    for _, v := range arr {\n       \
    \ if v > 9 {\n            arr = append(arr, fmt.Sprintf(\"%v\", v))\n        }\
    \ else {\n            arr = append(arr, fmt.Sprintf(\"%v\", v+1))\n        }\n\
    \    }\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    for _, v := range\
    \ arr {\n        arr = append(arr, fmt.Sprintf(\"%v\", v+1))\n    }\n    return\
    \ arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfso7l3h1_test.go:21:9: no new variables on left side of :=

    /tmp/tmpfso7l3h1_test.go:24:31: cannot use fmt.Sprintf("%v", v) (value of type
    string) as type int in argument to append

    /tmp/tmpfso7l3h1_test.go:26:31: cannot use fmt.Sprintf("%v", v + 1) (value of
    type string) as type int in argument to append

    /tmp/tmpfso7l3h1_test.go:29:5: undefined: sort

    /tmp/tmpfso7l3h1_test.go:31:27: cannot use fmt.Sprintf("%v", v + 1) (value of
    type string) as type int in argument to append

    /tmp/tmpfso7l3h1_test.go:33:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075214
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr := arr[:len(arr)-1]\n    arr := append([]string{\"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"}, arr...)\n\
    \    arr := append(arr, \"One\")\n    arr := append(arr, \"Two\")\n    arr :=\
    \ append(arr, \"Three\")\n    arr := append(arr, \"Four\")\n    arr := append(arr,\
    \ \"Five\")\n    arr := append(arr, \"Six\")\n    arr := append(arr, \"Seven\"\
    )\n    arr := append(arr, \"Eight\")\n    arr := append(arr, \"Nine\")\n    arr\
    \ := append(arr, \"One\")\n    arr := append(arr, \"Two\")\n    arr := append(arr,\
    \ \"Three\")\n    arr := append(arr, \"Four\")\n    arr := append(arr, \"Five\"\
    )\n    arr := append(arr, \"Six\")\n    arr := append(arr, \"Seven\")\n    arr\
    \ := append(arr, \"Eight\")\n    arr := append(arr, \"Nine\")\n    arr := append(arr,\
    \ \"One\")\n    arr := append(arr, \"Two\")\n    arr := append(arr, \"Three\"\
    )\n    arr := append(arr, \"Four\")\n    arr := append(arr, \"Five\")\n    arr\
    \ := append(arr, \"Six\")\n    arr := append(arr, \"Seven\")\n    arr := append(arr,\
    \ \"Eight\")\n    arr := append(arr, \"Nine\")\n    arr := append(arr, \"One\"\
    )\n    arr := append(arr, \"Two\")\n    arr := append(arr, \"Three\")\n    arr\
    \ := append(arr, \"Four\")\n    arr := append(arr, \"Five\")\n    arr := append(arr,\
    \ \"Six\")\n    arr := append(arr, \"Seven\")\n    arr := append(arr, \"Eight\"\
    )\n    arr := append(arr, \"Nine\")\n    arr := append(arr, \"One\")\n    arr\
    \ := append(arr, \"Two\")\n    arr := append(arr, \"Three\")\n    arr := append(arr,\
    \ \"Four\")\n    arr := append(arr, \"Five\")\n    arr := append(arr, \"Six\"\
    )\n    arr := append(arr, \"Seven\")\n    arr := append(\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpujtcntyi_test.go:70:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075213
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    for i := range arr\
    \ {\n        arr[i] = arr[i]\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n\
    \    arr := arr[:len(arr)-1]\n    arr := append(arr, 9)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n  \
    \  arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr,\
    \ []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n\
    \    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr,\
    \ []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n\
    \    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr,\
    \ []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n\
    \    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr,\
    \ []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n\
    \    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr,\
    \ []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n\
    func TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpybrxdoqy_test.go:55:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075213
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr := make([]int, len(arr))\n    for i := range arr {\n        arr[i] =\
    \ arr[i]\n    }\n    sort.Ints(arr)\n    arr[len(arr)-1]--\n    reverse(arr)\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppfy8r9jc_test.go:97:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075213
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr\
    \ := append([]string{\"One\"}, arr...)\n    arr := append([]string{\"Two\"}, arr...)\n\
    \    arr := append([]string{\"Three\"}, arr...)\n    arr := append([]string{\"\
    Four\"}, arr...)\n    arr := append([]string{\"Five\"}, arr...)\n    arr := append([]string{\"\
    Six\"}, arr...)\n    arr := append([]string{\"Seven\"}, arr...)\n    arr := append([]string{\"\
    Eight\"}, arr...)\n    arr := append([]string{\"Nine\"}, arr...)\n    return arr\n\
    }\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpufxui3fi_test.go:21:5:\
    \ undefined: sort\n/tmp/tmpufxui3fi_test.go:22:9: no new variables on left side\
    \ of :=\n/tmp/tmpufxui3fi_test.go:23:9: no new variables on left side of :=\n\
    /tmp/tmpufxui3fi_test.go:23:12: cannot use append([]string{\u2026}, arr...) (value\
    \ of type []string) as type []int in assignment\n/tmp/tmpufxui3fi_test.go:23:36:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmpufxui3fi_test.go:24:9: no new variables on left side of :=\n/tmp/tmpufxui3fi_test.go:24:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpufxui3fi_test.go:24:36: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpufxui3fi_test.go:25:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpufxui3fi_test.go:25:38: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpufxui3fi_test.go:25:12:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    i := 0\n    for\
    \ _, v := range arr {\n        if v < 1 || v > 9 {\n            continue\n   \
    \     }\n        result[i] = fmt.Sprintf(\"%v\", v)\n        i++\n    }\n    for\
    \ _, v := range result {\n        if v == \"One\" {\n            result[0] = \"\
    One\"\n            break\n        }\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmph87b3zfk_test.go:56: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 3]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmph87b3zfk_test.go:56: expected '[One]', got '[1  ]'\n   \
    \ --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmph87b3zfk_test.go:56:\
    \ expected '[Three Two One]', got '[1 3 2 ]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmph87b3zfk_test.go:56: expected '[Nine Eight Four]', got '[9\
    \ 4 8]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075214
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr := append(arr, \"One\"\
    , \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    )\n    arr := append(arr, arr...)\n    return arr\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmukouf7u_test.go:24:5: undefined: sort

    /tmp/tmpmukouf7u_test.go:25:9: no new variables on left side of :=

    /tmp/tmpmukouf7u_test.go:26:24: cannot use "One" (untyped string constant) as
    int value in argument to append

    /tmp/tmpmukouf7u_test.go:26:31: cannot use "Two" (untyped string constant) as
    int value in argument to append

    /tmp/tmpmukouf7u_test.go:26:38: cannot use "Three" (untyped string constant) as
    int value in argument to append

    /tmp/tmpmukouf7u_test.go:26:47: cannot use "Four" (untyped string constant) as
    int value in argument to append

    /tmp/tmpmukouf7u_test.go:26:55: cannot use "Five" (untyped string constant) as
    int value in argument to append

    /tmp/tmpmukouf7u_test.go:26:63: cannot use "Six" (untyped string constant) as
    int value in argument to append

    /tmp/tmpmukouf7u_test.go:26:70: cannot use "Seven" (untyped string constant) as
    int value in argument to append

    /tmp/tmpmukouf7u_test.go:26:79: cannot use "Eight" (untyped string constant) as
    int value in argument to append

    /tmp/tmpmukouf7u_test.go:26:79: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075214
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return nil\n    }\n    sort.Ints(arr)\n\
    \    arr := arr[:len(arr)-1]\n    arr := append([]string{\"One\"}, arr...)\n \
    \   arr := append([]string{\"Two\"}, arr...)\n    arr := append([]string{\"Three\"\
    }, arr...)\n    arr := append([]string{\"Four\"}, arr...)\n    arr := append([]string{\"\
    Five\"}, arr...)\n    arr := append([]string{\"Six\"}, arr...)\n    arr := append([]string{\"\
    Seven\"}, arr...)\n    arr := append([]string{\"Eight\"}, arr...)\n    arr :=\
    \ append([]string{\"Nine\"}, arr...)\n    return arr\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpaqmwsic4_test.go:24:5:\
    \ undefined: sort\n/tmp/tmpaqmwsic4_test.go:25:9: no new variables on left side\
    \ of :=\n/tmp/tmpaqmwsic4_test.go:26:9: no new variables on left side of :=\n\
    /tmp/tmpaqmwsic4_test.go:26:12: cannot use append([]string{\u2026}, arr...) (value\
    \ of type []string) as type []int in assignment\n/tmp/tmpaqmwsic4_test.go:26:36:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmpaqmwsic4_test.go:27:9: no new variables on left side of :=\n/tmp/tmpaqmwsic4_test.go:27:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpaqmwsic4_test.go:27:36: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpaqmwsic4_test.go:28:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpaqmwsic4_test.go:28:38: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpaqmwsic4_test.go:28:12:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075205
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    for i := range\
    \ arr2 {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            arr2[i] = \"One\"\
    \n        } else if arr[i] >= 10 && arr[i] <= 99 {\n            arr2[i] = \"Two\"\
    \n        } else if arr[i] >= 100 && arr[i] <= 999 {\n            arr2[i] = \"\
    Three\"\n        } else if arr[i] >= 1000 && arr[i] <= 9999 {\n            arr2[i]\
    \ = \"Four\"\n        } else if arr[i] >= 10000 && arr[i] <= 99999 {\n       \
    \     arr2[i] = \"Five\"\n        } else if arr[i] >= 100000 && arr[i] <= 999999\
    \ {\n            arr2[i] = \"Six\"\n        } else if arr[i] >= 1000000 && arr[i]\
    \ <= 9999999 {\n            arr2[i] = \"Seven\"\n        } else if arr[i] >= 10000000\
    \ && arr[i] <= 99999999 {\n            arr2[i] = \"Eight\"\n        } else if\
    \ arr[i] >= 100000000 && arr[i] <= 999999999 {\n            arr2[i] = \"Nine\"\
    \n        } else {\n            arr2[i] = fmt.Sprintf(\"%d\", arr[i])\n      \
    \  }\n    }\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmph26t5fmz_test.go:65: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[One One One One One One One One]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmph26t5fmz_test.go:65: expected '[One]', got '[One -1 Two]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmph26t5fmz_test.go:65:\
    \ expected '[Three Two One]', got '[One -1 One One]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmph26t5fmz_test.go:65: expected '[Nine Eight Four]', got '[One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075215
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    for _, v := range arr {\n  \
    \      if v >= 1 && v <= 9 {\n            result = append(result, fmt.Sprintf(\"\
    %v\", v))\n        } else {\n            result = append(result, \"One\")\n  \
    \      }\n    }\n    for i := len(result) - 1; i >= 0; i-- {\n        if result[i]\
    \ == \"One\" {\n            result[i] = \"One\"\n            break\n        }\n\
    \    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp68_2drz1_test.go:55: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 3]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmp68_2drz1_test.go:55: expected '[One]', got '[1 One One]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmp68_2drz1_test.go:55:\
    \ expected '[Three Two One]', got '[1 One 3 2]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmp68_2drz1_test.go:55: expected '[Nine Eight Four]', got '[9\
    \ 4 8]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075208
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    for i := 0; i < len(arr); i++ {\n        if arr[i] < 1 || arr[i]\
    \ > 9 {\n            continue\n        }\n        arr2[len(arr2)-i-1] = names[arr[i]]\n\
    \    }\n    for i := 0; i < len(arr2); i++ {\n        arr3[len(arr3)-i-1] = arr2[i]\n\
    \    }\n    for i := 0; i < len(arr3); i++ {\n        if arr3[i] < 1 {\n     \
    \       arr3[i] = \"One\"\n        } else if arr3[i] > 9 {\n            arr3[i]\
    \ = \"Nine\"\n        } else {\n            arr3[i] = fmt.Sprintf(\"%v\", arr3[i])\n\
    \        }\n    }\n    return arr3\n}\n\nfunc TestBy_Length(t *testing.T) {\n\
    \  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpckl0sxiy_test.go:27:31: undefined: names

    /tmp/tmpckl0sxiy_test.go:30:31: cannot use arr2[i] (variable of type string) as
    type int in assignment

    /tmp/tmpckl0sxiy_test.go:34:23: cannot use "One" (untyped string constant) as
    int value in assignment

    /tmp/tmpckl0sxiy_test.go:36:23: cannot use "Nine" (untyped string constant) as
    int value in assignment

    /tmp/tmpckl0sxiy_test.go:38:23: cannot use fmt.Sprintf("%v", arr3[i]) (value of
    type string) as type int in assignment

    /tmp/tmpckl0sxiy_test.go:41:12: cannot use arr3 (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075215
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    for _, v := range arr {\n  \
    \      if v > 9 {\n            v = v - 10\n        }\n        result = append(result,\
    \ fmt.Sprintf(\"%v\", v))\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmphqq6th_w_test.go:48: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 3]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmphqq6th_w_test.go:48: expected '[One]', got '[1 -1 45]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmphqq6th_w_test.go:48:\
    \ expected '[Three Two One]', got '[1 -1 3 2]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmphqq6th_w_test.go:48: expected '[Nine Eight Four]', got '[9\
    \ 4 8]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075216
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    i := 0\n    for\
    \ _, v := range arr {\n        if v < 1 || v > 9 {\n            continue\n   \
    \     }\n        result[i] = fmt.Sprintf(\"%v\", v)\n        i++\n    }\n    for\
    \ i := 0; i < len(result); i++ {\n        result[i] = \"One\"\n    }\n    return\
    \ result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmprm0172jh_test.go:53: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[One One One One One One One One]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmprm0172jh_test.go:53: expected '[One]', got '[One One One]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmprm0172jh_test.go:53:\
    \ expected '[Three Two One]', got '[One One One One]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmprm0172jh_test.go:53: expected '[Nine Eight Four]', got '[One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075209
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n\
    \    arr := arr[:len(arr)/2]\n    arr[len(arr)-1]--\n    arr := append([]string{},\
    \ One, Two, Three, Four, Five, Six, Seven, Eight, Nine...)[arr]\n    arr := append([]string{},\
    \ arr...)\n    return arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcgbyeowa_test.go:21:9: no new variables on left side of :=

    /tmp/tmpcgbyeowa_test.go:22:5: undefined: sort

    /tmp/tmpcgbyeowa_test.go:23:9: no new variables on left side of :=

    /tmp/tmpcgbyeowa_test.go:25:31: undefined: One

    /tmp/tmpcgbyeowa_test.go:25:36: undefined: Two

    /tmp/tmpcgbyeowa_test.go:25:41: undefined: Three

    /tmp/tmpcgbyeowa_test.go:25:48: undefined: Four

    /tmp/tmpcgbyeowa_test.go:25:54: undefined: Five

    /tmp/tmpcgbyeowa_test.go:25:60: undefined: Six

    /tmp/tmpcgbyeowa_test.go:25:65: undefined: Seven

    /tmp/tmpcgbyeowa_test.go:25:65: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075215
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    sort.Ints(arr)\n    arr := reverse(arr)\n    arr := map[int]string{1: \"\
    One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\"\
    , 8: \"Eight\", 9: \"Nine\"}\n    arr := map[int]string{1: \"One\", 2: \"Two\"\
    , 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\"\
    , 9: \"Nine\"}\n    arr := map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\"\
    , 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"\
    }\n    arr := map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\"\
    , 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    arr :=\
    \ map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\"\
    , 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    arr := map[int]string{1:\
    \ \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7:\
    \ \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    arr := map[int]string{1: \"One\"\
    , 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\"\
    , 8: \"Eight\", 9: \"Nine\"}\n    arr := map[int]string{1: \"One\", 2: \"Two\"\
    , 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\"\
    , 9: \"Nine\"}\n    arr := map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\"\
    , 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"\
    }\n    arr := map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\"\
    , 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    arr :=\
    \ map[int]string\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1zk08yyd_test.go:36:12: expected expression

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075214
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    for i := range arr\
    \ {\n        arr[i] = arr[i]\n    }\n    sort.Ints(arr)\n    arr := reverse(arr)\n\
    \    arr := replaceDigit(arr)\n    return arr\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg9xq2psx_test.go:21:9: no new variables on left side of :=

    /tmp/tmpg9xq2psx_test.go:25:5: undefined: sort

    /tmp/tmpg9xq2psx_test.go:26:9: no new variables on left side of :=

    /tmp/tmpg9xq2psx_test.go:26:12: undefined: reverse

    /tmp/tmpg9xq2psx_test.go:27:9: no new variables on left side of :=

    /tmp/tmpg9xq2psx_test.go:27:12: undefined: replaceDigit

    /tmp/tmpg9xq2psx_test.go:28:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075211
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    i := 0\n    for\
    \ _, v := range arr {\n        if v < 1 || v > 9 {\n            continue\n   \
    \     }\n        j := int(v)\n        result[i] = names[j]\n        i++\n    }\n\
    \    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp63dqzv1k_test.go:28:21: undefined: names

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075210
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    i := 0\n    for\
    \ _, num := range arr {\n        if num >= 1 && num <= 9 {\n            result[i]\
    \ = fmt.Sprintf(\"%v\", num)\n            i++\n        }\n    }\n    for i :=\
    \ len(result) - 1; i >= 0; i-- {\n        result[i] = reverse(result[i])\n   \
    \ }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate :=\
    \ by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg1ziydhe_test.go:30:21: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075215
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr2 := make([]int, len(arr))\n    for i := range arr2 {\n        arr2[i]\
    \ = arr[i]\n    }\n    sort.Ints(arr2)\n    arr2 = reverse(arr2)\n    arr2 = replaceDigit(arr2)\n\
    \    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpndoeuut7_test.go:28:5: undefined: sort

    /tmp/tmpndoeuut7_test.go:29:12: undefined: reverse

    /tmp/tmpndoeuut7_test.go:30:12: undefined: replaceDigit

    /tmp/tmpndoeuut7_test.go:31:12: cannot use arr2 (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075210
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr := append(arr, \"One\"\
    , \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    )\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr\
    \ := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr,\
    \ \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\"\
    )\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr\
    \ := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr,\
    \ \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\"\
    )\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr\
    \ := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr,\
    \ \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\"\
    )\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr\
    \ := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr,\
    \ \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\"\
    )\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr\
    \ := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr,\
    \ \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\"\
    )\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr\
    \ := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr,\
    \ \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\"\
    )\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr\
    \ := append(arr, \"Zero\")\n    arr := \nfunc TestBy_Length(t *testing.T) {\n\
    \  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy17nsbdw_test.go:73:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075215
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    for i := 0; i < len(arr); i++ {\n        arr3[i] = arr[i]\n \
    \   }\n    sort.Ints(arr3)\n    for i := 0; i < len(arr); i++ {\n        if arr3[i]\
    \ >= 1 && arr3[i] <= 9 {\n            arr2[i] = fmt.Sprintf(\"%v\", arr3[i])\n\
    \        } else {\n            arr2[i] = \"One\"\n        }\n    }\n    for i\
    \ := 0; i < len(arr); i++ {\n        arr2[i] = arr2[i][1:]\n    }\n    return\
    \ arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdbj0wniy_test.go:26:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075216
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \n    arr2 := make([]int, len(arr))\n    for i := range arr2 {\n        arr2[i]\
    \ = arr[i]\n    }\n\n    sort.Ints(arr2)\n\n    arr3 = make([]string, len(arr2))\n\
    \    for i := range arr2 {\n        if arr2[i] < 1 || arr2[i] > 9 {\n        \
    \    continue\n        }\n        arr3[i] = map[int]string{\n            1: \"\
    One\",\n            2: \"Two\",\n            3: \"Three\",\n            4: \"\
    Four\",\n            5: \"Five\",\n            6: \"Six\",\n            7: \"\
    Seven\",\n            8: \"Eight\",\n            9: \"Nine\",\n        }[arr2[i]]\n\
    \    }\n\n    return arr3\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppvoj2od1_test.go:30:5: undefined: sort

    /tmp/tmppvoj2od1_test.go:32:5: undefined: arr3

    /tmp/tmppvoj2od1_test.go:37:9: undefined: arr3

    /tmp/tmppvoj2od1_test.go:50:12: undefined: arr3

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075216
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    for i, v := range arr {\n        if v < 1 || v > 9 {\n      \
    \      continue\n        }\n        arr2[i] = fmt.Sprintf(\"%v\", v)\n       \
    \ arr3[i] = v\n    }\n    sort.Ints(arr3)\n    sort.Ints(arr2)\n    for i, v :=\
    \ range arr2 {\n        arr2[i] = arr3[v]\n    }\n    for i, v := range arr2 {\n\
    \        arr2[i] = arr2[i][:1] + map[int]string{\n            1: \"One\",\n  \
    \          2: \"Two\",\n            3: \"Three\",\n            4: \"Four\",\n\
    \            5: \"Five\",\n            6: \"Six\",\n            7: \"Seven\",\n\
    \            8: \"Eight\",\n            9: \"Nine\",\n        }[v] + arr2[i][1:]\n\
    \    }\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphufi52jo_test.go:30:5: undefined: sort

    /tmp/tmphufi52jo_test.go:31:5: undefined: sort

    /tmp/tmphufi52jo_test.go:33:19: cannot use arr3[v] (variable of type int) as type
    string in assignment

    /tmp/tmphufi52jo_test.go:33:24: invalid argument: index v (variable of type string)
    must be integer

    /tmp/tmphufi52jo_test.go:46:11: cannot use v (variable of type string) as type
    int in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075216
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    for i := range\
    \ arr2 {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            arr2[i] = fmt.Sprintf(\"\
    %s\", map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"\
    Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}[arr[i]])\n      \
    \  } else {\n            arr2[i] = \"\"\n        }\n    }\n    return arr2\n}\n\
    \nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp15hj6apk_test.go:49: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[Two One One Four Five Eight Two Three]'\n    --- FAIL:\
    \ TestBy_Length/test_num__2 (0.00s)\n        tmp15hj6apk_test.go:49: expected\
    \ '[One]', got '[One  ]'\n    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n  \
    \      tmp15hj6apk_test.go:49: expected '[Three Two One]', got '[One  Three Two]'\n\
    \    --- FAIL: TestBy_Length/test_num__4 (0.00s)\n        tmp15hj6apk_test.go:49:\
    \ expected '[Nine Eight Four]', got '[Nine Four Eight]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075216
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    if len(arr) == 0 {\n       \
    \ return result\n    }\n    sort.Ints(arr)\n    var lastNum int\n    for _, num\
    \ := range arr {\n        if num < 1 || num > 9 {\n            continue\n    \
    \    }\n        if num == lastNum {\n            continue\n        }\n       \
    \ result = append(result, fmt.Sprintf(\"%v\", num))\n        lastNum = num\n \
    \   }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5yb_1gmh_test.go:25:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075216
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr\
    \ := append(arr, 9)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n\
    \    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\n    arr := append(arr,\
    \ -1)\n    arr := append(arr, -1)\n    arr := append(arr, -1)\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8znkp2yb_test.go:85:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075215
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := []string{}\n    for _, v := range arr {\n \
    \       if v > 0 && v < 10 {\n            result := append(result, fmt.Sprintf(\"\
    %v\", v))\n        }\n    }\n    for _, v := range result {\n        if v == \"\
    One\" {\n            result[0] = \"One\"\n        } else if v == \"Two\" {\n \
    \           result[1] = \"Two\"\n        } else if v == \"Three\" {\n        \
    \    result[2] = \"Three\"\n        } else if v == \"Four\" {\n            result[3]\
    \ = \"Four\"\n        } else if v == \"Five\" {\n            result[4] = \"Five\"\
    \n        } else if v == \"Six\" {\n            result[5] = \"Six\"\n        }\
    \ else if v == \"Seven\" {\n            result[6] = \"Seven\"\n        } else\
    \ if v == \"Eight\" {\n            result[7] = \"Eight\"\n        } else if v\
    \ == \"Nine\" {\n            result[8] = \"Nine\"\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpih7300io_test.go:24:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075216
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] > 9 {\n            arr[i] = arr[i]%10\n           \
    \ arr[i] = \"Nine\"\n        }\n        if arr[i] < 1 {\n            arr[i] =\
    \ arr[i]%10\n            arr[i] = \"One\"\n        }\n        result[i] = fmt.Sprintf(\"\
    %v\", arr[i])\n    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgviy7gc5_test.go:25:22: cannot use "Nine" (untyped string constant) as
    int value in assignment

    /tmp/tmpgviy7gc5_test.go:29:22: cannot use "One" (untyped string constant) as
    int value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075216
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            arr2[i] = \"One\"\
    \n        } else if arr[i] >= 10 && arr[i] <= 99 {\n            arr2[i] = \"Two\"\
    \n        } else if arr[i] >= 100 && arr[i] <= 999 {\n            arr2[i] = \"\
    Three\"\n        } else if arr[i] >= 1000 && arr[i] <= 9999 {\n            arr2[i]\
    \ = \"Four\"\n        } else if arr[i] >= 10000 && arr[i] <= 99999 {\n       \
    \     arr2[i] = \"Five\"\n        } else if arr[i] >= 100000 && arr[i] <= 999999\
    \ {\n            arr2[i] = \"Six\"\n        } else if arr[i] >= 1000000 && arr[i]\
    \ <= 9999999 {\n            arr2[i] = \"Seven\"\n        } else if arr[i] >= 10000000\
    \ && arr[i] <= 99999999 {\n            arr2[i] = \"Eight\"\n        } else if\
    \ arr[i] >= 100000000 && arr[i] <= 999999999 {\n            arr2[i] = \"Nine\"\
    \n        }\n    }\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n\
    \  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[One One One One One One One One]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[One]', got '[One  Two]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmp21whjqzt_test.go:63:\
    \ expected '[Three Two One]', got '[One  One One]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmp21whjqzt_test.go:63: expected '[Nine Eight Four]', got '[One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075206
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)/2]\n    reverse(arr)\n\
    \    arr := arr[:len(arr)/2]\n    for i := 0; i < len(arr); i++ {\n        arr[i]\
    \ = \"One\"\n    }\n    return arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n\
    \  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjv1wllce_test.go:21:5: undefined: sort

    /tmp/tmpjv1wllce_test.go:22:9: no new variables on left side of :=

    /tmp/tmpjv1wllce_test.go:23:5: undefined: reverse

    /tmp/tmpjv1wllce_test.go:24:9: no new variables on left side of :=

    /tmp/tmpjv1wllce_test.go:26:18: cannot use "One" (untyped string constant) as
    int value in assignment

    /tmp/tmpjv1wllce_test.go:28:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075216
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    for _, v := range arr {\n  \
    \      if v >= 1 && v <= 9 {\n            result = append(result, fmt.Sprintf(\"\
    %s\", v))\n        } else {\n            result = append(result, \"One\")\n  \
    \      }\n    }\n    for i := len(result) - 1; i >= 0; i-- {\n        result[i]\
    \ = result[i][:1] + result[i][1:]\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpittwdn1k_test.go:24:37: fmt.Sprintf format %s has arg v of wrong type
    int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075214
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    i := 0\n    for\
    \ _, v := range arr {\n        if v >= 1 && v <= 9 {\n            result[i] =\
    \ fmt.Sprintf(\"%v\", v)\n        } else {\n            result[i] = \"One\"\n\
    \        }\n        i++\n    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmpj_aeedse_test.go:51: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 3]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmpj_aeedse_test.go:51: expected '[One]', got '[1 One One]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmpj_aeedse_test.go:51:\
    \ expected '[Three Two One]', got '[1 One 3 2]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmpj_aeedse_test.go:51: expected '[Nine Eight Four]', got '[9\
    \ 4 8]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075211
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] < 1 || arr[i] > 9 {\n            continue\n       \
    \ }\n        j := int(arr[i]) - 1\n        result[i] = names[j]\n    }\n    for\
    \ i := range result {\n        result[i] = reverse(result[i])\n    }\n    return\
    \ result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0bj1eweb_test.go:27:21: undefined: names

    /tmp/tmp0bj1eweb_test.go:30:21: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075216
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n\
    \    arr := append([]int{}, arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{},\
    \ arr...)\n    arr[len(arr)-1]--\n    arr := append([]int{}, \nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_u2e0m_4_test.go:80:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075215
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return nil\n    }\n    arr2\
    \ := make([]string, len(arr))\n    for i := range arr2 {\n        arr2[i] = \"\
    One\"\n        if arr[i] >= 1 && arr[i] <= 9 {\n            arr2[i] = fmt.Sprintf(\"\
    %v\", arr[i])\n        }\n    }\n    arr2 = append(arr2[:len(arr)-1], arr2...)\n\
    \    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmpqv8spxiu_test.go:52: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 2 1 1 4 5 8 2 3]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmpqv8spxiu_test.go:52: expected '[One]', got '[1 One 1 One\
    \ One]'\n    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmpqv8spxiu_test.go:52:\
    \ expected '[Three Two One]', got '[1 One 3 1 One 3 2]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmpqv8spxiu_test.go:52: expected '[Nine Eight Four]', got '[9\
    \ 4 9 4 8]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075217
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    copy(arr, arr)\n  \
    \  sort.Ints(arr)\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvbju_tn4_test.go:94:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075215
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    i := 0\n    for\
    \ _, v := range arr {\n        if v >= 1 && v <= 9 {\n            result[i] =\
    \ fmt.Sprintf(\"%s\", v)\n        } else {\n            result[i] = \"One\"\n\
    \        }\n        i++\n    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpzstezt2u_test.go:25:25: fmt.Sprintf format %s has arg v of wrong type
    int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075213
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    for i, v := range arr\
    \ {\n        if v < 1 || v > 9 {\n            continue\n        }\n        arr[i]\
    \ = v\n    }\n    sort.Ints(arr)\n    reverse(arr)\n    result := make([]string,\
    \ len(arr))\n    for i, v := range arr {\n        result[i] = names[v]\n    }\n\
    \    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8y_kn5aq_test.go:21:9: no new variables on left side of :=

    /tmp/tmp8y_kn5aq_test.go:28:5: undefined: sort

    /tmp/tmp8y_kn5aq_test.go:29:5: undefined: reverse

    /tmp/tmp8y_kn5aq_test.go:32:21: undefined: names

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075217
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    for i := range arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n\
    \            arr2[i] = fmt.Sprintf(\"%s\", arr[i])\n        } else {\n       \
    \     arr3[i] = arr[i]\n        }\n    }\n    sort.Ints(arr3)\n    arr4 = make([]string,\
    \ len(arr2))\n    for i := range arr2 {\n        arr4[i] = fmt.Sprintf(\"%s\"\
    , arr3[i])\n    }\n    for i := range arr4 {\n        if arr4[i] == \"One\" {\n\
    \            arr4[i] = \"One\"\n        } else if arr4[i] == \"Two\" {\n     \
    \       arr4[i] = \"Two\"\n        } else if arr4[i] == \"Three\" {\n        \
    \    arr4[i] = \"Three\"\n        } else if arr4[i] == \"Four\" {\n          \
    \  arr4[i] = \"Four\"\n        } else if arr4[i] == \"Five\" {\n            arr4[i]\
    \ = \"Five\"\n        } else if arr4[i] == \"Six\" {\n            arr4[i] = \"\
    Six\"\n        } else if arr4[i] == \"Seven\" {\n            arr4[i] = \"Seven\"\
    \n        } else if arr4[i] == \"Eight\" {\n            arr4[i] = \"Eight\"\n\
    \        } else if arr4[i] == \"Nine\" {\n            arr4[i] = \"Nine\"\n   \
    \     }\n    }\n    return arr4\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe7o4qb1x_test.go:30:5: undefined: sort

    /tmp/tmpe7o4qb1x_test.go:31:5: undefined: arr4

    /tmp/tmpe7o4qb1x_test.go:33:9: undefined: arr4

    /tmp/tmpe7o4qb1x_test.go:35:20: undefined: arr4

    /tmp/tmpe7o4qb1x_test.go:36:12: undefined: arr4

    /tmp/tmpe7o4qb1x_test.go:37:13: undefined: arr4

    /tmp/tmpe7o4qb1x_test.go:38:19: undefined: arr4

    /tmp/tmpe7o4qb1x_test.go:39:13: undefined: arr4

    /tmp/tmpe7o4qb1x_test.go:40:19: undefined: arr4

    /tmp/tmpe7o4qb1x_test.go:41:13: undefined: arr4

    /tmp/tmpe7o4qb1x_test.go:41:13: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075217
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    for i := range arr\
    \ {\n        arr[i] = arr[i]\n    }\n    sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n\
    \    arr := make([]string, len(arr))\n    for i := range arr {\n        arr[i]\
    \ = \"One\"\n        if arr[i] > 9 {\n            arr[i] = fmt.Sprintf(\"%v\"\
    , arr[i]%10)\n        }\n    }\n    return arr\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf33u_2rc_test.go:21:9: no new variables on left side of :=

    /tmp/tmpf33u_2rc_test.go:25:5: undefined: sort

    /tmp/tmpf33u_2rc_test.go:26:9: no new variables on left side of :=

    /tmp/tmpf33u_2rc_test.go:26:12: cannot use make([]string, len(arr)) (value of
    type []string) as type []int in assignment

    /tmp/tmpf33u_2rc_test.go:28:18: cannot use "One" (untyped string constant) as
    int value in assignment

    /tmp/tmpf33u_2rc_test.go:30:22: cannot use fmt.Sprintf("%v", arr[i] % 10) (value
    of type string) as type int in assignment

    /tmp/tmpf33u_2rc_test.go:33:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075217
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr := arr[:len(arr)/2]\n    arr[len(arr)-1], arr[len(arr)-2] = arr[len(arr)-2],\
    \ arr[len(arr)-1]\n    arr := reverse(arr)\n    arr := map[int]string{1: \"One\"\
    , 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\"\
    , 8: \"Eight\", 9: \"Nine\"}\n    arr := map[int]string{1: \"One\", 2: \"Two\"\
    , 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\"\
    , 9: \"Nine\"}\n    arr := map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\"\
    , 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"\
    }\n    arr := map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\"\
    , 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    arr :=\
    \ map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\"\
    , 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    arr := map[int]string{1:\
    \ \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7:\
    \ \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    arr := map[int]string{1: \"One\"\
    , 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\"\
    , 8: \"Eight\", 9: \"Nine\"}\n    arr := map[int]string{1: \"One\", 2: \"Two\"\
    , 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\"\
    , 9: \"Nine\"}\n    arr := map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\"\
    , 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"\
    }\n    arr := map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\"\
    , 5: \"Five\", 6: \"S\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4va60jlb_test.go:36:84: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075216
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \n    sort.Ints(arr)\n    arr := arr[:len(arr)/2]\n    reverse(arr)\n    arr :=\
    \ arr[:len(arr)/2]\n    arr := append(arr, \"One\", \"Two\", \"Three\", \"Four\"\
    , \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\")\n    return arr\n}\n\nfunc\
    \ TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzsu593tk_test.go:25:5: undefined: sort

    /tmp/tmpzsu593tk_test.go:26:9: no new variables on left side of :=

    /tmp/tmpzsu593tk_test.go:27:5: undefined: reverse

    /tmp/tmpzsu593tk_test.go:28:9: no new variables on left side of :=

    /tmp/tmpzsu593tk_test.go:29:24: cannot use "One" (untyped string constant) as
    int value in argument to append

    /tmp/tmpzsu593tk_test.go:29:31: cannot use "Two" (untyped string constant) as
    int value in argument to append

    /tmp/tmpzsu593tk_test.go:29:38: cannot use "Three" (untyped string constant) as
    int value in argument to append

    /tmp/tmpzsu593tk_test.go:29:47: cannot use "Four" (untyped string constant) as
    int value in argument to append

    /tmp/tmpzsu593tk_test.go:29:55: cannot use "Five" (untyped string constant) as
    int value in argument to append

    /tmp/tmpzsu593tk_test.go:29:63: cannot use "Six" (untyped string constant) as
    int value in argument to append

    /tmp/tmpzsu593tk_test.go:29:63: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075217
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            j := int(arr[i])\n\
    \            result[i] = \"One\"\n            if j > 0 {\n                result[i]\
    \ += string(j-1)\n            }\n        }\n    }\n    for i := range result {\n\
    \        result[i] = reverse(result[i])\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptdai51r2_test.go:32:21: undefined: reverse

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075217
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return nil\n    }\n    arr2\
    \ := make([]string, len(arr))\n    arr3 := make([]int, len(arr))\n    for i, v\
    \ := range arr {\n        if v < 1 || v > 9 {\n            continue\n        }\n\
    \        arr2[i] = \"One\"\n        arr3[i] = v\n    }\n    sort.Ints(arr3)\n\
    \    arr4 = reverse(arr3)\n    for i, v := range arr4 {\n        arr2[i] = \"\
    Two\"\n        arr2[i+1] = \"Three\"\n        arr2[i+2] = \"Four\"\n        arr2[i+3]\
    \ = \"Five\"\n        arr2[i+4] = \"Six\"\n        arr2[i+5] = \"Seven\"\n   \
    \     arr2[i+6] = \"Eight\"\n        arr2[i+7] = \"Nine\"\n        arr2[i+8] =\
    \ v\n    }\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8ak6_2y8_test.go:33:5: undefined: sort

    /tmp/tmp8ak6_2y8_test.go:34:5: undefined: arr4

    /tmp/tmp8ak6_2y8_test.go:34:12: undefined: reverse

    /tmp/tmp8ak6_2y8_test.go:35:23: undefined: arr4

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075218
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    for i := range\
    \ arr2 {\n        if arr[i] > 9 {\n            arr2[i] = \"Nine\"\n        } else\
    \ if arr[i] < 1 {\n            arr2[i] = \"One\"\n        } else {\n         \
    \   arr2[i] = fmt.Sprintf(\"%v\", arr[i])\n        }\n    }\n    arr2 = append(arr2[:len(arr)-1],\
    \ arr2...)\n    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\npanic: runtime error: slice bounds out\
    \ of range [:-1] [recovered]\n\tpanic: runtime error: slice bounds out of range\
    \ [:-1]\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700, 0xc000014360})\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389 +0x24e\ntesting.tRunner.func1()\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392 +0x39f\npanic({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.by_length({0xc0000f5d88, 0x0, 0x0?})\n\t\
    /tmp/tmp3o_a1un9_test.go:31 +0x239\ncommand-line-arguments_test.TestBy_Length(0x0?)\n\
    \t/tmp/tmp3o_a1un9_test.go:43 +0x102\ntesting.tRunner(0xc0001a0340, 0x529038)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075218
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    for _, v := range arr {\n  \
    \      if v > 9 {\n            v = v - 10\n        }\n        if v < 1 {\n   \
    \         v = v + 10\n        }\n        result = append(result, fmt.Sprintf(\"\
    %v\", v))\n    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n\
    \  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmpsnl84x9e_test.go:51: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 3]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmpsnl84x9e_test.go:51: expected '[One]', got '[1 9 45]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmpsnl84x9e_test.go:51:\
    \ expected '[Three Two One]', got '[1 9 3 2]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmpsnl84x9e_test.go:51: expected '[Nine Eight Four]', got '[9\
    \ 4 8]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075209
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    for _, v := range arr {\n  \
    \      if v >= 1 && v <= 9 {\n            result = append(result, fmt.Sprintf(\"\
    %s\", v))\n        } else {\n            result = append(result, \"One\")\n  \
    \      }\n    }\n    for _, v := range result {\n        if v == \"One\" {\n \
    \           result = []string{}\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpccboikvs_test.go:24:37: fmt.Sprintf format %s has arg v of wrong type
    int

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075218
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    for\
    \ i := 0; i < len(arr); i++ {\n        if arr[i] < 1 || arr[i] > 9 {\n       \
    \     continue\n        }\n        arr[i] = \"One\"\n        arr[i+1] = \"Two\"\
    \n        arr[i+2] = \"Three\"\n        arr[i+3] = \"Four\"\n        arr[i+4]\
    \ = \"Five\"\n        arr[i+5] = \"Six\"\n        arr[i+6] = \"Seven\"\n     \
    \   arr[i+7] = \"Eight\"\n        arr[i+8] = \"Nine\"\n    }\n    return arr\n\
    }\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp09710i9y_test.go:21:5: undefined: sort

    /tmp/tmp09710i9y_test.go:22:9: no new variables on left side of :=

    /tmp/tmp09710i9y_test.go:27:18: cannot use "One" (untyped string constant) as
    int value in assignment

    /tmp/tmp09710i9y_test.go:28:20: cannot use "Two" (untyped string constant) as
    int value in assignment

    /tmp/tmp09710i9y_test.go:29:20: cannot use "Three" (untyped string constant) as
    int value in assignment

    /tmp/tmp09710i9y_test.go:30:20: cannot use "Four" (untyped string constant) as
    int value in assignment

    /tmp/tmp09710i9y_test.go:31:20: cannot use "Five" (untyped string constant) as
    int value in assignment

    /tmp/tmp09710i9y_test.go:32:20: cannot use "Six" (untyped string constant) as
    int value in assignment

    /tmp/tmp09710i9y_test.go:33:20: cannot use "Seven" (untyped string constant) as
    int value in assignment

    /tmp/tmp09710i9y_test.go:34:20: cannot use "Eight" (untyped string constant) as
    int value in assignment

    /tmp/tmp09710i9y_test.go:34:20: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075218
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr := arr[:len(arr)-1]\n    arr := append([]string{\"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := reverse(arr)\n    arr := arr[:len(arr)-1]\n\
    \    arr := append([]string{}, arr...)\n    for _, v := range arr {\n        arr[v-1]\
    \ = names[v-1]\n    }\n    return arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n\
    \  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpd0vc_jq5_test.go:24:9:\
    \ no new variables on left side of :=\n/tmp/tmpd0vc_jq5_test.go:25:9: no new variables\
    \ on left side of :=\n/tmp/tmpd0vc_jq5_test.go:25:12: cannot use append([]string{\u2026\
    }, arr...) (value of type []string) as type []int in assignment\n/tmp/tmpd0vc_jq5_test.go:25:101:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmpd0vc_jq5_test.go:26:9: no new variables on left side of :=\n/tmp/tmpd0vc_jq5_test.go:26:12:\
    \ cannot use append([]string{}, arr...) (value of type []string) as type []int\
    \ in assignment\n/tmp/tmpd0vc_jq5_test.go:26:31: cannot use arr (variable of type\
    \ []int) as type []string in argument to append\n/tmp/tmpd0vc_jq5_test.go:27:9:\
    \ no new variables on left side of :=\n/tmp/tmpd0vc_jq5_test.go:27:12: undefined:\
    \ reverse\n/tmp/tmpd0vc_jq5_test.go:28:9: no new variables on left side of :=\n\
    /tmp/tmpd0vc_jq5_test.go:28:9: too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075218
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    for i := range arr\
    \ {\n        arr[i] = arr[i]\n    }\n    sort.Ints(arr)\n    arr[len(arr)-1] =\
    \ arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1] - 1\n    arr[len(arr)-1]\
    \ = arr[len(arr)-1] - 1\n    arr[len(arr)-1] = arr[len(arr)-1]\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_qw5ex4y_test.go:66:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075217
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    if len(arr) == 0 {\n       \
    \ return result\n    }\n    for _, v := range arr {\n        if v >= 1 && v <=\
    \ 9 {\n            result = append(result, fmt.Sprintf(\"%v\", v))\n        }\
    \ else {\n            result = append(result, \"One\")\n        }\n    }\n   \
    \ for i := len(result) - 1; i >= 0; i-- {\n        result[i] = result[i] + result[i+1]\n\
    \    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\npanic: runtime error: index out of range\
    \ [8] with length 8 [recovered]\n\tpanic: runtime error: index out of range [8]\
    \ with length 8\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.by_length({0xc0000f5e30, 0x8, 0x0?})\n\t\
    /tmp/tmp0isgf_zj_test.go:33 +0x2be\ncommand-line-arguments_test.TestBy_Length(0x0?)\n\
    \t/tmp/tmp0isgf_zj_test.go:45 +0xd5\ntesting.tRunner(0xc0001924e0, 0x529038)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr := make([]int, len(arr))\n    copy(arr, arr)\n    sort.Ints(arr)\n  \
    \  arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n    arr[len(arr)-1]--\n\
    \    \nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxkda98mt_test.go:96:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075217
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] < 1 || arr[i] > 9 {\n            continue\n       \
    \ }\n        j := int(arr[i]) - 1\n        result[i] = names[j]\n    }\n    return\
    \ result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph4jev640_test.go:27:21: undefined: names

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075218
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return nil\n    }\n    arr2\
    \ := make([]int, len(arr))\n    for i := range arr2 {\n        arr2[i] = arr[i]\n\
    \    }\n    sort.Ints(arr2)\n    arr2 = reverse(arr2)\n    arr2 = replaceDigits(arr2)\n\
    \    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplw7how6y_test.go:28:5: undefined: sort

    /tmp/tmplw7how6y_test.go:29:12: undefined: reverse

    /tmp/tmplw7how6y_test.go:30:12: undefined: replaceDigits

    /tmp/tmplw7how6y_test.go:31:12: cannot use arr2 (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075218
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)/2]\n    reverse(arr)\n\
    \    arr := arr[:len(arr)/2]\n    for _, v := range arr {\n        arr[v] = names[v]\n\
    \    }\n    return arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate :=\
    \ by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp01pk0zhp_test.go:21:5: undefined: sort

    /tmp/tmp01pk0zhp_test.go:22:9: no new variables on left side of :=

    /tmp/tmp01pk0zhp_test.go:23:5: undefined: reverse

    /tmp/tmp01pk0zhp_test.go:24:9: no new variables on left side of :=

    /tmp/tmp01pk0zhp_test.go:26:18: undefined: names

    /tmp/tmp01pk0zhp_test.go:28:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075218
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := []string{}\n    if len(arr) == 0 {\n      \
    \  return result\n    }\n    max := 9\n    min := 1\n    for _, v := range arr\
    \ {\n        if v < min {\n            min = v\n        }\n        if v > max\
    \ {\n            max = v\n        }\n    }\n    for _, v := range arr {\n    \
    \    if v >= min && v <= max {\n            result = append(result, fmt.Sprintf(\"\
    %v\", v))\n        }\n    }\n    for _, v := range result {\n        result[len(result)-1]\
    \ = result[len(result)-1][0:len(result[len(result)-1])-1] + map[int]string{\n\
    \            1: \"One\",\n            2: \"Two\",\n            3: \"Three\",\n\
    \            4: \"Four\",\n            5: \"Five\",\n            6: \"Six\",\n\
    \            7: \"Seven\",\n            8: \"Eight\",\n            9: \"Nine\"\
    ,\n        }[v]\n    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxs3yxp_7_test.go:51:11: cannot use v (variable of type string) as type
    int in map index

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075218
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    i := 0\n    for\
    \ _, v := range arr {\n        if v < 1 || v > 9 {\n            continue\n   \
    \     }\n        result[i] = fmt.Sprintf(\"%v\", v)\n        i++\n    }\n    for\
    \ i := 0; i < len(result); i++ {\n        result[i] = \"One\"\n    }\n    return\
    \ result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmprm0172jh_test.go:53: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[One One One One One One One One]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmprm0172jh_test.go:53: expected '[One]', got '[One One One]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmprm0172jh_test.go:53:\
    \ expected '[Three Two One]', got '[One One One One]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmprm0172jh_test.go:53: expected '[Nine Eight Four]', got '[One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075209
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    for i := range arr\
    \ {\n        arr[i] = arr[i]\n    }\n    sort.Ints(arr)\n    arr[len(arr)-1]--\n\
    \    reverse(arr)\n    arr := make([]string, len(arr))\n    for i := range arr\
    \ {\n        arr[i] = \"One\"\n        if arr[i] > 9 {\n            arr[i] = fmt.Sprintf(\"\
    %v\", arr[i]-10)\n        }\n    }\n    return arr\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv79volvv_test.go:21:9: no new variables on left side of :=

    /tmp/tmpv79volvv_test.go:25:5: undefined: sort

    /tmp/tmpv79volvv_test.go:27:5: undefined: reverse

    /tmp/tmpv79volvv_test.go:28:9: no new variables on left side of :=

    /tmp/tmpv79volvv_test.go:28:12: cannot use make([]string, len(arr)) (value of
    type []string) as type []int in assignment

    /tmp/tmpv79volvv_test.go:30:18: cannot use "One" (untyped string constant) as
    int value in assignment

    /tmp/tmpv79volvv_test.go:32:22: cannot use fmt.Sprintf("%v", arr[i] - 10) (value
    of type string) as type int in assignment

    /tmp/tmpv79volvv_test.go:35:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075218
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    for i := range arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n\
    \            arr3[i] = arr[i]\n        } else {\n            arr3[i] = -1\n  \
    \      }\n    }\n    sort.Ints(arr3)\n    for i := range arr3 {\n        if arr3[i]\
    \ >= 1 && arr3[i] <= 9 {\n            arr2[i] = fmt.Sprintf(\"%s\", arr3[i])\n\
    \        } else {\n            arr2[i] = \"One\"\n        }\n    }\n    return\
    \ arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_dlpbyuw_test.go:30:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075218
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    for i := range arr\
    \ {\n        arr[i] = arr[i]\n    }\n    sort.Sort(arr)\n    reverse(arr)\n  \
    \  arr := make([]string, len(arr))\n    for i := range arr {\n        arr[i] =\
    \ map[int]string{\n            1: \"One\",\n            2: \"Two\",\n        \
    \    3: \"Three\",\n            4: \"Four\",\n            5: \"Five\",\n     \
    \       6: \"Six\",\n            7: \"Seven\",\n            8: \"Eight\",\n  \
    \          9: \"Nine\",\n        }[arr[i]]\n    }\n    return arr\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp2f08rf1a_test.go:21:9:\
    \ no new variables on left side of :=\n/tmp/tmp2f08rf1a_test.go:25:5: undefined:\
    \ sort\n/tmp/tmp2f08rf1a_test.go:26:5: undefined: reverse\n/tmp/tmp2f08rf1a_test.go:27:9:\
    \ no new variables on left side of :=\n/tmp/tmp2f08rf1a_test.go:27:12: cannot\
    \ use make([]string, len(arr)) (value of type []string) as type []int in assignment\n\
    /tmp/tmp2f08rf1a_test.go:29:18: cannot use map[int]string{\u2026}[arr[i]] (map\
    \ index expression of type string) as type int in assignment\n/tmp/tmp2f08rf1a_test.go:41:12:\
    \ cannot use arr (variable of type []int) as type []string in return statement\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return nil\n    }\n    arr2\
    \ := make([]string, len(arr))\n    arr2 := append(arr2, fmt.Sprintf(\"One\"))\n\
    \    arr2 := append(arr2, fmt.Sprintf(\"Two\"))\n    arr2 := append(arr2, fmt.Sprintf(\"\
    Three\"))\n    arr2 := append(arr2, fmt.Sprintf(\"Four\"))\n    arr2 := append(arr2,\
    \ fmt.Sprintf(\"Five\"))\n    arr2 := append(arr2, fmt.Sprintf(\"Six\"))\n   \
    \ arr2 := append(arr2, fmt.Sprintf(\"Seven\"))\n    arr2 := append(arr2, fmt.Sprintf(\"\
    Eight\"))\n    arr2 := append(arr2, fmt.Sprintf(\"Nine\"))\n    arr2 := append(arr2,\
    \ fmt.Sprintf(\"Ten\"))\n    arr2 := append(arr2, fmt.Sprintf(\"Eleven\"))\n \
    \   arr2 := append(arr2, fmt.Sprintf(\"Twelve\"))\n    arr2 := append(arr2, fmt.Sprintf(\"\
    Thirteen\"))\n    arr2 := append(arr2, fmt.Sprintf(\"Fourteen\"))\n    arr2 :=\
    \ append(arr2, fmt.Sprintf(\"Fifteen\"))\n    arr2 := append(arr2, fmt.Sprintf(\"\
    Sixteen\"))\n    arr2 := append(arr2, fmt.Sprintf(\"Seventeen\"))\n    arr2 :=\
    \ append(arr2, fmt.Sprintf(\"Eighteen\"))\n    arr2 := append(arr2, fmt.Sprintf(\"\
    Nineteen\"))\n    arr2 := append(arr2, fmt.Sprintf(\"Twenty\"))\n    arr2 := append(arr2,\
    \ fmt.Sprintf(\"Twenty One\"))\n    arr2 := append(arr2, fmt.Sprintf(\"Twenty\
    \ Two\"))\n    arr2 := append(arr2, fmt.Sprintf(\"Twenty Three\"))\n    arr2 :=\
    \ append(arr2, fmt.Sprintf(\"Twenty Four\"))\n    arr2 := append(arr2, fmt.Sprintf(\"\
    Twenty Five\"))\n    arr2 := append(arr2, fmt.Sprintf(\"Twenty Six\"))\n    arr2\
    \ := append(arr2, fmt.Sprintf(\"Twenty Seven\"))\n    arr2 := append(arr2, fmt.Sprintf(\"\
    Twenty Eight\"))\n    arr2 := append(arr2, fmt.Sprintf(\"Twenty Nine\"))\n   \
    \ arr2 := append(arr2, fmt.Sprintf(\"Thirty\"))\n    arr2 := append(arr2, fmt.Sprintf(\"\
    Thirty One\"))\n    arr2 := append(arr2, fmt.Sprintf(\"Thirty Two\"))\n    arr2\
    \ := append(arr2, fmt.Sprintf(\"Thirty Three\"))\n\nfunc TestBy_Length(t *testing.T)\
    \ {\n  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp577811sj_test.go:59:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075218
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            result[i] = fmt.Sprintf(\"\
    %s\", map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"\
    Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}[arr[i]])\n      \
    \  } else {\n            result[i] = \"\"\n        }\n    }\n    return result\n\
    }\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmpuuysuuvo_test.go:49: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[Two One One Four Five Eight Two Three]'\n    --- FAIL:\
    \ TestBy_Length/test_num__2 (0.00s)\n        tmpuuysuuvo_test.go:49: expected\
    \ '[One]', got '[One  ]'\n    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n  \
    \      tmpuuysuuvo_test.go:49: expected '[Three Two One]', got '[One  Three Two]'\n\
    \    --- FAIL: TestBy_Length/test_num__4 (0.00s)\n        tmpuuysuuvo_test.go:49:\
    \ expected '[Nine Eight Four]', got '[Nine Four Eight]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    copy(arr, arr)\n  \
    \  sort.Sort(sort.Reverse(arr))\n    arr := arr[:len(arr)/2]\n    arr[len(arr)/2:]\
    \ = arr[:len(arr)/2]\n    arr := append(arr, 9...)\n    arr := append(arr, 1...)\n\
    \    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\n    arr := append(arr, arr...)\n  \
    \  arr := append(arr, arr...)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ arr...)\n    arr := append(arr, arr...)\nfunc TestBy_Length(t *testing.T) {\n\
    \  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb4lipiqh_test.go:26:27: expected selector or type assertion, found ''.''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075218
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return nil\n    }\n    sort.Ints(arr)\n\
    \    arr := arr[:len(arr)-1]\n    arr := append([]string{\"One\"}, arr...)\n \
    \   arr := append([]string{\"Two\"}, arr...)\n    arr := append([]string{\"Three\"\
    }, arr...)\n    arr := append([]string{\"Four\"}, arr...)\n    arr := append([]string{\"\
    Five\"}, arr...)\n    arr := append([]string{\"Six\"}, arr...)\n    arr := append([]string{\"\
    Seven\"}, arr...)\n    arr := append([]string{\"Eight\"}, arr...)\n    arr :=\
    \ append([]string{\"Nine\"}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    return arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmplseb71fs_test.go:24:5:\
    \ undefined: sort\n/tmp/tmplseb71fs_test.go:25:9: no new variables on left side\
    \ of :=\n/tmp/tmplseb71fs_test.go:26:9: no new variables on left side of :=\n\
    /tmp/tmplseb71fs_test.go:26:12: cannot use append([]string{\u2026}, arr...) (value\
    \ of type []string) as type []int in assignment\n/tmp/tmplseb71fs_test.go:26:36:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmplseb71fs_test.go:27:9: no new variables on left side of :=\n/tmp/tmplseb71fs_test.go:27:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmplseb71fs_test.go:27:36: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmplseb71fs_test.go:28:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmplseb71fs_test.go:28:38: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmplseb71fs_test.go:28:12:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    arr4 := make([]int, len(arr))\n    arr5 := make([]int, len(arr))\n\
    \    arr6 := make([]int, len(arr))\n    arr7 := make([]int, len(arr))\n    arr8\
    \ := make([]int, len(arr))\n    arr9 := make([]int, len(arr))\n    arr10 := make([]int,\
    \ len(arr))\n    arr11 := make([]int, len(arr))\n    arr12 := make([]int, len(arr))\n\
    \    arr13 := make([]int, len(arr))\n    arr14 := make([]int, len(arr))\n    arr15\
    \ := make([]int, len(arr))\n    arr16 := make([]int, len(arr))\n    arr17 := make([]int,\
    \ len(arr))\n    arr18 := make([]int, len(arr))\n    arr19 := make([]int, len(arr))\n\
    \    arr20 := make([]int, len(arr))\n    arr21 := make([]int, len(arr))\n    arr22\
    \ := make([]int, len(arr))\n    arr23 := make([]int, len(arr))\n    arr24 := make([]int,\
    \ len(arr))\n    arr25 := make([]int, len(arr))\n    arr26 := make([]int, len(arr))\n\
    \    arr27 := make([]int, len(arr))\n    arr28 := make([]int, len(arr))\n    arr29\
    \ := make([]int, len(arr))\n    arr30 := make([]int, len(arr))\n    arr31 := make([]int,\
    \ len(arr))\n    arr32 := make([]int, len(arr))\n    arr33 := make([]int, len(arr))\n\
    \    arr34 := make([]int, len(arr))\n    arr35 := make([]int, len(arr))\n    arr36\
    \ := make([]int, len(arr))\n    arr37 := make([]int, len(arr))\n    arr38 := make([]int,\
    \ len(arr))\n    arr39 := make([]int, len(arr))\n    arr40 := make([]int, len(arr))\n\
    \    arr41 := make([]int, len(arr))\n    arr42 := make([]int, len(arr))\n    arr43\
    \ := make([]int, len(arr))\n    arr\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmplbstdx5l_test.go:64:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075218
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr\
    \ := append([]string{\"One\"}, arr...)\n    arr := append([]string{\"Two\"}, arr...)\n\
    \    arr := append([]string{\"Three\"}, arr...)\n    arr := append([]string{\"\
    Four\"}, arr...)\n    arr := append([]string{\"Five\"}, arr...)\n    arr := append([]string{\"\
    Six\"}, arr...)\n    arr := append([]string{\"Seven\"}, arr...)\n    arr := append([]string{\"\
    Eight\"}, arr...)\n    arr := append([]string{\"Nine\"}, arr...)\n    return arr\n\
    }\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpufxui3fi_test.go:21:5:\
    \ undefined: sort\n/tmp/tmpufxui3fi_test.go:22:9: no new variables on left side\
    \ of :=\n/tmp/tmpufxui3fi_test.go:23:9: no new variables on left side of :=\n\
    /tmp/tmpufxui3fi_test.go:23:12: cannot use append([]string{\u2026}, arr...) (value\
    \ of type []string) as type []int in assignment\n/tmp/tmpufxui3fi_test.go:23:36:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmpufxui3fi_test.go:24:9: no new variables on left side of :=\n/tmp/tmpufxui3fi_test.go:24:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpufxui3fi_test.go:24:36: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpufxui3fi_test.go:25:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpufxui3fi_test.go:25:38: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpufxui3fi_test.go:25:12:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n\
    \    arr[len(arr)-1]--\n    arr := append([]int{}, arr...)\n    for i := 0; i\
    \ < len(arr); i++ {\n        arr[i] = name[arr[i]]\n    }\n    return arr\n}\n\
    \nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgc3b7woy_test.go:21:9: no new variables on left side of :=

    /tmp/tmpgc3b7woy_test.go:22:5: undefined: sort

    /tmp/tmpgc3b7woy_test.go:24:9: no new variables on left side of :=

    /tmp/tmpgc3b7woy_test.go:26:18: undefined: name

    /tmp/tmpgc3b7woy_test.go:28:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            result[i] = fmt.Sprintf(\"\
    %v\", arr[i])\n        } else {\n            result[i] = \"\"\n        }\n   \
    \ }\n    for i := range result {\n        if result[i] == \"\" {\n           \
    \ result[i] = \"One\"\n        }\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmpqdtaxmam_test.go:54: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 3]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmpqdtaxmam_test.go:54: expected '[One]', got '[1 One One]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmpqdtaxmam_test.go:54:\
    \ expected '[Three Two One]', got '[1 One 3 2]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmpqdtaxmam_test.go:54: expected '[Nine Eight Four]', got '[9\
    \ 4 8]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    for i, v := range arr {\n        if v < 1 || v > 9 {\n      \
    \      continue\n        }\n        arr3[i] = v\n    }\n    sort.Ints(arr3)\n\
    \    for i, v := range arr3 {\n        arr2[i] = names[v]\n    }\n    for i, v\
    \ := range arr2 {\n        arr2[i] = fmt.Sprintf(\"%v\", v)\n    }\n    return\
    \ arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfri5kt90_test.go:29:5: undefined: sort

    /tmp/tmpfri5kt90_test.go:31:19: undefined: names

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    for i := 0; i < len(arr); i++ {\n        if arr[i] >= 1 && arr[i]\
    \ <= 9 {\n            arr3[i] = arr[i]\n        } else {\n            arr3[i]\
    \ = -1\n        }\n    }\n    sort.Ints(arr3)\n    for i := 0; i < len(arr); i++\
    \ {\n        if arr3[i] >= 1 && arr3[i] <= 9 {\n            arr2[i] = fmt.Sprintf(\"\
    %s\", arr3[i])\n        } else {\n            arr2[i] = \"\"\n        }\n    }\n\
    \    for i := 0; i < len(arr); i++ {\n        if arr2[i] == \"\" {\n         \
    \   arr2[i] = \"One\"\n        }\n    }\n    return arr2\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpl19_d37q_test.go:30:5: undefined: sort

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    copy(arr, arr)\n  \
    \  sort.Sort(sort.Reverse(sort.IntSlice(arr)))\n    arr := arr[:len(arr)-1]\n\
    \    arr := append(arr, 9)\n    arr := append(arr, arr...)\n    arr := append(arr,\
    \ []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n\
    \    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr,\
    \ []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n\
    \    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr,\
    \ []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n\
    \    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr,\
    \ []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n\
    \    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr,\
    \ []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1,\
    \ 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5,\
    \ 6, 7, 8, 9}...)\n    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n\
    \    arr := append(arr, []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr,\
    \ []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}...)\n    arr := append(arr, []int{\nfunc\
    \ TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl9v2d6gt_test.go:54:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075219
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr\
    \ := append([]string{\"One\"}, arr...)\n    arr := append([]string{\"Two\"}, arr...)\n\
    \    arr := append([]string{\"Three\"}, arr...)\n    arr := append([]string{\"\
    Four\"}, arr...)\n    arr := append([]string{\"Five\"}, arr...)\n    arr := append([]string{\"\
    Six\"}, arr...)\n    arr := append([]string{\"Seven\"}, arr...)\n    arr := append([]string{\"\
    Eight\"}, arr...)\n    arr := append([]string{\"Nine\"}, arr...)\n    return arr\n\
    }\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpufxui3fi_test.go:21:5:\
    \ undefined: sort\n/tmp/tmpufxui3fi_test.go:22:9: no new variables on left side\
    \ of :=\n/tmp/tmpufxui3fi_test.go:23:9: no new variables on left side of :=\n\
    /tmp/tmpufxui3fi_test.go:23:12: cannot use append([]string{\u2026}, arr...) (value\
    \ of type []string) as type []int in assignment\n/tmp/tmpufxui3fi_test.go:23:36:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmpufxui3fi_test.go:24:9: no new variables on left side of :=\n/tmp/tmpufxui3fi_test.go:24:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpufxui3fi_test.go:24:36: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpufxui3fi_test.go:25:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpufxui3fi_test.go:25:38: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpufxui3fi_test.go:25:12:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr\
    \ := append([]string{\"One\"}, arr...)\n    arr := append([]string{\"Two\"}, arr...)\n\
    \    arr := append([]string{\"Three\"}, arr...)\n    arr := append([]string{\"\
    Four\"}, arr...)\n    arr := append([]string{\"Five\"}, arr...)\n    arr := append([]string{\"\
    Six\"}, arr...)\n    arr := append([]string{\"Seven\"}, arr...)\n    arr := append([]string{\"\
    Eight\"}, arr...)\n    arr := append([]string{\"Nine\"}, arr...)\n    arr := append([]string{},\
    \ arr...)\n    return arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp0l67i2om_test.go:21:5:\
    \ undefined: sort\n/tmp/tmp0l67i2om_test.go:22:9: no new variables on left side\
    \ of :=\n/tmp/tmp0l67i2om_test.go:23:9: no new variables on left side of :=\n\
    /tmp/tmp0l67i2om_test.go:23:12: cannot use append([]string{\u2026}, arr...) (value\
    \ of type []string) as type []int in assignment\n/tmp/tmp0l67i2om_test.go:23:36:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmp0l67i2om_test.go:24:9: no new variables on left side of :=\n/tmp/tmp0l67i2om_test.go:24:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmp0l67i2om_test.go:24:36: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmp0l67i2om_test.go:25:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmp0l67i2om_test.go:25:38: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmp0l67i2om_test.go:25:12:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075209
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]int, len(arr))\n    for i := range arr2\
    \ {\n        if arr[i] > 9 {\n            arr2[i] = arr[i]\n        } else {\n\
    \            arr2[i] = arr[i] + 1\n        }\n    }\n    sort.Ints(arr2)\n   \
    \ arr3 = make([]string, len(arr2))\n    for i := range arr2 {\n        if arr2[i]\
    \ > 9 {\n            arr3[i] = \"Nine\"\n        } else {\n            arr3[i]\
    \ = \"One\"\n        }\n    }\n    for i := range arr2 {\n        if arr2[i] >\
    \ 9 {\n            arr3[len(arr3)-i-1] = arr3[len(arr3)-i-1] + \"s\"\n       \
    \ }\n    }\n    return arr3\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdi0ddqwt_test.go:29:5: undefined: sort

    /tmp/tmpdi0ddqwt_test.go:30:5: undefined: arr3

    /tmp/tmpdi0ddqwt_test.go:33:13: undefined: arr3

    /tmp/tmpdi0ddqwt_test.go:35:13: undefined: arr3

    /tmp/tmpdi0ddqwt_test.go:40:35: undefined: arr3

    /tmp/tmpdi0ddqwt_test.go:43:12: undefined: arr3

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    for i := range arr\
    \ {\n        arr[i] = arr[i]\n    }\n    sort.Sort(sort.Reverse(arr))\n    arr\
    \ := reverse(arr)\n    arr := replaceDigit(arr)\n    return arr\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8_lfnxt1_test.go:21:9: no new variables on left side of :=

    /tmp/tmp8_lfnxt1_test.go:25:5: undefined: sort

    /tmp/tmp8_lfnxt1_test.go:26:9: no new variables on left side of :=

    /tmp/tmp8_lfnxt1_test.go:26:12: undefined: reverse

    /tmp/tmp8_lfnxt1_test.go:27:9: no new variables on left side of :=

    /tmp/tmp8_lfnxt1_test.go:27:12: undefined: replaceDigit

    /tmp/tmp8_lfnxt1_test.go:28:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := reverse(arr)\n    arr := map[int]string{1:\
    \ \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7:\
    \ \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    arr := make([]string, 0, len(arr))\n\
    \    for _, v := range arr {\n        arr = append(arr, arr[v])\n    }\n    return\
    \ arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpj1qco1pg_test.go:21:5:\
    \ undefined: sort\n/tmp/tmpj1qco1pg_test.go:22:9: no new variables on left side\
    \ of :=\n/tmp/tmpj1qco1pg_test.go:22:12: undefined: reverse\n/tmp/tmpj1qco1pg_test.go:23:9:\
    \ no new variables on left side of :=\n/tmp/tmpj1qco1pg_test.go:23:12: cannot\
    \ use map[int]string{\u2026} (value of type map[int]string) as type []int in assignment\n\
    /tmp/tmpj1qco1pg_test.go:24:9: no new variables on left side of :=\n/tmp/tmpj1qco1pg_test.go:24:12:\
    \ cannot use make([]string, 0, len(arr)) (value of type []string) as type []int\
    \ in assignment\n/tmp/tmpj1qco1pg_test.go:28:12: cannot use arr (variable of type\
    \ []int) as type []string in return statement\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \n    arr2 := make([]int, len(arr))\n    for i := range arr2 {\n        if arr[i]\
    \ >= 1 && arr[i] <= 9 {\n            arr2[i] = arr[i]\n        } else {\n    \
    \        arr2[i] = -1\n        }\n    }\n\n    sort.Ints(arr2)\n    reverse(arr2)\n\
    \n    result := make([]string, len(arr))\n    for i := range arr2 {\n        if\
    \ arr2[i] != -1 {\n            result[i] = names[arr2[i]]\n        }\n    }\n\n\
    \    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmparctz0qd_test.go:34:5: undefined: sort

    /tmp/tmparctz0qd_test.go:35:5: undefined: reverse

    /tmp/tmparctz0qd_test.go:40:25: undefined: names

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    for i := range\
    \ arr2 {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            arr2[i] = fmt.Sprintf(\"\
    %s\", map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"\
    Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}[arr[i]])\n      \
    \  } else {\n            arr2[i] = \"\"\n        }\n    }\n    return arr2\n}\n\
    \nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmp15hj6apk_test.go:49: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[Two One One Four Five Eight Two Three]'\n    --- FAIL:\
    \ TestBy_Length/test_num__2 (0.00s)\n        tmp15hj6apk_test.go:49: expected\
    \ '[One]', got '[One  ]'\n    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n  \
    \      tmp15hj6apk_test.go:49: expected '[Three Two One]', got '[One  Three Two]'\n\
    \    --- FAIL: TestBy_Length/test_num__4 (0.00s)\n        tmp15hj6apk_test.go:49:\
    \ expected '[Nine Eight Four]', got '[Nine Four Eight]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075216
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    arr3 := make([]int,\
    \ len(arr))\n    for i, v := range arr {\n        if v < 1 || v > 9 {\n      \
    \      continue\n        }\n        arr2[i] = \"One\"\n        arr3[i] = v\n \
    \   }\n    sort.Ints(arr3)\n    arr4 = reverse(arr3)\n    for i, v := range arr4\
    \ {\n        arr2[i] = fmt.Sprintf(\"%v\", v)\n    }\n    return arr2\n}\n\nfunc\
    \ TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdez4nmb_test.go:30:5: undefined: sort

    /tmp/tmpvdez4nmb_test.go:31:5: undefined: arr4

    /tmp/tmpvdez4nmb_test.go:31:12: undefined: reverse

    /tmp/tmpvdez4nmb_test.go:32:23: undefined: arr4

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    for i := 0; i <\
    \ len(arr); i++ {\n        if arr[i] < 1 || arr[i] > 9 {\n            continue\n\
    \        }\n        arr2[len(arr2)-i-1] = names[arr[i]]\n    }\n    return arr2\n\
    }\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbs0ve2tx_test.go:26:31: undefined: names

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr := reverse(arr)\n    arr := map[int]string{1: \"One\", 2: \"Two\", 3:\
    \ \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\"\
    , 9: \"Nine\"}\n    arr := map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\"\
    , 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"\
    }\n    arr := map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\"\
    , 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    arr :=\
    \ map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\"\
    , 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    arr := map[int]string{1:\
    \ \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7:\
    \ \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    arr := map[int]string{1: \"One\"\
    , 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\"\
    , 8: \"Eight\", 9: \"Nine\"}\n    arr := map[int]string{1: \"One\", 2: \"Two\"\
    , 3: \"Three\", 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\"\
    , 9: \"Nine\"}\n    arr := map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\"\
    , 4: \"Four\", 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"\
    }\n    arr := map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\"\
    , 5: \"Five\", 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    arr :=\
    \ map[int]string{1: \"One\", 2: \"Two\", 3: \"Three\", 4: \"Four\", 5: \"Five\"\
    , 6: \"Six\", 7: \"Seven\", 8: \"Eight\", 9: \"Nine\"}\n    arr := map[int]string{1:\
    \ \"One\", 2: \"Two\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp72w72ogb_test.go:35:40: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := []string{}\n    for _, v := range arr {\n \
    \       if v >= 1 && v <= 9 {\n            result = append(result, fmt.Sprintf(\"\
    %v\", v))\n        } else {\n            result = append(result, \"One\")\n  \
    \      }\n    }\n    for _, v := range arr {\n        if v >= 10 && v <= 99 {\n\
    \            result = append(result, fmt.Sprintf(\"%v\", v))\n        } else {\n\
    \            result = append(result, \"Two\")\n        }\n    }\n    for _, v\
    \ := range arr {\n        if v >= 100 && v <= 999 {\n            result = append(result,\
    \ fmt.Sprintf(\"%v\", v))\n        } else {\n            result = append(result,\
    \ \"Three\")\n        }\n    }\n    for _, v := range arr {\n        if v >= 1000\
    \ && v <= 9999 {\n            result = append(result, fmt.Sprintf(\"%v\", v))\n\
    \        } else {\n            result = append(result, \"Four\")\n        }\n\
    \    }\n    for _, v := range arr {\n        if v >= 10000 && v <= 99999 {\n \
    \           result = append(result, fmt.Sprintf(\"%v\", v))\n        } else {\n\
    \            result = append(result, \"Five\")\n        }\n    }\n    for _, v\
    \ := range arr {\n        if v >= 100000 && v <= 999999 {\n            result\
    \ = append(result, fmt.Sprintf(\"%v\", v))\n        } else {\n            result\
    \ = append(result, \"Six\")\n        }\n    }\n    for _, v := range arr {\n \
    \       if v >= 1000000 && v <= 9999999 {\n            result = append(result,\
    \ fmt.Sprintf(\"%v\", v))\n        } else {\n            result = append(result,\
    \ \"Seven\")\n        }\n    }\n    for _, v := range arr {\n        if v >= 10000000\
    \ && v <= 99999999 {\n            result = append(result, fmt.Sprintf(\"%v\",\
    \ v))\n        } else {\n            result = append(result, \"Eight\")\n    \
    \    }\n    }\n    for _, v := range arr {\n        if v >= 100000000 && v <=\
    \ 999999999 {\n            result = append(result, fmt.Sprintf(\"%v\", v))\n \
    \       } else {\n            result = append(result, \"Nine\")\n        }\n \
    \   }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmpr45wszlu_test.go:105: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 3 Two Two Two Two Two Two Two Two Three Three\
    \ Three Three Three Three Three Three Four Four Four Four Four Four Four Four\
    \ Five Five Five Five Five Five Five Five Six Six Six Six Six Six Six Six Seven\
    \ Seven Seven Seven Seven Seven Seven Seven Eight Eight Eight Eight Eight Eight\
    \ Eight Eight Nine Nine Nine Nine Nine Nine Nine Nine]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmpr45wszlu_test.go:105: expected '[One]', got '[1 One One\
    \ Two Two 55 Three Three Three Four Four Four Five Five Five Six Six Six Seven\
    \ Seven Seven Eight Eight Eight Nine Nine Nine]'\n    --- FAIL: TestBy_Length/test_num__3\
    \ (0.00s)\n        tmpr45wszlu_test.go:105: expected '[Three Two One]', got '[1\
    \ One 3 2 Two Two Two Two Three Three Three Three Four Four Four Four Five Five\
    \ Five Five Six Six Six Six Seven Seven Seven Seven Eight Eight Eight Eight Nine\
    \ Nine Nine Nine]'\n    --- FAIL: TestBy_Length/test_num__4 (0.00s)\n        tmpr45wszlu_test.go:105:\
    \ expected '[Nine Eight Four]', got '[9 4 8 Two Two Two Three Three Three Four\
    \ Four Four Five Five Five Six Six Six Seven Seven Seven Eight Eight Eight Nine\
    \ Nine Nine]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    for _, v := range arr {\n  \
    \      if v >= 1 && v <= 9 {\n            result = append(result, fmt.Sprintf(\"\
    %v\", v))\n        } else {\n            result = append(result, \"One\")\n  \
    \      }\n    }\n    for i := len(result) - 1; i >= 0; i-- {\n        result[i]\
    \ = \"One\"\n    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n\
    \  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmpr298vivl_test.go:52: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[One One One One One One One One]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmpr298vivl_test.go:52: expected '[One]', got '[One One One]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmpr298vivl_test.go:52:\
    \ expected '[Three Two One]', got '[One One One One]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmpr298vivl_test.go:52: expected '[Nine Eight Four]', got '[One\
    \ One One]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr := arr[:len(arr)-1]\n    arr := append([]string{\"One\", \"Two\", \"\
    Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string{}, arr...)\n\
    \    arr := append([]string{}, arr...)\n    arr := append([]string\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp__mjmhz5_test.go:67:27: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr := append([]string{\"\
    One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\",\
    \ \"Nine\"}, arr...)\n    arr := reverse(arr)\n    for i := range arr {\n    \
    \    arr[i] = fmt.Sprintf(\"%v\", arr[i])\n    }\n    return arr\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmp8cg38eqt_test.go:24:5:\
    \ undefined: sort\n/tmp/tmp8cg38eqt_test.go:25:9: no new variables on left side\
    \ of :=\n/tmp/tmp8cg38eqt_test.go:26:9: no new variables on left side of :=\n\
    /tmp/tmp8cg38eqt_test.go:26:12: cannot use append([]string{\u2026}, arr...) (value\
    \ of type []string) as type []int in assignment\n/tmp/tmp8cg38eqt_test.go:26:101:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmp8cg38eqt_test.go:27:9: no new variables on left side of :=\n/tmp/tmp8cg38eqt_test.go:27:12:\
    \ undefined: reverse\n/tmp/tmp8cg38eqt_test.go:29:18: cannot use fmt.Sprintf(\"\
    %v\", arr[i]) (value of type string) as type int in assignment\n/tmp/tmp8cg38eqt_test.go:31:12:\
    \ cannot use arr (variable of type []int) as type []string in return statement\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    for i := range\
    \ arr {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            j := int(arr[i])\
    \ - 1\n            result[i] = names[j]\n        } else {\n            result[i]\
    \ = fmt.Sprintf(\"%d\", arr[i])\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpix489b6j_test.go:25:25: undefined: names

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr2 := make([]string, len(arr))\n    for i := range\
    \ arr2 {\n        arr2[i] = \"One\"\n    }\n    for i := range arr {\n       \
    \ if arr[i] >= 1 && arr[i] <= 9 {\n            arr2[arr[i]-1] = fmt.Sprintf(\"\
    Two\")\n        }\n        if arr[i] >= 10 && arr[i] <= 99 {\n            arr2[arr[i]-10]\
    \ = fmt.Sprintf(\"Three\")\n        }\n        if arr[i] >= 100 && arr[i] <= 999\
    \ {\n            arr2[arr[i]-100] = fmt.Sprintf(\"Four\")\n        }\n       \
    \ if arr[i] >= 1000 && arr[i] <= 9999 {\n            arr2[arr[i]-1000] = fmt.Sprintf(\"\
    Five\")\n        }\n        if arr[i] >= 10000 && arr[i] <= 99999 {\n        \
    \    arr2[arr[i]-10000] = fmt.Sprintf(\"Six\")\n        }\n        if arr[i] >=\
    \ 100000 && arr[i] <= 999999 {\n            arr2[arr[i]-100000] = fmt.Sprintf(\"\
    Seven\")\n        }\n        if arr[i] >= 1000000 && arr[i] <= 999999999 {\n \
    \           arr2[arr[i]-1000000] = fmt.Sprintf(\"Eight\")\n        }\n       \
    \ if arr[i] >= 10000000 && arr[i] <= 99999999 {\n            arr2[arr[i]-10000000]\
    \ = fmt.Sprintf(\"Nine\")\n        }\n    }\n    return arr2\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\npanic: runtime error: index out of range\
    \ [45] with length 3 [recovered]\n\tpanic: runtime error: index out of range [45]\
    \ with length 3\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.by_length({0xc0000f5de0, 0x3, 0x0?})\n\t\
    /tmp/tmpdtxjwg3g_test.go:30 +0x4e7\ncommand-line-arguments_test.TestBy_Length(0x0?)\n\
    \t/tmp/tmpdtxjwg3g_test.go:63 +0x16a\ntesting.tRunner(0xc0001a0340, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr\
    \ := append([]string{\"One\"}, arr...)\n    arr := append([]string{\"Two\"}, arr...)\n\
    \    arr := append([]string{\"Three\"}, arr...)\n    arr := append([]string{\"\
    Four\"}, arr...)\n    arr := append([]string{\"Five\"}, arr...)\n    arr := append([]string{\"\
    Six\"}, arr...)\n    arr := append([]string{\"Seven\"}, arr...)\n    arr := append([]string{\"\
    Eight\"}, arr...)\n    arr := append([]string{\"Nine\"}, arr...)\n    return arr\n\
    }\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpufxui3fi_test.go:21:5:\
    \ undefined: sort\n/tmp/tmpufxui3fi_test.go:22:9: no new variables on left side\
    \ of :=\n/tmp/tmpufxui3fi_test.go:23:9: no new variables on left side of :=\n\
    /tmp/tmpufxui3fi_test.go:23:12: cannot use append([]string{\u2026}, arr...) (value\
    \ of type []string) as type []int in assignment\n/tmp/tmpufxui3fi_test.go:23:36:\
    \ cannot use arr (variable of type []int) as type []string in argument to append\n\
    /tmp/tmpufxui3fi_test.go:24:9: no new variables on left side of :=\n/tmp/tmpufxui3fi_test.go:24:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpufxui3fi_test.go:24:36: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpufxui3fi_test.go:25:12:\
    \ cannot use append([]string{\u2026}, arr...) (value of type []string) as type\
    \ []int in assignment\n/tmp/tmpufxui3fi_test.go:25:38: cannot use arr (variable\
    \ of type []int) as type []string in argument to append\n/tmp/tmpufxui3fi_test.go:25:12:\
    \ too many errors\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075208
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr\
    \ := append(arr, 9) // Add 9 to the end of the list\n    arr := append(arr, 0)\
    \ // Add 0 to the end of the list\n    arr := append(arr, 1) // Add 1 to the end\
    \ of the list\n    arr := append(arr, 2) // Add 2 to the end of the list\n   \
    \ arr := append(arr, 3) // Add 3 to the end of the list\n    arr := append(arr,\
    \ 4) // Add 4 to the end of the list\n    arr := append(arr, 5) // Add 5 to the\
    \ end of the list\n    arr := append(arr, 6) // Add 6 to the end of the list\n\
    \    arr := append(arr, 7) // Add 7 to the end of the list\n    arr := append(arr,\
    \ 8) // Add 8 to the end of the list\n    arr := append(arr, 9) // Add 9 to the\
    \ end of the list\n    arr := append(arr, 0) // Add 0 to the end of the list\n\
    \    arr := append(arr, 1) // Add 1 to the end of the list\n    arr := append(arr,\
    \ 2) // Add 2 to the end of the list\n    arr := append(arr, 3) // Add 3 to the\
    \ end of the list\n    arr := append(arr, 4) // Add 4 to the end of the list\n\
    \    arr := append(arr, 5) // Add 5 to the end of the list\n    arr := append(arr,\
    \ 6) // Add 6 to the end of the list\n    arr := append(arr, 7) // Add 7 to the\
    \ end of the list\n    arr := append(arr, 8) // Add 8 to the end of the list\n\
    \    arr := append(arr, 9) // Add 9 to the end of the list\n    arr := append(arr,\
    \ 0) // Add 0 to the end of the list\n    arr := append(arr, 1) // Add 1 to the\
    \ end of the list\n    arr := append(arr, 2) // Add 2 to the end of the list\n\
    \    arr := append(arr, 3) // Add 3 to the end of the list\n    arr := append(arr,\
    \ 4) // Add 4 to the end of the list\n    arr := append(arr, 5) // Add 5 to the\
    \ end of the list\n    arr := append(arr, 6) // Add 6 to the end of the list\n\
    \    arr := append(arr, 7) // Add 7 to the end of the list\n    arr := append(arr,\
    \ 8) // Add 8 to the end of the list\n    arr := append(arr, 9) // Add 9 to the\
    \ end of the list\n    arr := append(arr, 0) // Add 0 to the end of the list\n\
    \    arr := append(arr, 1) // Add 1 to the end of the list\n    arr := append(arr,\
    \ 2) // Add 2 to the end of the list\n    arr := append(arr, 3) // Add 3 to the\
    \ end of the list\n    arr := append(\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcjp75ysy_test.go:59:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075220
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    if len(arr) == 0 {\n       \
    \ return result\n    }\n    sort.Ints(arr)\n    for i := 0; i < len(arr); i++\
    \ {\n        if arr[i] >= 1 && arr[i] <= 9 {\n            result := append(result,\
    \ fmt.Sprintf(\"%s\", arr[i]))\n        } else {\n            fmt.Printf(\"[%d]\
    \ %s\\n\", arr[i], arr[i])\n        }\n    }\n    return result\n}\n\nfunc TestBy_Length(t\
    \ *testing.T) {\n  candidate := by_length\n\ttype test struct {\n\t\tactual  \
    \ interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\"\
    , \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual:\
    \ candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6bwr_eiv_test.go:25:5: undefined: sort

    /tmp/tmp6bwr_eiv_test.go:28:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    for i, v := range arr\
    \ {\n        if v < 1 || v > 9 {\n            continue\n        }\n        arr[i]\
    \ = v\n    }\n    sort.Ints(arr)\n    reverse(arr)\n    arr2 := make([]string,\
    \ len(arr))\n    for i, v := range arr {\n        arr2[i] = names[v]\n    }\n\
    \    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy2b3w70f_test.go:21:9: no new variables on left side of :=

    /tmp/tmpy2b3w70f_test.go:28:5: undefined: sort

    /tmp/tmpy2b3w70f_test.go:29:5: undefined: reverse

    /tmp/tmpy2b3w70f_test.go:32:19: undefined: names

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    result := make([]string, len(arr))\n    i := 0\n    for\
    \ _, v := range arr {\n        if v < 1 || v > 9 {\n            continue\n   \
    \     }\n        result[i] = names[v]\n        i++\n    }\n    for i := len(result)\
    \ - 1; i >= 0; i-- {\n        result[i] = result[i] + \"One\"\n    }\n    return\
    \ result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbsjw9lv1_test.go:27:21: undefined: names

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr2 := make([]int, len(arr))\n    for i := range arr2 {\n        if arr[i]\
    \ < 1 || arr[i] > 9 {\n            continue\n        }\n        arr2[i] = arr[i]\n\
    \    }\n    sort.Ints(arr2)\n    arr2 = reverse(arr2)\n    arr2 = replaceDigits(arr2)\n\
    \    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_bohgo21_test.go:31:5: undefined: sort

    /tmp/tmp_bohgo21_test.go:32:12: undefined: reverse

    /tmp/tmp_bohgo21_test.go:33:12: undefined: replaceDigits

    /tmp/tmp_bohgo21_test.go:34:12: cannot use arr2 (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    arr2 := make([]int, len(arr))\n    for i := range arr2 {\n        arr2[i]\
    \ = arr[i]\n    }\n    sort.Ints(arr2)\n    arr2 = reverse(arr2)\n    arr2 = replaceDigits(arr2)\n\
    \    return arr2\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdp3upj9r_test.go:28:5: undefined: sort

    /tmp/tmpdp3upj9r_test.go:29:12: undefined: reverse

    /tmp/tmpdp3upj9r_test.go:30:12: undefined: replaceDigits

    /tmp/tmpdp3upj9r_test.go:31:12: cannot use arr2 (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    if len(arr) == 0 {\n       \
    \ return result\n    }\n    for _, v := range arr {\n        if v < 1 || v > 9\
    \ {\n            continue\n        }\n        result := []string{\"One\", \"Two\"\
    , \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"}\n  \
    \      switch v {\n        case 1:\n            result = append(result, \"One\"\
    )\n        case 2:\n            result = append(result, \"Two\")\n        case\
    \ 3:\n            result = append(result, \"Three\")\n        case 4:\n      \
    \      result = append(result, \"Four\")\n        case 5:\n            result\
    \ = append(result, \"Five\")\n        case 6:\n            result = append(result,\
    \ \"Six\")\n        case 7:\n            result = append(result, \"Seven\")\n\
    \        case 8:\n            result = append(result, \"Eight\")\n        case\
    \ 9:\n            result = append(result, \"Nine\")\n        }\n    }\n    for\
    \ _, v := range result {\n        result = append(result, v)\n    }\n    return\
    \ result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}),\
    \ expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\"\
    , \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmpr3r3oyq2_test.go:74: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[]'\n    --- FAIL: TestBy_Length/test_num__2 (0.00s)\n \
    \       tmpr3r3oyq2_test.go:74: expected '[One]', got '[]'\n    --- FAIL: TestBy_Length/test_num__3\
    \ (0.00s)\n        tmpr3r3oyq2_test.go:74: expected '[Three Two One]', got '[]'\n\
    \    --- FAIL: TestBy_Length/test_num__4 (0.00s)\n        tmpr3r3oyq2_test.go:74:\
    \ expected '[Nine Eight Four]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    for _, v := range arr {\n  \
    \      if v >= 1 && v <= 9 {\n            result = append(result, fmt.Sprintf(\"\
    %v\", v))\n        } else {\n            result = append(result, \"One\")\n  \
    \      }\n    }\n    for _, v := range result {\n        if v == \"One\" {\n \
    \           continue\n        }\n        if v == \"Two\" {\n            result\
    \ = append(result, \"Two\")\n            continue\n        }\n        if v ==\
    \ \"Three\" {\n            result = append(result, \"Three\")\n            continue\n\
    \        }\n        if v == \"Four\" {\n            result = append(result, \"\
    Four\")\n            continue\n        }\n        if v == \"Five\" {\n       \
    \     result = append(result, \"Five\")\n            continue\n        }\n   \
    \     if v == \"Six\" {\n            result = append(result, \"Six\")\n      \
    \      continue\n        }\n        if v == \"Seven\" {\n            result =\
    \ append(result, \"Seven\")\n            continue\n        }\n        if v ==\
    \ \"Eight\" {\n            result = append(result, \"Eight\")\n            continue\n\
    \        }\n        if v == \"Nine\" {\n            result = append(result, \"\
    Nine\")\n            continue\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"\
    Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n\
    \     { actual: candidate([]int{}), expected: []string{} },\n     { actual: candidate([]int{1,\
    \ -1, 55}), expected: []string{\"One\"} },\n     { actual: candidate([]int{1,\
    \ -1, 3, 2}), expected: []string{\"Three\", \"Two\", \"One\"} },\n     { actual:\
    \ candidate([]int{9, 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"\
    } },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num %\
    \ d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestBy_Length (0.00s)\n    --- FAIL: TestBy_Length/test_num__0\
    \ (0.00s)\n        tmpm2pb3ozx_test.go:86: expected '[Eight Five Four Three Two\
    \ Two One One]', got '[2 1 1 4 5 8 2 3]'\n    --- FAIL: TestBy_Length/test_num__2\
    \ (0.00s)\n        tmpm2pb3ozx_test.go:86: expected '[One]', got '[1 One One]'\n\
    \    --- FAIL: TestBy_Length/test_num__3 (0.00s)\n        tmpm2pb3ozx_test.go:86:\
    \ expected '[Three Two One]', got '[1 One 3 2]'\n    --- FAIL: TestBy_Length/test_num__4\
    \ (0.00s)\n        tmpm2pb3ozx_test.go:86: expected '[Nine Eight Four]', got '[9\
    \ 4 8]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    var result []string\n    if len(arr) == 0 {\n       \
    \ return result\n    }\n    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    for\
    \ _, v := range arr {\n        result = append(result, fmt.Sprintf(\"%v\", v))\n\
    \    }\n    return result\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate\
    \ := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnjh_lg4o_test.go:25:5: undefined: sort

    /tmp/tmpnjh_lg4o_test.go:26:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 1
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    if len(arr) == 0 {\n        return []string{}\n    }\n\
    \    sort.Ints(arr)\n    arr := arr[:len(arr)-1]\n    arr := append(arr, \"One\"\
    , \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"\
    )\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr\
    \ := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr,\
    \ \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\"\
    )\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr\
    \ := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr,\
    \ \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\"\
    )\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr\
    \ := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr,\
    \ \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\"\
    )\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr\
    \ := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr,\
    \ \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\"\
    )\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr\
    \ := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr,\
    \ \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\"\
    )\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr\
    \ := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr,\
    \ \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\"\
    )\n    arr := append(arr, \"Zero\")\n    arr := append(arr, \"Zero\")\n    arr\
    \ := append(arr, \"Zero\")\n    arr := \nfunc TestBy_Length(t *testing.T) {\n\
    \  candidate := by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{2,\
    \ 1, 1, 4, 5, 8, 2, 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"\
    Three\", \"Two\", \"Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}),\
    \ expected: []string{} },\n     { actual: candidate([]int{1, -1, 55}), expected:\
    \ []string{\"One\"} },\n     { actual: candidate([]int{1, -1, 3, 2}), expected:\
    \ []string{\"Three\", \"Two\", \"One\"} },\n     { actual: candidate([]int{9,\
    \ 4, 8}), expected: []string{\"Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor\
    \ i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpy17nsbdw_test.go:73:6: expected ''('', found TestBy_Length

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075215
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := append([]int{}, arr...)\n    sort.Ints(arr)\n\
    \    arr := arr[:len(arr)/2]\n    for i := 0; i < len(arr); i++ {\n        if\
    \ arr[i] > 9 {\n            arr[i] = arr[i]%10\n            arr[i] = \"Nine\"\n\
    \        } else {\n            arr[i] = \"One\"\n        }\n    }\n    return\
    \ arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate := by_length\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2, 3}), expected:\
    \ []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\"\
    , \"One\"} },\n     { actual: candidate([]int{}), expected: []string{} },\n  \
    \   { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"} },\n  \
    \   { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\", \"\
    Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpynw9gc44_test.go:21:9: no new variables on left side of :=

    /tmp/tmpynw9gc44_test.go:22:5: undefined: sort

    /tmp/tmpynw9gc44_test.go:23:9: no new variables on left side of :=

    /tmp/tmpynw9gc44_test.go:27:22: cannot use "Nine" (untyped string constant) as
    int value in assignment

    /tmp/tmpynw9gc44_test.go:29:22: cannot use "One" (untyped string constant) as
    int value in assignment

    /tmp/tmpynw9gc44_test.go:32:12: cannot use arr (variable of type []int) as type
    []string in return statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
- exit_code: 2
  program: "package by_length_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n\
    // Given a list of integers, sort the integers that are between 1 and 9 inclusive,\n\
    // reverse the resulting list, and then replace each digit by its corresponding\
    \ name from\n// \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\"\
    , \"Eight\", \"Nine\".\n// For example:\n// >>> by_length([]int{2, 1, 1, 4, 5,\
    \ 8, 2, 3})\n// []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"}\n// If the list is empty, return an empty list:\n// >>>\
    \ by_length([]string{})\n// PATCH list\n// If the list has any strange number\
    \ ignore it:\n// >>> by_length([]int{1, -1, 55})\n// []string{\"One\"}\nfunc by_length(arr\
    \ []int) []string {\n    arr := make([]int, len(arr))\n    for i := range arr\
    \ {\n        arr[i] = arr[i]\n    }\n    sort.Ints(arr)\n    arr[len(arr)-1] =\
    \ arr[len(arr)-1] - 1\n    reverse(arr)\n    arr := make([]string, len(arr))\n\
    \    for i := range arr {\n        arr[i] = map[int]string{\n            1: \"\
    One\",\n            2: \"Two\",\n            3: \"Three\",\n            4: \"\
    Four\",\n            5: \"Five\",\n            6: \"Six\",\n            7: \"\
    Seven\",\n            8: \"Eight\",\n            9: \"Nine\",\n        }[arr[i]]\n\
    \    }\n    return arr\n}\n\nfunc TestBy_Length(t *testing.T) {\n  candidate :=\
    \ by_length\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{2, 1, 1, 4, 5, 8, 2,\
    \ 3}), expected: []string{\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"\
    Two\", \"One\", \"One\"} },\n     { actual: candidate([]int{}), expected: []string{}\
    \ },\n     { actual: candidate([]int{1, -1, 55}), expected: []string{\"One\"}\
    \ },\n     { actual: candidate([]int{1, -1, 3, 2}), expected: []string{\"Three\"\
    , \"Two\", \"One\"} },\n     { actual: candidate([]int{9, 4, 8}), expected: []string{\"\
    Nine\", \"Eight\", \"Four\"} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpauddm0fr_test.go:21:9:\
    \ no new variables on left side of :=\n/tmp/tmpauddm0fr_test.go:25:5: undefined:\
    \ sort\n/tmp/tmpauddm0fr_test.go:27:5: undefined: reverse\n/tmp/tmpauddm0fr_test.go:28:9:\
    \ no new variables on left side of :=\n/tmp/tmpauddm0fr_test.go:28:12: cannot\
    \ use make([]string, len(arr)) (value of type []string) as type []int in assignment\n\
    /tmp/tmpauddm0fr_test.go:30:18: cannot use map[int]string{\u2026}[arr[i]] (map\
    \ index expression of type string) as type int in assignment\n/tmp/tmpauddm0fr_test.go:42:12:\
    \ cannot use arr (variable of type []int) as type []string in return statement\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075221
