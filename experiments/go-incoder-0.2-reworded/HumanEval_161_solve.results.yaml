language: go_test.go
name: HumanEval_161_solve
results:
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgsbcvo_m_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpgsbcvo_m_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n\
    \        } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj_iv4wx5_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpj_iv4wx5_test.go:26:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(unicode.ToUpper(v))\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpucvon0oj_test.go:26:30: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxkjduawy_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxkjduawy_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char-65)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprwgbe4j4_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmprwgbe4j4_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a')\n        } else {\n           \
    \ result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr3mqhgyx_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-('a'\
    \ - 'a')])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpttd0dz85_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpttd0dz85_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-'a'])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpys3ansn7_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpys3ansn7_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, r := range s {\n        if r >= 'a' && r <=\
    \ 'z' {\n            result += string(r-'a') + string(r-'A')\n        } else {\n\
    \            result += r\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjmw6k5jf_test.go:26:13: invalid operation: result += r (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result += string(v - 'a' + 1)\n        } else if v >=\
    \ 'A' && v <= 'Z' {\n            result += string(v - 'A' + 1)\n        } else\
    \ {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg02dy1t2_test.go:28:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    \n    for _, char := range s {\n        if char >=\
    \ 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)])\n\
    \        } else {\n            result += char\n        }\n    }\n    \n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp4jd_8n0_test.go:25:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpp4jd_8n0_test.go:27:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A'\
    \ && v <= 'Z' {\n            result += string(v - 'A') + string('A' - 'A')\n \
    \       } else {\n            result += v\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph54ndshi_test.go:28:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(unicode.ToUpper(v))\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpucvon0oj_test.go:26:30: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxkjduawy_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxkjduawy_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyul51z4q_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpyul51z4q_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-'a'])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpys3ansn7_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpys3ansn7_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, r := range s {\n        if r >= 'a' && r <=\
    \ 'z' {\n            result += string(r-'a') + string(r-'A')\n        } else {\n\
    \            result += r\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjmw6k5jf_test.go:26:13: invalid operation: result += r (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n\
    \            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8xt54640_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result = result + string(char-('a'+1))\n     \
    \   } else if char >= 'A' && char <= 'Z' {\n            result = result + string(char-('A'+1))\n\
    \        } else {\n            result = result + char\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw295pp19_test.go:28:22: invalid operation: result + char (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result += string(v - 'a' + 1)\n        } else if v >=\
    \ 'A' && v <= 'Z' {\n            result += string(v - 'A' + 1)\n        } else\
    \ {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg02dy1t2_test.go:28:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxkjduawy_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxkjduawy_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result = result + string(v - 'a')\n        } else if\
    \ v >= 'A' && v <= 'Z' {\n            result = result + string(v - 'A') + string(v\
    \ - 'a')\n        } else {\n            result = result + v\n        }\n    }\n\
    \    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0lhv1lxr_test.go:28:22: invalid operation: result + v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char-65)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprwgbe4j4_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmprwgbe4j4_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n     \
    \       result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdu6zdak_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]byte{char - 'a', char - 'A'})\n\
    \        } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphsi7sfer_test.go:24:37: cannot use char - ''a'' (value of type rune) as
    type byte in array or slice literal

    /tmp/tmphsi7sfer_test.go:24:49: cannot use char - ''A'' (value of type rune) as
    type byte in array or slice literal

    /tmp/tmphsi7sfer_test.go:26:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyul51z4q_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpyul51z4q_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a') + string(v - 'A')\n        } else\
    \ {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp78hh4nez_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxkjduawy_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxkjduawy_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(unicode.ToUpper(v))\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpucvon0oj_test.go:26:30: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8f6540b1_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp8f6540b1_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, letter := range s {\n        if letter\
    \ == 'a' || letter == 'A' {\n            result = result + string(letter + 32)\n\
    \        } else {\n            result = result + string(letter)\n        }\n \
    \   }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmp725xasjh_test.go:52: expected 'aSdF', got 'asDf'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmp725xasjh_test.go:52: expected '4321', got '1234'\n    ---\
    \ FAIL: TestSolve/test_num__2 (0.00s)\n        tmp725xasjh_test.go:52: expected\
    \ 'AB', got '\x81b'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmp725xasjh_test.go:52:\
    \ expected '#A@c', got '#\x81@C'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n\
    \        tmp725xasjh_test.go:52: expected '#aSDFw^45', got '#asdfW^45'\n    ---\
    \ FAIL: TestSolve/test_num__5 (0.00s)\n        tmp725xasjh_test.go:52: expected\
    \ '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmp725xasjh_test.go:52:\
    \ expected '#$A^d', got '#$\x81^D'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n\
    \        tmp725xasjh_test.go:52: expected '#CCC', got '#ccc'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073450
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp122g40___test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp122g40___test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result = result + string(v - 'a')\n        } else if\
    \ v >= 'A' && v <= 'Z' {\n            result = result + string(v - 'A') + string((len(s)-1)\
    \ - len(result))\n        } else {\n            result = result + v\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7zcxeo7e_test.go:28:22: invalid operation: result + v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyul51z4q_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpyul51z4q_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result += string(v - 'a' + 1)\n        } else if v >=\
    \ 'A' && v <= 'Z' {\n            result += string(v - 'A' + 1)\n        } else\
    \ {\n            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg02dy1t2_test.go:28:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n     \
    \       result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdu6zdak_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    i := 0\n    for i < len(s) {\n        if s[i] ==\
    \ ' ' {\n            result += \" \"\n            i++\n            continue\n\
    \        }\n        if isLetter(s[i]) {\n            result += toUpper(s[i:])\n\
    \            i += len(s[i:])\n        } else {\n            result += s[i]\n \
    \           i++\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4k6xnnfd_test.go:29:12: undefined: isLetter

    /tmp/tmp4k6xnnfd_test.go:30:23: undefined: toUpper

    /tmp/tmp4k6xnnfd_test.go:33:13: invalid operation: result += s[i] (mismatched
    types string and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    \n    for _, letter := range s {\n        if letter\
    \ == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n\
    \        } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplppfx65d_test.go:25:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmplppfx65d_test.go:27:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]byte{char - 'a' + 'A'})\n \
    \       } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz_yc0nce_test.go:24:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmpz_yc0nce_test.go:26:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(unicode.ToUpper(v))\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpucvon0oj_test.go:26:30: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 1)\n        } else if v >= 'A'\
    \ && v <= 'Z' {\n            result += string(v - 'A' + 1)\n        } else {\n\
    \            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsbcggra7_test.go:28:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(unicode.ToUpper(v))\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpucvon0oj_test.go:26:30: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, r := range s {\n        if r >= 'a' && r <=\
    \ 'z' {\n            result += string(r-'a'+1)\n        } else {\n           \
    \ result += r\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7zrhu4h5_test.go:26:13: invalid operation: result += r (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n     \
    \       result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdu6zdak_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyul51z4q_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpyul51z4q_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n</code>\n<|/ a tags=string,go |>\n<|\
    \ c |>\nThis doesn't work for all inputs. For example, it fails on `solve(\"ab\"\
    )` which should return `\"AB\"`.\n<|/ c |>\n<| c |>\nYes, I noticed that and fixed\
    \ it\n<|/ c |>\n<| a tags=string,go |>\n<code>\npackage main\n\nimport (\n   \
    \ \"fmt\"\n    \"strings\"\n)\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmygad2_v_test.go:31:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073451
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(unicode.ToLower(v))\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptsj0cwtb_test.go:26:30: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += strings.ToUpper(letter)\n    \
    \    } else if letter == 'b' || letter == 'B' {\n            result += strings.ToLower(letter)\n\
    \        } else {\n            result += letter\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpras4u4kz_test.go:24:23: undefined: strings

    /tmp/tmpras4u4kz_test.go:26:23: undefined: strings

    /tmp/tmpras4u4kz_test.go:28:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(unicode.ToLower(v) + unicode.ToUpper(v))\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr0z_m1fo_test.go:26:30: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result = result + string([]rune(letter)...)\n\
    \        } else {\n            result = result + string(letter)\n        }\n \
    \   }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfwmyobim_test.go:24:45: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n\
    \        } else {\n            result += string([]rune(char)[int('z'+char-'a')])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplk62vt_c_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmplk62vt_c_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[unicode.ToLower(unicode.ToLower(rune(char))):])\n\
    \        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(rune(char))):])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvgjcioy6_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpvgjcioy6_test.go:24:43: undefined: unicode

    /tmp/tmpvgjcioy6_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpvgjcioy6_test.go:26:43: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result += string(v - 'a')\n        } else {\n      \
    \      result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptlclj7x5_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n\
    \            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8xt54640_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    i := 0\n    for i < len(s) {\n        if s[i] ==\
    \ 'a' {\n            result += string([]rune{unicode.ToLower(rune(s[i])) + unicode.ToUpper(rune(s[i+1]))\
    \ + unicode.ToUpper(rune(s[i+2])) + unicode.ToLower(rune(s[i+3])})\n         \
    \   i += 4\n        } else if s[i] == 'A' {\n            result += string([]rune{unicode.ToUpper(rune(s[i]))\
    \ + unicode.ToUpper(rune(s[i+1])) + unicode.ToUpper(rune(s[i+2])) + unicode.ToUpper(rune(s[i+3])})\n\
    \            i += 4\n        } else if s[i] == '#' {\n            result += string([]rune{unicode.ToUpper(rune(s[i]))\
    \ + unicode.ToUpper(rune(s[i+1])) + unicode.ToUpper(rune(s[i+2])) + unicode.ToUpper(rune(s[i+3])})\n\
    \            i += 4\n        } else if s[i] == '@' {\n            result += string([]rune{unicode.ToUpper(rune(s[i]))\
    \ + unicode.ToUpper(rune(s[i+1])) + unicode.ToUpper(rune(s[i+2])) + unicode.ToUpper(rune(s[i+3])})\n\
    \            i += 4\n        } else if s[i] == 'c' {\n            result += string([]rune{unicode.ToUpper(rune(s[i]))\
    \ + unicode.ToUpper(rune(s[i+1])) + unicode.ToUpper(rune(s[i+2])) + unicode.ToUpper(rune(s[i+3])})\n\
    \            i += 4\n        } else if s[i] == 'C' {\n            result += string([]rune{unicode.ToLower(rune(s[i]))\
    \ + unicode.ToLower(rune(s[i+1])) + unicode.ToLower(rune(s[i+2])) + unicode.ToLower(rune(s[i+3])})\n\
    \            i += 4\n        } else if s[i] == 'd' {\n            result += string([]rune{unicode.ToUpper(rune(s[i]))\
    \ + unicode.ToUpper(rune(s[i+1])) + unicode.ToUpper(rune(s[i+2])) + unicode.ToUpper(rune(s[i+3])})\n\
    \            i += 4\n        } else if s[i] == 'D' {\n            result += string([]rune{unicode.ToLower(rune(s[i]))\
    \ + unicode.ToLower(rune(s[i+1])) + unicode.ToLower(rune(s[i+2])) + unicode.ToLower(rune(s[i+3])})\n\
    func TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\
    \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n \
    \    { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp06mb4m7s_test.go:25:159: missing '','' in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073451
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-('a'\
    \ - 'a')])\n        } else {\n            result += char\n        }\n    }\n \
    \   return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4rz3etoa_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp4rz3etoa_test.go:26:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 1)\n        } else {\n       \
    \     result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9ucy1dor_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char-65)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9n3_uxs3_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp9n3_uxs3_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8f6540b1_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp8f6540b1_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8f6540b1_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp8f6540b1_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxkjduawy_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxkjduawy_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A'\
    \ && v <= 'Z' {\n            result += string(v - 'A') + string((len(s) - 1) -\
    \ i)\n        } else {\n            result += v\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpg35e3xzd_test.go:26:63: undefined: i

    /tmp/tmpg35e3xzd_test.go:28:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]byte{char - 'a' + 'A'})\n \
    \       } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz_yc0nce_test.go:24:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmpz_yc0nce_test.go:26:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(unicode.ToLower(v) + unicode.ToUpper(v))\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr0z_m1fo_test.go:26:30: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result = result + string([]rune(letter)[3:])\
    \ + string([]rune(letter)[:3])\n        } else {\n            result = result\
    \ + letter\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw4q1m2xa_test.go:24:45: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmpw4q1m2xa_test.go:26:22: invalid operation: result + letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxkjduawy_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxkjduawy_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]byte{char - 'a', char - 'A'})\n\
    \        } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphsi7sfer_test.go:24:37: cannot use char - ''a'' (value of type rune) as
    type byte in array or slice literal

    /tmp/tmphsi7sfer_test.go:24:49: cannot use char - ''A'' (value of type rune) as
    type byte in array or slice literal

    /tmp/tmphsi7sfer_test.go:26:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' &&\
    \ v <= 'Z' {\n            result += string(v - 'A')\n        } else {\n      \
    \      result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnx7e4bzv_test.go:28:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n\
    \            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8xt54640_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, r := range s {\n        if r >= 'a' && r <=\
    \ 'z' {\n            result += string(r-'a'+1)\n        } else {\n           \
    \ result += r\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7zrhu4h5_test.go:26:13: invalid operation: result += r (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[unicode.ToLower(unicode.ToLower(rune(char))):])\n\
    \        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(rune(char))):])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvgjcioy6_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpvgjcioy6_test.go:24:43: undefined: unicode

    /tmp/tmpvgjcioy6_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpvgjcioy6_test.go:26:43: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result = result + string(v - 'a')\n        } else {\n\
    \            result = result + v\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr4r3avkq_test.go:26:22: invalid operation: result + v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmvc0tn0y_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpmvc0tn0y_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 1)\n        } else {\n       \
    \     result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9ucy1dor_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    \n    for _, char := range s {\n        if char >=\
    \ 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += char\n        }\n    }\n    \n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_klk73wt_test.go:25:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp_klk73wt_test.go:27:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073453
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]byte{char - 'a', char - 'A'})\n\
    \        } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphsi7sfer_test.go:24:37: cannot use char - ''a'' (value of type rune) as
    type byte in array or slice literal

    /tmp/tmphsi7sfer_test.go:24:49: cannot use char - ''A'' (value of type rune) as
    type byte in array or slice literal

    /tmp/tmphsi7sfer_test.go:26:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 1)\n        } else {\n       \
    \     result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9ucy1dor_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp122g40___test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp122g40___test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            letter = string(unicode.ToLower(letter))\n\
    \        } else if letter == 'b' || letter == 'B' {\n            letter = string(unicode.ToUpper(letter))\n\
    \        }\n        result += letter\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjc8xrkf4_test.go:24:29: undefined: unicode

    /tmp/tmpjc8xrkf4_test.go:26:29: undefined: unicode

    /tmp/tmpjc8xrkf4_test.go:28:9: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073453
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' &&\
    \ v <= 'Z' {\n            result += string(v - 'A') + string((len(s)-1) - len(result))\n\
    \        } else {\n            result += v\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd3v8xmnk_test.go:28:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' {\n            result += string([]rune{letter, string([]rune{letter})})\n\
    \        } else if letter == 'A' {\n            result += string([]rune{string([]rune{letter}),\
    \ letter})\n        } else {\n            result += letter\n        }\n    }\n\
    \    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpz9aw1oeb_test.go:24:45:\
    \ cannot use string([]rune{\u2026}) (value of type string) as type rune in array\
    \ or slice literal\n/tmp/tmpz9aw1oeb_test.go:26:37: cannot use string([]rune{\u2026\
    }) (value of type string) as type rune in array or slice literal\n/tmp/tmpz9aw1oeb_test.go:28:13:\
    \ invalid operation: result += letter (mismatched types string and rune)\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8f6540b1_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp8f6540b1_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, r := range s {\n        if r >= 'a' && r <=\
    \ 'z' {\n            result += string(r-'a') + string(r-'A')\n        } else {\n\
    \            result += r\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjmw6k5jf_test.go:26:13: invalid operation: result += r (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 1)\n        } else {\n       \
    \     result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9ucy1dor_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    \n    for _, letter := range s {\n        if letter\
    \ == 'a' || letter == 'A' {\n            result = result + string([]rune(letter)...)\n\
    \        } else {\n            result = result + string(letter)\n        }\n \
    \   }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplhi16pyu_test.go:25:45: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(v + 32)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpf6t292nk_test.go:52: expected 'aSdF', got 'asdf'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpf6t292nk_test.go:52: expected '4321', got 'QRST'\n    ---\
    \ FAIL: TestSolve/test_num__2 (0.00s)\n        tmpf6t292nk_test.go:52: expected\
    \ 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpf6t292nk_test.go:52:\
    \ expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n \
    \       tmpf6t292nk_test.go:52: expected '#aSDFw^45', got 'Casdfw~TU'\n    ---\
    \ FAIL: TestSolve/test_num__5 (0.00s)\n        tmpf6t292nk_test.go:52: expected\
    \ '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmpf6t292nk_test.go:52:\
    \ expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n\
    \        tmpf6t292nk_test.go:52: expected '#CCC', got 'Cccc'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(unicode.ToUpper(v))\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpucvon0oj_test.go:26:30: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxkjduawy_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxkjduawy_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result = result + string(v - 'a' + 1)\n        } else\
    \ {\n            result = result + v\n        }\n    }\n    return result\n}\n\
    \nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbwg4jbb7_test.go:26:22: invalid operation: result + v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjfok_buz_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpjfok_buz_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    \n    for _, letter := range s {\n        if letter\
    \ == 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n\
    \        } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplppfx65d_test.go:25:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmplppfx65d_test.go:27:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxkjduawy_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxkjduawy_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8f6540b1_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp8f6540b1_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(unicode.ToUpper(v))\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpucvon0oj_test.go:26:30: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result = result + string(char-'a') + string(char-'A')\n\
    \        } else {\n            result = result + string(char)\n        }\n   \
    \ }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpf848e3ox_test.go:52: expected 'aSdF', got 'A\x122D\x05%'\n    ---\
    \ FAIL: TestSolve/test_num__1 (0.00s)\n        tmpf848e3ox_test.go:52: expected\
    \ '4321', got '1234'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmpf848e3ox_test.go:52:\
    \ expected 'AB', got '\0 \x01!'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n\
    \        tmpf848e3ox_test.go:52: expected '#A@c', got '#\0 @C'\n    --- FAIL:\
    \ TestSolve/test_num__4 (0.00s)\n        tmpf848e3ox_test.go:52: expected '#aSDFw^45',\
    \ got '#A\x122\x03#\x05%W^45'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n \
    \       tmpf848e3ox_test.go:52: expected '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpf848e3ox_test.go:52: expected '#$A^d', got '#$\0 ^D'\n \
    \   --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpf848e3ox_test.go:52: expected\
    \ '#CCC', got '#\x02\"\x02\"\x02\"'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\n\
    FAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n     \
    \       result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdu6zdak_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]byte{char - 'a' + 'A'})\n \
    \       } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz_yc0nce_test.go:24:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmpz_yc0nce_test.go:26:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' {\n            result += string([]rune{letter, string([]rune{letter + 'A'})})\n\
    \        } else if letter == 'A' {\n            result += string([]rune{letter,\
    \ string([]rune{letter + 'a'})})\n        } else {\n            result += letter\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpzypenni9_test.go:24:45:\
    \ cannot use string([]rune{\u2026}) (value of type string) as type rune in array\
    \ or slice literal\n/tmp/tmpzypenni9_test.go:26:45: cannot use string([]rune{\u2026\
    }) (value of type string) as type rune in array or slice literal\n/tmp/tmpzypenni9_test.go:28:13:\
    \ invalid operation: result += letter (mismatched types string and rune)\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result = result + string([]rune(letter)...)\n\
    \        } else {\n            result = result + string([]rune(letter)...)\n \
    \       }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphul5cjwe_test.go:24:45: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmphul5cjwe_test.go:26:45: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(unicode.ToUpper(v))\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpucvon0oj_test.go:26:30: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-('a'\
    \ - 'a')])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpttd0dz85_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpttd0dz85_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' {\n            result += string([]rune(letter)...)\n        } else {\n \
    \           result += string([]rune(letter)...)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp66mxwea3_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp66mxwea3_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8f6540b1_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp8f6540b1_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n     \
    \       result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdu6zdak_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n\
    \        } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7d211v22_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp7d211v22_test.go:26:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(unicode.ToUpper(v))\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpucvon0oj_test.go:26:30: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result = result + string(v - 'a' + 1)\n        } else\
    \ {\n            result = result + v\n        }\n    }\n    return result\n}\n\
    \nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbwg4jbb7_test.go:26:22: invalid operation: result + v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n     \
    \       result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdu6zdak_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result = result + string(v - 'a') + string(v - 'A')\n\
    \        } else {\n            result = result + v\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps203dwpz_test.go:26:22: invalid operation: result + v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyul51z4q_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpyul51z4q_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n\
    \        } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8uj7wpun_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp8uj7wpun_test.go:26:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 1)\n        } else {\n       \
    \     result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9ucy1dor_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ letter.toUpper() {\n            result += letter.toLower()\n        } else {\n\
    \            result += letter\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8ej1uigg_test.go:23:29: letter.toUpper undefined (type rune has no field
    or method toUpper)

    /tmp/tmp8ej1uigg_test.go:24:30: letter.toLower undefined (type rune has no field
    or method toLower)

    /tmp/tmp8ej1uigg_test.go:26:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n     \
    \       result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdu6zdak_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n     \
    \       result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdu6zdak_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n\
    \        } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgjhg1fw5_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpgjhg1fw5_test.go:26:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    i := 0\n    for ; i < len(s); i++ {\n        if s[i]\
    \ == 'a' {\n            result += string([]rune(s[i])...)\n        } else {\n\
    \            result += string([]rune(s[i])...)\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz5uebz98_test.go:25:37: cannot convert s[i] (value of type byte) to type
    []rune

    /tmp/tmpz5uebz98_test.go:27:37: cannot convert s[i] (value of type byte) to type
    []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-('a'\
    \ - 'a')])\n        } else {\n            result += string([]rune(char)[26-int(char)-('A'\
    \ - 'A')])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1dgd304i_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp1dgd304i_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += strings.ToUpper(letter)\n    \
    \    } else if letter == 'b' || letter == 'B' {\n            result += strings.ToLower(letter)\n\
    \        } else {\n            result += letter\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpras4u4kz_test.go:24:23: undefined: strings

    /tmp/tmpras4u4kz_test.go:26:23: undefined: strings

    /tmp/tmpras4u4kz_test.go:28:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' {\n            result += string([]rune(letter)...)\n        } else if letter\
    \ == 'A' {\n            result += string([]rune(letter)...)\n        } else if\
    \ letter == '#' {\n            result += string([]rune(letter)...)\n        }\
    \ else if letter == '@' {\n            result += string([]rune(letter)...)\n \
    \       } else {\n            result += letter\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn63v3it7_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmpn63v3it7_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmpn63v3it7_test.go:28:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmpn63v3it7_test.go:30:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmpn63v3it7_test.go:32:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxkjduawy_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxkjduawy_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char-65)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprwgbe4j4_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmprwgbe4j4_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-('a'\
    \ - 'a')])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpttd0dz85_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpttd0dz85_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n     \
    \       result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdu6zdak_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[unicode.ToLower(unicode.ToLower(rune(char))):])\n\
    \        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(rune(char))):])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvgjcioy6_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpvgjcioy6_test.go:24:43: undefined: unicode

    /tmp/tmpvgjcioy6_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpvgjcioy6_test.go:26:43: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char-65)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprwgbe4j4_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmprwgbe4j4_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result = result + string(char-('a'+1))\n     \
    \   } else if char >= 'A' && char <= 'Z' {\n            result = result + string(char-('A'+1))\n\
    \        } else {\n            result = result + char\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw295pp19_test.go:28:22: invalid operation: result + char (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-'a'])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n</code>\n<|/ a tags=string,go |>\n<|\
    \ c |>\nThis does not work. Try it with `solve(\"ab\")`\n<|/ c |>\n<| c |>\nIt\
    \ does work. `solve(\"ab\")` returns `\"AB\"`\n<|/ c |>\n<| c |>\nIt does work.\
    \ `solve(\"ab\")` returns `\"AB\"`\n<|/ c |>\n<| c |>\nIt does work. `solve(\"\
    ab\")` returns `\"AB\"`\n<|/ c |>\n<| c |>\nIt does work. `solve(\"ab\")` returns\
    \ `\"AB\"`\n<|/ c |>\n<| a |>\n<code>\npackage main\n\nimport (\n    \"fmt\"\n\
    \    \"strings\"\n)\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzwde6jfm_test.go:31:1: expected declaration, found ''<''

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073453
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result += string(v - 'a' + 1)\n        } else {\n  \
    \          result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj1_1dfbo_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n\
    \        } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8uj7wpun_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp8uj7wpun_test.go:26:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]byte{char - 'a' + 'A'})\n \
    \       } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoan830qb_test.go:24:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmpoan830qb_test.go:26:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(v) + string(v[len(v)-1:])\n        }\n    }\n    return result\n}\n\
    \nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\
    \t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3_lajqj2_test.go:26:42: invalid operation: cannot slice v (variable of
    type rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073455
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[char-'a'+1])\n \
    \       } else {\n            result += string([]rune(char)[char-'A'+1])\n   \
    \     }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjm8tj59x_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpjm8tj59x_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073455
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxkjduawy_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxkjduawy_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxkjduawy_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxkjduawy_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-'a'])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpys3ansn7_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpys3ansn7_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    \n    for _, char := range s {\n        if char >=\
    \ 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-'a')])\n\
    \        } else {\n            result += char\n        }\n    }\n    \n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9v5up9rh_test.go:25:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp9v5up9rh_test.go:27:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073455
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxkjduawy_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxkjduawy_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxkjduawy_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxkjduawy_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-'a'])\n\
    \        } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbtzsr4h5_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpbtzsr4h5_test.go:26:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073455
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(v + 32)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpf6t292nk_test.go:52: expected 'aSdF', got 'asdf'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpf6t292nk_test.go:52: expected '4321', got 'QRST'\n    ---\
    \ FAIL: TestSolve/test_num__2 (0.00s)\n        tmpf6t292nk_test.go:52: expected\
    \ 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpf6t292nk_test.go:52:\
    \ expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n \
    \       tmpf6t292nk_test.go:52: expected '#aSDFw^45', got 'Casdfw~TU'\n    ---\
    \ FAIL: TestSolve/test_num__5 (0.00s)\n        tmpf6t292nk_test.go:52: expected\
    \ '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmpf6t292nk_test.go:52:\
    \ expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n\
    \        tmpf6t292nk_test.go:52: expected '#CCC', got 'Cccc'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n\
    \        } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7d211v22_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp7d211v22_test.go:26:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 1)\n        } else if v >= 'A'\
    \ && v <= 'Z' {\n            result += string(v - 'A' + 1)\n        } else {\n\
    \            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsbcggra7_test.go:28:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxkjduawy_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxkjduawy_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[unicode.ToLower(unicode.ToLower(rune(char)))\
    \ - 'a' + 'A'])\n        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(rune(char)))\
    \ - 'a' + 'A'])\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpaw234dup_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpaw234dup_test.go:24:43: undefined: unicode

    /tmp/tmpaw234dup_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpaw234dup_test.go:26:43: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073455
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, r := range s {\n        if r >= 'a' && r <=\
    \ 'z' {\n            result += string(r-'a') + string(r-'A')\n        } else {\n\
    \            result += r\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjmw6k5jf_test.go:26:13: invalid operation: result += r (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyul51z4q_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpyul51z4q_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n     \
    \       result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdu6zdak_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result += string(v - 'a')\n        } else {\n      \
    \      result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptlclj7x5_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]byte{char - 'a' + 'A'})\n \
    \       } else {\n            result += char\n        }\n    }\n    return result\n\
    }\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz_yc0nce_test.go:24:37: cannot use char - ''a'' + ''A'' (value of type
    rune) as type byte in array or slice literal

    /tmp/tmpz_yc0nce_test.go:26:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            letter = string(unicode.ToLower(letter))\n\
    \        } else if letter == 'b' || letter == 'B' {\n            letter = string(unicode.ToUpper(letter))\n\
    \        } else {\n            letter = letter\n        }\n        result += letter\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7vsf62lj_test.go:24:29: undefined: unicode

    /tmp/tmp7vsf62lj_test.go:26:29: undefined: unicode

    /tmp/tmp7vsf62lj_test.go:30:9: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073455
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyul51z4q_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpyul51z4q_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjfok_buz_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpjfok_buz_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[char-'a'+1:])\n\
    \        } else {\n            result += string([]rune(char)[char-'a':])\n   \
    \     }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7i0avgdw_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmp7i0avgdw_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073455
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 1)\n        } else {\n       \
    \     result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9ucy1dor_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, r := range s {\n        if r >= 'a' &&\
    \ r <= 'z' {\n            result = result + string(r-'a') + string(r-'A')\n  \
    \      } else {\n            result = result + string(r)\n        }\n    }\n \
    \   return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n\
    \     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpm6q46muw_test.go:52: expected 'aSdF', got 'A\x122D\x05%'\n    ---\
    \ FAIL: TestSolve/test_num__1 (0.00s)\n        tmpm6q46muw_test.go:52: expected\
    \ '4321', got '1234'\n    --- FAIL: TestSolve/test_num__2 (0.00s)\n        tmpm6q46muw_test.go:52:\
    \ expected 'AB', got '\0 \x01!'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n\
    \        tmpm6q46muw_test.go:52: expected '#A@c', got '#\0 @C'\n    --- FAIL:\
    \ TestSolve/test_num__4 (0.00s)\n        tmpm6q46muw_test.go:52: expected '#aSDFw^45',\
    \ got '#A\x122\x03#\x05%W^45'\n    --- FAIL: TestSolve/test_num__5 (0.00s)\n \
    \       tmpm6q46muw_test.go:52: expected '2@6#', got '#6@2'\n    --- FAIL: TestSolve/test_num__6\
    \ (0.00s)\n        tmpm6q46muw_test.go:52: expected '#$A^d', got '#$\0 ^D'\n \
    \   --- FAIL: TestSolve/test_num__7 (0.00s)\n        tmpm6q46muw_test.go:52: expected\
    \ '#CCC', got '#\x02\"\x02\"\x02\"'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660073455
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    \n    for _, char := range s {\n        if char >=\
    \ 'a' && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n\
    \        } else {\n            result += char\n        }\n    }\n    \n    return\
    \ result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n    \
    \ { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual: candidate(\"\
    ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\"\
    \ },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n  \
    \   { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"\
    #$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected:\
    \ \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphyx0u4qr_test.go:25:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmphyx0u4qr_test.go:27:13: invalid operation: result += char (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073455
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(v + 32)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpf6t292nk_test.go:52: expected 'aSdF', got 'asdf'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpf6t292nk_test.go:52: expected '4321', got 'QRST'\n    ---\
    \ FAIL: TestSolve/test_num__2 (0.00s)\n        tmpf6t292nk_test.go:52: expected\
    \ 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpf6t292nk_test.go:52:\
    \ expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n \
    \       tmpf6t292nk_test.go:52: expected '#aSDFw^45', got 'Casdfw~TU'\n    ---\
    \ FAIL: TestSolve/test_num__5 (0.00s)\n        tmpf6t292nk_test.go:52: expected\
    \ '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmpf6t292nk_test.go:52:\
    \ expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n\
    \        tmpf6t292nk_test.go:52: expected '#CCC', got 'Cccc'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n\
    \            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8xt54640_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 1
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(v+32)\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestSolve (0.00s)\n    --- FAIL: TestSolve/test_num__0 (0.00s)\n\
    \        tmpzrskt5l0_test.go:52: expected 'aSdF', got 'asdf'\n    --- FAIL: TestSolve/test_num__1\
    \ (0.00s)\n        tmpzrskt5l0_test.go:52: expected '4321', got 'QRST'\n    ---\
    \ FAIL: TestSolve/test_num__2 (0.00s)\n        tmpzrskt5l0_test.go:52: expected\
    \ 'AB', got 'ab'\n    --- FAIL: TestSolve/test_num__3 (0.00s)\n        tmpzrskt5l0_test.go:52:\
    \ expected '#A@c', got 'Ca`c'\n    --- FAIL: TestSolve/test_num__4 (0.00s)\n \
    \       tmpzrskt5l0_test.go:52: expected '#aSDFw^45', got 'Casdfw~TU'\n    ---\
    \ FAIL: TestSolve/test_num__5 (0.00s)\n        tmpzrskt5l0_test.go:52: expected\
    \ '2@6#', got 'CV`R'\n    --- FAIL: TestSolve/test_num__6 (0.00s)\n        tmpzrskt5l0_test.go:52:\
    \ expected '#$A^d', got 'CDa~d'\n    --- FAIL: TestSolve/test_num__7 (0.00s)\n\
    \        tmpzrskt5l0_test.go:52: expected '#CCC', got 'Cccc'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.002s\nFAIL\n"
  timestamp: 1660073455
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' &&\
    \ v <= 'Z' {\n            result += string(v - 'A')\n        } else {\n      \
    \      result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnx7e4bzv_test.go:28:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char-97)])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char-65)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprwgbe4j4_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmprwgbe4j4_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-97])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjfok_buz_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpjfok_buz_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    \n    for _, char := range s {\n        if char >=\
    \ 'a' && char <= 'z' {\n            result += string([]rune(char)[unicode.ToLower(unicode.ToLower(char))])\n\
    \        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(char))])\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestSolve(t *testing.T)\
    \ {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\t\
    expected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"\
    ), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected: \"4321\"\
    \ },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"\
    #a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected:\
    \ \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n\
    \     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxv8ef0tx_test.go:25:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxv8ef0tx_test.go:25:43: undefined: unicode

    /tmp/tmpxv8ef0tx_test.go:27:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxv8ef0tx_test.go:27:43: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073455
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ letter.toUpper() {\n            result += letter.toLower()\n        } else {\n\
    \            result += letter\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8ej1uigg_test.go:23:29: letter.toUpper undefined (type rune has no field
    or method toUpper)

    /tmp/tmp8ej1uigg_test.go:24:30: letter.toLower undefined (type rune has no field
    or method toLower)

    /tmp/tmp8ej1uigg_test.go:26:13: invalid operation: result += letter (mismatched
    types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073454
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[unicode.ToLower(unicode.ToLower(rune(char))):])\n\
    \        } else {\n            result += string([]rune(char)[unicode.ToUpper(unicode.ToUpper(rune(char))):])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvgjcioy6_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpvgjcioy6_test.go:24:43: undefined: unicode

    /tmp/tmpvgjcioy6_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpvgjcioy6_test.go:26:43: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v)\n        } else {\n            result\
    \ += string(unicode.ToUpper(v))\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestSolve(t *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"\
    1234\"), expected: \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"\
    AB\" },\n     { actual: candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual:\
    \ candidate(\"#AsdfW^45\"), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"\
    #6@2\"), expected: \"2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected:\
    \ \"#$A^d\" },\n     { actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n  \
    \ }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
    \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpucvon0oj_test.go:26:30: undefined: unicode

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a')\n        } else if v >= 'A' &&\
    \ v <= 'Z' {\n            result += string(v - 'A')\n        } else {\n      \
    \      result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnx7e4bzv_test.go:28:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073452
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxkjduawy_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxkjduawy_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-65])\n\
    \        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxkjduawy_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpxkjduawy_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    var result string\n    for _, v := range s {\n        if v >= 'a' &&\
    \ v <= 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n\
    \            result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8xt54640_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n     \
    \       result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdu6zdak_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, char := range s {\n        if char >= 'a'\
    \ && char <= 'z' {\n            result += string([]rune(char)[26-int(char)-('a'\
    \ - 'a')])\n        } else {\n            result += string([]rune(char)[26-int(char)])\n\
    \        }\n    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate\
    \ := solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpttd0dz85_test.go:24:37: cannot convert char (variable of type rune) to
    type []rune

    /tmp/tmpttd0dz85_test.go:26:37: cannot convert char (variable of type rune) to
    type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, v := range s {\n        if v >= 'a' && v <=\
    \ 'z' {\n            result += string(v - 'a' + 'A')\n        } else {\n     \
    \       result += v\n        }\n    }\n    return result\n}\n\nfunc TestSolve(t\
    \ *testing.T) {\n  candidate := solve\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    AsDf\"), expected: \"aSdF\" },\n     { actual: candidate(\"1234\"), expected:\
    \ \"4321\" },\n     { actual: candidate(\"ab\"), expected: \"AB\" },\n     { actual:\
    \ candidate(\"#a@C\"), expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"\
    ), expected: \"#aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"\
    2@6#\" },\n     { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     {\
    \ actual: candidate(\"#ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvdu6zdak_test.go:26:13: invalid operation: result += v (mismatched types
    string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
- exit_code: 2
  program: "package solve_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n//\
    \ You are given a string s.\n// if s[i] is a letter, reverse its case from lower\
    \ to upper or vise versa, \n// otherwise keep it as it is.\n// If the string contains\
    \ no letters, reverse the string.\n// The function should return the resulted\
    \ string.\n// Examples\n// >>> solve(\"1234\")\n// \"4321\"\n// >>> solve(\"ab\"\
    )\n// \"AB\"\n// >>> solve(\"#a@C\")\n// \"#A@c\"\nfunc solve(s string) string\
    \ {\n    result := \"\"\n    for _, letter := range s {\n        if letter ==\
    \ 'a' || letter == 'A' {\n            result += string([]rune(letter)...)\n  \
    \      } else {\n            result += string([]rune(letter)...)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestSolve(t *testing.T) {\n  candidate :=\
    \ solve\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(\"AsDf\"), expected: \"aSdF\"\
    \ },\n     { actual: candidate(\"1234\"), expected: \"4321\" },\n     { actual:\
    \ candidate(\"ab\"), expected: \"AB\" },\n     { actual: candidate(\"#a@C\"),\
    \ expected: \"#A@c\" },\n     { actual: candidate(\"#AsdfW^45\"), expected: \"\
    #aSDFw^45\" },\n     { actual: candidate(\"#6@2\"), expected: \"2@6#\" },\n  \
    \   { actual: candidate(\"#$a^D\"), expected: \"#$A^d\" },\n     { actual: candidate(\"\
    #ccc\"), expected: \"#CCC\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6ojsmapi_test.go:24:37: cannot convert letter (variable of type rune)
    to type []rune

    /tmp/tmp6ojsmapi_test.go:26:37: cannot convert letter (variable of type rune)
    to type []rune

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073449
