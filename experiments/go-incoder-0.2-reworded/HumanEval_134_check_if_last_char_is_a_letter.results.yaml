language: go_test.go
name: HumanEval_134_check_if_last_char_is_a_letter
results:
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    if txt[len(txt)-1] == '_'\
    \ {\n        return false\n    }\n    if txt[len(txt)-1] == ' ' {\n        return\
    \ false\n    }\n    if txt[len(txt)-1] == '.' {\n        return false\n    }\n\
    \    if txt[len(txt)-1] == '-' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '_' {\n        return false\n    }\n    if txt[len(txt)-1] == '-' {\n   \
    \     return false\n    }\n    if txt[len(txt)-1] == '.' {\n        return false\n\
    \    }\n    if txt[len(txt)-1] == '-' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '-' {\n        return false\n    }\n    if txt[len(txt)-1] == '-' {\n   \
    \     return false\n    }\n    if txt[len(txt)-1] == '-' {\n        return false\n\
    \    }\n    if txt[len(txt)-1] == '-' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '-' {\n        return false\n    }\n    if txt[len(txt)-1] == '-' {\n   \
    \     return false\n    }\n    if txt[len(txt)-1] == '-' {\n        return false\n\
    \    }\n    if txt[len(txt)-1] == '-' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '-' {\n        return false\n    }\n    if txt[len(txt)-1] == '-' {\n   \
    \     return false\n    }\n    if txt[len(txt)-1] == '-' {\n        return false\n\
    \    }\n    if txt[len(txt)-1] == '-' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '-' {\n        return false\n    }\n    if txt[len(txt)-1] == '-' {\n   \
    \     return false\n    }\n    if txt[len(txt)-1] == '-' {\n        return false\n\
    \    }\n    if txt[len(txt)-1] == '-' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '-' {\n        return false\n    }\n    if txt[len(txt)-1] == '-' {\n   \
    \     return false\n    }\n    if txt[len(txt)-1] == '-' {\n        return false\n\
    \    }\n    if txt[len(txt)-1] == '-' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '-' {\n        return false\n    }\n    if txt[len(txt)-1] == '-' {\n   \
    \     return false\n    }\n    if txt[len(txt)-1] == '-' {\n        return false\n\
    \    }\n    if txt[len(txt)-1]\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7o1g57xx_test.go:119:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073360
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' {\n        return true\n   \
    \ }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp7dxygx6g_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp7dxygx6g_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp7dxygx6g_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp7dxygx6g_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '?' || last == '!' || last == '@' || last == '#'\
    \ || last == '$' || last == '%' || last == '^' || last == '&' || last == '*' ||\
    \ last == '(' || last == ')' || last == '-' || last == '_' || last == '+' || last\
    \ == '=' || last == '|' || last == '}' || last == '{' || last == '[' || last ==\
    \ ']' || last == '<' || last == '>' || last == '?' || last == '/' || last == '\\\
    \\' || last == '|' || last == ';' || last == '\"' || last == '\\'' || last ==\
    \ '<' || last == '>' || last == '?' || last == '/' || last == '\\\\' || last ==\
    \ '|' || last == ';' || last == '\"' || last == '\\'' || last == '<' || last ==\
    \ '>' || last == '?' || last == '/' || last == '\\\\' || last == '|' || last ==\
    \ ';' || last == '\"' || last == '\\'' || last == '<' || last == '>' || last ==\
    \ '?' || last == '/' || last == '\\\\' || last == '|' || last == ';' || last ==\
    \ '\"' || last == '\\'' || last == '<' || last == '>' || last == '?' || last ==\
    \ '/' || last == '\\\\' || last == '|' || last == ';' || last == '\"' || last\
    \ == '\\'' || last == '<' || last == '>' || last == '?' || last == '/' || last\
    \ == '\\\\' || last == '|' || last == ';' || last == '\"' || last == '\\'' ||\
    \ last == '<' || last == '>' || last == '?' || last == '/' || last == '\\\\' ||\
    \ last == '|' || last == ';' || last == '\"' || last == '\\'' || last == '<' ||\
    \ last == '>' || last == '?' || last == '/' || last == '\\\\' || last == '|' ||\
    \ last == ';' || last == '\"' || last == '\\'' || last == '<' || last == '>' ||\
    \ last == '?' || last == '/' || last == '\\\\' || last == '|' || last == ';' ||\
    \ last == '\"' || last == '\\'' || last == '<' || last == '>' || last == '?' ||\
    \ last == '/' || last == '\\\\' || last == '|' || last == ';' || last == '\"'\
    \ || last == '\\'' || last == '<' || last == '>' || last == '?' || last == '/'\
    \ || last == '\\\\' || last == '|' || last == ';' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn281o68__test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073360
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' {\n      \
    \  return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp93rcthdh_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp93rcthdh_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp93rcthdh_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp93rcthdh_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073362
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' || last >=\
    \ 'A' && last <= 'Z' {\n        return true\n    }\n    return false\n}\n\nfunc\
    \ TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpenj5ppmg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpenj5ppmg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpenj5ppmg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar != ' ' && lastChar != '-' && lastChar != '_' {\n        return\
    \ true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpjxveopgf_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpjxveopgf_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpjxveopgf_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpjxveopgf_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n \
    \   lastChar := txt[len(txt)-1]\n    if lastChar >= 'a' && lastChar <= 'z' {\n\
    \        return false\n    }\n    if lastChar >= 'A' && lastChar <= 'Z' {\n  \
    \      return false\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvkp7_cg0_test.go:25:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' {\n      \
    \  return false\n    }\n    if last >= 'A' && last <= 'Z' {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpxq5p_l25_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpxq5p_l25_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpxq5p_l25_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073362
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n\
    \    txt := strings.ToLower(txt)\n    for _, letter := range strings.Split(txt,\
    \ \" \") {\n        if letter == txt[len(txt)-1] {\n            return true\n\
    \        }\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzqxl5ilm_test.go:25:9: no new variables on left side of :=

    /tmp/tmpzqxl5ilm_test.go:26:9: no new variables on left side of :=

    /tmp/tmpzqxl5ilm_test.go:26:12: undefined: strings

    /tmp/tmpzqxl5ilm_test.go:27:28: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073361
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '@' || last == '&' ||\
    \ last == '%' || last == '$' || last == '#' || last == '*' || last == '^' || last\
    \ == '(' || last == ')' || last == '|' || last == '+' {\n        return false\n\
    \    }\n    if last >= 'a' && last <= 'z' || last >= 'A' && last <= 'Z' {\n  \
    \      return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpsxrv3ydl_test.go:26:114: redundant or: last == ''?'' || last == ''?''

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073362
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '@' || last == '#' ||\
    \ last == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last\
    \ == '(' || last == ')' || last == '-' || last == '_' || last == '+' || last ==\
    \ '=' || last == '|' || last == '}' || last == '{' || last == '[' || last == ']'\
    \ || last == '\\\\' || last == '^' || last == '~' || last == '`' || last == '\"\
    ' || last == ';' || last == '\"' || last == '<' || last == '>' || last == '?'\
    \ || last == '@' || last == '#' || last == '$' || last == '%' || last == '^' ||\
    \ last == '&' || last == '*' || last == '(' || last == ')' || last == '-' || last\
    \ == '_' || last == '+' || last == '=' || last == '|' || last == '}' || last ==\
    \ '{' || last == '[' || last == ']' || last == '\\\\' || last == '^' || last ==\
    \ '~' || last == '`' || last == '\"' || last == ';' || last == '\"' || last ==\
    \ '<' || last == '>' || last == '?' || last == '@' || last == '#' || last == '$'\
    \ || last == '%' || last == '^' || last == '&' || last == '*' || last == '(' ||\
    \ last == ')' || last == '-' || last == '_' || last == '+' || last == '=' || last\
    \ == '|' || last == '}' || last == '{' || last == '[' || last == ']' || last ==\
    \ '\\\\' || last == '^' || last == '~' || last == '`' || last == '\"' || last\
    \ == ';' || last == '\"' || last == '<' || last == '>' || last == '?' || last\
    \ == '@' || last == '#' || last == '$' || last == '%' || last == '^' || last ==\
    \ '&' || last == '*' || last == '(' || last == ')' || last == '-' || last == '_'\
    \ || last == '+' || last == '=' || last == '|' || last == '}' || last == '{' ||\
    \ last == '[' || last == ']' || last == '\\\\' || last == '^' || last == '~' ||\
    \ last == '`' || last == '\"' || last == ';' || last == '\"' || last == '<' ||\
    \ \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe0jh9j4f_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073360
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n \
    \   lastChar := txt[len(txt)-1]\n    if lastChar >= 'a' && lastChar <= 'z' {\n\
    \        return true\n    }\n    if lastChar >= 'A' && lastChar <= 'Z' {\n   \
    \     return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgsgcsnif_test.go:25:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '@' || last == '&' ||\
    \ last == '%' || last == '^' || last == '*' || last == '(' || last == ')' || last\
    \ == '[' || last == ']' || last == '{' || last == '}' || last == '|' || last ==\
    \ '~' || last == '`' || last == '\"' || last == '$' || last == '#' || last ==\
    \ '@' || last == '$' || last == '%' || last == '^' || last == '&' || last == '*'\
    \ || last == '+' || last == '-' || last == '=' || last == '|' || last == '>' ||\
    \ last == '<' || last == '?' || last == '!' || last == '.' || last == '/' || last\
    \ == '\\\\' || last == '(' || last == ')' || last == '[' || last == ']' || last\
    \ == '{' || last == '}' || last == '|' || last == '~' || last == '`' || last ==\
    \ '\"' || last == '$' || last == '#' || last == '@' || last == '$' || last ==\
    \ '%' || last == '^' || last == '&' || last == '*' || last == '+' || last == '-'\
    \ || last == '=' || last == '|' || last == '>' || last == '<' || last == '?' ||\
    \ last == '!' || last == '.' || last == '/' || last == '\\\\' || last == '(' ||\
    \ last == ')' || last == '[' || last == ']' || last == '{' || last == '}' || last\
    \ == '|' || last == '~' || last == '`' || last == '\"' || last == '$' || last\
    \ == '#' || last == '@' || last == '$' || last == '%' || last == '^' || last ==\
    \ '&' || last == '*' || last == '+' || last == '-' || last == '=' || last == '|'\
    \ || last == '>' || last == '<' || last == '?' || last == '!' || last == '.' ||\
    \ last == '/' || last == '\\\\' || last == '(' || last == ')' || last == '[' ||\
    \ last == ']' || last == '{' || last == '}' || last == '|' || last == '~' || last\
    \ == '`' || last == '\"' || last == '$' || last == '#' || last == '@' || last\
    \ == '$' || last == '%' || last == '^' || last == '&' || last == '*' || \nfunc\
    \ TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq7igbvuh_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073360
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '@' || last == '#' ||\
    \ last == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last\
    \ == '(' || last == ')' || last == '-' || last == '_' || last == '+' || last ==\
    \ '=' || last == '|' || last == '}' || last == '{' || last == '[' || last == ']'\
    \ || last == '\\\\' || last == '|' || last == ';' || last == ':' || last == '\"\
    ' || last == '\\'' || last == '\"' || last == '<' || last == '>' || last == '?'\
    \ || last == '@' || last == '#' || last == '$' || last == '%' || last == '^' ||\
    \ last == '&' || last == '*' || last == '(' || last == ')' || last == '-' || last\
    \ == '_' || last == '+' || last == '=' || last == '|' || last == '}' || last ==\
    \ '{' || last == '[' || last == ']' || last == '\\\\' || last == '|' || last ==\
    \ ';' || last == ':' || last == '\"' || last == '\\'' || last == '\"' || last\
    \ == '<' || last == '>' || last == '?' || last == '@' || last == '#' || last ==\
    \ '$' || last == '%' || last == '^' || last == '&' || last == '*' || last == '('\
    \ || last == ')' || last == '-' || last == '_' || last == '+' || last == '=' ||\
    \ last == '|' || last == '}' || last == '{' || last == '[' || last == ']' || last\
    \ == '\\\\' || last == '|' || last == ';' || last == ':' || last == '\"' || last\
    \ == '\\'' || last == '\"' || last == '<' || last == '>' || last == '?' || last\
    \ == '@' || last == '#' || last == '$' || last == '%' || last == '^' || last ==\
    \ '&' || last == '*' || last == '(' || last == ')' || last == '-' || last == '_'\
    \ || last == '+' || last == '=' || last == '|' || last == '}' || last == '{' ||\
    \ last == '[' || last == ']' || last == '\\\\' || last == '|' || last == ';' ||\
    \ last == ':' || last == '\"' || last == '\\'' || last == '\"' || last == '<'\
    \ || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate :=\
    \ check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6gfgafnl_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073360
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n\
    \    txt := strings.ToLower(txt)\n    txt := strings.TrimSpace(txt)\n    txt :=\
    \ strings.ToUpper(txt)\n    txt := strings.Split(txt, \" \")\n    for _, word\
    \ := range txt {\n        if word == \"\" {\n            continue\n        }\n\
    \        if word[len(word)-1] == txt[len(txt)-1] {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptaajmlur_test.go:25:9: no new variables on left side of :=

    /tmp/tmptaajmlur_test.go:26:9: no new variables on left side of :=

    /tmp/tmptaajmlur_test.go:26:12: undefined: strings

    /tmp/tmptaajmlur_test.go:27:9: no new variables on left side of :=

    /tmp/tmptaajmlur_test.go:27:12: undefined: strings

    /tmp/tmptaajmlur_test.go:28:9: no new variables on left side of :=

    /tmp/tmptaajmlur_test.go:28:12: undefined: strings

    /tmp/tmptaajmlur_test.go:29:9: no new variables on left side of :=

    /tmp/tmptaajmlur_test.go:29:12: undefined: strings

    /tmp/tmptaajmlur_test.go:31:20: invalid operation: word == "" (mismatched types
    rune and untyped string)

    /tmp/tmptaajmlur_test.go:31:20: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073361
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 2 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   letters := []rune(\"abcdefghijklmnopqrstuvwxyz\")\n    for _, letter := range\
    \ letters {\n        if letter == last {\n            return false\n        }\n\
    \    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfe14_rfg_test.go:28:22: invalid operation: letter == last (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar != ' ' && lastChar != '-' && lastChar != '_' {\n        return\
    \ true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpwf85b3r3_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpwf85b3r3_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpwf85b3r3_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpwf85b3r3_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n\
    \    txt := strings.ToLower(txt)\n    for _, char := range txt {\n        if char\
    \ == ' ' || char == '-' || char == '_' || char == '.' || char == '_' || char ==\
    \ '-' || char == '_' || char == '.' || char == '_' || char == '-' || char == '_'\
    \ || char == '.' || char == '_' || char == '-' || char == '_' || char == '.' ||\
    \ char == '_' || char == '-' || char == '_' || char == '.' || char == '_' || char\
    \ == '-' || char == '_' || char == '.' || char == '_' || char == '-' || char ==\
    \ '_' || char == '.' || char == '_' || char == '-' || char == '_' || char == '.'\
    \ || char == '_' || char == '-' || char == '_' || char == '.' || char == '_' ||\
    \ char == '-' || char == '_' || char == '.' || char == '_' || char == '-' || char\
    \ == '_' || char == '.' || char == '_' || char == '-' || char == '_' || char ==\
    \ '.' || char == '_' || char == '-' || char == '_' || char == '.' || char == '_'\
    \ || char == '-' || char == '_' || char == '.' || char == '_' || char == '-' ||\
    \ char == '_' || char == '.' || char == '_' || char == '-' || char == '_' || char\
    \ == '.' || char == '_' || char == '-' || char == '_' || char == '.' || char ==\
    \ '_' || char == '-' || char == '_' || char == '.' || char == '_' || char == '-'\
    \ || char == '_' || char == '.' || char == '_' || char == '-' || char == '_' ||\
    \ char == '.' || char == '_' || char == '-' || char == '_' || char == '.' || char\
    \ == '_' || char == '-' || char == '_' || char == '.' || char == '_' || char ==\
    \ '-' || char == '_' || char == '.' || char == '_' || char == '-' || char == '_'\
    \ || char == '.' || char == '_' || char == '-' || char == '_' || char == '.' ||\
    \ char == '_' || char == '-' || char == '_' || char == '.' || char == '_' || char\
    \ == '-' || char == '_' || char == '.' || char == '_' || char == '-' || char ==\
    \ '_' || char == '.' || char == '_' || char == '-' || char == '_' || char == '.'\
    \ || char == '_' || char == '-' || char\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpczql_ven_test.go:29:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073360
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '\\'' || last == '\"' || last == ';' || last ==\
    \ '?' || last == '!' || last == '@' || last == '#' || last == '$' || last == '%'\
    \ || last == '^' || last == '&' || last == '*' || last == '(' || last == ')' ||\
    \ last == '+' || last == ',' || last == '{' || last == '}' || last == '|' || last\
    \ == ';' || last == '<' || last == '>' || last == '?' || last == '~' || last ==\
    \ '`' || last == '-' || last == '_' || last == '.' || last == '/' || last == '\\\
    \\' || last == '\\'' || last == '\"' || last == ';' || last == '?' || last ==\
    \ '!' || last == '@' || last == '#' || last == '$' || last == '%' || last == '^'\
    \ || last == '&' || last == '*' || last == '(' || last == ')' || last == '+' ||\
    \ last == ',' || last == '{' || last == '}' || last == '|' || last == ';' || last\
    \ == '<' || last == '>' || last == '?' || last == '~' || last == '`' || last ==\
    \ '-' || last == '_' || last == '.' || last == '/' || last == '\\\\' || last ==\
    \ '\\'' || last == '\"' || last == ';' || last == '?' || last == '!' || last ==\
    \ '@' || last == '#' || last == '$' || last == '%' || last == '^' || last == '&'\
    \ || last == '*' || last == '(' || last == ')' || last == '+' || last == ',' ||\
    \ last == '{' || last == '}' || last == '|' || last == ';' || last == '<' || last\
    \ == '>' || last == '?' || last == '~' || last == '`' || last == '-' || last ==\
    \ '_' || last == '.' || last == '/' || last == '\\\\' || last == '\\'' || last\
    \ == '\"' || last == ';' || last == '?' || last == '!' || last == '@' || last\
    \ == '#' || last == '$' || last == '%' || last == '^' || last == '&' || last ==\
    \ '*' || last == '(' || last == ')' || last == '+' || last == ',' || last == '{'\
    \ || last == '}' || last == '|' || last == ';' || last == '<' || last == '>' ||\
    \ last == '?' || last == '~' || last == '`' || last == '-' || last == '_' || \n\
    func TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvsfmh78r_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073360
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n \
    \   lastChar := txt[len(txt)-1]\n    if lastChar >= 'a' && lastChar <= 'z' {\n\
    \        return false\n    }\n    if lastChar >= 'A' && lastChar <= 'Z' {\n  \
    \      return false\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvkp7_cg0_test.go:25:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '@' || last == '&' ||\
    \ last == '*' || last == '+' || last == '%' || last == '$' || last == '#' || last\
    \ == '^' || last == '&' || last == '*' || last == '-' || last == '_' || last ==\
    \ '|' || last == '~' || last == '`' || last == '(' || last == ')' || last == '['\
    \ || last == ']' || last == '{' || last == '}' || last == ';' || last == ':' ||\
    \ last == '\"' || last == '\\'' || last == '<' || last == '>' || last == '?' ||\
    \ last == '@' || last == '&' || last == '*' || last == '+' || last == '%' || last\
    \ == '$' || last == '#' || last == '^' || last == '&' || last == '*' || last ==\
    \ '-' || last == '_' || last == '|' || last == '~' || last == '`' || last == '('\
    \ || last == ')' || last == '[' || last == ']' || last == '{' || last == '}' ||\
    \ last == ';' || last == ':' || last == '\"' || last == '\\'' || last == '<' ||\
    \ last == '>' || last == '?' || last == '@' || last == '&' || last == '*' || last\
    \ == '+' || last == '%' || last == '$' || last == '#' || last == '^' || last ==\
    \ '&' || last == '*' || last == '-' || last == '_' || last == '|' || last == '~'\
    \ || last == '`' || last == '(' || last == ')' || last == '[' || last == ']' ||\
    \ last == '{' || last == '}' || last == ';' || last == ':' || last == '\"' ||\
    \ last == '\\'' || last == '<' || last == '>' || last == '?' || last == '@' ||\
    \ last == '&' || last == '*' || last == '+' || last == '%' || last == '$' || last\
    \ == '#' || last == '^' || last == '&' || last == '*' || last == '-' || last ==\
    \ '_' || last == '|' || last == '~' || last == '`' || last == '(' || last == ')'\
    \ || last == '[' || last == ']' || last == '{' || last == '}' || last == ';' ||\
    \ last == ':' || last == '\"' || last == '\\'' || last == '<' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp64n6lovv_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073361
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n\
    \    lastChar := txt[len(txt)-1]\n    if lastChar >= 'a' && lastChar <= 'z' {\n\
    \        return false\n    }\n    if lastChar >= 'A' && lastChar <= 'Z' {\n  \
    \      return false\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpays__h22_test.go:25:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '!' || last == '?' || last == ';'\
    \ || last == '-' || last == '_' || last == '/' || last == '\\\\' || last == '$'\
    \ || last == '%' || last == '&' || last == '*' || last == '(' || last == ')' ||\
    \ last == '+' || last == '{' || last == '}' || last == '[' || last == ']' || last\
    \ == '|' || last == ';' || last == '<' || last == '>' || last == '?' || last ==\
    \ '@' || last == '^' || last == '~' || last == '`' || last == '\"' || last ==\
    \ '=' || last == '|' || last == ';' || last == '<' || last == '>' || last == '?'\
    \ || last == '@' || last == '^' || last == '~' || last == '`' || last == '\"'\
    \ || last == '=' || last == '|' || last == ';' || last == '<' || last == '>' ||\
    \ last == '?' || last == '@' || last == '^' || last == '~' || last == '`' || last\
    \ == '\"' || last == '=' || last == '|' || last == ';' || last == '<' || last\
    \ == '>' || last == '?' || last == '@' || last == '^' || last == '~' || last ==\
    \ '`' || last == '\"' || last == '=' || last == '|' || last == ';' || last ==\
    \ '<' || last == '>' || last == '?' || last == '@' || last == '^' || last == '~'\
    \ || last == '`' || last == '\"' || last == '=' || last == '|' || last == ';'\
    \ || last == '<' || last == '>' || last == '?' || last == '@' || last == '^' ||\
    \ last == '~' || last == '`' || last == '\"' || last == '=' || last == '|' ||\
    \ last == ';' || last == '<' || last == '>' || last == '?' || last == '@' || last\
    \ == '^' || last == '~' || last == '`' || last == '\"' || last == '=' || last\
    \ == '|' || last == ';' || last == '<' || last == '>' || last == '?' || last ==\
    \ '@' || last == '^' || last == '~' || last == '`' || last == '\"' || last ==\
    \ '=' || last == '|' || last == ';' || last == '<' || last == '>' || last == '?'\
    \ || last == '@' || last == '^' || last == '~' || last == '`' || last == '\"'\
    \ || last == '=' || last == '|' || last == ';' || last == '<' || last == '>' ||\
    \ \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_ptgcy5__test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == '<'\
    \ || last == '>' || last == '@' || last == '#' || last == '$' || last == '%' ||\
    \ last == '^' || last == '&' || last == '*' || last == '(' || last == ')' || last\
    \ == '=' || last == '+' || last == '{' || last == '}' || last == '|' || last ==\
    \ ';' || last == '\"' || last == '\\'' || last == '\"' || last == '?' || last\
    \ == ';' || last == '<' || last == '>' || last == '@' || last == '#' || last ==\
    \ '$' || last == '%' || last == '^' || last == '&' || last == '*' || last == '('\
    \ || last == ')' || last == '=' || last == '+' || last == '{' || last == '}' ||\
    \ last == '|' || last == ';' || last == '\"' || last == '\\'' || last == '\"'\
    \ || last == '?' || last == ';' || last == '<' || last == '>' || last == '@' ||\
    \ last == '#' || last == '$' || last == '%' || last == '^' || last == '&' || last\
    \ == '*' || last == '(' || last == ')' || last == '=' || last == '+' || last ==\
    \ '{' || last == '}' || last == '|' || last == ';' || last == '\"' || last ==\
    \ '\\'' || last == '\"' || last == '?' || last == ';' || last == '<' || last ==\
    \ '>' || last == '@' || last == '#' || last == '$' || last == '%' || last == '^'\
    \ || last == '&' || last == '*' || last == '(' || last == ')' || last == '=' ||\
    \ last == '+' || last == '{' || last == '}' || last == '|' || last == ';' || last\
    \ == '\"' || last == '\\'' || last == '\"' || last == '?' || last == ';' || last\
    \ == '<' || last == '>' || last == '@' || last == '#' || last == '$' || last ==\
    \ '%' || last == '^' || last == '&' || last == '*' || last == '(' || last == ')'\
    \ || last == '=' || last == '+' || last == '{' || last == '}' || last == '|' ||\
    \ last == ';' || last == '\"' || last == '\\'' || last == '\"' || last == '?'\
    \ || last == ';' || last == '<' || last == '>' || last == '@' || last == '#' ||\
    \ \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmposnohorw_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073362
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' {\n        return false\n    }\n    if last >= 'a' && last\
    \ <= 'z' || last >= 'A' && last <= 'Z' {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpu95m0mpw_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpu95m0mpw_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpu95m0mpw_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n\
    \    lastChar := txt[len(txt)-1]\n    if lastChar >= 'a' && lastChar <= 'z' {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8n8qb856_test.go:25:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073362
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '@' || last == '#' ||\
    \ last == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last\
    \ == '(' || last == ')' || last == '-' || last == '_' || last == '+' || last ==\
    \ '=' || last == '{' || last == '}' || last == '|' || last == ';' || last == '\"\
    ' || last == '\\'' || last == '\"' || last == '~' || last == ';' || last == ';'\
    \ || last == ';' || last == ';' || last == ';' || last == ';' || last == ';' ||\
    \ last == ';' || last == ';' || last == ';' || last == ';' || last == ';' || last\
    \ == ';' || last == ';' || last == ';' || last == ';' || last == ';' || last ==\
    \ ';' || last == ';' || last == ';' || last == ';' || last == ';' || last == ';'\
    \ || last == ';' || last == ';' || last == ';' || last == ';' || last == ';' ||\
    \ last == ';' || last == ';' || last == ';' || last == ';' || last == ';' || last\
    \ == ';' || last == ';' || last == ';' || last == ';' || last == ';' || last ==\
    \ ';' || last == ';' || last == ';' || last == ';' || last == ';' || last == ';'\
    \ || last == ';' || last == ';' || last == ';' || last == ';' || last == ';' ||\
    \ last == ';' || last == ';' || last == ';' || last == ';' || last == ';' || last\
    \ == ';' || last == ';' || last == ';' || last == ';' || last == ';' || last ==\
    \ ';' || last == ';' || last == ';' || last == ';' || last == ';' || last == ';'\
    \ || last == ';' || last == ';' || last == ';' || last == ';' || last == ';' ||\
    \ last == ';' || last == ';' || last == ';' || last == ';' || last == ';' || last\
    \ == ';' || last == ';' || last == ';' || last == ';' || last == ';' || last ==\
    \ ';' || last == ';' || last == ';' || last == ';' || last == ';' || last == ';'\
    \ || last == ';' || last == ';' || last == ';' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphft4_tu8_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073362
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' {\n      \
    \  return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    for _, letter := range []rune(txt) {\n \
    \       if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' ||\
    \ letter == 'u' {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpt2tw0rsj_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n\
    \  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi\
    \ e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false\
    \ },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"\
    Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"\
    apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpzvsxd069_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' {\n        return true\n   \
    \ }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp7dxygx6g_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp7dxygx6g_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp7dxygx6g_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp7dxygx6g_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return true\n    }\n   \
    \ if lastChar >= 'A' && lastChar <= 'Z' {\n        return true\n    }\n    if\
    \ lastChar >= '0' && lastChar <= '9' {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpi7zsh6_u_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpi7zsh6_u_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpi7zsh6_u_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpi7zsh6_u_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar != ' ' {\n        return true\n    }\n    words := strings.Split(txt,\
    \ \" \")\n    for _, word := range words {\n        if strings.Contains(word,\
    \ lastChar) {\n            return false\n        }\n    }\n    return true\n}\n\
    \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpto86mv9n_test.go:29:14: undefined: strings

    /tmp/tmpto86mv9n_test.go:31:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073362
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n\
    \  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi\
    \ e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false\
    \ },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"\
    Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"\
    apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpjtmotk8d_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpjtmotk8d_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpjtmotk8d_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpjtmotk8d_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpjtmotk8d_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpgwx0jlu__test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpgwx0jlu__test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpgwx0jlu__test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpgwx0jlu__test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpgwx0jlu__test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpgwx0jlu__test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '?' || last == '!' || last == '@' || last == '#'\
    \ || last == '$' || last == '%' || last == '^' || last == '&' || last == '*' ||\
    \ last == '(' || last == ')' || last == '-' || last == '+' {\n        return false\n\
    \    }\n    if last >= 'a' && last <= 'z' || last >= 'A' && last <= 'Z' {\n  \
    \      return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmpv6dawn36_test.go:26:38: redundant or: last == ''-'' || last == ''-''

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073363
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar != ' ' {\n        return true\n    }\n    words := strings.Split(txt,\
    \ \" \")\n    for _, word := range words {\n        if lastChar == word[len(word)-1]\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjh6qh6ck_test.go:29:14: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == '<'\
    \ || last == '>' || last == '?' || last == '!' || last == '@' || last == '#' ||\
    \ last == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last\
    \ == '(' || last == ')' || last == '+' || last == ',' || last == '-' || last ==\
    \ '.' || last == '/' || last == '\\\\' || last == '_' || last == '{' || last ==\
    \ '}' || last == '|' || last == ';' || last == '?' || last == '!' || last == '@'\
    \ || last == '#' || last == '$' || last == '%' || last == '^' || last == '&' ||\
    \ last == '*' || last == '(' || last == ')' || last == '+' || last == ',' || last\
    \ == '-' || last == '.' || last == '/' || last == '\\\\' || last == '_' || last\
    \ == '{' || last == '}' || last == '|' || last == ';' || last == '?' || last ==\
    \ '!' || last == '@' || last == '#' || last == '$' || last == '%' || last == '^'\
    \ || last == '&' || last == '*' || last == '(' || last == ')' || last == '+' ||\
    \ last == ',' || last == '-' || last == '.' || last == '/' || last == '\\\\' ||\
    \ last == '_' || last == '{' || last == '}' || last == '|' || last == ';' || last\
    \ == '?' || last == '!' || last == '@' || last == '#' || last == '$' || last ==\
    \ '%' || last == '^' || last == '&' || last == '*' || last == '(' || last == ')'\
    \ || last == '+' || last == ',' || last == '-' || last == '.' || last == '/' ||\
    \ last == '\\\\' || last == '_' || last == '{' || last == '}' || last == '|' ||\
    \ last == ';' || last == '?' || last == '!' || last == '@' || last == '#' || last\
    \ == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last ==\
    \ '(' || last == ')' || last == '+' || last == ',' || last == '-' || last == '.'\
    \ || last == '/' || last == '\\\\' || last == '_' || last == '{' || last == '}'\
    \ || last == '|' || last == ';' || last == '?' || last == '!' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxz99t1qb_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073362
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '\\'' || last == '\"' || last == ';' || last ==\
    \ '?' || last == '!' || last == '@' || last == '#' || last == '$' || last == '%'\
    \ || last == '^' || last == '&' || last == '*' || last == '(' || last == ')' ||\
    \ last == '+' || last == ',' || last == '-' || last == '.' || last == '/' || last\
    \ == '\\\\' || last == '\\'' || last == '\"' || last == ';' || last == '?' ||\
    \ last == '!' || last == '@' || last == '#' || last == '$' || last == '%' || last\
    \ == '^' || last == '&' || last == '*' || last == '(' || last == ')' || last ==\
    \ '+' || last == ',' || last == '-' || last == '.' || last == '/' || last == '\\\
    \\' || last == '\\'' || last == '\"' || last == ';' || last == '?' || last ==\
    \ '!' || last == '@' || last == '#' || last == '$' || last == '%' || last == '^'\
    \ || last == '&' || last == '*' || last == '(' || last == ')' || last == '+' ||\
    \ last == ',' || last == '-' || last == '.' || last == '/' || last == '\\\\' ||\
    \ last == '\\'' || last == '\"' || last == ';' || last == '?' || last == '!' ||\
    \ last == '@' || last == '#' || last == '$' || last == '%' || last == '^' || last\
    \ == '&' || last == '*' || last == '(' || last == ')' || last == '+' || last ==\
    \ ',' || last == '-' || last == '.' || last == '/' || last == '\\\\' || last ==\
    \ '\\'' || last == '\"' || last == ';' || last == '?' || last == '!' || last ==\
    \ '@' || last == '#' || last == '$' || last == '%' || last == '^' || last == '&'\
    \ || last == '*' || last == '(' || last == ')' || last == '+' || last == ',' ||\
    \ last == '-' || last == '.' || last == '/' || last == '\\\\' || last == '\\''\
    \ || last == '\"' || last == ';' || last == '?' || last == '!' || last == '@'\
    \ || last == '#' || last == '$' || last == '%' || last == '^' || last == '&' ||\
    \ last == '*' || last == '(' || last == ')' || last == '+' || last == ',' || last\
    \ == '-' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8mleeuh2_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073362
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' || last >= 'A' && last <= 'Z'\
    \ {\n        return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpphudcn9p_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpphudcn9p_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpphudcn9p_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return true\n    }\n   \
    \ if lastChar >= 'A' && lastChar <= 'Z' {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmppk8fmie0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmppk8fmie0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmppk8fmie0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n\
    \  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi\
    \ e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false\
    \ },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"\
    Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"\
    apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpzvsxd069_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    for _, letter := range txt {\n        if\
    \ letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter ==\
    \ 'u' {\n            return false\n        }\n    }\n    return true\n}\n\nfunc\
    \ TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpnzj7pr77_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    if txt[len(txt)-1] == '_'\
    \ {\n        return false\n    }\n    if txt[len(txt)-1] == ' ' {\n        return\
    \ false\n    }\n    if txt[len(txt)-1] == '-' {\n        return false\n    }\n\
    \    if txt[len(txt)-1] == '.' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '!' {\n        return false\n    }\n    if txt[len(txt)-1] == '?' {\n   \
    \     return false\n    }\n    if txt[len(txt)-1] == '\\'' {\n        return false\n\
    \    }\n    if txt[len(txt)-1] == '\\\"' {\n        return false\n    }\n    if\
    \ txt[len(txt)-1] == '$' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '%' {\n        return false\n    }\n    if txt[len(txt)-1] == '&' {\n   \
    \     return false\n    }\n    if txt[len(txt)-1] == '\\'' {\n        return false\n\
    \    }\n    if txt[len(txt)-1] == '(' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == ')' {\n        return false\n    }\n    if txt[len(txt)-1] == '*' {\n   \
    \     return false\n    }\n    if txt[len(txt)-1] == '+' {\n        return false\n\
    \    }\n    if txt[len(txt)-1] == ',' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '-' {\n        return false\n    }\n    if txt[len(txt)-1] == '.' {\n   \
    \     return false\n    }\n    if txt[len(txt)-1] == '/' {\n        return false\n\
    \    }\n    if txt[len(txt)-1] == '0' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '1' {\n        return false\n    }\n    if txt[len(txt)-1] == '2' {\n   \
    \     return false\n    }\n    if txt[len(txt)-1] == '3' {\n        return false\n\
    \    }\n    if txt[len(txt)-1] == '4' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '5' {\n        return false\n    }\n    if txt[len(txt)-1] == '6' {\n   \
    \     return false\n    }\n    if txt[len(txt)-1] == '7' {\n        return false\n\
    \    }\n    if txt[len(txt)-1] == '8' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '9' {\n        return false\n    }\n    if txt[len(txt)-1] == ':' {\n   \
    \     return false\n    }\n    if txt[len(txt)-1] == ';' {\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpj5jxwtyy_test.go:46:29: unknown escape sequence

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '@' || last == '#' ||\
    \ last == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last\
    \ == '(' || last == ')' || last == '_' || last == '+' || last == ',' || last ==\
    \ '{' || last == '}' || last == '|' || last == '\\\\' || last == ';' || last ==\
    \ '\"' || last == '\\'' || last == '\"' || last == '(' || last == ')' || last\
    \ == '[' || last == ']' || last == '{' || last == '}' || last == '|' || last ==\
    \ ';' || last == '\"' || last == '\\'' || last == '\"' || last == '(' || last\
    \ == ')' || last == '[' || last == ']' || last == '{' || last == '}' || last ==\
    \ '|' || last == ';' || last == '\"' || last == '\\'' || last == '\"' || last\
    \ == '(' || last == ')' || last == '[' || last == ']' || last == '{' || last ==\
    \ '}' || last == '|' || last == ';' || last == '\"' || last == '\\'' || last ==\
    \ '\"' || last == '(' || last == ')' || last == '[' || last == ']' || last ==\
    \ '{' || last == '}' || last == '|' || last == ';' || last == '\"' || last ==\
    \ '\\'' || last == '\"' || last == '(' || last == ')' || last == '[' || last ==\
    \ ']' || last == '{' || last == '}' || last == '|' || last == ';' || last == '\"\
    ' || last == '\\'' || last == '\"' || last == '(' || last == ')' || last == '['\
    \ || last == ']' || last == '{' || last == '}' || last == '|' || last == ';' ||\
    \ last == '\"' || last == '\\'' || last == '\"' || last == '(' || last == ')'\
    \ || last == '[' || last == ']' || last == '{' || last == '}' || last == '|' ||\
    \ last == ';' || last == '\"' || last == '\\'' || last == '\"' || last == '('\
    \ || last == ')' || last == '[' || last == ']' || last == '{' || last == '}' ||\
    \ last == '|' || last == ';' || last == '\"' || last == '\\'' || last == '\"'\
    \ || last == '(' || last == ')' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0exy27e4_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n\
    \  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi\
    \ e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false\
    \ },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"\
    Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"\
    apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpzvsxd069_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpzm09ia_i_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' {\n      \
    \  return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '?' || last == '!' || last == '@' || last == '#'\
    \ || last == '$' || last == '%' || last == '^' || last == '&' || last == '*' ||\
    \ last == '(' || last == ')' || last == '-' || last == '_' || last == '+' || last\
    \ == '=' || last == '[' || last == ']' || last == '{' || last == '}' || last ==\
    \ '|' || last == ';' || last == '<' || last == '>' || last == '?' || last == '/'\
    \ || last == '\\\\' || last == '|' || last == ';' || last == '<' || last == '>'\
    \ || last == '?' || last == '/' || last == '\\\\' || last == '|' || last == ';'\
    \ || last == '<' || last == '>' || last == '?' || last == '/' || last == '\\\\\
    ' || last == '|' || last == ';' || last == '<' || last == '>' || last == '?' ||\
    \ last == '/' || last == '\\\\' || last == '|' || last == ';' || last == '<' ||\
    \ last == '>' || last == '?' || last == '/' || last == '\\\\' || last == '|' ||\
    \ last == ';' || last == '<' || last == '>' || last == '?' || last == '/' || last\
    \ == '\\\\' || last == '|' || last == ';' || last == '<' || last == '>' || last\
    \ == '?' || last == '/' || last == '\\\\' || last == '|' || last == ';' || last\
    \ == '<' || last == '>' || last == '?' || last == '/' || last == '\\\\' || last\
    \ == '|' || last == ';' || last == '<' || last == '>' || last == '?' || last ==\
    \ '/' || last == '\\\\' || last == '|' || last == ';' || last == '<' || last ==\
    \ '>' || last == '?' || last == '/' || last == '\\\\' || last == '|' || last ==\
    \ ';' || last == '<' || last == '>' || last == '?' || last == '/' || last == '\\\
    \\' || last == '|' || last == ';' || last == '<' || last == '>' || last == '?'\
    \ || last == '/' || last == '\\\\' || last == '|' || last == ';' || last == '<'\
    \ || last == '>' || last == '?' || last == '/' || last == '\\\\' || last == '|'\
    \ || last == ';' || last == '<' || last == '>' || last == '?' || last == '/' ||\
    \ last == '\\\\' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n\
    \  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi\
    \ e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false\
    \ },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"\
    Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"\
    apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe2gevyrn_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar != ' ' && lastChar != '-' && lastChar != '_' && lastChar != '/'\
    \ {\n        return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmppvp5ubr0_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmppvp5ubr0_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmppvp5ubr0_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmppvp5ubr0_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' {\n      \
    \  return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp93rcthdh_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp93rcthdh_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp93rcthdh_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp93rcthdh_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073362
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' {\n      \
    \  return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n\
    \    lastChar := txt[len(txt)-1]\n    if lastChar >= 'a' && lastChar <= 'z' {\n\
    \        return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnutk3ets_test.go:25:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == '<'\
    \ || last == '>' || last == '@' || last == '#' || last == '$' || last == '%' ||\
    \ last == '^' || last == '&' || last == '*' || last == '(' || last == ')' || last\
    \ == '+' || last == ',' || last == '-' || last == '.' || last == '/' || last ==\
    \ '\\\\' || last == '!' || last == '?' || last == ';' || last == '<' || last ==\
    \ '>' || last == '@' || last == '#' || last == '$' || last == '%' || last == '^'\
    \ || last == '&' || last == '*' || last == '(' || last == ')' || last == '+' ||\
    \ last == ',' || last == '-' || last == '.' || last == '/' || last == '\\\\' ||\
    \ last == '!' || last == '?' || last == ';' || last == '<' || last == '>' || last\
    \ == '@' || last == '#' || last == '$' || last == '%' || last == '^' || last ==\
    \ '&' || last == '*' || last == '(' || last == ')' || last == '+' || last == ','\
    \ || last == '-' || last == '.' || last == '/' || last == '\\\\' || last == '!'\
    \ || last == '?' || last == ';' || last == '<' || last == '>' || last == '@' ||\
    \ last == '#' || last == '$' || last == '%' || last == '^' || last == '&' || last\
    \ == '*' || last == '(' || last == ')' || last == '+' || last == ',' || last ==\
    \ '-' || last == '.' || last == '/' || last == '\\\\' || last == '!' || last ==\
    \ '?' || last == ';' || last == '<' || last == '>' || last == '@' || last == '#'\
    \ || last == '$' || last == '%' || last == '^' || last == '&' || last == '*' ||\
    \ last == '(' || last == ')' || last == '+' || last == ',' || last == '-' || last\
    \ == '.' || last == '/' || last == '\\\\' || last == '!' || last == '?' || last\
    \ == ';' || last == '<' || last == '>' || last == '@' || last == '#' || last ==\
    \ '$' || last == '%' || last == '^' || last == '&' || last == '*' || last == '('\
    \ || last == ')' || last == '+' || last == ',' || last == '-' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7p_mds3y_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpzm09ia_i_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '?' || last == '!' || last == '@' || last == '$'\
    \ || last == '%' || last == '^' || last == '&' || last == '*' || last == '(' ||\
    \ last == ')' || last == '+' || last == ',' || last == '{' || last == '}' || last\
    \ == '|' || last == ';' || last == ':' || last == '<' || last == '>' || last ==\
    \ '?' || last == '[' || last == ']' || last == '\\\\' || last == '^' || last ==\
    \ '`' || last == '~' || last == '`' || last == '-' || last == '.' || last == '_'\
    \ || last == '/' || last == '\\\\' || last == '?' || last == '!' || last == '@'\
    \ || last == '$' || last == '%' || last == '^' || last == '&' || last == '*' ||\
    \ last == '(' || last == ')' || last == '+' || last == ',' || last == '{' || last\
    \ == '}' || last == '|' || last == ';' || last == ':' || last == '<' || last ==\
    \ '>' || last == '?' || last == '[' || last == ']' || last == '\\\\' || last ==\
    \ '^' || last == '`' || last == '~' || last == '`' || last == '-' || last == '.'\
    \ || last == '_' || last == '/' || last == '\\\\' || last == '?' || last == '!'\
    \ || last == '@' || last == '$' || last == '%' || last == '^' || last == '&' ||\
    \ last == '*' || last == '(' || last == ')' || last == '+' || last == ',' || last\
    \ == '{' || last == '}' || last == '|' || last == ';' || last == ':' || last ==\
    \ '<' || last == '>' || last == '?' || last == '[' || last == ']' || last == '\\\
    \\' || last == '^' || last == '`' || last == '~' || last == '`' || last == '-'\
    \ || last == '.' || last == '_' || last == '/' || last == '\\\\' || last == '?'\
    \ || last == '!' || last == '@' || last == '$' || last == '%' || last == '^' ||\
    \ last == '&' || last == '*' || last == '(' || last == ')' || last == '+' || last\
    \ == ',' || last == '{' || last == '}' || last == '|' || last == ';' || last ==\
    \ ':' || last == '<' || last == '>' || last == '?' || last == '[' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp521h3wyf_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n\
    \    txt := strings.ToLower(txt)\n    txt := strings.TrimSpace(txt)\n    txt :=\
    \ strings.TrimSuffix(txt, \" \")\n    txt := strings.TrimPrefix(txt, \" \")\n\
    \    txt := strings.ToUpper(txt)\n    txt := strings.ToLower(txt)\n    txt :=\
    \ strings.TrimSpace(txt)\n    txt := strings.TrimSuffix(txt, \" \")\n    txt :=\
    \ strings.TrimPrefix(txt, \" \")\n    txt := strings.ToUpper(txt)\n    txt :=\
    \ strings.ToLower(txt)\n    txt := strings.TrimSpace(txt)\n    txt := strings.TrimSuffix(txt,\
    \ \" \")\n    txt := strings.TrimPrefix(txt, \" \")\n    txt := strings.ToUpper(txt)\n\
    \    txt := strings.ToLower(txt)\n    txt := strings.TrimSpace(txt)\n    txt :=\
    \ strings.TrimSuffix(txt, \" \")\n    txt := strings.TrimPrefix(txt, \" \")\n\
    \    txt := strings.ToUpper(txt)\n    txt := strings.ToLower(txt)\n    txt :=\
    \ strings.TrimSpace(txt)\n    txt := strings.TrimSuffix(txt, \" \")\n    txt :=\
    \ strings.TrimPrefix(txt, \" \")\n    txt := strings.ToUpper(txt)\n    txt :=\
    \ strings.ToLower(txt)\n    txt := strings.TrimSpace(txt)\n    txt := strings.TrimSuffix(txt,\
    \ \" \")\n    txt := strings.TrimPrefix(txt, \" \")\n    txt := strings.ToUpper(txt)\n\
    \    txt := strings.ToLower(txt)\n    txt := strings.TrimSpace(txt)\n    txt :=\
    \ strings.TrimSuffix(txt, \" \")\n    txt := strings.TrimPrefix(txt, \" \")\n\
    \    txt := strings.ToUpper(txt)\n    txt := strings.ToLower(txt)\n    txt :=\
    \ strings.TrimSpace(txt)\n    txt := strings.TrimSuffix(txt, \" \")\n    txt :=\
    \ strings.TrimPrefix(txt, \" \")\n    txt := strings.ToUpper(txt)\n    txt :=\
    \ strings.ToLower(txt)\n    txt := strings.TrimSpace(txt)\n    txt := strings.TrimSuffix(txt,\
    \ \" \")\n    txt := strings.TrimPrefix(txt, \" \")\n    txt := strings.ToUpper(\n\
    func TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa67z2iq9_test.go:71:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' || last >=\
    \ 'A' && last <= 'Z' {\n        return true\n    }\n    return false\n}\n\nfunc\
    \ TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpenj5ppmg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpenj5ppmg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpenj5ppmg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '?' || last == '!' || last == '@' || last == '#'\
    \ || last == '$' || last == '%' || last == '^' || last == '&' || last == '*' ||\
    \ last == '(' || last == ')' || last == '-' || last == '_' || last == '+' || last\
    \ == '=' || last == '|' || last == '}' || last == '{' || last == '[' || last ==\
    \ ']' || last == '<' || last == '>' || last == '?' || last == '/' || last == '\\\
    \\' || last == '|' || last == ';' || last == '\"' || last == '\\'' || last ==\
    \ ';' || last == '.' || last == '-' || last == '_' || last == '+' || last == '='\
    \ || last == '|' || last == '}' || last == '{' || last == '[' || last == ']' ||\
    \ last == '<' || last == '>' || last == '?' || last == '/' || last == '\\\\' ||\
    \ last == '|' || last == ';' || last == '\"' || last == '\\'' || last == ';' ||\
    \ last == '.' || last == '-' || last == '_' || last == '+' || last == '=' || last\
    \ == '|' || last == '}' || last == '{' || last == '[' || last == ']' || last ==\
    \ '<' || last == '>' || last == '?' || last == '/' || last == '\\\\' || last ==\
    \ '|' || last == ';' || last == '\"' || last == '\\'' || last == ';' || last ==\
    \ '.' || last == '-' || last == '_' || last == '+' || last == '=' || last == '|'\
    \ || last == '}' || last == '{' || last == '[' || last == ']' || last == '<' ||\
    \ last == '>' || last == '?' || last == '/' || last == '\\\\' || last == '|' ||\
    \ last == ';' || last == '\"' || last == '\\'' || last == ';' || last == '.' ||\
    \ last == '-' || last == '_' || last == '+' || last == '=' || last == '|' || last\
    \ == '}' || last == '{' || last == '[' || last == ']' || last == '<' || last ==\
    \ '>' || last == '?' || last == '/' || last == '\\\\' || last == '|' || last ==\
    \ ';' || last == '\"' || last == '\\'' || last == ';' || last == '.' || last ==\
    \ '-' || last == '_' || last == '+' || last == '=' || last == '|' || last == '}'\
    \ || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate :=\
    \ check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp62816s8c_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' {\n        return false\n    }\n    if last >= 'a' && last\
    \ <= 'z' || last >= 'A' && last <= 'Z' {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpf7ayz4m3_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpf7ayz4m3_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpf7ayz4m3_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073365
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == '@'\
    \ || last == '#' || last == '$' || last == '%' || last == '^' || last == '&' ||\
    \ last == '*' || last == '(' || last == ')' || last == '-' || last == '+' {\n\
    \        return false\n    }\n    for _, c := range txt {\n        if c >= 'a'\
    \ && c <= 'z' || c >= 'A' && c <= 'Z' {\n            return false\n        }\n\
    \    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test

    /tmp/tmp1lu9ukld_test.go:26:38: redundant or: last == ''-'' || last == ''-''

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073365
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n \
    \   lastChar := txt[len(txt)-1]\n    if lastChar >= 'a' && lastChar <= 'z' {\n\
    \        return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpk44yr9f7_test.go:25:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073365
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '?' || last == '!' || last == '@' || last == '#'\
    \ || last == '$' || last == '%' || last == '^' || last == '&' || last == '*' ||\
    \ last == '(' || last == ')' || last == '+' || last == ',' || last == '{' || last\
    \ == '}' || last == '|' || last == ';' || last == ':' || last == '<' || last ==\
    \ '>' || last == '?' || last == '~' || last == '`' || last == '-' || last == '.'\
    \ || last == '_' || last == '/' || last == '\\\\' || last == '?' || last == '!'\
    \ || last == '@' || last == '#' || last == '$' || last == '%' || last == '^' ||\
    \ last == '&' || last == '*' || last == '(' || last == ')' || last == '+' || last\
    \ == ',' || last == '{' || last == '}' || last == '|' || last == ';' || last ==\
    \ ':' || last == '<' || last == '>' || last == '?' || last == '~' || last == '`'\
    \ || last == '-' || last == '.' || last == '_' || last == '/' || last == '\\\\\
    ' || last == '?' || last == '!' || last == '@' || last == '#' || last == '$' ||\
    \ last == '%' || last == '^' || last == '&' || last == '*' || last == '(' || last\
    \ == ')' || last == '+' || last == ',' || last == '{' || last == '}' || last ==\
    \ '|' || last == ';' || last == ':' || last == '<' || last == '>' || last == '?'\
    \ || last == '~' || last == '`' || last == '-' || last == '.' || last == '_' ||\
    \ last == '/' || last == '\\\\' || last == '?' || last == '!' || last == '@' ||\
    \ last == '#' || last == '$' || last == '%' || last == '^' || last == '&' || last\
    \ == '*' || last == '(' || last == ')' || last == '+' || last == ',' || last ==\
    \ '{' || last == '}' || last == '|' || last == ';' || last == ':' || last == '<'\
    \ || last == '>' || last == '?' || last == '~' || last == '`' || last == '-' ||\
    \ last == '.' || last == '_' || last == '/' || last == '\\\\' || last == '?' ||\
    \ last == '!' || last == '@' || last == '#' || last == '$' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxy8zrnhf_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '!' || last == '?' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' {\n        return true\n   \
    \ }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpa4enll0b_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpa4enll0b_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpa4enll0b_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpa4enll0b_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073365
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' {\n        return false\n    }\n    if last >= 'a' && last\
    \ <= 'z' || last >= 'A' && last <= 'Z' {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpf7ayz4m3_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpf7ayz4m3_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpf7ayz4m3_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073365
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpzm09ia_i_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073364
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 2 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   lastIsLetter := false\n    for _, letter := range last {\n        if letter\
    \ == 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n\
    \            lastIsLetter = true\n        }\n    }\n    return !lastIsLetter\n\
    }\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp770ka2vb_test.go:27:28: cannot range over last (variable of type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073365
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    last := last[:len(last)-1]\n    for _, c\
    \ := range last {\n        if !isAlphaNumeric(c) {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2ac1y5z__test.go:29:10: no new variables on left side of :=

    /tmp/tmp2ac1y5z__test.go:29:13: invalid operation: cannot slice last (variable
    of type byte)

    /tmp/tmp2ac1y5z__test.go:30:23: cannot range over last (variable of type byte)

    /tmp/tmp2ac1y5z__test.go:31:13: undefined: isAlphaNumeric

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073365
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n\
    \    txt := strings.ToLower(txt)\n    txt := strings.TrimSpace(txt)\n    txt :=\
    \ strings.Trim(txt, \" \")\n    return len(txt) > 0 && strings.ContainsAny(txt,\
    \ []rune(\"abcdefghijklmnopqrstuvwxyz\"))\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4pv9rffm_test.go:25:9: no new variables on left side of :=

    /tmp/tmp4pv9rffm_test.go:26:9: no new variables on left side of :=

    /tmp/tmp4pv9rffm_test.go:26:12: undefined: strings

    /tmp/tmp4pv9rffm_test.go:27:9: no new variables on left side of :=

    /tmp/tmp4pv9rffm_test.go:27:12: undefined: strings

    /tmp/tmp4pv9rffm_test.go:28:9: no new variables on left side of :=

    /tmp/tmp4pv9rffm_test.go:28:12: undefined: strings

    /tmp/tmp4pv9rffm_test.go:29:28: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073365
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 2 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   last := last[:1]\n    if last == ' ' || last == '.' || last == '-' || last\
    \ == '_' || last == '/' {\n        return false\n    }\n    for _, letter := range\
    \ txt {\n        if letter == last {\n            return false\n        }\n  \
    \  }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmps9yzl4dw_test.go:26:10: no new variables on left side of :=

    /tmp/tmps9yzl4dw_test.go:26:13: invalid operation: cannot slice last (variable
    of type byte)

    /tmp/tmps9yzl4dw_test.go:31:22: invalid operation: letter == last (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073365
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '!' || last == '?' || last == ';'\
    \ || last == '-' || last == '_' || last == '/' || last == '\\\\' || last == '$'\
    \ || last == '%' || last == '&' || last == '*' || last == '(' || last == ')' ||\
    \ last == '+' || last == '{' || last == '}' || last == '[' || last == ']' || last\
    \ == '<' || last == '>' || last == '|' || last == ';' || last == '?' || last ==\
    \ '.' || last == '!' || last == '?' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '$' || last == '%' || last == '&' || last == '*'\
    \ || last == '(' || last == ')' || last == '+' || last == '{' || last == '}' ||\
    \ last == '[' || last == ']' || last == '<' || last == '>' || last == '|' || last\
    \ == ';' || last == '?' || last == '.' || last == '!' || last == '?' || last ==\
    \ '-' || last == '_' || last == '/' || last == '\\\\' || last == '$' || last ==\
    \ '%' || last == '&' || last == '*' || last == '(' || last == ')' || last == '+'\
    \ || last == '{' || last == '}' || last == '[' || last == ']' || last == '<' ||\
    \ last == '>' || last == '|' || last == ';' || last == '?' || last == '.' || last\
    \ == '!' || last == '?' || last == '-' || last == '_' || last == '/' || last ==\
    \ '\\\\' || last == '$' || last == '%' || last == '&' || last == '*' || last ==\
    \ '(' || last == ')' || last == '+' || last == '{' || last == '}' || last == '['\
    \ || last == ']' || last == '<' || last == '>' || last == '|' || last == ';' ||\
    \ last == '?' || last == '.' || last == '!' || last == '?' || last == '-' || last\
    \ == '_' || last == '/' || last == '\\\\' || last == '$' || last == '%' || last\
    \ == '&' || last == '*' || last == '(' || last == ')' || last == '+' || last ==\
    \ '{' || last == '}' || last == '[' || last == ']' || last == '<' || last == '>'\
    \ || last == '|' || last == ';' || last == '?' || last == '.' || last == '!' ||\
    \ last == '?' || last == '-' || last == '_' || last == '/' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpscpokl09_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return true\n    }\n   \
    \ if lastChar >= 'A' && lastChar <= 'Z' {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmppk8fmie0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmppk8fmie0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmppk8fmie0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '\\'' || last == '\"' || last == ';' || last ==\
    \ '?' || last == '!' || last == '@' || last == '$' || last == '%' || last == '^'\
    \ || last == '&' || last == '*' || last == '(' || last == ')' || last == '+' ||\
    \ last == ',' || last == '{' || last == '}' || last == '|' || last == ';' || last\
    \ == '<' || last == '>' || last == '?' || last == '!' || last == '~' || last ==\
    \ '`' || last == '-' || last == '_' || last == '.' || last == '/' || last == '\\\
    \\' || last == '\\'' || last == '\"' || last == ';' || last == '?' || last ==\
    \ '!' || last == '~' || last == '`' || last == '-' || last == '_' || last == '.'\
    \ || last == '/' || last == '\\\\' || last == '\\'' || last == '\"' || last ==\
    \ ';' || last == '?' || last == '!' || last == '~' || last == '`' || last == '-'\
    \ || last == '_' || last == '.' || last == '/' || last == '\\\\' || last == '\\\
    '' || last == '\"' || last == ';' || last == '?' || last == '!' || last == '~'\
    \ || last == '`' || last == '-' || last == '_' || last == '.' || last == '/' ||\
    \ last == '\\\\' || last == '\\'' || last == '\"' || last == ';' || last == '?'\
    \ || last == '!' || last == '~' || last == '`' || last == '-' || last == '_' ||\
    \ last == '.' || last == '/' || last == '\\\\' || last == '\\'' || last == '\"\
    ' || last == ';' || last == '?' || last == '!' || last == '~' || last == '`' ||\
    \ last == '-' || last == '_' || last == '.' || last == '/' || last == '\\\\' ||\
    \ last == '\\'' || last == '\"' || last == ';' || last == '?' || last == '!' ||\
    \ last == '~' || last == '`' || last == '-' || last == '_' || last == '.' || last\
    \ == '/' || last == '\\\\' || last == '\\'' || last == '\"' || last == ';' ||\
    \ last == '?' || last == '!' || last == '~' || last == '`' || last == '-' || last\
    \ == '_' || last == '.' || last == '/' || last == '\\\\' || last == '\\'' || last\
    \ == '\"' || last == ';' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqbtyhmfs_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    lastChar := last\n    if lastChar == 'a'\
    \ || lastChar == 'e' || lastChar == 'i' || lastChar == 'o' || lastChar == 'u'\
    \ {\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpx_u6e37k_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpx_u6e37k_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073366
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' {\n        return false\n    }\n    if last >= 'a' && last\
    \ <= 'z' {\n        return true\n    }\n    if last >= 'A' && last <= 'Z' {\n\
    \        return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmphv4jpv2w_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmphv4jpv2w_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmphv4jpv2w_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073366
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' || last >=\
    \ 'A' && last <= 'Z' {\n        return true\n    }\n    return false\n}\n\nfunc\
    \ TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpenj5ppmg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpenj5ppmg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpenj5ppmg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    if txt[len(txt)-1] == ' '\
    \ {\n        return false\n    }\n    if txt[len(txt)-1] >= 'a' && txt[len(txt)-1]\
    \ <= 'z' {\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpgwdbz8n3_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpgwdbz8n3_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073366
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    if txt[len(txt)-1] >= 'a'\
    \ && txt[len(txt)-1] <= 'z' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ >= 'A' && txt[len(txt)-1] <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpmq42160q_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpmq42160q_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpmq42160q_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpmq42160q_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpmq42160q_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpmq42160q_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073366
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar != ' ' {\n        return true\n    }\n    lastChar = txt[len(txt)-2]\n\
    \    if lastChar != ' ' {\n        return true\n    }\n    lastChar = txt[len(txt)-3]\n\
    \    if lastChar != ' ' {\n        return true\n    }\n    lastChar = txt[len(txt)-4]\n\
    \    if lastChar != ' ' {\n        return true\n    }\n    return false\n}\n\n\
    func TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp1sxiu05a_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp1sxiu05a_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmp1sxiu05a_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmp1sxiu05a_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmp1sxiu05a_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp1sxiu05a_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmp1sxiu05a_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073366
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n \
    \   txt := strings.ToLower(txt)\n    txt := strings.TrimSpace(txt)\n    txt :=\
    \ strings.ToUpper(txt)\n    txt := strings.Trim(txt, \" \")\n    txt := strings.Split(txt,\
    \ \" \")\n    for _, word := range txt {\n        if strings.Contains(word, txt[len(txt)-1])\
    \ {\n            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr6hgfuez_test.go:25:9: no new variables on left side of :=

    /tmp/tmpr6hgfuez_test.go:26:9: no new variables on left side of :=

    /tmp/tmpr6hgfuez_test.go:26:12: undefined: strings

    /tmp/tmpr6hgfuez_test.go:27:9: no new variables on left side of :=

    /tmp/tmpr6hgfuez_test.go:27:12: undefined: strings

    /tmp/tmpr6hgfuez_test.go:28:9: no new variables on left side of :=

    /tmp/tmpr6hgfuez_test.go:28:12: undefined: strings

    /tmp/tmpr6hgfuez_test.go:29:9: no new variables on left side of :=

    /tmp/tmpr6hgfuez_test.go:29:12: undefined: strings

    /tmp/tmpr6hgfuez_test.go:30:12: undefined: strings

    /tmp/tmpr6hgfuez_test.go:30:12: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073366
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n\
    \  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi\
    \ e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false\
    \ },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"\
    Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"\
    apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpzvsxd069_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '@' || last == '#' ||\
    \ last == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last\
    \ == '(' || last == ')' || last == '+' || last == ',' || last == '-' || last ==\
    \ '.' || last == '/' || last == '\\\\' || last == '!' || last == '?' || last ==\
    \ ';' || last == ':' || last == '<' || last == '>' || last == '?' || last == '@'\
    \ || last == '#' || last == '$' || last == '%' || last == '^' || last == '&' ||\
    \ last == '*' || last == '(' || last == ')' || last == '+' || last == ',' || last\
    \ == '-' || last == '.' || last == '/' || last == '\\\\' || last == '!' || last\
    \ == '?' || last == ';' || last == ':' || last == '<' || last == '>' || last ==\
    \ '?' || last == '@' || last == '#' || last == '$' || last == '%' || last == '^'\
    \ || last == '&' || last == '*' || last == '(' || last == ')' || last == '+' ||\
    \ last == ',' || last == '-' || last == '.' || last == '/' || last == '\\\\' ||\
    \ last == '!' || last == '?' || last == ';' || last == ':' || last == '<' || last\
    \ == '>' || last == '?' || last == '@' || last == '#' || last == '$' || last ==\
    \ '%' || last == '^' || last == '&' || last == '*' || last == '(' || last == ')'\
    \ || last == '+' || last == ',' || last == '-' || last == '.' || last == '/' ||\
    \ last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':' ||\
    \ last == '<' || last == '>' || last == '?' || last == '@' || last == '#' || last\
    \ == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last ==\
    \ '(' || last == ')' || last == '+' || last == ',' || last == '-' || last == '.'\
    \ || last == '/' || last == '\\\\' || last == '!' || last == '?' || last == ';'\
    \ || last == ':' || last == '<' || last == '>' || last == '?' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmzy3wha1_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073365
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '!' || last == '?' || last == ';'\
    \ || last == '-' || last == '_' || last == '/' || last == '\\\\' || last == '$'\
    \ || last == '@' || last == '&' || last == '*' || last == '+' || last == '%' ||\
    \ last == '^' || last == '<' || last == '>' || last == '|' || last == '~' {\n\
    \        return false\n    }\n    if last >= 'a' && last <= 'z' || last >= 'A'\
    \ && last <= 'Z' {\n        return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp4bbbemi2_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp4bbbemi2_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp4bbbemi2_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073366
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    if\
    \ lastChar >= '0' && lastChar <= '9' {\n        return false\n    }\n    if lastChar\
    \ >= 'a' && lastChar <= 'z' {\n        return false\n    }\n    if lastChar >=\
    \ 'A' && lastChar <= 'Z' {\n        return false\n    }\n    if lastChar >= '0'\
    \ && lastChar <= '9' {\n        return false\n    }\n    return true\n}\n\nfunc\
    \ TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpk6e6e6qu_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpk6e6e6qu_test.go:69: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpk6e6e6qu_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpk6e6e6qu_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpk6e6e6qu_test.go:69: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073366
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpzm09ia_i_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073364
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n\
    \    lastChar := txt[len(txt)-1]\n    if lastChar >= 'a' && lastChar <= 'z' {\n\
    \        return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnutk3ets_test.go:25:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' {\n        return false\n  \
    \  }\n    if last >= 'A' && last <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpx0wdbyo7_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpx0wdbyo7_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpx0wdbyo7_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073367
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' {\n      \
    \  return true\n    }\n    if last >= 'A' && last <= 'Z' {\n        return true\n\
    \    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpq0u5cb2a_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpq0u5cb2a_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpq0u5cb2a_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073367
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n \
    \   for _, c := range txt {\n        if !isLetter(c) {\n            return true\n\
    \        }\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp48od3qrs_test.go:25:9: no new variables on left side of :=

    /tmp/tmp48od3qrs_test.go:27:13: undefined: isLetter

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073366
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpzm09ia_i_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '!' || last == '?' || last == ';'\
    \ || last == '-' || last == '_' || last == '/' || last == '\\\\' || last == '$'\
    \ || last == '%' || last == '&' || last == '*' || last == '+' || last == '(' ||\
    \ last == ')' || last == '{' || last == '}' || last == '[' || last == ']' || last\
    \ == '<' || last == '>' || last == '|' || last == ';' || last == '?' || last ==\
    \ '@' || last == '^' || last == '~' || last == '`' || last == '-' || last == '_'\
    \ || last == '.' || last == '/' || last == '\\\\' || last == '$' || last == '%'\
    \ || last == '&' || last == '*' || last == '+' || last == '(' || last == ')' ||\
    \ last == '{' || last == '}' || last == '[' || last == ']' || last == '<' || last\
    \ == '>' || last == '|' || last == ';' || last == '?' || last == '@' || last ==\
    \ '^' || last == '~' || last == '`' || last == '-' || last == '_' || last == '.'\
    \ || last == '/' || last == '\\\\' || last == '$' || last == '%' || last == '&'\
    \ || last == '*' || last == '+' || last == '(' || last == ')' || last == '{' ||\
    \ last == '}' || last == '[' || last == ']' || last == '<' || last == '>' || last\
    \ == '|' || last == ';' || last == '?' || last == '@' || last == '^' || last ==\
    \ '~' || last == '`' || last == '-' || last == '_' || last == '.' || last == '/'\
    \ || last == '\\\\' || last == '$' || last == '%' || last == '&' || last == '*'\
    \ || last == '+' || last == '(' || last == ')' || last == '{' || last == '}' ||\
    \ last == '[' || last == ']' || last == '<' || last == '>' || last == '|' || last\
    \ == ';' || last == '?' || last == '@' || last == '^' || last == '~' || last ==\
    \ '`' || last == '-' || last == '_' || last == '.' || last == '/' || last == '\\\
    \\' || last == '$' || last == '%' || last == '&' || last == '*' || last == '+'\
    \ || last == '(' || last == ')' || last == '{' || last == '}' || last == '[' ||\
    \ last == ']' || last == '<' || last == '>' || last == '|' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2dgue8r7_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073365
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '&' || last == '%' ||\
    \ last == '@' || last == '$' || last == '%' || last == '^' || last == '&' || last\
    \ == '*' || last == '(' || last == ')' || last == '+' || last == '-' || last ==\
    \ '=' || last == '|' || last == '[' || last == ']' || last == '{' || last == '}'\
    \ || last == ';' || last == '\"' || last == '\\'' || last == '`' || last == '~'\
    \ || last == ';' || last == ',' || last == '.' || last == '?' || last == '!' ||\
    \ last == ';' || last == ';' || last == ';' || last == ';' || last == ';' || last\
    \ == ';' || last == ';' || last == ';' || last == ';' || last == ';' || last ==\
    \ ';' || last == ';' || last == ';' || last == ';' || last == ';' || last == ';'\
    \ || last == ';' || last == ';' || last == ';' || last == ';' || last == ';' ||\
    \ last == ';' || last == ';' || last == ';' || last == ';' || last == ';' || last\
    \ == ';' || last == ';' || last == ';' || last == ';' || last == ';' || last ==\
    \ ';' || last == ';' || last == ';' || last == ';' || last == ';' || last == ';'\
    \ || last == ';' || last == ';' || last == ';' || last == ';' || last == ';' ||\
    \ last == ';' || last == ';' || last == ';' || last == ';' || last == ';' || last\
    \ == ';' || last == ';' || last == ';' || last == ';' || last == ';' || last ==\
    \ ';' || last == ';' || last == ';' || last == ';' || last == ';' || last == ';'\
    \ || last == ';' || last == ';' || last == ';' || last == ';' || last == ';' ||\
    \ last == ';' || last == ';' || last == ';' || last == ';' || last == ';' || last\
    \ == ';' || last == ';' || last == ';' || last == ';' || last == ';' || last ==\
    \ ';' || last == ';' || last == ';' || last == ';' || last == ';' || last == ';'\
    \ || last == ';' || last == ';' || last == ';' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyew678n1_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073366
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '[' || last == ']' ||\
    \ last == '{' || last == '}' || last == '(' || last == ')' || last == '|' || last\
    \ == '\"' || last == '\\'' || last == '/' || last == '\\\\' || last == '*' ||\
    \ last == '?' || last == '+' || last == '-' || last == '=' || last == '^' || last\
    \ == '&' || last == '|' || last == '~' || last == '`' || last == '~' || last ==\
    \ '!' || last == '@' || last == '#' || last == '$' || last == '%' || last == '^'\
    \ || last == '&' || last == '*' || last == '(' || last == ')' || last == '+' ||\
    \ last == '-' || last == '=' || last == '^' || last == '&' || last == '|' || last\
    \ == '~' || last == '`' || last == '~' || last == '!' || last == '@' || last ==\
    \ '#' || last == '$' || last == '%' || last == '^' || last == '&' || last == '*'\
    \ || last == '(' || last == ')' || last == '+' || last == '-' || last == '=' ||\
    \ last == '^' || last == '&' || last == '|' || last == '~' || last == '`' || last\
    \ == '~' || last == '!' || last == '@' || last == '#' || last == '$' || last ==\
    \ '%' || last == '^' || last == '&' || last == '*' || last == '(' || last == ')'\
    \ || last == '+' || last == '-' || last == '=' || last == '^' || last == '&' ||\
    \ last == '|' || last == '~' || last == '`' || last == '~' || last == '!' || last\
    \ == '@' || last == '#' || last == '$' || last == '%' || last == '^' || last ==\
    \ '&' || last == '*' || last == '(' || last == ')' || last == '+' || last == '-'\
    \ || last == '=' || last == '^' || last == '&' || last == '|' || last == '~' ||\
    \ last == '`' || last == '~' || last == '!' || last == '@' || last == '#' || last\
    \ == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last ==\
    \ '(' || last == ')' || last == '+' || last == '-' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppxlpitrr_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073366
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == '<'\
    \ || last == '>' || last == '?' || last == '!' || last == '@' || last == '#' ||\
    \ last == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last\
    \ == '(' || last == ')' || last == '-' || last == '_' || last == '+' || last ==\
    \ '=' || last == '|' || last == '}' || last == '{' || last == '[' || last == ']'\
    \ || last == ';' || last == ':' || last == ';' || last == '\"' || last == '\\\
    '' || last == '\"' || last == '<' || last == '>' || last == '?' || last == '!'\
    \ || last == '@' || last == '#' || last == '$' || last == '%' || last == '^' ||\
    \ last == '&' || last == '*' || last == '(' || last == ')' || last == '-' || last\
    \ == '_' || last == '+' || last == '=' || last == '|' || last == '}' || last ==\
    \ '{' || last == '[' || last == ']' || last == ';' || last == ':' || last == ';'\
    \ || last == '\"' || last == '\\'' || last == '\"' || last == '<' || last == '>'\
    \ || last == '?' || last == '!' || last == '@' || last == '#' || last == '$' ||\
    \ last == '%' || last == '^' || last == '&' || last == '*' || last == '(' || last\
    \ == ')' || last == '-' || last == '_' || last == '+' || last == '=' || last ==\
    \ '|' || last == '}' || last == '{' || last == '[' || last == ']' || last == ';'\
    \ || last == ':' || last == ';' || last == '\"' || last == '\\'' || last == '\"\
    ' || last == '<' || last == '>' || last == '?' || last == '!' || last == '@' ||\
    \ last == '#' || last == '$' || last == '%' || last == '^' || last == '&' || last\
    \ == '*' || last == '(' || last == ')' || last == '-' || last == '_' || last ==\
    \ '+' || last == '=' || last == '|' || last == '}' || last == '{' || last == '['\
    \ || last == ']' || last == ';' || last == ':' || last == ';' || last == '\"'\
    \ || last == '\\'' || last == '\"' || last == '<' || last == '>' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpxju7cx29_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073366
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == '<'\
    \ || last == '>' || last == '?' || last == '!' || last == '@' || last == '#' ||\
    \ last == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last\
    \ == '(' || last == ')' || last == '+' || last == ',' || last == '-' || last ==\
    \ '.' || last == '/' || last == '\\\\' || last == '[' || last == ']' || last ==\
    \ '{' || last == '}' || last == '|' || last == ';' || last == '?' || last == '!'\
    \ || last == '@' || last == '#' || last == '$' || last == '%' || last == '^' ||\
    \ last == '&' || last == '*' || last == '(' || last == ')' || last == '+' || last\
    \ == ',' || last == '-' || last == '.' || last == '/' || last == '\\\\' || last\
    \ == '[' || last == ']' || last == '{' || last == '}' || last == '|' || last ==\
    \ ';' || last == '?' || last == '!' || last == '@' || last == '#' || last == '$'\
    \ || last == '%' || last == '^' || last == '&' || last == '*' || last == '(' ||\
    \ last == ')' || last == '+' || last == ',' || last == '-' || last == '.' || last\
    \ == '/' || last == '\\\\' || last == '[' || last == ']' || last == '{' || last\
    \ == '}' || last == '|' || last == ';' || last == '?' || last == '!' || last ==\
    \ '@' || last == '#' || last == '$' || last == '%' || last == '^' || last == '&'\
    \ || last == '*' || last == '(' || last == ')' || last == '+' || last == ',' ||\
    \ last == '-' || last == '.' || last == '/' || last == '\\\\' || last == '[' ||\
    \ last == ']' || last == '{' || last == '}' || last == '|' || last == ';' || last\
    \ == '?' || last == '!' || last == '@' || last == '#' || last == '$' || last ==\
    \ '%' || last == '^' || last == '&' || last == '*' || last == '(' || last == ')'\
    \ || last == '+' || last == ',' || last == '-' || last == '.' || last == '/' ||\
    \ last == '\\\\' || last == '[' || last == ']' || last == '{' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpucu3bv02_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073366
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' || last >=\
    \ 'A' && last <= 'Z' {\n        return true\n    }\n    return false\n}\n\nfunc\
    \ TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpenj5ppmg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpenj5ppmg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpenj5ppmg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' {\n      \
    \  return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n\
    \    lastChar := txt[len(txt)-1]\n    if lastChar >= 'a' && lastChar <= 'z' {\n\
    \        return true\n    }\n    if lastChar >= 'A' && lastChar <= 'Z' {\n   \
    \     return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqw_tnpuw_test.go:25:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073367
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '@' || last == '&' ||\
    \ last == '*' || last == '+' || last == '%' || last == '$' || last == '^' || last\
    \ == '(' || last == ')' || last == '{' || last == '}' || last == '[' || last ==\
    \ ']' || last == '|' || last == ';' || last == '\"' || last == '~' || last ==\
    \ '?' || last == '-' || last == '.' || last == '_' || last == '/' || last == '\\\
    \\' || last == '!' || last == '?' || last == ';' || last == ':' || last == '<'\
    \ || last == '>' || last == '?' || last == '@' || last == '&' || last == '*' ||\
    \ last == '+' || last == '%' || last == '$' || last == '^' || last == '(' || last\
    \ == ')' || last == '{' || last == '}' || last == '[' || last == ']' || last ==\
    \ '|' || last == ';' || last == '\"' || last == '~' || last == '?' || last ==\
    \ '-' || last == '.' || last == '_' || last == '/' || last == '\\\\' || last ==\
    \ '!' || last == '?' || last == ';' || last == ':' || last == '<' || last == '>'\
    \ || last == '?' || last == '@' || last == '&' || last == '*' || last == '+' ||\
    \ last == '%' || last == '$' || last == '^' || last == '(' || last == ')' || last\
    \ == '{' || last == '}' || last == '[' || last == ']' || last == '|' || last ==\
    \ ';' || last == '\"' || last == '~' || last == '?' || last == '-' || last ==\
    \ '.' || last == '_' || last == '/' || last == '\\\\' || last == '!' || last ==\
    \ '?' || last == ';' || last == ':' || last == '<' || last == '>' || last == '?'\
    \ || last == '@' || last == '&' || last == '*' || last == '+' || last == '%' ||\
    \ last == '$' || last == '^' || last == '(' || last == ')' || last == '{' || last\
    \ == '}' || last == '[' || last == ']' || last == '|' || last == ';' || last ==\
    \ '\"' || last == '~' || last == '?' || last == '-' || last == '.' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpd86gt9l6_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073366
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' {\n        return false\n    }\n    if last >= 'a' && last\
    \ <= 'z' {\n        return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmparsdrrzb_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmparsdrrzb_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmparsdrrzb_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmparsdrrzb_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073368
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpzm09ia_i_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '?' || last == '!' || last == '@' || last == '#'\
    \ || last == '$' || last == '%' || last == '^' || last == '&' || last == '*' ||\
    \ last == '(' || last == ')' || last == '-' || last == '_' || last == '+' || last\
    \ == '=' || last == '{' || last == '}' || last == '|' || last == ';' || last ==\
    \ '<' || last == '>' || last == '?' || last == '/' || last == '\\\\' || last ==\
    \ '|' || last == ';' || last == '<' || last == '>' || last == '?' || last == '/'\
    \ || last == '\\\\' || last == '|' || last == ';' || last == '<' || last == '>'\
    \ || last == '?' || last == '/' || last == '\\\\' || last == '|' || last == ';'\
    \ || last == '<' || last == '>' || last == '?' || last == '/' || last == '\\\\\
    ' || last == '|' || last == ';' || last == '<' || last == '>' || last == '?' ||\
    \ last == '/' || last == '\\\\' || last == '|' || last == ';' || last == '<' ||\
    \ last == '>' || last == '?' || last == '/' || last == '\\\\' || last == '|' ||\
    \ last == ';' || last == '<' || last == '>' || last == '?' || last == '/' || last\
    \ == '\\\\' || last == '|' || last == ';' || last == '<' || last == '>' || last\
    \ == '?' || last == '/' || last == '\\\\' || last == '|' || last == ';' || last\
    \ == '<' || last == '>' || last == '?' || last == '/' || last == '\\\\' || last\
    \ == '|' || last == ';' || last == '<' || last == '>' || last == '?' || last ==\
    \ '/' || last == '\\\\' || last == '|' || last == ';' || last == '<' || last ==\
    \ '>' || last == '?' || last == '/' || last == '\\\\' || last == '|' || last ==\
    \ ';' || last == '<' || last == '>' || last == '?' || last == '/' || last == '\\\
    \\' || last == '|' || last == ';' || last == '<' || last == '>' || last == '?'\
    \ || last == '/' || last == '\\\\' || last == '|' || last == ';' || last == '<'\
    \ || last == '>' || last == '?' || last == '/' || last == '\\\\' || last == '|'\
    \ || last == ';' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n\
    \  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi\
    \ e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false\
    \ },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"\
    Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"\
    apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpw2wpu184_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073366
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n\
    \    lastChar := txt[len(txt)-1]\n    if lastChar >= 'a' && lastChar <= 'z' {\n\
    \        return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnutk3ets_test.go:25:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073364
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 2 {\n        return false\n    }\n    if txt[len(txt)-1] == ' ' {\n\
    \        return false\n    }\n    for _, char := range txt[len(txt)-1] {\n   \
    \     if char >= 'a' && char <= 'z' {\n            return false\n        }\n \
    \   }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpis7ezygg_test.go:28:26: cannot range over txt[len(txt) - 1] (value of
    type byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073367
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    for _, letter := range []rune(txt) {\n \
    \       if letter == 'a' || letter == 'e' || letter == 'i' || letter == 'o' ||\
    \ letter == 'u' {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmp3ig58njn_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073368
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '@' || last == '#' ||\
    \ last == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last\
    \ == '(' || last == ')' || last == '-' || last == '_' || last == '+' || last ==\
    \ '=' || last == '[' || last == ']' || last == '{' || last == '}' || last == '|'\
    \ || last == ';' || last == '\\\\' || last == '\"' || last == '\\'' || last ==\
    \ '(' || last == ')' || last == '\"' || last == '\\'' || last == ';' || last ==\
    \ '<' || last == '>' || last == '?' || last == '@' || last == '#' || last == '$'\
    \ || last == '%' || last == '^' || last == '&' || last == '*' || last == '(' ||\
    \ last == ')' || last == '-' || last == '_' || last == '+' || last == '=' || last\
    \ == '[' || last == ']' || last == '{' || last == '}' || last == '|' || last ==\
    \ ';' || last == '\\\\' || last == '\"' || last == '\\'' || last == '(' || last\
    \ == ')' || last == '\"' || last == '\\'' || last == ';' || last == '<' || last\
    \ == '>' || last == '?' || last == '@' || last == '#' || last == '$' || last ==\
    \ '%' || last == '^' || last == '&' || last == '*' || last == '(' || last == ')'\
    \ || last == '-' || last == '_' || last == '+' || last == '=' || last == '[' ||\
    \ last == ']' || last == '{' || last == '}' || last == '|' || last == ';' || last\
    \ == '\\\\' || last == '\"' || last == '\\'' || last == '(' || last == ')' ||\
    \ last == '\"' || last == '\\'' || last == ';' || last == '<' || last == '>' ||\
    \ last == '?' || last == '@' || last == '#' || last == '$' || last == '%' || last\
    \ == '^' || last == '&' || last == '*' || last == '(' || last == ')' || last ==\
    \ '-' || last == '_' || last == '+' || last == '=' || last == '[' || last == ']'\
    \ || last == '{' || last == '}' || last == '|' || last == ';' || last == '\\\\\
    ' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate :=\
    \ check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwwyd__zj_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073367
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar != ' ' && lastChar != '-' && lastChar != '_' {\n        return\
    \ true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpwf85b3r3_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpwf85b3r3_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpwf85b3r3_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpwf85b3r3_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n \
    \   txt := strings.ToLower(txt)\n    txt := strings.Trim(txt, \" \")\n    txt\
    \ := strings.ToUpper(txt)\n    txt := strings.Split(txt, \" \")\n    for _, v\
    \ := range txt {\n        if v[len(v)-1] == v[len(v)-1] {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpyy81qppi_test.go:25:9: no new variables on left side of :=

    /tmp/tmpyy81qppi_test.go:26:9: no new variables on left side of :=

    /tmp/tmpyy81qppi_test.go:26:12: undefined: strings

    /tmp/tmpyy81qppi_test.go:27:9: no new variables on left side of :=

    /tmp/tmpyy81qppi_test.go:27:12: undefined: strings

    /tmp/tmpyy81qppi_test.go:28:9: no new variables on left side of :=

    /tmp/tmpyy81qppi_test.go:28:12: undefined: strings

    /tmp/tmpyy81qppi_test.go:29:9: no new variables on left side of :=

    /tmp/tmpyy81qppi_test.go:29:12: undefined: strings

    /tmp/tmpyy81qppi_test.go:31:13: invalid operation: cannot index v (variable of
    type rune)

    /tmp/tmpyy81qppi_test.go:31:13: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073368
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' {\n      \
    \  return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar != ' ' {\n        return true\n    }\n    words := strings.Split(txt,\
    \ \" \")\n    for _, word := range words {\n        if word == \"\" {\n      \
    \      continue\n        }\n        if strings.Contains(word, lastChar) {\n  \
    \          return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbwlcets8_test.go:29:14: undefined: strings

    /tmp/tmpbwlcets8_test.go:34:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073368
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' {\n        return true\n   \
    \ }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp7dxygx6g_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp7dxygx6g_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp7dxygx6g_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp7dxygx6g_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' {\n        return true\n   \
    \ }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp6_cvumu0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp6_cvumu0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp6_cvumu0_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp6_cvumu0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073369
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n \
    \   if txt[len(txt)-1] >= 'a' && txt[len(txt)-1] <= 'z' {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7y6br2pc_test.go:25:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073368
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 2 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '\\'' || last == '\"' || last == ';' || last ==\
    \ '?' || last == '!' || last == '@' || last == '#' || last == '$' || last == '%'\
    \ || last == '^' || last == '&' || last == '*' || last == '(' || last == ')' ||\
    \ last == '+' || last == ',' || last == '{' || last == '}' || last == '|' || last\
    \ == ';' || last == '<' || last == '>' || last == '?' || last == '~' || last ==\
    \ '`' || last == '-' || last == '_' || last == '.' || last == '/' || last == '\\\
    \\' || last == '\\'' || last == '\"' || last == ';' || last == '?' || last ==\
    \ '!' || last == '@' || last == '#' || last == '$' || last == '%' || last == '^'\
    \ || last == '&' || last == '*' || last == '(' || last == ')' || last == '+' ||\
    \ last == ',' || last == '{' || last == '}' || last == '|' || last == ';' || last\
    \ == '<' || last == '>' || last == '?' || last == '~' || last == '`' || last ==\
    \ '-' || last == '_' || last == '.' || last == '/' || last == '\\\\' || last ==\
    \ '\\'' || last == '\"' || last == ';' || last == '?' || last == '!' || last ==\
    \ '@' || last == '#' || last == '$' || last == '%' || last == '^' || last == '&'\
    \ || last == '*' || last == '(' || last == ')' || last == '+' || last == ',' ||\
    \ last == '{' || last == '}' || last == '|' || last == ';' || last == '<' || last\
    \ == '>' || last == '?' || last == '~' || last == '`' || last == '-' || last ==\
    \ '_' || last == '.' || last == '/' || last == '\\\\' || last == '\\'' || last\
    \ == '\"' || last == ';' || last == '?' || last == '!' || last == '@' || last\
    \ == '#' || last == '$' || last == '%' || last == '^' || last == '&' || last ==\
    \ '*' || last == '(' || last == ')' || last == '+' || last == ',' || last == '{'\
    \ || last == '}' || last == '|' || last == ';' || last == '<' || last == '>' ||\
    \ last == '?' || last == '~' || last == '`' || last == '-' || last == '_' || \n\
    func TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp18z13abx_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073368
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '!' || last == '?' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' {\n        return true\n   \
    \ }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpz7wp5v78_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpz7wp5v78_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpz7wp5v78_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpz7wp5v78_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073369
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n\
    \    for _, letter := range txt {\n        if letter == ' ' || letter == '-' ||\
    \ letter == '_' || letter == '.' || letter == '!' || letter == '?' || letter ==\
    \ '\\'' || letter == '\"' || letter == '#' || letter == '$' || letter == '%' ||\
    \ letter == '&' || letter == '\\\\' || letter == '(' || letter == ')' || letter\
    \ == '*' || letter == '+' || letter == ',' || letter == '-' || letter == '.' ||\
    \ letter == '/' || letter == '0' || letter == '1' || letter == '2' || letter ==\
    \ '3' || letter == '4' || letter == '5' || letter == '6' || letter == '7' || letter\
    \ == '8' || letter == '9' || letter == 'A' || letter == 'B' || letter == 'C' ||\
    \ letter == 'D' || letter == 'E' || letter == 'F' || letter == 'G' || letter ==\
    \ 'H' || letter == 'I' || letter == 'J' || letter == 'K' || letter == 'L' || letter\
    \ == 'M' || letter == 'N' || letter == 'O' || letter == 'P' || letter == 'Q' ||\
    \ letter == 'R' || letter == 'S' || letter == 'T' || letter == 'U' || letter ==\
    \ 'V' || letter == 'W' || letter == 'X' || letter == 'Y' || letter == 'Z' || letter\
    \ == '[' || letter == ']' || letter == '^' || letter == '_' || letter == '`' ||\
    \ letter == 'a' || letter == 'b' || letter == 'c' || letter == 'd' || letter ==\
    \ 'e' || letter == 'f' || letter == 'g' || letter == 'h' || letter == 'i' || letter\
    \ == 'j' || letter == 'k' || letter == 'l' || letter == 'm' || letter == 'n' ||\
    \ letter == 'o' || letter == 'p' || letter == 'q' || letter == 'r' || letter ==\
    \ 's' || letter == 't' || letter == 'u' || letter == 'v' || letter == 'w' || letter\
    \ == 'x' || letter == 'y' || letter == 'z' || letter == '{' || letter == '}' ||\
    \ letter == '~' || letter == '-' || letter == '_' || letter == '`' || letter ==\
    \ 'a' || letter == 'b' || letter == 'c' || letter == 'd' || letter == 'e' || letter\
    \ == 'f' || letter == 'g' || letter == 'h' || letter == 'i' || letter == 'j' ||\
    \ letter == 'k' || letter == 'l' || letter == 'm' || letter == 'n' || letter ==\
    \ 'o' || letter == 'p' || letter == 'q' || letter == 'r' || letter == 's' || letter\
    \ == 't' || letter == 'u' || letter == 'v' || letter == 'w' || letter == 'x' ||\
    \ letter == 'y' || letter == 'z' || letter == '{\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvqmntibn_test.go:27:2064: rune literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073368
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '\\'' || last == '\"' || last == ';' || last ==\
    \ '?' || last == '!' || last == '@' || last == '#' || last == '$' || last == '%'\
    \ || last == '^' || last == '&' || last == '*' || last == '(' || last == ')' ||\
    \ last == '-' || last == '_' || last == '+' || last == '=' || last == '{' || last\
    \ == '}' || last == '[' || last == ']' || last == '|' || last == ';' || last ==\
    \ '<' || last == '>' || last == '?' || last == '/' || last == '\\\\' || last ==\
    \ '\"' || last == '\\'' || last == '\"' || last == ';' || last == '?' || last\
    \ == '!' || last == '@' || last == '#' || last == '$' || last == '%' || last ==\
    \ '^' || last == '&' || last == '*' || last == '(' || last == ')' || last == '-'\
    \ || last == '_' || last == '+' || last == '=' || last == '{' || last == '}' ||\
    \ last == '[' || last == ']' || last == '|' || last == ';' || last == '<' || last\
    \ == '>' || last == '?' || last == '/' || last == '\\\\' || last == '\"' || last\
    \ == '\\'' || last == '\"' || last == ';' || last == '?' || last == '!' || last\
    \ == '@' || last == '#' || last == '$' || last == '%' || last == '^' || last ==\
    \ '&' || last == '*' || last == '(' || last == ')' || last == '-' || last == '_'\
    \ || last == '+' || last == '=' || last == '{' || last == '}' || last == '[' ||\
    \ last == ']' || last == '|' || last == ';' || last == '<' || last == '>' || last\
    \ == '?' || last == '/' || last == '\\\\' || last == '\"' || last == '\\'' ||\
    \ last == '\"' || last == ';' || last == '?' || last == '!' || last == '@' ||\
    \ last == '#' || last == '$' || last == '%' || last == '^' || last == '&' || last\
    \ == '*' || last == '(' || last == ')' || last == '-' || last == '_' || last ==\
    \ '+' || last == '=' || last == '{' || last == '}' || last == '[' || last == ']'\
    \ || last == '|' || last == ';' || last == '<' || last == '>' || last == '?' ||\
    \ \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbllou72y_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073368
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' {\n        return false\n    }\n    if last >= 'a' && last\
    \ <= 'z' || last >= 'A' && last <= 'Z' {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpu95m0mpw_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpu95m0mpw_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpu95m0mpw_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '!' || last == '?' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' {\n        return true\n   \
    \ }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpz7wp5v78_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpz7wp5v78_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpz7wp5v78_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpz7wp5v78_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073369
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' || last >=\
    \ 'A' && last <= 'Z' {\n        return true\n    }\n    return false\n}\n\nfunc\
    \ TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpenj5ppmg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpenj5ppmg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpenj5ppmg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return true\n    }\n   \
    \ return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n\
    \  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi\
    \ e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false\
    \ },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"\
    Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"\
    apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpc0ran3ly_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpc0ran3ly_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpc0ran3ly_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpc0ran3ly_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073369
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return true\n    }\n   \
    \ if lastChar >= 'A' && lastChar <= 'Z' {\n        return true\n    }\n    if\
    \ lastChar >= '0' && lastChar <= '9' {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpi7zsh6_u_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpi7zsh6_u_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpi7zsh6_u_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpi7zsh6_u_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpzm09ia_i_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073364
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n \
    \   if txt[len(txt)-1] != ' ' {\n        return false\n    }\n    for _, letter\
    \ := range strings.Split(txt, \" \") {\n        if !isAlpha(letter) {\n      \
    \      return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpartsml8l_test.go:25:9: no new variables on left side of :=

    /tmp/tmpartsml8l_test.go:29:28: undefined: strings

    /tmp/tmpartsml8l_test.go:30:13: undefined: isAlpha

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073368
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' {\n        return false\n    }\n    if last >= 'a' && last\
    \ <= 'z' {\n        return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpppjwl8gg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpppjwl8gg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpppjwl8gg_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpppjwl8gg_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073369
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar != ' ' {\n        return true\n    }\n    for _, letter := range\
    \ strings.Split(txt, \" \") {\n        if letter == lastChar {\n            return\
    \ false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprx7ntu36_test.go:29:28: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073369
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' {\n        return false\n    }\n    if last >= 'a' && last\
    \ <= 'z' || last >= 'A' && last <= 'Z' {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpu95m0mpw_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpu95m0mpw_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpu95m0mpw_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' || last >=\
    \ 'A' && last <= 'Z' {\n        return true\n    }\n    return false\n}\n\nfunc\
    \ TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpe1ay7d9z_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpe1ay7d9z_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpe1ay7d9z_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073369
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar != ' ' && lastChar != '-' && lastChar != '_' {\n        return\
    \ true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpjxveopgf_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpjxveopgf_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpjxveopgf_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpjxveopgf_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n\
    \    lastChar := txt[len(txt)-1]\n    if lastChar >= 'a' && lastChar <= 'z' {\n\
    \        return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp58jywcmn_test.go:25:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073369
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n\
    \    if txt[len(txt)-1] == ' ' {\n        return false\n    }\n    for _, letter\
    \ := range txt {\n        if letter == 'a' || letter == 'e' || letter == 'i' ||\
    \ letter == 'o' || letter == 'u' {\n            return false\n        }\n    }\n\
    \    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n\
    \  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi\
    \ e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false\
    \ },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"\
    Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"\
    apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3makf_ya_test.go:25:9: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073369
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '@' || last == '#' ||\
    \ last == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last\
    \ == '(' || last == ')' || last == '-' || last == '_' || last == '+' || last ==\
    \ '=' || last == '[' || last == ']' || last == '{' || last == '}' || last == '|'\
    \ || last == ';' || last == '\"' || last == '\\'' || last == '/' || last == '\\\
    \\' || last == '(' || last == ')' || last == '[' || last == ']' || last == '{'\
    \ || last == '}' || last == '<' || last == '>' || last == '?' || last == '@' ||\
    \ last == '#' || last == '$' || last == '%' || last == '^' || last == '&' || last\
    \ == '*' || last == '(' || last == ')' || last == '-' || last == '_' || last ==\
    \ '+' || last == '=' || last == '[' || last == ']' || last == '{' || last == '}'\
    \ || last == '|' || last == ';' || last == '\"' || last == '\\'' || last == '/'\
    \ || last == '\\\\' || last == '(' || last == ')' || last == '[' || last == ']'\
    \ || last == '{' || last == '}' || last == '<' || last == '>' || last == '?' ||\
    \ last == '@' || last == '#' || last == '$' || last == '%' || last == '^' || last\
    \ == '&' || last == '*' || last == '(' || last == ')' || last == '-' || last ==\
    \ '_' || last == '+' || last == '=' || last == '[' || last == ']' || last == '{'\
    \ || last == '}' || last == '|' || last == ';' || last == '\"' || last == '\\\
    '' || last == '/' || last == '\\\\' || last == '(' || last == ')' || last == '['\
    \ || last == ']' || last == '{' || last == '}' || last == '<' || last == '>' ||\
    \ last == '?' || last == '@' || last == '#' || last == '$' || last == '%' || last\
    \ == '^' || last == '&' || last == '*' || last == '(' || last == ')' || last ==\
    \ '-' || last == '_' || last == '+' || last == '=' || last == '[' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpssyapgog_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073368
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '!' || last == '?' || last == ';'\
    \ || last == '-' || last == '_' || last == '/' || last == '\\\\' || last == '@'\
    \ || last == '#' || last == '$' || last == '%' || last == '^' || last == '&' ||\
    \ last == '*' || last == '(' || last == ')' || last == '+' || last == ',' || last\
    \ == '{' || last == '}' || last == '|' || last == ';' || last == '<' || last ==\
    \ '>' || last == '?' || last == '/' || last == '\\\\' || last == '{' || last ==\
    \ '}' || last == '[' || last == ']' || last == '\\\\' || last == '^' || last ==\
    \ '`' || last == '|' || last == ';' || last == '<' || last == '>' || last == '?'\
    \ || last == '/' || last == '\\\\' || last == '{' || last == '}' || last == '['\
    \ || last == ']' || last == '\\\\' || last == '^' || last == '`' || last == '|'\
    \ || last == ';' || last == '<' || last == '>' || last == '?' || last == '/' ||\
    \ last == '\\\\' || last == '{' || last == '}' || last == '[' || last == ']' ||\
    \ last == '\\\\' || last == '^' || last == '`' || last == '|' || last == ';' ||\
    \ last == '<' || last == '>' || last == '?' || last == '/' || last == '\\\\' ||\
    \ last == '{' || last == '}' || last == '[' || last == ']' || last == '\\\\' ||\
    \ last == '^' || last == '`' || last == '|' || last == ';' || last == '<' || last\
    \ == '>' || last == '?' || last == '/' || last == '\\\\' || last == '{' || last\
    \ == '}' || last == '[' || last == ']' || last == '\\\\' || last == '^' || last\
    \ == '`' || last == '|' || last == ';' || last == '<' || last == '>' || last ==\
    \ '?' || last == '/' || last == '\\\\' || last == '{' || last == '}' || last ==\
    \ '[' || last == ']' || last == '\\\\' || last == '^' || last == '`' || last ==\
    \ '|' || last == ';' || last == '<' || last == '>' || last == '?' || last == '/'\
    \ || last == '\\\\' || last == '{' || last == '}' || last == '[' || last == ']'\
    \ || last == '\\\\' || last == '^' || last == '`' || last == '|' || last == ';'\
    \ || last == '<' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n\
    \  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi\
    \ e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false\
    \ },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"\
    Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"\
    apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6fr_bpwn_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073368
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '?' || last == '!' || last == '@' || last == '#'\
    \ || last == '$' || last == '%' || last == '^' || last == '&' || last == '*' ||\
    \ last == '(' || last == ')' || last == '+' || last == ',' || last == '{' || last\
    \ == '}' || last == '|' || last == ';' || last == ':' || last == '<' || last ==\
    \ '>' || last == '?' || last == '[' || last == ']' || last == '\\\\' || last ==\
    \ '^' || last == '`' || last == '{' || last == '}' || last == '~' || last == '`'\
    \ || last == '-' || last == '_' || last == '/' || last == '\\\\' || last == '?'\
    \ || last == '!' || last == '@' || last == '#' || last == '$' || last == '%' ||\
    \ last == '^' || last == '&' || last == '*' || last == '(' || last == ')' || last\
    \ == '+' || last == ',' || last == '{' || last == '}' || last == '|' || last ==\
    \ ';' || last == ':' || last == '<' || last == '>' || last == '?' || last == '['\
    \ || last == ']' || last == '\\\\' || last == '^' || last == '`' || last == '{'\
    \ || last == '}' || last == '~' || last == '`' || last == '-' || last == '_' ||\
    \ last == '/' || last == '\\\\' || last == '?' || last == '!' || last == '@' ||\
    \ last == '#' || last == '$' || last == '%' || last == '^' || last == '&' || last\
    \ == '*' || last == '(' || last == ')' || last == '+' || last == ',' || last ==\
    \ '{' || last == '}' || last == '|' || last == ';' || last == ':' || last == '<'\
    \ || last == '>' || last == '?' || last == '[' || last == ']' || last == '\\\\\
    ' || last == '^' || last == '`' || last == '{' || last == '}' || last == '~' ||\
    \ last == '`' || last == '-' || last == '_' || last == '/' || last == '\\\\' ||\
    \ last == '?' || last == '!' || last == '@' || last == '#' || last == '$' || last\
    \ == '%' || last == '^' || last == '&' || last == '*' || last == '(' || last ==\
    \ ')' || last == '+' || last == ',' || last == '{' || last == '}' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1vkvae5l_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073368
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpzm09ia_i_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpzm09ia_i_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return true\n    }\n   \
    \ if lastChar >= 'A' && lastChar <= 'Z' {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpf73fqfpz_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpf73fqfpz_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpf73fqfpz_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073153
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' {\n        return false\n    }\n    for _, letter := range\
    \ txt {\n        if letter == last {\n            return false\n        }\n  \
    \  }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_ijqn268_test.go:30:22: invalid operation: letter == last (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073369
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' {\n        return false\n    }\n    for _, letter := range\
    \ txt {\n        if letter == last {\n            return false\n        }\n  \
    \  }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn5ztfgfz_test.go:30:22: invalid operation: letter == last (mismatched
    types rune and byte)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073370
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '?' || last == '!' || last == '@' || last == '#'\
    \ || last == '$' || last == '%' || last == '^' || last == '&' || last == '*' ||\
    \ last == '(' || last == ')' || last == '_' || last == '+' || last == ',' || last\
    \ == '{' || last == '}' || last == '|' || last == ';' || last == ':' || last ==\
    \ '<' || last == '>' || last == '?' || last == '~' || last == '`' || last == '\"\
    ' || last == '\\'' || last == '<' || last == '>' || last == '{' || last == '}'\
    \ || last == '|' || last == ';' || last == ':' || last == '<' || last == '>' ||\
    \ last == '?' || last == '~' || last == '`' || last == '\"' || last == '\\'' ||\
    \ last == '<' || last == '>' || last == '{' || last == '}' || last == '|' || last\
    \ == ';' || last == ':' || last == '<' || last == '>' || last == '?' || last ==\
    \ '~' || last == '`' || last == '\"' || last == '\\'' || last == '<' || last ==\
    \ '>' || last == '{' || last == '}' || last == '|' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '~' || last == '`' ||\
    \ last == '\"' || last == '\\'' || last == '<' || last == '>' || last == '{' ||\
    \ last == '}' || last == '|' || last == ';' || last == ':' || last == '<' || last\
    \ == '>' || last == '?' || last == '~' || last == '`' || last == '\"' || last\
    \ == '\\'' || last == '<' || last == '>' || last == '{' || last == '}' || last\
    \ == '|' || last == ';' || last == ':' || last == '<' || last == '>' || last ==\
    \ '?' || last == '~' || last == '`' || last == '\"' || last == '\\'' || last ==\
    \ '<' || last == '>' || last == '{' || last == '}' || last == '|' || last == ';'\
    \ || last == ':' || last == '<' || last == '>' || last == '?' || last == '~' ||\
    \ last == '`' || last == '\"' || last == '\\'' || last == '<' || last == '>' ||\
    \ last == '{' || last == '}' || last == '|' || last == ';' || last == ':' || \n\
    func TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiha00ouv_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073369
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '!' || last == '?' || last == ';'\
    \ || last == '-' || last == '_' || last == '*' || last == '+' || last == '(' ||\
    \ last == ')' || last == '[' || last == ']' || last == '{' || last == '}' || last\
    \ == '|' || last == '\\\\' || last == '^' || last == '~' || last == '%' || last\
    \ == '$' || last == '&' || last == '*' || last == '+' || last == '-' || last ==\
    \ '.' || last == '/' || last == '?' || last == '@' || last == '!' || last == '#'\
    \ || last == '$' || last == '%' || last == '^' || last == '&' || last == '*' ||\
    \ last == '+' || last == '-' || last == '.' || last == '/' || last == '?' || last\
    \ == '@' || last == '!' || last == '#' || last == '$' || last == '%' || last ==\
    \ '^' || last == '&' || last == '*' || last == '+' || last == '-' || last == '.'\
    \ || last == '/' || last == '?' || last == '@' || last == '!' || last == '#' ||\
    \ last == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last\
    \ == '+' || last == '-' || last == '.' || last == '/' || last == '?' || last ==\
    \ '@' || last == '!' || last == '#' || last == '$' || last == '%' || last == '^'\
    \ || last == '&' || last == '*' || last == '+' || last == '-' || last == '.' ||\
    \ last == '/' || last == '?' || last == '@' || last == '!' || last == '#' || last\
    \ == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last ==\
    \ '+' || last == '-' || last == '.' || last == '/' || last == '?' || last == '@'\
    \ || last == '!' || last == '#' || last == '$' || last == '%' || last == '^' ||\
    \ last == '&' || last == '*' || last == '+' || last == '-' || last == '.' || last\
    \ == '/' || last == '?' || last == '@' || last == '!' || last == '#' || last ==\
    \ '$' || last == '%' || last == '^' || last == '&' || last == '*' || last == '+'\
    \ || last == '-' || last == '.' || last == '/' || last == '?' || last == '@' ||\
    \ last == '!' || last == '#' || last == '$' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpabs3wl2b_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073369
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 2 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' {\n        return true\n   \
    \ }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpzjudtooj_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpzjudtooj_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpzjudtooj_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpzjudtooj_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' {\n      \
    \  return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' {\n        return\
    \ false\n    }\n    for _, letter := range []rune(txt) {\n        if letter ==\
    \ 'a' || letter == 'e' || letter == 'i' || letter == 'o' || letter == 'u' {\n\
    \            return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpbnhklnga_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '?' || last == '!' || last == '@' || last == '#'\
    \ || last == '$' || last == '%' || last == '^' || last == '&' || last == '*' ||\
    \ last == '(' || last == ')' || last == '-' || last == '_' || last == '+' || last\
    \ == '=' || last == '{' || last == '}' || last == '[' || last == ']' || last ==\
    \ '|' || last == ';' || last == '<' || last == '>' || last == '?' || last == '/'\
    \ || last == '\\\\' || last == '|' || last == ';' || last == '<' || last == '>'\
    \ || last == '?' || last == '/' || last == '\\\\' || last == '|' || last == ';'\
    \ || last == '<' || last == '>' || last == '?' || last == '/' || last == '\\\\\
    ' || last == '|' || last == ';' || last == '<' || last == '>' || last == '?' ||\
    \ last == '/' || last == '\\\\' || last == '|' || last == ';' || last == '<' ||\
    \ last == '>' || last == '?' || last == '/' || last == '\\\\' || last == '|' ||\
    \ last == ';' || last == '<' || last == '>' || last == '?' || last == '/' || last\
    \ == '\\\\' || last == '|' || last == ';' || last == '<' || last == '>' || last\
    \ == '?' || last == '/' || last == '\\\\' || last == '|' || last == ';' || last\
    \ == '<' || last == '>' || last == '?' || last == '/' || last == '\\\\' || last\
    \ == '|' || last == ';' || last == '<' || last == '>' || last == '?' || last ==\
    \ '/' || last == '\\\\' || last == '|' || last == ';' || last == '<' || last ==\
    \ '>' || last == '?' || last == '/' || last == '\\\\' || last == '|' || last ==\
    \ ';' || last == '<' || last == '>' || last == '?' || last == '/' || last == '\\\
    \\' || last == '|' || last == ';' || last == '<' || last == '>' || last == '?'\
    \ || last == '/' || last == '\\\\' || last == '|' || last == ';' || last == '<'\
    \ || last == '>' || last == '?' || last == '/' || last == '\\\\' || last == '|'\
    \ || last == ';' || last == '<' || last == '>' || last == '?' || last == '/' ||\
    \ last == '\\\\' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n\
    \  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi\
    \ e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false\
    \ },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"\
    Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"\
    apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1y4mkw7k_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073369
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n\
    \  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi\
    \ e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false\
    \ },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"\
    Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"\
    apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpjtmotk8d_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpjtmotk8d_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpjtmotk8d_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpjtmotk8d_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpjtmotk8d_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' {\n      \
    \  return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '[' || last == ']' ||\
    \ last == '{' || last == '}' || last == '(' || last == ')' || last == '|' || last\
    \ == '\"' || last == '\\'' || last == ';' || last == '-' || last == '.' || last\
    \ == '-' || last == '_' || last == '/' || last == '\\\\' || last == '!' || last\
    \ == '?' || last == ';' || last == ':' || last == '<' || last == '>' || last ==\
    \ '?' || last == '[' || last == ']' || last == '{' || last == '}' || last == '('\
    \ || last == ')' || last == '|' || last == '\"' || last == '\\'' || last == ';'\
    \ || last == '-' || last == '.' || last == '-' || last == '_' || last == '/' ||\
    \ last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':' ||\
    \ last == '<' || last == '>' || last == '?' || last == '[' || last == ']' || last\
    \ == '{' || last == '}' || last == '(' || last == ')' || last == '|' || last ==\
    \ '\"' || last == '\\'' || last == ';' || last == '-' || last == '.' || last ==\
    \ '-' || last == '_' || last == '/' || last == '\\\\' || last == '!' || last ==\
    \ '?' || last == ';' || last == ':' || last == '<' || last == '>' || last == '?'\
    \ || last == '[' || last == ']' || last == '{' || last == '}' || last == '(' ||\
    \ last == ')' || last == '|' || last == '\"' || last == '\\'' || last == ';' ||\
    \ last == '-' || last == '.' || last == '-' || last == '_' || last == '/' || last\
    \ == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':' || last\
    \ == '<' || last == '>' || last == '?' || last == '[' || last == ']' || last ==\
    \ '{' || last == '}' || last == '(' || last == ')' || last == '|' || last == '\"\
    ' || last == '\\'' || last == ';' || last == '-' || last == '.' || last == '-'\
    \ || last == '_' || last == '/' || last == '\\\\' || last == '!' || last == '?'\
    \ || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate :=\
    \ check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqojvlmv4_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073369
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '!' || last == '?' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' {\n        return false\n  \
    \  }\n    if last >= 'A' && last <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmplyt6bnpk_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmplyt6bnpk_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmplyt6bnpk_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '!' || last == '?' || last == ';'\
    \ || last == '-' || last == '_' || last == '/' || last == '\\\\' || last == '$'\
    \ || last == '%' || last == '&' || last == '*' || last == '+' || last == '(' ||\
    \ last == ')' || last == '{' || last == '}' || last == '[' || last == ']' || last\
    \ == '<' || last == '>' || last == '|' || last == ';' || last == '?' || last ==\
    \ '.' || last == '!' || last == '?' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '$' || last == '%' || last == '&' || last == '*'\
    \ || last == '+' || last == '(' || last == ')' || last == '{' || last == '}' ||\
    \ last == '[' || last == ']' || last == '<' || last == '>' || last == '|' || last\
    \ == ';' || last == '?' || last == '.' || last == '!' || last == '?' || last ==\
    \ '-' || last == '_' || last == '/' || last == '\\\\' || last == '$' || last ==\
    \ '%' || last == '&' || last == '*' || last == '+' || last == '(' || last == ')'\
    \ || last == '{' || last == '}' || last == '[' || last == ']' || last == '<' ||\
    \ last == '>' || last == '|' || last == ';' || last == '?' || last == '.' || last\
    \ == '!' || last == '?' || last == '-' || last == '_' || last == '/' || last ==\
    \ '\\\\' || last == '$' || last == '%' || last == '&' || last == '*' || last ==\
    \ '+' || last == '(' || last == ')' || last == '{' || last == '}' || last == '['\
    \ || last == ']' || last == '<' || last == '>' || last == '|' || last == ';' ||\
    \ last == '?' || last == '.' || last == '!' || last == '?' || last == '-' || last\
    \ == '_' || last == '/' || last == '\\\\' || last == '$' || last == '%' || last\
    \ == '&' || last == '*' || last == '+' || last == '(' || last == ')' || last ==\
    \ '{' || last == '}' || last == '[' || last == ']' || last == '<' || last == '>'\
    \ || last == '|' || last == ';' || last == '?' || last == '.' || last == '!' ||\
    \ last == '?' || last == '-' || last == '_' || last == '/' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvyrqx0jp_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073370
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '?' || last == '!' || last == '@' || last == '#'\
    \ || last == '$' || last == '%' || last == '^' || last == '&' || last == '*' ||\
    \ last == '(' || last == ')' || last == '-' || last == '_' || last == '+' || last\
    \ == '=' || last == '{' || last == '}' || last == '[' || last == ']' || last ==\
    \ '|' || last == ';' || last == ':' || last == '<' || last == '>' || last == '?'\
    \ || last == '/' || last == '\\\\' || last == '|' || last == ';' || last == '<'\
    \ || last == '>' || last == '?' || last == '/' || last == '\\\\' || last == '|'\
    \ || last == ';' || last == '<' || last == '>' || last == '?' || last == '/' ||\
    \ last == '\\\\' || last == '|' || last == ';' || last == '<' || last == '>' ||\
    \ last == '?' || last == '/' || last == '\\\\' || last == '|' || last == ';' ||\
    \ last == '<' || last == '>' || last == '?' || last == '/' || last == '\\\\' ||\
    \ last == '|' || last == ';' || last == '<' || last == '>' || last == '?' || last\
    \ == '/' || last == '\\\\' || last == '|' || last == ';' || last == '<' || last\
    \ == '>' || last == '?' || last == '/' || last == '\\\\' || last == '|' || last\
    \ == ';' || last == '<' || last == '>' || last == '?' || last == '/' || last ==\
    \ '\\\\' || last == '|' || last == ';' || last == '<' || last == '>' || last ==\
    \ '?' || last == '/' || last == '\\\\' || last == '|' || last == ';' || last ==\
    \ '<' || last == '>' || last == '?' || last == '/' || last == '\\\\' || last ==\
    \ '|' || last == ';' || last == '<' || last == '>' || last == '?' || last == '/'\
    \ || last == '\\\\' || last == '|' || last == ';' || last == '<' || last == '>'\
    \ || last == '?' || last == '/' || last == '\\\\' || last == '|' || last == ';'\
    \ || last == '<' || last == '>' || last == '?' || last == '/' || last == '\\\\\
    ' || last == '|' || last == ';' || last == '<' || last == '>' || last == '?' ||\
    \ last == '/' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n \
    \ candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi\
    \ e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false\
    \ },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"\
    Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"\
    apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1nc5p14l_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073370
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n\
    \  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi\
    \ e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false\
    \ },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"\
    Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"\
    apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpzvsxd069_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 2 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '!' || last == '?' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' {\n        return true\n   \
    \ }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpvsatu9nf_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpvsatu9nf_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpvsatu9nf_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpvsatu9nf_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n\
    \  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi\
    \ e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false\
    \ },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"\
    Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"\
    apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpzvsxd069_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpzvsxd069_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    if txt[len(txt)-1] == '.'\
    \ || txt[len(txt)-1] == '?' || txt[len(txt)-1] == '!' || txt[len(txt)-1] == '-'\
    \ || txt[len(txt)-1] == '_' || txt[len(txt)-1] == '/' || txt[len(txt)-1] == '\\\
    \\' || txt[len(txt)-1] == '|' || txt[len(txt)-1] == '@' || txt[len(txt)-1] ==\
    \ '#' || txt[len(txt)-1] == '$' || txt[len(txt)-1] == '%' || txt[len(txt)-1] ==\
    \ '^' || txt[len(txt)-1] == '&' || txt[len(txt)-1] == '*' || txt[len(txt)-1] ==\
    \ '(' || txt[len(txt)-1] == ')' || txt[len(txt)-1] == '+' || txt[len(txt)-1] ==\
    \ '=' || txt[len(txt)-1] == '{' || txt[len(txt)-1] == '}' || txt[len(txt)-1] ==\
    \ '[' || txt[len(txt)-1] == ']' || txt[len(txt)-1] == '|' || txt[len(txt)-1] ==\
    \ '<' || txt[len(txt)-1] == '>' || txt[len(txt)-1] == '?' || txt[len(txt)-1] ==\
    \ '!' || txt[len(txt)-1] == '-' || txt[len(txt)-1] == '_' || txt[len(txt)-1] ==\
    \ '/' || txt[len(txt)-1] == '\\\\' || txt[len(txt)-1] == '|' || txt[len(txt)-1]\
    \ == '@' || txt[len(txt)-1] == '#' || txt[len(txt)-1] == '$' || txt[len(txt)-1]\
    \ == '%' || txt[len(txt)-1] == '^' || txt[len(txt)-1] == '&' || txt[len(txt)-1]\
    \ == '*' || txt[len(txt)-1] == '(' || txt[len(txt)-1] == ')' || txt[len(txt)-1]\
    \ == '+' || txt[len(txt)-1] == '=' || txt[len(txt)-1] == '{' || txt[len(txt)-1]\
    \ == '}' || txt[len(txt)-1] == '[' || txt[len(txt)-1] == ']' || txt[len(txt)-1]\
    \ == '|' || txt[len(txt)-1] == '<' || txt[len(txt)-1] == '>' || txt[len(txt)-1]\
    \ == '?' || txt[len(txt)-1] == '!' || txt[len(txt)-1] == '-' || txt[len(txt)-1]\
    \ == '_' || txt[len(txt)-1] == '/' || txt[len(txt)-1] == '\\\\' || txt[len(txt)-1]\
    \ == '|' || txt[len(txt)-1] == '@' || txt[len(txt)-1] == '#' || txt[len(txt)-1]\
    \ == '$' || txt[len(txt)-1] == '%' || txt[len(txt)-1]\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbzdd85z4_test.go:26:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073370
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n \
    \   txt := strings.ToLower(txt)\n    txt := strings.TrimSpace(txt)\n    txt :=\
    \ strings.Trim(txt, \" \")\n    if strings.Contains(txt, \" \") {\n        return\
    \ false\n    }\n    if strings.Contains(txt, \".\") {\n        return false\n\
    \    }\n    if strings.Contains(txt, \"!\") {\n        return false\n    }\n \
    \   if strings.Contains(txt, \"?\") {\n        return false\n    }\n    if strings.Contains(txt,\
    \ \"-\") {\n        return false\n    }\n    if strings.Contains(txt, \"_\") {\n\
    \        return false\n    }\n    if strings.Contains(txt, \"/\") {\n        return\
    \ false\n    }\n    if strings.Contains(txt, \"(\") {\n        return false\n\
    \    }\n    if strings.Contains(txt, \")\") {\n        return false\n    }\n \
    \   if strings.Contains(txt, \"[\") {\n        return false\n    }\n    if strings.Contains(txt,\
    \ \"]\") {\n        return false\n    }\n    if strings.Contains(txt, \"{\") {\n\
    \        return false\n    }\n    if strings.Contains(txt, \"}\") {\n        return\
    \ false\n    }\n    if strings.Contains(txt, \"\\\"\") {\n        return false\n\
    \    }\n    if strings.Contains(txt, \"'\") {\n        return false\n    }\n \
    \   if strings.Contains(txt, \"<\") {\n        return false\n    }\n    if strings.Contains(txt,\
    \ \">\") {\n        return false\n    }\n    if strings.Contains(txt, \"%\") {\n\
    \        return false\n    }\n    if strings.Contains(txt, \"$\") {\n        return\
    \ false\n    }\n    if strings.Contains(txt, \"&\") {\n        return false\n\
    \    }\n    if strings.Contains(txt, \"'\") {\n        return false\n    }\n \
    \   if strings.Contains(txt, \"=\") {\n        return false\n    }\n    if strings.Contains(txt,\
    \ \";\") {\n        return false\n    }\n    if strings.Contains(txt, \":\") {\n\
    \        return false\n    }\n    if strings.Contains(txt, \"@\") {\n        return\
    \ false\n    }\n    if strings.Contains(txt, \"~\") {\n        return false\n\
    \    }\n    if strings.Contains(txt, \"^\") {\n        return false\n    }\n \
    \   if strings.Contains(txt, \"%\") {\n        return false\n    }\n    if strings.Contains(txt,\
    \ \"+\") {\n        return false\n    }\n    if strings.Contains(txt, \"*\") {\n\
    \        return false\n    }\n    if strings.Contains(txt, \"(\") {\n        return\
    \ false\n    }\n    if strings.Contains(txt, \")\") {\n        return false\n\
    \    }\n    if strings.Contains(txt, \"[\") {\n        return false\n    }\nfunc\
    \ TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpjgpj6o1y_test.go:128:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073370
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' || last >= 'A' && last <= 'Z'\
    \ {\n        return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpphudcn9p_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpphudcn9p_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpphudcn9p_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' {\n        return false\n    }\n    if last >= 'a' && last\
    \ <= 'z' || last >= 'A' && last <= 'Z' {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmprd_knx3l_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmprd_knx3l_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmprd_knx3l_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' {\n        return true\n   \
    \ }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpfa1vi1o__test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpfa1vi1o__test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpfa1vi1o__test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpfa1vi1o__test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return true\n    }\n   \
    \ if lastChar >= 'A' && lastChar <= 'Z' {\n        return true\n    }\n    return\
    \ false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmppk8fmie0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmppk8fmie0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmppk8fmie0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073364
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    if txt[len(txt)-1] >= 'a' &&\
    \ txt[len(txt)-1] <= 'z' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ >= 'A' && txt[len(txt)-1] <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpy8d9im87_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpy8d9im87_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmpy8d9im87_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpy8d9im87_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmpy8d9im87_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmpy8d9im87_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' {\n        return true\n   \
    \ }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp6_cvumu0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp6_cvumu0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp6_cvumu0_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp6_cvumu0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073369
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '?' || last == '!' || last == '@' || last == '#'\
    \ || last == '$' || last == '%' || last == '^' || last == '&' || last == '*' ||\
    \ last == '(' || last == ')' || last == '_' || last == '+' || last == '=' || last\
    \ == '{' || last == '}' || last == '|' || last == ';' || last == '<' || last ==\
    \ '>' || last == '?' || last == '[' || last == ']' || last == '\\\\' || last ==\
    \ '^' || last == '`' || last == '|' || last == ';' || last == '<' || last == '>'\
    \ || last == '?' || last == '[' || last == ']' || last == '\\\\' || last == '^'\
    \ || last == '`' || last == '|' || last == ';' || last == '<' || last == '>' ||\
    \ last == '?' || last == '[' || last == ']' || last == '\\\\' || last == '^' ||\
    \ last == '`' || last == '|' || last == ';' || last == '<' || last == '>' || last\
    \ == '?' || last == '[' || last == ']' || last == '\\\\' || last == '^' || last\
    \ == '`' || last == '|' || last == ';' || last == '<' || last == '>' || last ==\
    \ '?' || last == '[' || last == ']' || last == '\\\\' || last == '^' || last ==\
    \ '`' || last == '|' || last == ';' || last == '<' || last == '>' || last == '?'\
    \ || last == '[' || last == ']' || last == '\\\\' || last == '^' || last == '`'\
    \ || last == '|' || last == ';' || last == '<' || last == '>' || last == '?' ||\
    \ last == '[' || last == ']' || last == '\\\\' || last == '^' || last == '`' ||\
    \ last == '|' || last == ';' || last == '<' || last == '>' || last == '?' || last\
    \ == '[' || last == ']' || last == '\\\\' || last == '^' || last == '`' || last\
    \ == '|' || last == ';' || last == '<' || last == '>' || last == '?' || last ==\
    \ '[' || last == ']' || last == '\\\\' || last == '^' || last == '`' || last ==\
    \ '|' || last == ';' || last == '<' || last == '>' || last == '?' || last == '['\
    \ || last == ']' || last == '\\\\' || last == '^' || last == '`' || last == '|'\
    \ || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate :=\
    \ check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0jt1rqov_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073370
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' || last >=\
    \ 'A' && last <= 'Z' {\n        return true\n    }\n    return false\n}\n\nfunc\
    \ TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp80fzjh57_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp80fzjh57_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp80fzjh57_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '@' || last == '#' ||\
    \ last == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last\
    \ == '(' || last == ')' || last == '+' || last == ',' || last == '-' || last ==\
    \ '.' || last == '/' || last == '\\\\' || last == '!' || last == '?' || last ==\
    \ ';' || last == ':' || last == '<' || last == '>' || last == '?' || last == '@'\
    \ || last == '#' || last == '$' || last == '%' || last == '^' || last == '&' ||\
    \ last == '*' || last == '(' || last == ')' || last == '+' || last == ',' || last\
    \ == '-' || last == '.' || last == '/' || last == '\\\\' || last == '!' || last\
    \ == '?' || last == ';' || last == ':' || last == '<' || last == '>' || last ==\
    \ '?' || last == '@' || last == '#' || last == '$' || last == '%' || last == '^'\
    \ || last == '&' || last == '*' || last == '(' || last == ')' || last == '+' ||\
    \ last == ',' || last == '-' || last == '.' || last == '/' || last == '\\\\' ||\
    \ last == '!' || last == '?' || last == ';' || last == ':' || last == '<' || last\
    \ == '>' || last == '?' || last == '@' || last == '#' || last == '$' || last ==\
    \ '%' || last == '^' || last == '&' || last == '*' || last == '(' || last == ')'\
    \ || last == '+' || last == ',' || last == '-' || last == '.' || last == '/' ||\
    \ last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':' ||\
    \ last == '<' || last == '>' || last == '?' || last == '@' || last == '#' || last\
    \ == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last ==\
    \ '(' || last == ')' || last == '+' || last == ',' || last == '-' || last == '.'\
    \ || last == '/' || last == '\\\\' || last == '!' || last == '?' || last == ';'\
    \ || last == ':' || last == '<' || last == '>' || last == '?' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmzy3wha1_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073365
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    if txt[len(txt)-1] == '.'\
    \ || txt[len(txt)-1] == ' ' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '-' || txt[len(txt)-1] == '_' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '!' || txt[len(txt)-1] == '?' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '.' || txt[len(txt)-1] == ' ' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '-' || txt[len(txt)-1] == '_' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '!' || txt[len(txt)-1] == '?' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '.' || txt[len(txt)-1] == ' ' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '-' || txt[len(txt)-1] == '_' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '!' || txt[len(txt)-1] == '?' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '.' || txt[len(txt)-1] == ' ' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '-' || txt[len(txt)-1] == '_' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '!' || txt[len(txt)-1] == '?' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '.' || txt[len(txt)-1] == ' ' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '-' || txt[len(txt)-1] == '_' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '!' || txt[len(txt)-1] == '?' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '.' || txt[len(txt)-1] == ' ' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '-' || txt[len(txt)-1] == '_' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '!' || txt[len(txt)-1] == '?' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '.' || txt[len(txt)-1] == ' ' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '-' || txt[len(txt)-1] == '_' {\n        return false\n    }\n    if txt[len(txt)-1]\
    \ == '!' || txt[len(txt)-1] == '?' {\n        return false\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpwv4ywcqr_test.go:88:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '@' || last == '&' ||\
    \ last == '%' || last == '^' || last == '$' || last == '*' || last == '(' || last\
    \ == ')' || last == '+' || last == ',' || last == '{' || last == '}' || last ==\
    \ '|' || last == '~' || last == '`' || last == '\xA9' || last == '\xAE' || last\
    \ == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE\
    ' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last\
    \ == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE\
    ' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last\
    \ == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE\
    ' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last\
    \ == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE\
    ' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last\
    \ == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE\
    ' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last\
    \ == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE\
    ' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last\
    \ == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE\
    ' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last\
    \ == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE\
    ' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last == '\xAE' || last\
    \ == '\xAE' || last == '\xAE' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa2hkbkav_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return false\n    }\n  \
    \  if lastChar >= 'A' && lastChar <= 'Z' {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmp0m3rgspl_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar != ' ' && lastChar != '-' && lastChar != '_' {\n        return\
    \ true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpjxveopgf_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpjxveopgf_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpjxveopgf_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpjxveopgf_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' {\n      \
    \  return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' {\n        return\
    \ false\n    }\n    lastchar := last\n    if lastchar == 'a' || lastchar == 'e'\
    \ || lastchar == 'i' || lastchar == 'o' || lastchar == 'u' {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmptia7erom_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmptia7erom_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    if txt[len(txt)-1] == ' '\
    \ {\n        return false\n    }\n    if txt[len(txt)-1] >= 'a' && txt[len(txt)-1]\
    \ <= 'z' {\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpgwdbz8n3_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpgwdbz8n3_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073366
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' {\n      \
    \  return false\n    }\n    if last >= 'A' && last <= 'Z' {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpn23o3rnh_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpn23o3rnh_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpn23o3rnh_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073371
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar != ' ' {\n        return true\n    }\n    words := strings.Split(txt,\
    \ \" \")\n    for _, word := range words {\n        if word == \"\" {\n      \
    \      continue\n        }\n        if strings.Contains(word, lastChar) {\n  \
    \          return false\n        }\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbwlcets8_test.go:29:14: undefined: strings

    /tmp/tmpbwlcets8_test.go:34:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073368
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar != ' ' {\n        return true\n    }\n    lastChar = txt[len(txt)-2]\n\
    \    if lastChar != ' ' {\n        return true\n    }\n    lastChar = txt[len(txt)-3]\n\
    \    if lastChar != ' ' {\n        return true\n    }\n    lastChar = txt[len(txt)-4]\n\
    \    if lastChar != ' ' {\n        return true\n    }\n    return false\n}\n\n\
    func TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmphjfc8bxo_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmphjfc8bxo_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__4 (0.00s)\n      \
    \  tmphjfc8bxo_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmphjfc8bxo_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__7 (0.00s)\n      \
    \  tmphjfc8bxo_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmphjfc8bxo_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__9 (0.00s)\n      \
    \  tmphjfc8bxo_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' {\n        return true\n   \
    \ }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp6_cvumu0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp6_cvumu0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp6_cvumu0_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp6_cvumu0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073369
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 2 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '\\'' || last == '\"' || last == ';' || last ==\
    \ '?' || last == '!' || last == '@' || last == '#' || last == '$' || last == '%'\
    \ || last == '^' || last == '&' || last == '*' || last == '(' || last == ')' ||\
    \ last == '+' || last == ',' || last == '-' || last == '.' || last == '/' || last\
    \ == '\\\\' || last == '\\'' || last == '\"' || last == ';' || last == '?' ||\
    \ last == '!' || last == '@' || last == '#' || last == '$' || last == '%' || last\
    \ == '^' || last == '&' || last == '*' || last == '(' || last == ')' || last ==\
    \ '+' || last == ',' || last == '-' || last == '.' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '\\'' || last == '\"' || last == ';' || last ==\
    \ '?' || last == '!' || last == '@' || last == '#' || last == '$' || last == '%'\
    \ || last == '^' || last == '&' || last == '*' || last == '(' || last == ')' ||\
    \ last == '+' || last == ',' || last == '-' || last == '.' || last == '_' || last\
    \ == '/' || last == '\\\\' || last == '\\'' || last == '\"' || last == ';' ||\
    \ last == '?' || last == '!' || last == '@' || last == '#' || last == '$' || last\
    \ == '%' || last == '^' || last == '&' || last == '*' || last == '(' || last ==\
    \ ')' || last == '+' || last == ',' || last == '-' || last == '.' || last == '_'\
    \ || last == '/' || last == '\\\\' || last == '\\'' || last == '\"' || last ==\
    \ ';' || last == '?' || last == '!' || last == '@' || last == '#' || last == '$'\
    \ || last == '%' || last == '^' || last == '&' || last == '*' || last == '(' ||\
    \ last == ')' || last == '+' || last == ',' || last == '-' || last == '.' || last\
    \ == '_' || last == '/' || last == '\\\\' || last == '\\'' || last == '\"' ||\
    \ last == ';' || last == '?' || last == '!' || last == '@' || last == '#' || last\
    \ == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last ==\
    \ '(' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyvrso5xv_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '@' || last == '#' ||\
    \ last == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last\
    \ == '(' || last == ')' || last == '+' || last == ',' || last == '{' || last ==\
    \ '}' || last == '|' || last == '\\\\' || last == ';' || last == '\"' || last\
    \ == '\"' || last == '/' || last == '\\\\' || last == '[' || last == ']' || last\
    \ == '^' || last == '`' || last == '~' || last == '-' || last == '_' || last ==\
    \ '.' || last == '/' || last == '\\\\' || last == '!' || last == '?' || last ==\
    \ ';' || last == ':' || last == '<' || last == '>' || last == '?' || last == '@'\
    \ || last == '#' || last == '$' || last == '%' || last == '^' || last == '&' ||\
    \ last == '*' || last == '(' || last == ')' || last == '+' || last == ',' || last\
    \ == '{' || last == '}' || last == '|' || last == '\\\\' || last == ';' || last\
    \ == '\"' || last == '\"' || last == '/' || last == '\\\\' || last == '[' || last\
    \ == ']' || last == '^' || last == '`' || last == '~' || last == '-' || last ==\
    \ '_' || last == '.' || last == '/' || last == '\\\\' || last == '!' || last ==\
    \ '?' || last == ';' || last == ':' || last == '<' || last == '>' || last == '?'\
    \ || last == '@' || last == '#' || last == '$' || last == '%' || last == '^' ||\
    \ last == '&' || last == '*' || last == '(' || last == ')' || last == '+' || last\
    \ == ',' || last == '{' || last == '}' || last == '|' || last == '\\\\' || last\
    \ == ';' || last == '\"' || last == '\"' || last == '/' || last == '\\\\' || last\
    \ == '[' || last == ']' || last == '^' || last == '`' || last == '~' || last ==\
    \ '-' || last == '_' || last == '.' || last == '/' || last == '\\\\' || last ==\
    \ '!' || last == '?' || last == ';' || last == ':' || last == '<' || last == '>'\
    \ || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate :=\
    \ check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppdp1hm_g_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    if txt[len(txt)-1] == ' '\
    \ {\n        return false\n    }\n    if txt[len(txt)-1] >= 'a' && txt[len(txt)-1]\
    \ <= 'z' {\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpgwdbz8n3_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpgwdbz8n3_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073366
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 2 {\n        return false\n    }\n    if txt[len(txt)-1] == ' ' {\n\
    \        return false\n    }\n    if txt[len(txt)-1] >= 'a' && txt[len(txt)-1]\
    \ <= 'z' {\n        return false\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__1\
    \ (0.00s)\n        tmpbj2n808w_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpbj2n808w_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmpbj2n808w_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073372
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar >= 'a' && lastChar <= 'z' {\n        return true\n    }\n   \
    \ return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n\
    \  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(\"apple\"), expected: false },\n     { actual: candidate(\"apple pi\
    \ e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected: false\
    \ },\n     { actual: candidate(\"A\"), expected: true },\n     { actual: candidate(\"\
    Pumpkin pie \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"\
    ), expected: false },\n     { actual: candidate(\"\"), expected: false },\n  \
    \   { actual: candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"\
    apple pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmpwq26uptf_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmpwq26uptf_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmpwq26uptf_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmpwq26uptf_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '!' || last == '?' || last == ';'\
    \ || last == '-' || last == '_' || last == '/' || last == '\\\\' || last == '$'\
    \ || last == '@' || last == '&' || last == '*' || last == '(' || last == ')' ||\
    \ last == '+' || last == '{' || last == '}' || last == '|' || last == ';' || last\
    \ == ':' || last == '<' || last == '>' || last == '?' || last == '[' || last ==\
    \ ']' || last == '^' || last == '~' || last == '`' || last == '{' || last == '}'\
    \ || last == '~' || last == '-' || last == '_' || last == '/' || last == '\\\\\
    ' || last == '$' || last == '@' || last == '&' || last == '*' || last == '(' ||\
    \ last == ')' || last == '+' || last == '{' || last == '}' || last == '|' || last\
    \ == ';' || last == ':' || last == '<' || last == '>' || last == '?' || last ==\
    \ '[' || last == ']' || last == '^' || last == '~' || last == '`' || last == '{'\
    \ || last == '}' || last == '~' || last == '-' || last == '_' || last == '/' ||\
    \ last == '\\\\' || last == '$' || last == '@' || last == '&' || last == '*' ||\
    \ last == '(' || last == ')' || last == '+' || last == '{' || last == '}' || last\
    \ == '|' || last == ';' || last == ':' || last == '<' || last == '>' || last ==\
    \ '?' || last == '[' || last == ']' || last == '^' || last == '~' || last == '`'\
    \ || last == '{' || last == '}' || last == '~' || last == '-' || last == '_' ||\
    \ last == '/' || last == '\\\\' || last == '$' || last == '@' || last == '&' ||\
    \ last == '*' || last == '(' || last == ')' || last == '+' || last == '{' || last\
    \ == '}' || last == '|' || last == ';' || last == ':' || last == '<' || last ==\
    \ '>' || last == '?' || last == '[' || last == ']' || last == '^' || last == '~'\
    \ || last == '`' || last == '{' || last == '}' || last == '~' || last == '-' ||\
    \ last == '_' || last == '/' || last == '\\\\' || last == '$' || last == '@' ||\
    \ last == '&' || last == '*' || last == '(' || last == ')' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbw9iby07_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '!' || last == '?' || last == ';' || last == ':'\
    \ || last == '<' || last == '>' || last == '?' || last == '@' || last == '#' ||\
    \ last == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last\
    \ == '(' || last == ')' || last == '_' || last == '+' || last == '=' || last ==\
    \ '{' || last == '}' || last == '|' || last == '\\\\' || last == ';' || last ==\
    \ '\"' || last == '\\'' || last == '\"' || last == '<' || last == '>' || last\
    \ == '?' || last == '@' || last == '#' || last == '$' || last == '%' || last ==\
    \ '^' || last == '&' || last == '*' || last == '(' || last == ')' || last == '_'\
    \ || last == '+' || last == '=' || last == '{' || last == '}' || last == '|' ||\
    \ last == '\\\\' || last == ';' || last == '\"' || last == '\\'' || last == '\"\
    ' || last == '<' || last == '>' || last == '?' || last == '@' || last == '#' ||\
    \ last == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last\
    \ == '(' || last == ')' || last == '_' || last == '+' || last == '=' || last ==\
    \ '{' || last == '}' || last == '|' || last == '\\\\' || last == ';' || last ==\
    \ '\"' || last == '\\'' || last == '\"' || last == '<' || last == '>' || last\
    \ == '?' || last == '@' || last == '#' || last == '$' || last == '%' || last ==\
    \ '^' || last == '&' || last == '*' || last == '(' || last == ')' || last == '_'\
    \ || last == '+' || last == '=' || last == '{' || last == '}' || last == '|' ||\
    \ last == '\\\\' || last == ';' || last == '\"' || last == '\\'' || last == '\"\
    ' || last == '<' || last == '>' || last == '?' || last == '@' || last == '#' ||\
    \ last == '$' || last == '%' || last == '^' || last == '&' || last == '*' || last\
    \ == '(' || last == ')' || last == '_' || last == '+' || last == '=' || last ==\
    \ '{' || last == '}' || last == '|' || last == '\\\\' || last == ';' || last ==\
    \ '\"' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6efv6h15_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    lastChar := txt[len(txt)-1]\n\
    \    if lastChar != ' ' && lastChar != '-' && lastChar != '_' {\n        return\
    \ true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp6y39b89w_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp6y39b89w_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__5 (0.00s)\n      \
    \  tmp6y39b89w_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp6y39b89w_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660073372
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' {\n      \
    \  return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp93rcthdh_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp93rcthdh_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp93rcthdh_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp93rcthdh_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073362
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '?' || last == '!' || last == '@' || last == '$'\
    \ || last == '%' || last == '^' || last == '&' || last == '*' || last == '(' ||\
    \ last == ')' || last == '+' || last == ',' || last == '{' || last == '}' || last\
    \ == '|' || last == ';' || last == ':' || last == '<' || last == '>' || last ==\
    \ '?' || last == '[' || last == ']' || last == '\\\\' || last == '{' || last ==\
    \ '}' || last == '|' || last == ';' || last == ':' || last == '<' || last == '>'\
    \ || last == '?' || last == '[' || last == ']' || last == '\\\\' || last == '{'\
    \ || last == '}' || last == '|' || last == ';' || last == ':' || last == '<' ||\
    \ last == '>' || last == '?' || last == '[' || last == ']' || last == '\\\\' ||\
    \ last == '{' || last == '}' || last == '|' || last == ';' || last == ':' || last\
    \ == '<' || last == '>' || last == '?' || last == '[' || last == ']' || last ==\
    \ '\\\\' || last == '{' || last == '}' || last == '|' || last == ';' || last ==\
    \ ':' || last == '<' || last == '>' || last == '?' || last == '[' || last == ']'\
    \ || last == '\\\\' || last == '{' || last == '}' || last == '|' || last == ';'\
    \ || last == ':' || last == '<' || last == '>' || last == '?' || last == '[' ||\
    \ last == ']' || last == '\\\\' || last == '{' || last == '}' || last == '|' ||\
    \ last == ';' || last == ':' || last == '<' || last == '>' || last == '?' || last\
    \ == '[' || last == ']' || last == '\\\\' || last == '{' || last == '}' || last\
    \ == '|' || last == ';' || last == ':' || last == '<' || last == '>' || last ==\
    \ '?' || last == '[' || last == ']' || last == '\\\\' || last == '{' || last ==\
    \ '}' || last == '|' || last == ';' || last == ':' || last == '<' || last == '>'\
    \ || last == '?' || last == '[' || last == ']' || last == '\\\\' || last == '{'\
    \ || last == '}' || last == '|' || last == ';' || last == ':' || last == '<' ||\
    \ \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpe41j9pc5_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' {\n        return true\n   \
    \ }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp6_cvumu0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp6_cvumu0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp6_cvumu0_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp6_cvumu0_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073369
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    if last >= 'a' && last <= 'z' {\n      \
    \  return true\n    }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp_k_7edun_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073363
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) == 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' {\n        return\
    \ false\n    }\n    if last >= 'a' && last <= 'z' {\n        return true\n   \
    \ }\n    return false\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T)\
    \ {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCheck_If_Last_Char_Is_A_Letter (0.00s)\n    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__0\
    \ (0.00s)\n        tmp7dxygx6g_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__2 (0.00s)\n      \
    \  tmp7dxygx6g_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__3 (0.00s)\n      \
    \  tmp7dxygx6g_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestCheck_If_Last_Char_Is_A_Letter/test_num__8 (0.00s)\n      \
    \  tmp7dxygx6g_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660073361
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    txt := txt[:len(txt)-1]\n\
    \    txt := strings.ToLower(txt)\n    txt := strings.Trim(txt, \" \")\n    txt\
    \ := strings.Split(txt, \" \")\n    for _, word := range txt {\n        if strings.Contains(word,\
    \ txt[len(txt)-1]) {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(\"apple\"), expected: false },\n\
    \     { actual: candidate(\"apple pi e\"), expected: true },\n     { actual: candidate(\"\
    eeeee\"), expected: false },\n     { actual: candidate(\"A\"), expected: true\
    \ },\n     { actual: candidate(\"Pumpkin pie \"), expected: false },\n     { actual:\
    \ candidate(\"Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\
    \"), expected: false },\n     { actual: candidate(\"eeeee e \"), expected: false\
    \ },\n     { actual: candidate(\"apple pie\"), expected: false },\n     { actual:\
    \ candidate(\"apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwg4wfpjt_test.go:25:9: no new variables on left side of :=

    /tmp/tmpwg4wfpjt_test.go:26:9: no new variables on left side of :=

    /tmp/tmpwg4wfpjt_test.go:26:12: undefined: strings

    /tmp/tmpwg4wfpjt_test.go:27:9: no new variables on left side of :=

    /tmp/tmpwg4wfpjt_test.go:27:12: undefined: strings

    /tmp/tmpwg4wfpjt_test.go:28:9: no new variables on left side of :=

    /tmp/tmpwg4wfpjt_test.go:28:12: undefined: strings

    /tmp/tmpwg4wfpjt_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '\\'' || last == '\"' || last == ';' || last ==\
    \ '<' || last == '>' || last == '?' || last == '!' || last == '@' || last == '#'\
    \ || last == '$' || last == '%' || last == '^' || last == '&' || last == '*' ||\
    \ last == '(' || last == ')' || last == '+' || last == ',' || last == '-' || last\
    \ == '.' || last == '/' || last == '\\\\' || last == '\\'' || last == '\"' ||\
    \ last == ';' || last == '<' || last == '>' || last == '?' || last == '!' || last\
    \ == '@' || last == '#' || last == '$' || last == '%' || last == '^' || last ==\
    \ '&' || last == '*' || last == '(' || last == ')' || last == '+' || last == ','\
    \ || last == '-' || last == '.' || last == '_' || last == '/' || last == '\\\\\
    ' || last == '\\'' || last == '\"' || last == ';' || last == '<' || last == '>'\
    \ || last == '?' || last == '!' || last == '@' || last == '#' || last == '$' ||\
    \ last == '%' || last == '^' || last == '&' || last == '*' || last == '(' || last\
    \ == ')' || last == '+' || last == ',' || last == '-' || last == '.' || last ==\
    \ '_' || last == '/' || last == '\\\\' || last == '\\'' || last == '\"' || last\
    \ == ';' || last == '<' || last == '>' || last == '?' || last == '!' || last ==\
    \ '@' || last == '#' || last == '$' || last == '%' || last == '^' || last == '&'\
    \ || last == '*' || last == '(' || last == ')' || last == '+' || last == ',' ||\
    \ last == '-' || last == '.' || last == '_' || last == '/' || last == '\\\\' ||\
    \ last == '\\'' || last == '\"' || last == ';' || last == '<' || last == '>' ||\
    \ last == '?' || last == '!' || last == '@' || last == '#' || last == '$' || last\
    \ == '%' || last == '^' || last == '&' || last == '*' || last == '(' || last ==\
    \ ')' || last == '+' || last == ',' || last == '-' || last == '.' || last == '_'\
    \ || last == '/' || last == '\\\\' || last == '\\'' || last == '\"' || last ==\
    \ ';' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t *testing.T) {\n  candidate\
    \ := check_if_last_char_is_a_letter\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(\"\
    apple\"), expected: false },\n     { actual: candidate(\"apple pi e\"), expected:\
    \ true },\n     { actual: candidate(\"eeeee\"), expected: false },\n     { actual:\
    \ candidate(\"A\"), expected: true },\n     { actual: candidate(\"Pumpkin pie\
    \ \"), expected: false },\n     { actual: candidate(\"Pumpkin pie 1\"), expected:\
    \ false },\n     { actual: candidate(\"\"), expected: false },\n     { actual:\
    \ candidate(\"eeeee e \"), expected: false },\n     { actual: candidate(\"apple\
    \ pie\"), expected: false },\n     { actual: candidate(\"apple pi e \"), expected:\
    \ false },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4x22j5ts_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073371
- exit_code: 1
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) < 1 {\n        return false\n    }\n    last := txt[len(txt)-1]\n \
    \   if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ || last == '\\\\' || last == '?' || last == '!' || last == '@' || last == '#'\
    \ || last == '$' || last == '%' || last == '^' || last == '&' || last == '*' ||\
    \ last == '(' || last == ')' || last == '+' || last == ',' || last == '{' || last\
    \ == '}' || last == '|' || last == ';' || last == ':' || last == '<' || last ==\
    \ '>' || last == '?' || last == '~' || last == '`' || last == '-' || last == '_'\
    \ || last == '.' || last == '/' || last == '\\\\' || last == '?' || last == '!'\
    \ || last == '@' || last == '#' || last == '$' || last == '%' || last == '^' ||\
    \ last == '&' || last == '*' || last == '(' || last == ')' || last == '+' || last\
    \ == ',' || last == '{' || last == '}' || last == '|' || last == ';' || last ==\
    \ ':' || last == '<' || last == '>' || last == '?' || last == '~' || last == '`'\
    \ || last == '-' || last == '_' || last == '.' || last == '/' || last == '\\\\\
    ' || last == '?' || last == '!' || last == '@' || last == '#' || last == '$' ||\
    \ last == '%' || last == '^' || last == '&' || last == '*' || last == '(' || last\
    \ == ')' || last == '+' || last == ',' || last == '{' || last == '}' || last ==\
    \ '|' || last == ';' || last == ':' || last == '<' || last == '>' || last == '?'\
    \ || last == '~' || last == '`' || last == '-' || last == '_' || last == '.' ||\
    \ last == '/' || last == '\\\\' || last == '?' || last == '!' || last == '@' ||\
    \ last == '#' || last == '$' || last == '%' || last == '^' || last == '&' || last\
    \ == '*' || last == '(' || last == ')' || last == '+' || last == ',' || last ==\
    \ '{' || last == '}' || last == '|' || last == ';' || last == ':' || last == '<'\
    \ || last == '>' || last == '?' || last == '~' || last == '`' || last == '-' ||\
    \ last == '_' || last == '.' || last == '/' || last == '\\\\' || last == '?' ||\
    \ last == '!' || last == '@' || last == '#' || last == '$' || \nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp9muss8rg_test.go:27:6: expected ''('', found TestCheck_If_Last_Char_Is_A_Letter

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660073371
- exit_code: 2
  program: "package check_if_last_char_is_a_letter_test\n\nimport (\n    \"testing\"\
    \n    \"fmt\"\n)\n\n// Create a function that returns true if the last character\n\
    // of a given string is an alphabetical character and is not\n// a part of a word,\
    \ and false otherwise.\n// Note: \"word\" is a group of characters separated by\
    \ space.\n// Examples:\n// >>> check_if_last_char_is_a_letter(\"apple pie\")\n\
    // false\n// >>> check_if_last_char_is_a_letter(\"apple pi e\")\n// true\n// >>>\
    \ check_if_last_char_is_a_letter(\"apple pi e \")\n// false\n// >>> check_if_last_char_is_a_letter(\"\
    \")\n// false\nfunc check_if_last_char_is_a_letter(txt string) bool {\n    if\
    \ len(txt) <= 0 {\n        return false\n    }\n    last := txt[len(txt)-1]\n\
    \    if last == ' ' || last == '.' || last == '-' || last == '_' || last == '/'\
    \ {\n        return false\n    }\n    for _, letter := range []string{\"a\", \"\
    b\", \"c\", \"d\", \"e\", \"f\", \"g\", \"h\", \"i\", \"j\", \"k\", \"l\", \"\
    m\", \"n\", \"o\", \"p\", \"q\", \"r\", \"s\", \"t\", \"u\", \"v\", \"w\", \"\
    x\", \"y\", \"z\"} {\n        if last == letter {\n            return false\n\
    \        }\n    }\n    return true\n}\n\nfunc TestCheck_If_Last_Char_Is_A_Letter(t\
    \ *testing.T) {\n  candidate := check_if_last_char_is_a_letter\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(\"apple\"), expected: false },\n     { actual: candidate(\"\
    apple pi e\"), expected: true },\n     { actual: candidate(\"eeeee\"), expected:\
    \ false },\n     { actual: candidate(\"A\"), expected: true },\n     { actual:\
    \ candidate(\"Pumpkin pie \"), expected: false },\n     { actual: candidate(\"\
    Pumpkin pie 1\"), expected: false },\n     { actual: candidate(\"\"), expected:\
    \ false },\n     { actual: candidate(\"eeeee e \"), expected: false },\n     {\
    \ actual: candidate(\"apple pie\"), expected: false },\n     { actual: candidate(\"\
    apple pi e \"), expected: false },\n   }\n\n\tfor i, tc := range tests {\n\t\t\
    t.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpgq5sf9lf_test.go:30:20: invalid operation: last == letter (mismatched
    types byte and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660073371
