language: go_test.go
name: HumanEval_74_total_match
results:
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    m := make(map[string]int)\n    for _, s := range\
    \ lst1 {\n        m[s]++\n    }\n    for _, s := range lst2 {\n        m[s]++\n\
    \    }\n    result := make([]string, 0, len(m))\n    for k := range m {\n    \
    \    if m[k] == len(lst1) {\n            result = append(result, k)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpcwlobkd__test.go:60: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpcwlobkd__test.go:60: expected\
    \ '[hi admin]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpcwlobkd__test.go:60: expected '[4]', got '[1 2 3 5]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__4 (0.00s)\n        tmpcwlobkd__test.go:60: expected\
    \ '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n   \
    \     tmpcwlobkd__test.go:60: expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpcwlobkd__test.go:60: expected '[hi admin]', got '[hi]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpcwlobkd__test.go:60:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst2 = append([]string{}, lst2...)\n        len2 = len1\n    }\n    result\
    \ := make([]string, len2)\n    for i := 0; i < len2; i++ {\n        result[i]\
    \ = lst1[i]\n    }\n    for i := 0; i < len1; i++ {\n        j := i\n        for\
    \ j < len2 && lst1[j] == lst2[i] {\n            j++\n        }\n        if j >\
    \ len2 {\n            break\n        }\n        result[i] = lst2[j]\n    }\n \
    \   return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0001d6020?, 0x2, 0x450329?},\
    \ {0xc000187db0?, 0x4, 0x0?})\n\t/tmp/tmphmndixvj_test.go:34 +0x27b\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmphmndixvj_test.go:58 +0x1f0\ntesting.tRunner(0xc000199040, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            result[i] = lst1[i]\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpjkcyjac8_test.go:57: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpjkcyjac8_test.go:57:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpjkcyjac8_test.go:57: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpjkcyjac8_test.go:57:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write your code here\n    \n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n    for _, str1 := range\
    \ lst1 {\n        for _, str2 := range lst2 {\n            if str1 == str2 {\n\
    \                continue\n            }\n            result += []string{str1,\
    \ str2}\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp05whr3af_test.go:29:13: invalid operation: operator + not defined on result
    (variable of type []string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := make([]string, 0)\n    if len(lst1)\
    \ != len(lst2) {\n        return nil\n    }\n    for _, v := range lst1 {\n  \
    \      if lst2 != nil && len(v) < len(lst2[0]) {\n            return nil\n   \
    \     }\n        for _, v2 := range lst2 {\n            if v == v2 {\n       \
    \         continue // skip the loop if v is already in the result\n          \
    \  }\n        }\n        result = append(result, v)\n    }\n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmprvfkqnnc_test.go:62: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmprvfkqnnc_test.go:62:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmprvfkqnnc_test.go:62: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmprvfkqnnc_test.go:62: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmprvfkqnnc_test.go:62:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmprvfkqnnc_test.go:62: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len == 0 || lst2Len == 0 {\n        return []string{}\n    }\n   \
    \ \n    result := []string{}\n    \n    for i := 0; i < lst1Len; i++ {\n     \
    \   if lst1[i] < lst2[i] {\n            lst1[i] = lst1[i] + \"\"\n           \
    \ lst2[i] = lst2[i] + \"\"\n        }\n    }\n    \n    for i := 0; i < lst2Len;\
    \ i++ {\n        if lst1[i] < lst2[i] {\n            lst1[i] = lst1[i] + \"\"\n\
    \            lst2[i] = lst2[i] + \"\"\n        }\n    }\n    \n    for i := 0;\
    \ i < lst1Len; i++ {\n        if lst1[i] < lst2[i] {\n            result = append(result,\
    \ lst1[i])\n        }\n    }\n    \n    for i := 0; i < lst2Len; i++ {\n     \
    \   if lst1[i] < lst2[i] {\n            result = append(result, lst2[i])\n   \
    \     }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000f5d30, 0x2, 0x0?}, {0xc0000f5db0,\
    \ 0x4, 0x0?})\n\t/tmp/tmpedgp_hgu_test.go:39 +0x5f0\ncommand-line-arguments_test.TestTotal_Match(0xc0001924e0?)\n\
    \t/tmp/tmpedgp_hgu_test.go:69 +0x22f\ntesting.tRunner(0xc0001924e0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            result[i] = lst1[i]\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpg7vpcbvy_test.go:57: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpg7vpcbvy_test.go:57:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpg7vpcbvy_test.go:57: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpg7vpcbvy_test.go:57: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpg7vpcbvy_test.go:57:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpg7vpcbvy_test.go:57: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    m := make(map[string]int)\n    for _, v := range\
    \ lst1 {\n        m[v]++\n    }\n    for _, v := range lst2 {\n        m[v]--\n\
    \    }\n    result := make([]string, 0)\n    for k := range m {\n        if m[k]\
    \ == 0 {\n            result = append(result, k)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpmglks52h_test.go:60: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpmglks52h_test.go:60: expected\
    \ '[hi admin]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n\
    \        tmpmglks52h_test.go:60: expected '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpmglks52h_test.go:60: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpmglks52h_test.go:60:\
    \ expected '[hi admin]', got '[hi]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := make([]string, 0)\n    if len(lst1)\
    \ == 0 {\n        return result\n    }\n    if len(lst2) == 0 {\n        return\
    \ result\n    }\n    \n    len1 := len(lst1)\n    len2 := len(lst2)\n    \n  \
    \  if len1 == len2 {\n        for i := 0; i < len1; i++ {\n            if lst1[i]\
    \ < lst2[i] {\n                result = append(result, lst1[i])\n            }\n\
    \        }\n        return result\n    }\n    \n    for i := 0; i < len1; i++\
    \ {\n        if lst1[i] < lst2[i] {\n            result = append(result, lst1[i])\n\
    \        }\n    }\n    for i := 0; i < len2; i++ {\n        if lst2[i] < lst1[i]\
    \ {\n            result = append(result, lst2[i])\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000f5d30, 0x2, 0x0?}, {0xc0000f5db0,\
    \ 0x4, 0x0?})\n\t/tmp/tmp45v38qd8_test.go:49 +0x34e\ncommand-line-arguments_test.TestTotal_Match(0xc0001a0340?)\n\
    \t/tmp/tmp45v38qd8_test.go:65 +0x22f\ntesting.tRunner(0xc0001a0340, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    m := make(map[string]int)\n    for _, s := range\
    \ lst1 {\n        m[s] = m[s] + 1\n    }\n    for _, s := range lst2 {\n     \
    \   m[s] = m[s] + 1\n    }\n    result := make([]string, 0)\n    for k := range\
    \ m {\n        if m[k] == len(lst1) {\n            result = append(result, k)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmphb158ctl_test.go:60: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmphb158ctl_test.go:60: expected\
    \ '[hi admin]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmphb158ctl_test.go:60: expected '[4]', got '[1 2 3 5]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__4 (0.00s)\n        tmphb158ctl_test.go:60: expected\
    \ '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n   \
    \     tmphb158ctl_test.go:60: expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmphb158ctl_test.go:60: expected '[hi admin]', got '[hi]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmphb158ctl_test.go:60:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := []string{}\n    \n    for _, val := range lst1\
    \ {\n        if strings.Count(val, \"\") < strings.Count(lst2[0], \"\") {\n  \
    \          result = append(result, val)\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjyylm6sg_test.go:31:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074750
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    \n    if len(lst1)\
    \ != len(lst2) {\n        return lst3\n    }\n    \n    for _, v := range lst1\
    \ {\n        if lst2 := total_match_single(v, lst2); lst2 != nil {\n         \
    \   lst3 = append(lst3, lst2...)\n        }\n    }\n    \n    return lst3\n}\n\
    \nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpoxslm5tm_test.go:30:20: undefined: total_match_single

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ nil\n    }\n    \n    result := []string{}\n    \n    for _, item := range lst1\
    \ {\n        if item == \"\" {\n            continue\n        }\n        \n  \
    \      found := false\n        for _, item2 := range lst2 {\n            if item\
    \ == item2 {\n                found = true\n                break\n          \
    \  }\n        }\n        \n        if !found {\n            result = append(result,\
    \ item)\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp_c7nvt6a_test.go:72: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp_c7nvt6a_test.go:72:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp_c7nvt6a_test.go:72: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp_c7nvt6a_test.go:72: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp_c7nvt6a_test.go:72:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp_c7nvt6a_test.go:72: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        result[i] = lst1[i]\n    }\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            break\n        }\n    }\n\
    \    \n    for i := 0; i < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n\
    \            break\n        }\n    }\n    \n    for i := 0; i < len(lst1); i++\
    \ {\n        if lst1[i] != lst2[i] {\n            break\n        }\n    }\n  \
    \  \n    for i := 0; i < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n \
    \           break\n        }\n    }\n    \n    for i := 0; i < len(lst1); i++\
    \ {\n        if lst1[i] != lst2[i] {\n            break\n        }\n    }\n  \
    \  \n    for i := 0; i < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n \
    \           break\n        }\n    }\n    \n    for i := 0; i < len(lst1); i++\
    \ {\n        if lst1[i] != lst2[i] {\n            break\n        }\n    }\n  \
    \  \n    for i := 0; i < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n \
    \           break\n        }\n    }\n    \n    for i := 0; i < len(lst1); i++\
    \ {\n        if lst1[i] != lst2[i] {\n            break\n        }\n    }\n  \
    \  \n    for i := 0; i < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n \
    \           break\n        }\n    }\n    \n    for i := 0; i < len(lst1); i++\
    \ {\n        if lst1[i] != lst2[i] {\n            break\n        }\n    }\n  \
    \  \n    for i := 0; i < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n \
    \           break\n        }\n    }\n    \n    for i := 0; i < len(lst1); i++\
    \ {\n        if lst1[i] != lst2[i] {\n            break\n        }\n    }\n  \
    \  \n    for i := 0; i < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n \
    \           break\n        }\n    }\n    \n    for i := 0; i < len(lst1); i++\
    \ {\n        if lst1[i] != lst2[i] {\n            break\n        }\n    }\n  \
    \  \n    for i := 0; i < len(lst1); i++ {\n        if lst\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpr8ckkl3y_test.go:124:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074749
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    for _, val := range lst1 {\n\
    \        if lst2 != nil && len(val) < len(lst2) {\n            continue\n    \
    \    }\n        if lst2 != nil && len(val) >= len(lst2) {\n            continue\n\
    \        }\n        result = append(result, val)\n    }\n    return result\n}\n\
    \nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp2s1o9h5z_test.go:61: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp2s1o9h5z_test.go:61: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp2s1o9h5z_test.go:61: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp2s1o9h5z_test.go:61: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp2s1o9h5z_test.go:61: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp2s1o9h5z_test.go:61: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := 0; i\
    \ < len(lst1); i++ {\n        total := 0\n        for _, s := range lst1 {\n \
    \           if s == lst2[i] {\n                total++\n            }\n      \
    \  }\n        if total == len(lst1) {\n            result[i] = lst1[i]\n     \
    \   }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp1096kxe4_test.go:65: expected '[hi hi]', got '[ ]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp1096kxe4_test.go:65:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp1096kxe4_test.go:65: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp1096kxe4_test.go:65: expected '[hI Hi]', got '[ ]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp1096kxe4_test.go:65:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp1096kxe4_test.go:65: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  \n    if len1 == len2 {\n        return lst1\n    }\n    \n    result := make([]string,\
    \ len1)\n    \n    for i := 0; i < len1; i++ {\n        if lst1[i] < lst2[i] {\n\
    \            result[i] = lst1[i]\n        } else {\n            result[i] = lst2[i]\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x5134c0,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5134c0, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmpdtyjnfvp_test.go:33\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmpdtyjnfvp_test.go:58\
    \ +0x737\ntesting.tRunner(0xc0001036c0, 0x528dd8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    lst4 := make([]string,\
    \ 0)\n    lst5 := make([]string, 0)\n    lst6 := make([]string, 0)\n    lst7 :=\
    \ make([]string, 0)\n    lst8 := make([]string, 0)\n    lst9 := make([]string,\
    \ 0)\n    lst10 := make([]string, 0)\n    lst11 := make([]string, 0)\n    lst12\
    \ := make([]string, 0)\n    lst13 := make([]string, 0)\n    lst14 := make([]string,\
    \ 0)\n    lst15 := make([]string, 0)\n    lst16 := make([]string, 0)\n    lst17\
    \ := make([]string, 0)\n    lst18 := make([]string, 0)\n    lst19 := make([]string,\
    \ 0)\n    lst20 := make([]string, 0)\n    lst21 := make([]string, 0)\n    lst22\
    \ := make([]string, 0)\n    lst23 := make([]string, 0)\n    lst24 := make([]string,\
    \ 0)\n    lst25 := make([]string, 0)\n    lst26 := make([]string, 0)\n    lst27\
    \ := make([]string, 0)\n    lst28 := make([]string, 0)\n    lst29 := make([]string,\
    \ 0)\n    lst30 := make([]string, 0)\n    lst31 := make([]string, 0)\n    lst32\
    \ := make([]string, 0)\n    lst33 := make([]string, 0)\n    lst34 := make([]string,\
    \ 0)\n    lst35 := make([]string, 0)\n    lst36 := make([]string, 0)\n    lst37\
    \ := make([]string, 0)\n    lst38 := make([]string, 0)\n    lst39 := make([]string,\
    \ 0)\n    lst40 := make([]string, 0)\n    lst41 := make([]string, 0)\n    lst42\
    \ := make([]string, 0)\n    lst43 := make([]string, 0)\n    lst44 := make([]string,\
    \ 0)\n    lst45 := make([]string, 0)\n    lst46 := make([]string, 0)\n    lst47\
    \ := make([]string, 0)\n    lst48 := make([]string, 0)\n    lst49 := make([]string,\
    \ 0)\n    lst50 := make([]string, 0)\n    lst51 := make([]string, 0)\n    lst52\
    \ := make([]string, 0)\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate :=\
    \ total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm907yxs1_test.go:74:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074749
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkee1wx5g_test.go:280:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074749
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := 0; i\
    \ < len(lst1); i++ {\n        if lst1[i] < lst2[i] {\n            result[i] =\
    \ lst1[i]\n        } else {\n            result[i] = lst2[i]\n        }\n    }\n\
    \    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpv2t440oi_test.go:61: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpv2t440oi_test.go:61:\
    \ expected '[hI hi hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__8\
    \ (0.00s)\n        tmpv2t440oi_test.go:61: expected '[]', got '[this]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst2\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    len1 := len(lst1)\n\
    \    len2 := len(lst2)\n    \n    if len1 == len2 {\n        \n        for i :=\
    \ 0; i < len1; i++ {\n            if lst1[i] > lst2[i] {\n                return\
    \ lst1\n            }\n        }\n        return lst2\n    }\n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \nfunc TestTotal_Match(t *testing.T) {\n  candidate :=\
    \ total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpud7f12q1_test.go:256:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074749
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    for _, val :=\
    \ range lst1 {\n        if !contains(lst2, val) {\n            lst3 = append(lst3,\
    \ val)\n        }\n    }\n    return lst3\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwt2tglnu_test.go:25:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0;\
    \ i < len2; i++ {\n        if result[i] != lst2[i] {\n            return result\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5124c0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5124c0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmpzjix10b8_test.go:36\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmpzjix10b8_test.go:57\
    \ +0x60f\ntesting.tRunner(0xc0001a0340, 0x527dd0)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074751
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   return lst2\n    }\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpfab3puaw_test.go:55: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpfab3puaw_test.go:55:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpfab3puaw_test.go:55: expected '[hI hi hi]', got '[hi admin]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074751
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst2\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    lst1_count\
    \ := 0\n    lst2_count := 0\n    for _, s := range lst1 {\n        lst1_count\
    \ += len(s)\n    }\n    for _, s := range lst2 {\n        lst2_count += len(s)\n\
    \    }\n    if lst1_count == lst2_count {\n        return lst1\n    }\n    return\
    \ lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__2\
    \ (0.00s)\n        tmpae0racfe_test.go:65: expected '[hi admin]', got '[hi hi\
    \ admin project]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n       \
    \ tmpae0racfe_test.go:65: expected '[4]', got '[1 2 3 4 5]'\n    --- FAIL: TestTotal_Match/test_num__7\
    \ (0.00s)\n        tmpae0racfe_test.go:65: expected '[]', got '[this]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpae0racfe_test.go:65: expected\
    \ '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074751
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst1, lst2 = lst2, lst1\n        len1, len2 = len2, len1\n    }\n    result\
    \ := make([]string, len1)\n    for i := 0; i < len1; i++ {\n        result[i]\
    \ = lst1[i]\n    }\n    for i := 0; i < len2; i++ {\n        j := i\n        for\
    \ j < len1 && lst1[j] == lst2[i] {\n            j++\n        }\n        if j ==\
    \ len1 {\n            result[i] = lst2[i]\n        } else {\n            result[i]\
    \ = lst1[j]\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513800,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513800, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000e2060?, 0x8?, 0x51400000003?},\
    \ {0xc0000fa7c0?, 0x5e4ea0?, 0x5d4570?})\n\t/tmp/tmpoxvnvf5s_test.go:42 +0x246\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmpoxvnvf5s_test.go:59\
    \ +0x1ce\ntesting.tRunner(0xc000192680, 0x529140)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074751
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ nil\n    }\n    \n    result := make([]string, 0)\n    \n    for _, val := range\
    \ lst1 {\n        if strings.Contains(val, lst2[0]) {\n            lst2 = lst2[1:]\n\
    \        }\n        result = append(result, val)\n    }\n    \n    if len(lst2)\
    \ > 0 {\n        result = append(result, lst2[0])\n    }\n    \n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpnd8_awh__test.go:31:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074751
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write your code here\n    \n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpkee1wx5g_test.go:280:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074749
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i, v := range\
    \ lst1 {\n        if lst1[i] < lst2[i] {\n            result[i] = lst1[i]\n  \
    \      } else {\n            result[i] = lst2[i]\n        }\n    }\n    \n   \
    \ return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7_aiwssk_test.go:29:12: v declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074751
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 || len(lst2) == 0 {\n     \
    \   return lst1\n    }\n    \n    len1 := len(lst1)\n    len2 := len(lst2)\n \
    \   \n    if len1 == len2 {\n        \n        for i := 0; i < len1; i++ {\n \
    \           if lst1[i] < lst2[i] {\n                return lst1\n            }\n\
    \        }\n        return lst2\n    }\n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_4pyhsbg_test.go:257:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074751
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := make([]string, 0)\n    \n    if len(lst1)\
    \ == 0 {\n        return result\n    }\n    if len(lst2) == 0 {\n        return\
    \ result\n    }\n    \n    len1 := len(lst1)\n    len2 := len(lst2)\n    \n  \
    \  if len1 == len2 {\n        for i := 0; i < len1; i++ {\n            if lst1[i]\
    \ < lst2[i] {\n                result = append(result, lst1[i])\n            }\n\
    \        }\n        return result\n    }\n    \n    for i := 0; i < len1; i++\
    \ {\n        if lst1[i] < lst2[i] {\n            result = append(result, lst1[i])\n\
    \        }\n    }\n    \n    for i := 0; i < len2; i++ {\n        if lst2[i] <\
    \ lst1[i] {\n            result = append(result, lst2[i])\n        }\n    }\n\
    \    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc000124d30, 0x2, 0x0?}, {0xc000124db0,\
    \ 0x4, 0x55555555555555?})\n\t/tmp/tmp8oxe8iup_test.go:51 +0x34e\ncommand-line-arguments_test.TestTotal_Match(0xc0001036c0?)\n\
    \t/tmp/tmp8oxe8iup_test.go:68 +0x22f\ntesting.tRunner(0xc0001036c0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0;\
    \ i < len2; i++ {\n        j := i\n        for j < len1 && lst1[j] == lst2[i]\
    \ {\n            j++\n        }\n        if j == len1 {\n            result[i]\
    \ = lst2[i]\n        } else {\n            result[i] = lst1[j]\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000ea040?, 0x2, 0x450329?},\
    \ {0xc0000f5db0, 0x4, 0x0?})\n\t/tmp/tmpdu2hxph0_test.go:41 +0x2b0\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmpdu2hxph0_test.go:58 +0x1f0\ntesting.tRunner(0xc0001924e0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) != len(lst2)\
    \ {\n        return lst1\n    }\n    for _, v := range lst1 {\n        if lst2\
    \ != nil && len(v) > len(lst2[0]) {\n            continue\n        }\n       \
    \ for _, v2 := range lst2 {\n            if v == v2 {\n                result\
    \ = append(result, v)\n                break\n            }\n        }\n    }\n\
    \    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate :=\
    \ total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpj2sqtfpa_test.go:62: expected '[hi hi]', got '[hi]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpj2sqtfpa_test.go:62:\
    \ expected '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpj2sqtfpa_test.go:62: expected '[hI hi hi]', got '[hi admin]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpj2sqtfpa_test.go:62:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := make([]string, len(lst1))\n    \n    for i\
    \ := 0; i < len(lst1); i++ {\n        \n        if lst1[i] != lst2[i] {\n    \
    \        result[i] = lst1[i]\n        }\n    }\n    \n    return result\n}\n\n\
    func TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpcbruv8hr_test.go:61: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpcbruv8hr_test.go:61:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpcbruv8hr_test.go:61: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpcbruv8hr_test.go:61:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp2tn8o81p_test.go:55: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp2tn8o81p_test.go:55:\
    \ expected '[hi admin]', got '[hi hi admin project]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmp2tn8o81p_test.go:55: expected '[4]', got '[1 2 3 4 5]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp2tn8o81p_test.go:55:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp2tn8o81p_test.go:55: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp2tn8o81p_test.go:55:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp2tn8o81p_test.go:55: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 < len2 {\n     \
    \   return lst2\n    }\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp2vw012pd_test.go:55: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp2vw012pd_test.go:55:\
    \ expected '[hi admin]', got '[hi hi admin project]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmp2vw012pd_test.go:55: expected '[4]', got '[1 2 3 4 5]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp2vw012pd_test.go:55:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp2vw012pd_test.go:55: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp2vw012pd_test.go:55:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp2vw012pd_test.go:55: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst1, lst2 = lst2, lst1\n        len1, len2 = len2, len1\n    }\n    result\
    \ := make([]string, len1)\n    for i := 0; i < len1; i++ {\n        result[i]\
    \ = lst1[i]\n    }\n    for i := 0; i < len2; i++ {\n        if result[i] != lst2[i]\
    \ {\n            break\n        }\n    }\n    return result[:i+1]\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr7g_veb1_test.go:41:20: undefined: i

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := []string{}\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] < lst2[i] {\n            result = append(result, lst1[i])\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpoodthk_v_test.go:60: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpoodthk_v_test.go:60:\
    \ expected '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpoodthk_v_test.go:60: expected '[hI hi hi]', got '[hi admin]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpoodthk_v_test.go:60:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n    if len(lst1) == 0 {\n\
    \        return result\n    }\n    if len(lst2) == 0 {\n        return result\n\
    \    }\n    if len(lst1) > len(lst2) {\n        lst1, lst2 = lst2, lst1\n    }\n\
    \    for _, val := range lst1 {\n        if val <= lst2[0] {\n            result\
    \ = append(result, val)\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpwn3efq8q_test.go:62: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n        tmpwn3efq8q_test.go:62:\
    \ expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n\
    \        tmpwn3efq8q_test.go:62: expected '[hI Hi]', got '[admin]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__5 (0.00s)\n        tmpwn3efq8q_test.go:62: expected\
    \ '[hI hi hi]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpwn3efq8q_test.go:62: expected '[hi admin]', got '[admin]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    for _, s := range\
    \ lst1 {\n        if lst2 != nil && len(s) < len(lst2) {\n            continue\n\
    \        }\n        lst3 = append(lst3, s)\n    }\n    return lst3\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpbi4nye5v_test.go:54: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpbi4nye5v_test.go:54:\
    \ expected '[hi admin]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmpbi4nye5v_test.go:54: expected '[4]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__4 (0.00s)\n        tmpbi4nye5v_test.go:54: expected\
    \ '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpbi4nye5v_test.go:54: expected '[hI hi hi]', got '[admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpbi4nye5v_test.go:54: expected\
    \ '[hi admin]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpbi4nye5v_test.go:54: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i, v := range lst1\
    \ {\n        if lst1[i] != lst2[i] {\n            result[i] = lst1[i]\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp68nz1k37_test.go:28:12: v declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := []string{}\n    for _, str1 := range lst1 {\n    \
    \    for _, str2 := range lst2 {\n            if str1 == str2 {\n            \
    \    continue\n            }\n            \n            count := 0\n         \
    \   for _, c := range str1 {\n                count += int(c)\n            }\n\
    \            \n            if count > len(str2) {\n                continue\n\
    \            }\n            \n            result = append(result, str2)\n    \
    \    }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmplm1rz3dy_test.go:71: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmplm1rz3dy_test.go:71: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmplm1rz3dy_test.go:71: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmplm1rz3dy_test.go:71: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmplm1rz3dy_test.go:71: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmplm1rz3dy_test.go:71: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write your code here\n    \n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) == 0 || len(lst2) == 0 {\n\
    \        return []string{}\n    }\n    \n    result := []string{}\n    \n    for\
    \ _, element := range lst1 {\n        \n        if element == \"\" {\n       \
    \     continue\n        }\n        \n        for _, element2 := range lst2 {\n\
    \            \n            if element == element2 {\n                continue\n\
    \            }\n            \n            if element < element2 {\n          \
    \      break\n            }\n            \n            result = append(result,\
    \ element)\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpnqw8dss0_test.go:74: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpnqw8dss0_test.go:74: expected\
    \ '[hi admin]', got '[hi]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpnqw8dss0_test.go:74: expected '[4]', got '[4 4 4]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__4 (0.00s)\n        tmpnqw8dss0_test.go:74: expected\
    \ '[hI Hi]', got '[hi hi]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpnqw8dss0_test.go:74: expected '[hI hi hi]', got '[hi]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__6 (0.00s)\n        tmpnqw8dss0_test.go:74: expected\
    \ '[hi admin]', got '[hi]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            result[i] = lst1[i]\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpjkcyjac8_test.go:57: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpjkcyjac8_test.go:57:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpjkcyjac8_test.go:57: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpjkcyjac8_test.go:57:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n    for _, val := range\
    \ lst1 {\n        if !contains(lst2, val) {\n            result = append(result,\
    \ val)\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7waa0qum_test.go:25:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074752
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) != len(lst2)\
    \ {\n        return result\n    }\n    for _, item := range lst1 {\n        if\
    \ lst2 := total_match_test(item, lst2); len(lst2) != 0 {\n            result =\
    \ append(result, item)\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpd3xtxl38_test.go:28:20: undefined: total_match_test

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp2tn8o81p_test.go:55: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp2tn8o81p_test.go:55:\
    \ expected '[hi admin]', got '[hi hi admin project]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmp2tn8o81p_test.go:55: expected '[4]', got '[1 2 3 4 5]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp2tn8o81p_test.go:55:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp2tn8o81p_test.go:55: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp2tn8o81p_test.go:55:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp2tn8o81p_test.go:55: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := []string{}\n    for _, item := range lst1 {\n    \
    \    if lst2 != nil && len(item) > len(lst2[0]) {\n            continue\n    \
    \    }\n        \n        result := append(result, item)\n    }\n    \n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2skuwv02_test.go:33:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) > len(lst2)\
    \ {\n        result = lst1\n    } else {\n        result = lst2\n    }\n    for\
    \ _, val := range result {\n        total := 0\n        for _, val2 := range lst2\
    \ {\n            total += len(val2)\n        }\n        if total < len(val) {\n\
    \            result = result[:len(result)]\n            break\n        }\n   \
    \ }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__2\
    \ (0.00s)\n        tmp7tuo5e6t_test.go:63: expected '[hi admin]', got '[hi hi\
    \ admin project]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n       \
    \ tmp7tuo5e6t_test.go:63: expected '[4]', got '[1 2 3 4 5]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp7tuo5e6t_test.go:63: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp7tuo5e6t_test.go:63:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp7tuo5e6t_test.go:63: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074753
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := []string{}\n    for _, val := range lst1 {\n     \
    \   if !contains(lst2, val) {\n            result = append(result, val)\n    \
    \    }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdvb8kb1__test.go:29:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074753
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len > lst2Len {\n        return lst1\n    }\n    if lst2Len > lst1Len\
    \ {\n        return lst2\n    }\n    \n    result := make([]string, 0)\n    \n\
    \    for i := 0; i < lst1Len; i++ {\n        result := append(result, lst1[i])\n\
    \    }\n    for i := 0; i < lst2Len; i++ {\n        result := append(result, lst2[i])\n\
    \    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4q15786t_test.go:35:9: result declared but not used

    /tmp/tmp4q15786t_test.go:38:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074753
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := []string{}\n    for _, val1 := range lst1 {\n    \
    \    for _, val2 := range lst2 {\n            if val1 == val2 {\n            \
    \    continue\n            }\n            \n            count := 0\n         \
    \   for _, val3 := range val2 {\n                if val3 == val1 {\n         \
    \           count++\n                }\n            }\n            \n        \
    \    if count > len(val2) {\n                result = append(result, val1)\n \
    \           }\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpikqpob3f_test.go:36:28: invalid operation: val3 == val1 (mismatched types
    rune and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074753
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    \n    for _, lst1str := range\
    \ lst1 {\n        foundMatch := false\n        for _, lst2str := range lst2 {\n\
    \            if lst1str == lst2str {\n                foundMatch = true\n    \
    \            break\n            }\n        }\n        if !foundMatch {\n     \
    \       result = append(result, lst1str)\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp6yxpk5ff_test.go:66: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp6yxpk5ff_test.go:66:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp6yxpk5ff_test.go:66: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp6yxpk5ff_test.go:66: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp6yxpk5ff_test.go:66:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp6yxpk5ff_test.go:66: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074753
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    for _, s := range\
    \ lst1 {\n        if !contains(lst2, s) {\n            lst3 = append(lst3, s)\n\
    \        }\n    }\n    return lst3\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf9wt8s34_test.go:25:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074753
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i, v := range lst1\
    \ {\n        total := 0\n        for _, v2 := range lst2 {\n            if v ==\
    \ v2 {\n                total++\n            }\n        }\n        if total <\
    \ len(lst2) {\n            result[i] = v\n        }\n    }\n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpieude5j7_test.go:63: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpieude5j7_test.go:63:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpieude5j7_test.go:63: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpieude5j7_test.go:63:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        result[i] = lst1[i]\n    }\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        for j := i + 1; j < len(lst1); j++ {\n            if lst1[i]\
    \ < lst1[j] {\n                result[i] = lst1[j]\n                break\n  \
    \          }\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpyz7whrcn_test.go:65: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpyz7whrcn_test.go:65:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpyz7whrcn_test.go:65: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpyz7whrcn_test.go:65: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpyz7whrcn_test.go:65:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpyz7whrcn_test.go:65: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := make([]string, 0)\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            result = append(result,\
    \ lst1[i])\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpz876h354_test.go:59: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpz876h354_test.go:59:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpz876h354_test.go:59: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpz876h354_test.go:59:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write your code here\n    \n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := 0; i\
    \ < len(lst1); i++ {\n        count := 0\n        for j := 0; j < len(lst2); j++\
    \ {\n            if lst1[i] < lst2[j] {\n                count++\n           \
    \ }\n        }\n        if count == len(lst2) {\n            result[i] = lst1[i]\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpvfmoj1oy_test.go:65: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpvfmoj1oy_test.go:65:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpvfmoj1oy_test.go:65: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpvfmoj1oy_test.go:65: expected '[hI Hi]', got '[ ]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpvfmoj1oy_test.go:65:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpvfmoj1oy_test.go:65: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    m := make(map[string]int)\n    for _, s := range\
    \ lst1 {\n        m[s]++\n    }\n    for _, s := range lst2 {\n        m[s]++\n\
    \    }\n    result := make([]string, 0, len(m))\n    for k := range m {\n    \
    \    if m[k] == len(lst1) {\n            result = append(result, k)\n        }\n\
    \    }\n    if len(result) == 0 {\n        return lst1\n    }\n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp6_0sz8cx_test.go:63: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp6_0sz8cx_test.go:63:\
    \ expected '[hi admin]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmp6_0sz8cx_test.go:63: expected '[4]', got '[1 2 3 5]'\n \
    \   --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp6_0sz8cx_test.go:63:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp6_0sz8cx_test.go:63: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmp6_0sz8cx_test.go:63:\
    \ expected '[hi admin]', got '[hi]'\n    --- FAIL: TestTotal_Match/test_num__8\
    \ (0.00s)\n        tmp6_0sz8cx_test.go:63: expected '[]', got '[this]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074754
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    \n    for _, val := range lst1\
    \ {\n        if !contains(lst2, val) {\n            result = append(result, val)\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0pt9s96g_test.go:30:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len > lst2Len {\n        lst1, lst2 = lst2, lst1\n        lst1Len,\
    \ lst2Len = lst2Len, lst1Len\n    }\n    \n    result := make([]string, lst1Len)\n\
    \    for i := 0; i < lst1Len; i++ {\n        result[i] = lst1[i]\n    }\n    for\
    \ i := 0; i < lst2Len; i++ {\n        j := i\n        for j < lst1Len && lst1[j]\
    \ == lst2[i] {\n            j++\n        }\n        if j == lst1Len {\n      \
    \      result[i] = lst2[i]\n        } else {\n            result[i] = lst1[j]\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc0001d0000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc0001d0000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc000189d30?, 0x0?, 0x0?},\
    \ {0xc000189db0?, 0x0?, 0x0?})\n\t/tmp/tmp7214ydzc_test.go:40 +0x246\ncommand-line-arguments_test.TestTotal_Match(0xc00019aea0?)\n\
    \t/tmp/tmp7214ydzc_test.go:57 +0x22f\ntesting.tRunner(0xc00019aea0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074754
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    for _, str1 :=\
    \ range lst1 {\n        for _, str2 := range lst2 {\n            if str1 == str2\
    \ {\n                lst3 = append(lst3, str1)\n            }\n        }\n   \
    \ }\n    if len(lst3) == 0 {\n        return lst1\n    }\n    if len(lst3) ==\
    \ 1 {\n        return lst3\n    }\n    lst4 = make([]string, 0)\n    for _, str1\
    \ := range lst1 {\n        for _, str2 := range lst3 {\n            if str1 ==\
    \ str2 {\n                lst4 = append(lst4, str1)\n            }\n        }\n\
    \    }\n    return lst4\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb6nrekxh_test.go:37:5: undefined: lst4

    /tmp/tmpb6nrekxh_test.go:41:31: undefined: lst4

    /tmp/tmpb6nrekxh_test.go:45:12: undefined: lst4

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0;\
    \ i < len2; i++ {\n        j := i\n        for j < len1 && lst1[j] == lst2[i]\
    \ {\n            j++\n        }\n        if j == len1 {\n            result[i]\
    \ = lst2[i]\n        } else {\n            j := i\n            for j < len2 &&\
    \ lst2[j] == lst1[i] {\n                j++\n            }\n            if j ==\
    \ len2 {\n                result[i] = lst1[i]\n            }\n        }\n    }\n\
    \    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate :=\
    \ total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000ea040?, 0x2, 0x450329?},\
    \ {0xc0000f5db0, 0x4, 0x0?})\n\t/tmp/tmp4a653_ue_test.go:41 +0x365\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmp4a653_ue_test.go:64 +0x1f0\ntesting.tRunner(0xc0001a01a0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] < lst2[i] {\n            result[i] = lst1[i]\n   \
    \     } else {\n            result[i] = lst2[i]\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmph2erqzno_test.go:59: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmph2erqzno_test.go:59:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmph2erqzno_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmph2erqzno_test.go:59: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmph2erqzno_test.go:59:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) != len(lst2)\
    \ {\n        return nil\n    }\n    for _, str1 := range lst1 {\n        found\
    \ := false\n        for _, str2 := range lst2 {\n            if str1 == str2 {\n\
    \                found = true\n                break\n            }\n        }\n\
    \        if !found {\n            result = append(result, str1)\n        }\n \
    \   }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp03m7zuyg_test.go:63: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp03m7zuyg_test.go:63:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp03m7zuyg_test.go:63: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp03m7zuyg_test.go:63: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp03m7zuyg_test.go:63:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp03m7zuyg_test.go:63: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074755
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := make([]string, 0)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\n    result := append(result,\
    \ lst1...)\n    result := append(result, lst2...)\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5d5edyz__test.go:80:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ nil\n    }\n    \n    result := []string{}\n    \n    for _, item := range lst1\
    \ {\n        \n        if lst2 != nil && len(item) > len(lst2[0]) {\n        \
    \    return nil\n        }\n        \n        for _, item2 := range lst2 {\n \
    \           \n            if item == item2 {\n                \n             \
    \   if item != \"\" {\n                    result = append(result, item)\n   \
    \             }\n                \n                break\n            }\n    \
    \    }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmperug3cvh_test.go:73: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmperug3cvh_test.go:73: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmperug3cvh_test.go:73: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmperug3cvh_test.go:73: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmperug3cvh_test.go:73: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmperug3cvh_test.go:73: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074755
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := []string{}\n    \n    for _, val := range lst1\
    \ {\n        \n        if _, ok := lst2[len(lst2)-1]; ok {\n            \n   \
    \         if val == lst2[len(lst2)-1] {\n                lst2 = lst2[:len(lst2)-1]\n\
    \            }\n            \n        } else {\n            \n            if val\
    \ == lst2[len(lst2)] {\n                lst2 = lst2[:len(lst2)+1]\n          \
    \  }\n            \n        }\n        \n    }\n    \n    for _, val := range\
    \ lst2 {\n        \n        if _, ok := lst1[len(lst1)-1]; ok {\n            \n\
    \            if val == lst1[len(lst1)-1] {\n                lst1 = lst1[:len(lst1)-1]\n\
    \            }\n            \n        } else {\n            \n            if val\
    \ == lst1[len(lst1)] {\n                lst1 = lst1[:len(lst1)+1]\n          \
    \  }\n            \n        }\n        \n    }\n    \n    for _, val := range\
    \ lst1 {\n        \n        if _, ok := lst2[len(lst2)-1]; ok {\n            \n\
    \            if val == lst2[len(lst2)-1] {\n                lst2 = lst2[:len(lst2)-1]\n\
    \            }\n            \n        } else {\n            \n            if val\
    \ == lst2[len(lst2)] {\n                lst2 = lst2[:len(lst2)+1]\n          \
    \  }\n            \n        }\n        \n    }\n    \n    for _, val := range\
    \ lst2 {\n        \n        if _, ok := lst1[len(lst1)-1]; ok {\n            \n\
    \            if val == lst1[len(lst1)-1] {\n                lst1 = lst1[:len(lst1)-1]\n\
    \            }\n            \n        } else {\n            \n            if val\
    \ == lst1[len(lst1)] {\n                lst1 = lst1[:len(lst1)+1]\n          \
    \  }\n            \n        }\n        \n    }\n    \n    for _, val := range\
    \ lst1 {\n        \n        if _, ok := lst2[len(lst2)-1]; ok {\n            \n\
    \            if val == lst2[len(lst2)-1] {\n                lst2 = lst2[:len(lst2)-1]\n\
    \            }\n            \n        } else {\n            \n            if val\
    \ == lst2[len(lst2)] {\n                lst2 = lst2[:len(lst2)+1]\n          \
    \  }\n            \n        }\n        \n    }\n    \n    for _, val := range\
    \ lst2 {\n        \n        if _, ok := lst1[len(lst1)-1]; ok {\n            \n\
    \            if val == lst1[len(lst1)-1] {\n                lst1 = \nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph4e4nfnu_test.go:126:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    len1 := len(lst1)\n\
    \    len2 := len(lst2)\n    if len1 == len2 {\n        for i := 0; i < len1; i++\
    \ {\n            if lst1[i] < lst2[i] {\n                result = append(result,\
    \ lst1[i])\n            }\n        }\n    } else {\n        fmt.Println(\"lst1\
    \ and lst2 have different length\")\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "lst1 and lst2 have different length\nlst1 and lst2 have different length\n\
    lst1 and lst2 have different length\nlst1 and lst2 have different length\nlst1\
    \ and lst2 have different length\nlst1 and lst2 have different length\n--- FAIL:\
    \ TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1 (0.00s)\n\
    \        tmpwlqmol6d_test.go:59: expected '[hi hi]', got '[admin]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__2 (0.00s)\n        tmpwlqmol6d_test.go:59: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpwlqmol6d_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpwlqmol6d_test.go:59: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpwlqmol6d_test.go:59: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpwlqmol6d_test.go:59: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074755
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := []string{}\n    \n    for _, val := range lst1\
    \ {\n        if !contains(lst2, val) {\n            result = append(result, val)\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcte5yucc_test.go:31:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    len1 := len(lst1)\n\
    \    len2 := len(lst2)\n    if len1 == len2 {\n        for i := 0; i < len1; i++\
    \ {\n            if lst1[i] < lst2[i] {\n                result = append(result,\
    \ lst1[i])\n            } else {\n                result = append(result, lst2[i])\n\
    \            }\n        }\n    } else {\n        fmt.Println(\"lists must have\
    \ same length\")\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "lists must have same length\nlists must have same length\nlists must have\
    \ same length\nlists must have same length\nlists must have same length\nlists\
    \ must have same length\n--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpswatak_i_test.go:61: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpswatak_i_test.go:61:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpswatak_i_test.go:61: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpswatak_i_test.go:61: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpswatak_i_test.go:61:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074755
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len > lst2Len {\n        return lst1\n    }\n    if lst1Len == lst2Len\
    \ {\n        for i := 0; i < lst1Len; i++ {\n            if lst1[i] < lst2[i]\
    \ {\n                return lst1\n            }\n        }\n        return lst2\n\
    \    }\n    for i := 0; i < lst2Len; i++ {\n        if lst1[i] < lst2[i] {\n \
    \           return lst1\n        }\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmpkrfmzoes_test.go:37\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmpkrfmzoes_test.go:54\
    \ +0x5a5\ntesting.tRunner(0xc0001a0340, 0x528f38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074755
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        if lst1[i] < lst2[i] {\n            result[i]\
    \ = lst1[i]\n        } else {\n            result[i] = lst2[i]\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmppimwwec5_test.go:63: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n        tmppimwwec5_test.go:63:\
    \ expected '[4]', got '[1]'\n    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n\
    \        tmppimwwec5_test.go:63: expected '[hI Hi]', got '[hi admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmppimwwec5_test.go:63: expected\
    \ '[hI hi hi]', got '[hI admin]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmppimwwec5_test.go:63: expected '[hi admin]', got '[hI admin]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074755
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst2\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    lst1Len :=\
    \ len(lst1)\n    lst2Len := len(lst2)\n    \n    if lst1Len > lst2Len {\n    \
    \    lst1, lst2 = lst2, lst1\n        lst1Len, lst2Len = lst2Len, lst1Len\n  \
    \  }\n    \n    result := make([]string, 0)\n    \n    for i := 0; i < lst1Len;\
    \ i++ {\n        total := 0\n        for j := 0; j < lst2Len; j++ {\n        \
    \    total += lst1[i][0] == lst2[j][0]\n        }\n        if total < lst2Len\
    \ {\n            result = append(result, lst1[i])\n        }\n    }\n    \n  \
    \  return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmw2ngw9i_test.go:43:13: invalid operation: total += lst1[i][0] == lst2[j][0]
    (mismatched types int and untyped bool)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074755
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    result := make([]string, 0)\n    for _, val := range lst1 {\n    \
    \    if lst2 != nil && len(val) < len(lst2) {\n            continue\n        }\n\
    \        for _, val2 := range lst2 {\n            if val == val2 {\n         \
    \       continue\n            }\n            if val2 != nil && len(val) < len(val2)\
    \ {\n                continue\n            }\n            if val != nil && len(val)\
    \ < len(val2) {\n                continue\n            }\n            if val !=\
    \ nil && len(val) < len(val2) {\n                continue\n            }\n   \
    \         if val != nil && len(val) < len(val2) {\n                continue\n\
    \            }\n            if val != nil && len(val) < len(val2) {\n        \
    \        continue\n            }\n            if val != nil && len(val) < len(val2)\
    \ {\n                continue\n            }\n            if val != nil && len(val)\
    \ < len(val2) {\n                continue\n            }\n            if val !=\
    \ nil && len(val) < len(val2) {\n                continue\n            }\n   \
    \         if val != nil && len(val) < len(val2) {\n                continue\n\
    \            }\n            if val != nil && len(val) < len(val2) {\n        \
    \        continue\n            }\n            if val != nil && len(val) < len(val2)\
    \ {\n                continue\n            }\n            if val != nil && len(val)\
    \ < len(val2) {\n                continue\n            }\n            if val !=\
    \ nil && len(val) < len(val2) {\n                continue\n            }\n   \
    \         if val != nil && len(val) < len(val2) {\n                continue\n\
    \            }\n            if val != nil && len(val) < len(val2) {\n        \
    \        continue\n            }\n            if val != nil && len(val) < len(val2)\
    \ {\n                continue\n            }\n            if val != nil && len(val)\
    \ < len(val2) {\n                continue\n            }\n            if val !=\
    \ nil && len(val) < len(val2) {\n                continue\n            }\n   \
    \         if val != nil && len(val) < len(val2) {\n                continue\n\
    \            }\n            if val != nil && len(val) < len(val2) {\n        \
    \        continue\n            }\n            if val != nil && len(val) < len(val2)\
    \ {\n                continue\n            }\n            if val != nil && len(val)\
    \ < len(val2) {\n                continue\n            }\n            if val !=\
    \ nil && len(val) < len(val2) {\n                continue\n            }\n   \
    \         if val != nil && len(val) < len(val2) {\n                continue\n\
    \            }\n            if val != nil && len(val) < len(val2) {\n        \
    \        continue\n            }\n            if val != nil && len(val) < len(val2)\
    \ {\n                continue\n            }\n            if val != nil && len(val)\
    \ < len(val2) {\n                continue\n            }\n            if val !=\
    \ nil && len(val) < len(val2) {\n                continue\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmponjfjt9m_test.go:118:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   return lst2\n    }\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpfab3puaw_test.go:55: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpfab3puaw_test.go:55:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpfab3puaw_test.go:55: expected '[hI hi hi]', got '[hi admin]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074751
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        j := 0\n        for ; j < len2 && lst1[i] <\
    \ lst2[j]; j++ {\n        }\n        if j == len2 {\n            result[i] = lst1[i]\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmptaan274r_test.go:64: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmptaan274r_test.go:64:\
    \ expected '[hi admin]', got '[ ]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmptaan274r_test.go:64: expected '[4]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__4 (0.00s)\n        tmptaan274r_test.go:64: expected\
    \ '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmptaan274r_test.go:64: expected '[hI hi hi]', got '[ admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmptaan274r_test.go:64: expected\
    \ '[hi admin]', got '[ admin]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074756
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len > lst2Len {\n        return lst1\n    }\n    if lst1Len == lst2Len\
    \ {\n        return lst1\n    }\n    result := make([]string, lst1Len)\n    for\
    \ i := 0; i < lst1Len; i++ {\n        result[i] = lst1[i]\n    }\n    for i :=\
    \ 0; i < lst2Len; i++ {\n        if result[i] != lst2[i] {\n            break\n\
    \        }\n    }\n    return result[0:i]\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmv0l57___test.go:40:21: undefined: i

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074755
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := make([]string, 0)\n    for _, str1 := range lst1 {\n\
    \        for _, str2 := range lst2 {\n            if str1 == str2 {\n        \
    \        continue // ignore the string that has same chars\n            }\n  \
    \      }\n        result = append(result, str1)\n    }\n    return result\n}\n\
    \nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpd5qz4l0h_test.go:60: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpd5qz4l0h_test.go:60:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpd5qz4l0h_test.go:60: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpd5qz4l0h_test.go:60:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074756
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) == 0 {\n        return lst2\n\
    \    }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk5xvna93_test.go:274:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074755
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ nil\n    }\n    \n    result := make([]string, 0)\n    \n    for _, str1 :=\
    \ range lst1 {\n        for _, str2 := range lst2 {\n            if str1 == str2\
    \ {\n                continue // skip the matching string\n            }\n   \
    \     }\n        result = append(result, str1)\n    }\n    \n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpkibeh86y_test.go:63: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpkibeh86y_test.go:63:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpkibeh86y_test.go:63: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpkibeh86y_test.go:63: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpkibeh86y_test.go:63:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpkibeh86y_test.go:63: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074756
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := []string{}\n    \n    for _, val := range lst1\
    \ {\n        if !contains(lst2, val) {\n            result = append(result, val)\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcte5yucc_test.go:31:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst2\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    if len(lst1) >\
    \ len(lst2) {\n        return lst1\n    }\n    if len(lst2) > len(lst1) {\n  \
    \      return lst2\n    }\n    \n    result := []string{}\n    \n    for _, str1\
    \ := range lst1 {\n        for _, str2 := range lst2 {\n            if str1 ==\
    \ str2 {\n                continue\n            }\n            \n            count\
    \ := 0\n            for _, char1 := range str1 {\n                for _, char2\
    \ := range str2 {\n                    if char1 == char2 {\n                 \
    \       count++\n                    }\n                }\n            }\n   \
    \         \n            if count > len(str1) {\n                result = append(result,\
    \ str1)\n            }\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpte0qjdn4_test.go:83: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpte0qjdn4_test.go:83: expected\
    \ '[hi admin]', got '[hi hi admin project]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmpte0qjdn4_test.go:83: expected '[4]', got '[1 2 3 4 5]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpte0qjdn4_test.go:83:\
    \ expected '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpte0qjdn4_test.go:83: expected '[hi admin]', got '[hI hi hii]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmpte0qjdn4_test.go:83:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmpte0qjdn4_test.go:83: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len > lst2Len {\n        lst1, lst2 = lst2, lst1\n        lst1Len,\
    \ lst2Len = lst2Len, lst1Len\n    }\n    \n    result := make([]string, 0)\n \
    \   for i := 0; i < lst1Len; i++ {\n        total := 0\n        for j := 0; j\
    \ < lst2Len; j++ {\n            if lst1[i] == lst2[j] {\n                total++\n\
    \            }\n        }\n        if total == lst2Len {\n            result =\
    \ append(result, lst1[i])\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpn651_gpd_test.go:66: expected '[hi hi]', got '[hi]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpn651_gpd_test.go:66:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpn651_gpd_test.go:66: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpn651_gpd_test.go:66: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpn651_gpd_test.go:66: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpn651_gpd_test.go:66: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            result[i] = lst1[i]\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpg7vpcbvy_test.go:57: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpg7vpcbvy_test.go:57:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpg7vpcbvy_test.go:57: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpg7vpcbvy_test.go:57: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpg7vpcbvy_test.go:57:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpg7vpcbvy_test.go:57: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst2 = append(lst2, lst1...)\n        lst1 = lst1[:len1]\n    }\n    for i\
    \ := 0; i < len1; i++ {\n        if lst1[i] != lst2[i] {\n            return lst1\n\
    \        }\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp4f6uw1c3_test.go:61: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp4f6uw1c3_test.go:61:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp4f6uw1c3_test.go:61: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp4f6uw1c3_test.go:61:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp4f6uw1c3_test.go:61: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    result := []string{}\n    for _, val := range lst1 {\n        if lst2\
    \ != nil && len(val) < len(lst2) {\n            continue\n        }\n        if\
    \ lst2 != nil && len(val) >= len(lst2) {\n            result = append(result,\
    \ val)\n            continue\n        }\n        result = append(result, val)\n\
    \    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpt0al3sii_test.go:61: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpt0al3sii_test.go:61:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpt0al3sii_test.go:61: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpt0al3sii_test.go:61: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpt0al3sii_test.go:61:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpt0al3sii_test.go:61: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := []string{}\n    \n    for _, str1 := range\
    \ lst1 {\n        \n        for _, str2 := range lst2 {\n            \n      \
    \      if str1 == str2 {\n                continue\n            }\n          \
    \  \n            totalMatch := len(str1) + len(str2)\n            \n         \
    \   if totalMatch > len(result) {\n                result = append(result, str1)\n\
    \            }\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpvdjqfwwr_test.go:70: expected '[hi hi]', got '[admin admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpvdjqfwwr_test.go:70:\
    \ expected '[hI Hi]', got '[hi hi admin admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpvdjqfwwr_test.go:70: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpvdjqfwwr_test.go:70:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := make([]string, 0)\n    if len(lst1)\
    \ != len(lst2) {\n        return nil\n    }\n    for i := 0; i < len(lst1); i++\
    \ {\n        if lst1[i] < lst2[i] {\n            result = append(result, lst1[i])\n\
    \        } else {\n            result = append(result, lst2[i])\n        }\n \
    \   }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp3gjz10qt_test.go:58: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp3gjz10qt_test.go:58:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp3gjz10qt_test.go:58: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp3gjz10qt_test.go:58: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmp3gjz10qt_test.go:58:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst2\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    len1 := len(lst1)\n\
    \    len2 := len(lst2)\n    \n    if len1 == len2 {\n        return lst1\n   \
    \ }\n    \n    result := make([]string, len1)\n    \n    for i := 0; i < len1;\
    \ i++ {\n        j := i\n        \n        for ; j < len2; j++ {\n           \
    \ if lst1[i] < lst2[j] {\n                break\n            }\n            result[i]\
    \ = lst1[i]\n            i++\n        }\n    }\n    \n    return result\n}\n\n\
    func TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513800,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513800, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000d8520?, 0x1, 0x51400000003?},\
    \ {0xc0000ee140?, 0x5, 0x5d4550?})\n\t/tmp/tmpkfc87dqa_test.go:43 +0x177\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmpkfc87dqa_test.go:64 +0x2a3\ntesting.tRunner(0xc0001a01a0, 0x529140)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) == 0 {\n        return lst2\n\
    \    }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk5xvna93_test.go:274:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074755
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    \n    for _, item := range\
    \ lst1 {\n        if lst2 != nil && len(item) > len(lst2[0]) {\n            continue\n\
    \        }\n        \n        for _, item2 := range lst2 {\n            if item\
    \ == item2 {\n                continue\n            }\n            \n        \
    \    if len(item) > len(item2) {\n                continue\n            }\n  \
    \          \n            if len(item) < len(item2) {\n                continue\n\
    \            }\n            \n            result = append(result, item)\n    \
    \    }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpwinhzbaf_test.go:75: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpwinhzbaf_test.go:75: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpwinhzbaf_test.go:75: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpwinhzbaf_test.go:75: expected '[hI Hi]', got '[hi hi]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpwinhzbaf_test.go:75:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpwinhzbaf_test.go:75: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    if len(lst1) !=\
    \ len(lst2) {\n        return lst3\n    }\n    for _, x := range lst1 {\n    \
    \    if lst2 != nil && len(x) >= len(lst2[0]) {\n            lst3 = append(lst3,\
    \ x)\n        }\n    }\n    return lst3\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpbzhpp66f_test.go:56: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpbzhpp66f_test.go:56:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpbzhpp66f_test.go:56: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpbzhpp66f_test.go:56: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpbzhpp66f_test.go:56:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpbzhpp66f_test.go:56: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write your code here\n    \n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    \n    for _, val1 := range\
    \ lst1 {\n        found := false\n        for _, val2 := range lst2 {\n      \
    \      if val1 == val2 {\n                found = true\n                break\n\
    \            }\n        }\n        if !found {\n            result = append(result,\
    \ val1)\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0fih0w82_test.go:66: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp0fih0w82_test.go:66:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp0fih0w82_test.go:66: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp0fih0w82_test.go:66: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp0fih0w82_test.go:66:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp0fih0w82_test.go:66: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            result[i] = lst1[i]\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpg7vpcbvy_test.go:57: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpg7vpcbvy_test.go:57:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpg7vpcbvy_test.go:57: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpg7vpcbvy_test.go:57: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpg7vpcbvy_test.go:57:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpg7vpcbvy_test.go:57: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := []string{}\n    \n    for i := 0; i < len(lst1); i++\
    \ {\n        if lst1[i] < lst2[i] {\n            result = append(result, lst1[i])\n\
    \        } else {\n            result = append(result, lst2[i])\n        }\n \
    \   }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpimgfy3l2_test.go:61: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpimgfy3l2_test.go:61:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpimgfy3l2_test.go:61: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpimgfy3l2_test.go:61: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpimgfy3l2_test.go:61:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ nil\n    }\n    \n    result := []string{}\n    \n    for _, val := range lst1\
    \ {\n        if val <= lst2[0] {\n            result = append(result, val)\n \
    \       }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp6dt6_b0z_test.go:60: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp6dt6_b0z_test.go:60:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp6dt6_b0z_test.go:60: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp6dt6_b0z_test.go:60: expected '[hI Hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp6dt6_b0z_test.go:60:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp6dt6_b0z_test.go:60: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074757
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    for _, str1 := range\
    \ lst1 {\n        for _, str2 := range lst2 {\n            if str1 == str2 {\n\
    \                continue\n            }\n            result += []string{str1}\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp41ix7q1m_test.go:29:13: invalid operation: operator + not defined on result
    (variable of type []string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    \n    if lst1Len > lst2Len {\n        return lst1\n    }\n    \n    result\
    \ := []string{}\n    \n    for i := 0; i < lst1Len; i++ {\n        if lst1[i]\
    \ != lst2[i] {\n            break\n        }\n    }\n    \n    for i := lst1Len;\
    \ i < lst2Len; i++ {\n        result = append(result, lst1[i])\n    }\n    \n\
    \    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate :=\
    \ total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5124c0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5124c0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmp1vhubznh_test.go:39\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmp1vhubznh_test.go:54\
    \ +0x1d6\ntesting.tRunner(0xc0001a01a0, 0x527dc8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst2\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    if len(lst1) >\
    \ len(lst2) {\n        return lst1\n    }\n    if len(lst2) > len(lst1) {\n  \
    \      return lst2\n    }\n    \n    result := make([]string, len(lst1))\n   \
    \ \n    for i := 0; i < len(lst1); i++ {\n        result[i] = lst1[i]\n    }\n\
    \    \n    for i := 0; i < len(lst2); i++ {\n        if lst1[i] != lst2[i] {\n\
    \            result[i] = lst2[i]\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__2\
    \ (0.00s)\n        tmp5ozt_qyd_test.go:72: expected '[hi admin]', got '[hi hi\
    \ admin project]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n       \
    \ tmp5ozt_qyd_test.go:72: expected '[4]', got '[1 2 3 4 5]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp5ozt_qyd_test.go:72: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp5ozt_qyd_test.go:72:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp5ozt_qyd_test.go:72: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    result := make([]string, 0)\n    for _, val := range lst1 {\n    \
    \    if val <= lst2[0] {\n            result = append(result, val)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpwtaer7fx_test.go:56: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpwtaer7fx_test.go:56:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpwtaer7fx_test.go:56: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpwtaer7fx_test.go:56: expected '[hI Hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpwtaer7fx_test.go:56:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpwtaer7fx_test.go:56: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        if lst1[i] < lst2[i] {\n            result[i]\
    \ = lst1[i]\n        } else {\n            result[i] = lst2[i]\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmppimwwec5_test.go:63: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n        tmppimwwec5_test.go:63:\
    \ expected '[4]', got '[1]'\n    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n\
    \        tmppimwwec5_test.go:63: expected '[hI Hi]', got '[hi admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmppimwwec5_test.go:63: expected\
    \ '[hI hi hi]', got '[hI admin]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmppimwwec5_test.go:63: expected '[hi admin]', got '[hI admin]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074755
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i, v := range lst1\
    \ {\n        if lst1[i] != lst2[i] {\n            result[i] = lst1[i]\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2aoau9a1_test.go:28:12: v declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 < len2 {\n     \
    \   return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp1rdilk47_test.go:55: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp1rdilk47_test.go:55:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp1rdilk47_test.go:55: expected '[hI hi hi]', got '[hi admin]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst2\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    len1 := len(lst1)\n\
    \    len2 := len(lst2)\n    \n    if len1 == len2 {\n        for i := 0; i < len1;\
    \ i++ {\n            if lst1[i] < lst2[i] {\n                return lst1\n   \
    \         }\n        }\n        return lst2\n    }\n    \n    if len1 > len2 {\n\
    \        len1 = len2\n    }\n    \n    result := make([]string, len1)\n    \n\
    \    for i := 0; i < len1; i++ {\n        if lst1[i] < lst2[i] {\n           \
    \ result[i] = lst1[i]\n        } else {\n            result[i] = lst2[i]\n   \
    \     }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp_xl4ysun_test.go:80: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n        tmp_xl4ysun_test.go:80:\
    \ expected '[4]', got '[1]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmp_xl4ysun_test.go:80: expected '[hI hi hi]', got '[hI admin]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmp_xl4ysun_test.go:80:\
    \ expected '[hi admin]', got '[hI admin]'\n    --- FAIL: TestTotal_Match/test_num__7\
    \ (0.00s)\n        tmp_xl4ysun_test.go:80: expected '[]', got '[this]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp_xl4ysun_test.go:80: expected\
    \ '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074757
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write your code here\n    \n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := 0; i\
    \ < len(lst1); i++ {\n        if lst1[i] < lst2[i] {\n            result[i] =\
    \ lst1[i]\n        } else {\n            result[i] = lst2[i]\n        }\n    }\n\
    \    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpaxu9y11w_test.go:61: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpaxu9y11w_test.go:61:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpaxu9y11w_test.go:61: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpaxu9y11w_test.go:61: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpaxu9y11w_test.go:61:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074758
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst1, lst2 = lst2, lst1\n        len1, len2 = len2, len1\n    }\n    \n  \
    \  result := make([]string, len1)\n    \n    for i := 0; i < len1; i++ {\n   \
    \     j := 0\n        for ; j < len2 && lst1[i] < lst2[j]; j++ {\n        }\n\
    \        if j == len2 {\n            result[i] = lst1[i]\n        }\n    }\n \
    \   return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpazdlp91y_test.go:67: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpazdlp91y_test.go:67:\
    \ expected '[hi admin]', got '[ ]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmpazdlp91y_test.go:67: expected '[4]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__4 (0.00s)\n        tmpazdlp91y_test.go:67: expected\
    \ '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpazdlp91y_test.go:67: expected '[hI hi hi]', got '[ admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpazdlp91y_test.go:67: expected\
    \ '[hi admin]', got '[ admin]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074758
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len > lst2Len {\n        return lst1\n    }\n    if lst1Len == lst2Len\
    \ {\n        return lst1\n    }\n    \n    result := []string{}\n    for i :=\
    \ 0; i < lst1Len; i++ {\n        if lst1[i] < lst2[i] {\n            result =\
    \ append(result, lst1[i])\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmphdmuqnv0_test.go:62: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmphdmuqnv0_test.go:62:\
    \ expected '[hi admin]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmphdmuqnv0_test.go:62: expected '[4]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__4 (0.00s)\n        tmphdmuqnv0_test.go:62: expected\
    \ '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmphdmuqnv0_test.go:62: expected '[hI hi hi]', got '[admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmphdmuqnv0_test.go:62: expected\
    \ '[hi admin]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmphdmuqnv0_test.go:62: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074758
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len > lst2Len {\n        return lst1\n    }\n    if lst2Len > lst1Len\
    \ {\n        return lst2\n    }\n    \n    result := make([]string, 0)\n    \n\
    \    for i := 0; i < lst1Len; i++ {\n        result := append(result, lst1[i])\n\
    \    }\n    \n    for i := 0; i < lst2Len; i++ {\n        result := append(result,\
    \ lst2[i])\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvct70m3m_test.go:35:9: result declared but not used

    /tmp/tmpvct70m3m_test.go:39:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074758
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := 0; i\
    \ < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n            return nil\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmppulgkc7l_test.go:59: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmppulgkc7l_test.go:59: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmppulgkc7l_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmppulgkc7l_test.go:59: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmppulgkc7l_test.go:59: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmppulgkc7l_test.go:59: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    for _, val := range lst1 {\n\
    \        if val <= lst2[0] {\n            result = append(result, val)\n     \
    \   }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0v_ztpqo_test.go:58: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp0v_ztpqo_test.go:58:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp0v_ztpqo_test.go:58: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp0v_ztpqo_test.go:58: expected '[hI Hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp0v_ztpqo_test.go:58:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp0v_ztpqo_test.go:58: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := range lst1\
    \ {\n        result[i] = lst1[i]\n    }\n    \n    for i := range lst2 {\n   \
    \     j := 0\n        for k := range result {\n            if lst1[k] == lst2[i]\
    \ {\n                result[j] = lst1[k]\n                j++\n            }\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp80zvxnzr_test.go:66: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp80zvxnzr_test.go:66:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp80zvxnzr_test.go:66: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp80zvxnzr_test.go:66: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp80zvxnzr_test.go:66:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp80zvxnzr_test.go:66: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := []string{}\n    for _, str1 := range lst1 {\n    \
    \    found := false\n        for _, str2 := range lst2 {\n            if str1\
    \ == str2 {\n                found = true\n                break\n           \
    \ }\n        }\n        if !found {\n            result = append(result, str1)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpmheg6cer_test.go:64: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpmheg6cer_test.go:64:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpmheg6cer_test.go:64: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpmheg6cer_test.go:64: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpmheg6cer_test.go:64:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpmheg6cer_test.go:64: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ nil\n    }\n    \n    result := make([]string, len(lst1))\n    \n    for i :=\
    \ 0; i < len(lst1); i++ {\n        \n        if lst1[i] < lst2[i] {\n        \
    \    result[i] = lst1[i]\n        } else {\n            result[i] = lst2[i]\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpfmextmq2_test.go:63: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpfmextmq2_test.go:63:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpfmextmq2_test.go:63: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpfmextmq2_test.go:63: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpfmextmq2_test.go:63:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i, _ := range\
    \ lst1 {\n        result[i] = lst1[i]\n    }\n    \n    for _, v := range lst2\
    \ {\n        for i, _ := range result {\n            if v == result[i] {\n   \
    \             result[i] = v\n                break\n            }\n        }\n\
    \    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpwqcjh45o_test.go:66: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpwqcjh45o_test.go:66:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpwqcjh45o_test.go:66: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpwqcjh45o_test.go:66: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpwqcjh45o_test.go:66:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpwqcjh45o_test.go:66: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write your code here\n    \n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    // Write your code here\n    \n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpw0ywk6kn_test.go:50: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpw0ywk6kn_test.go:50:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst1, lst2 = lst2, lst1\n        len1, len2 = len2, len1\n    }\n    \n  \
    \  result := []string{}\n    for i := 0; i < len1; i++ {\n        result := append(result,\
    \ lst1[i])\n    }\n    for i := 0; i < len2; i++ {\n        result := append(result,\
    \ lst2[i])\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv9q581kp_test.go:35:9: result declared but not used

    /tmp/tmpv9q581kp_test.go:38:9: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) == 0 {\n        return lst2\n\
    \    }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk5xvna93_test.go:274:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074755
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    for _, str1 := range lst1 {\n\
    \        for _, str2 := range lst2 {\n            if str1 == str2 {\n        \
    \        continue\n            }\n            \n            totalMatch := len(str1)\
    \ + len(str2)\n            if totalMatch > len(result) {\n                result\
    \ = append(result, str1)\n            }\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpih79et57_test.go:65: expected '[hi hi]', got '[admin admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpih79et57_test.go:65:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpih79et57_test.go:65: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpih79et57_test.go:65: expected '[hI Hi]', got '[hi hi admin\
    \ admin]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpih79et57_test.go:65:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpih79et57_test.go:65: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        result[i] = lst1[i]\n    }\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            return nil\n        }\n\
    \    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpmnr9wdc0_test.go:62: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpmnr9wdc0_test.go:62: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpmnr9wdc0_test.go:62: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpmnr9wdc0_test.go:62: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpmnr9wdc0_test.go:62: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpmnr9wdc0_test.go:62: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := []string{}\n    for _, x := range lst1 {\n       \
    \ if !contains(lst2, x) {\n            result = append(result, x)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvtu0cnpv_test.go:29:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0; i < len(lst1); i++\
    \ {\n        if lst1[i] != lst2[i] {\n            break\n        }\n    }\n  \
    \  return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmphynl_zpf_test.go:59: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmphynl_zpf_test.go:59:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmphynl_zpf_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmphynl_zpf_test.go:59: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmphynl_zpf_test.go:59:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmphynl_zpf_test.go:59: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst2\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    count :=\
    \ 0\n    for _, s := range lst1 {\n        count += len(s)\n    }\n    for _,\
    \ s := range lst2 {\n        count += len(s)\n    }\n    \n    if count == 0 {\n\
    \        return lst1\n    }\n    if count == len(lst1) {\n        return lst1\n\
    \    }\n    if count == len(lst2) {\n        return lst2\n    }\n    \n    result\
    \ := []string{}\n    for _, s := range lst1 {\n        if count < len(s) {\n \
    \           result = append(result, s)\n        }\n    }\n    for _, s := range\
    \ lst2 {\n        if count < len(s) {\n            result = append(result, s)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpnujyln9j_test.go:83: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpnujyln9j_test.go:83: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpnujyln9j_test.go:83: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpnujyln9j_test.go:83: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpnujyln9j_test.go:83: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpnujyln9j_test.go:83: expected '[hi admin]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__7 (0.00s)\n        tmpnujyln9j_test.go:83: expected\
    \ '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n    \
    \    tmpnujyln9j_test.go:83: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) != len(lst2)\
    \ {\n        return nil\n    }\n    for _, str1 := range lst1 {\n        found\
    \ := false\n        for _, str2 := range lst2 {\n            if str1 == str2 {\n\
    \                found = true\n                break\n            }\n        }\n\
    \        if !found {\n            result = append(result, str1)\n        }\n \
    \   }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp03m7zuyg_test.go:63: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp03m7zuyg_test.go:63:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp03m7zuyg_test.go:63: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp03m7zuyg_test.go:63: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp03m7zuyg_test.go:63:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp03m7zuyg_test.go:63: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074755
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := []string{}\n    for _, val1 := range lst1 {\n    \
    \    for _, val2 := range lst2 {\n            if val1 == val2 {\n            \
    \    result = append(result, val1)\n                break\n            }\n   \
    \     }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0dabqfxq_test.go:60: expected '[hi hi]', got '[hi]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp0dabqfxq_test.go:60:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp0dabqfxq_test.go:60: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp0dabqfxq_test.go:60: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp0dabqfxq_test.go:60: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp0dabqfxq_test.go:60: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    for _, val :=\
    \ range lst1 {\n        if lst2 != nil {\n            for _, val2 := range lst2\
    \ {\n                if val == val2 {\n                    lst3 = append(lst3,\
    \ val)\n                }\n            }\n        }\n    }\n    return lst3\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__2\
    \ (0.00s)\n        tmpau6zwkt1_test.go:57: expected '[hi admin]', got '[hi hi\
    \ admin]'\n    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpau6zwkt1_test.go:57:\
    \ expected '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpau6zwkt1_test.go:57: expected '[hI hi hi]', got '[hi hi]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpau6zwkt1_test.go:57: expected\
    \ '[hi admin]', got '[hi]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := 0; i\
    \ < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n            result[i] =\
    \ lst1[i]\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp5d93kwak_test.go:59: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp5d93kwak_test.go:59:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp5d93kwak_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp5d93kwak_test.go:59: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp5d93kwak_test.go:59:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp5d93kwak_test.go:59: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst2\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    len1 := len(lst1)\n\
    \    len2 := len(lst2)\n    \n    if len1 == len2 {\n        for i := 0; i < len1;\
    \ i++ {\n            if lst1[i] < lst2[i] {\n                return lst1\n   \
    \         }\n        }\n        return lst2\n    }\n    \n    i := 0\n    j :=\
    \ 0\n    \n    for i < len1 && j < len2 {\n        if lst1[i] < lst2[j] {\n  \
    \          i++\n        } else if lst1[i] > lst2[j] {\n            j++\n     \
    \   } else {\n            i++\n            j++\n        }\n    }\n    \n    if\
    \ i == len1 {\n        return lst2\n    }\n    if j == len2 {\n        return\
    \ lst1\n    }\n    \n    return lst1[0:i]\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp6ei7wm3m_test.go:87: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp6ei7wm3m_test.go:87:\
    \ expected '[hi admin]', got '[hi hi admin project]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmp6ei7wm3m_test.go:87: expected '[4]', got '[1 2 3 4 5]'\n\
    \    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmp6ei7wm3m_test.go:87:\
    \ expected '[hi admin]', got '[hI hi hii]'\n    --- FAIL: TestTotal_Match/test_num__7\
    \ (0.00s)\n        tmp6ei7wm3m_test.go:87: expected '[]', got '[this]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp6ei7wm3m_test.go:87: expected\
    \ '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   return lst1\n    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp2tn8o81p_test.go:55: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp2tn8o81p_test.go:55:\
    \ expected '[hi admin]', got '[hi hi admin project]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmp2tn8o81p_test.go:55: expected '[4]', got '[1 2 3 4 5]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp2tn8o81p_test.go:55:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp2tn8o81p_test.go:55: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp2tn8o81p_test.go:55:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp2tn8o81p_test.go:55: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            result[i] = lst1[i]\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpg7vpcbvy_test.go:57: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpg7vpcbvy_test.go:57:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpg7vpcbvy_test.go:57: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpg7vpcbvy_test.go:57: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpg7vpcbvy_test.go:57:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpg7vpcbvy_test.go:57: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n    if len(lst1) == 0 {\n\
    \        return result\n    }\n    if len(lst2) == 0 {\n        return result\n\
    \    }\n    if len(lst1) > len(lst2) {\n        lst1, lst2 = lst2, lst1\n    }\n\
    \    for _, val := range lst1 {\n        if val <= lst2[0] {\n            result\
    \ = append(result, val)\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpwn3efq8q_test.go:62: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n        tmpwn3efq8q_test.go:62:\
    \ expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n\
    \        tmpwn3efq8q_test.go:62: expected '[hI Hi]', got '[admin]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__5 (0.00s)\n        tmpwn3efq8q_test.go:62: expected\
    \ '[hI hi hi]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpwn3efq8q_test.go:62: expected '[hi admin]', got '[admin]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := make([]string, len(lst1))\n    \n    for i\
    \ := 0; i < len(lst1); i++ {\n        \n        count := 0\n        \n       \
    \ for j := 0; j < len(lst2); j++ {\n            \n            if lst1[i] == lst2[j]\
    \ {\n                count++\n            }\n        }\n        \n        if count\
    \ > len(lst2) {\n            result = append(result, lst1[i])\n        }\n   \
    \ }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp_kmfe5z9_test.go:70: expected '[hi hi]', got '[ ]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp_kmfe5z9_test.go:70:\
    \ expected '[hI Hi]', got '[ ]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmp_kmfe5z9_test.go:70: expected '[hI hi hi]', got '[hi admin]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp_kmfe5z9_test.go:70:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 < len2 {\n     \
    \   return lst2\n    }\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp2vw012pd_test.go:55: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp2vw012pd_test.go:55:\
    \ expected '[hi admin]', got '[hi hi admin project]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmp2vw012pd_test.go:55: expected '[4]', got '[1 2 3 4 5]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp2vw012pd_test.go:55:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp2vw012pd_test.go:55: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp2vw012pd_test.go:55:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp2vw012pd_test.go:55: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    \n    for _, str1 := range\
    \ lst1 {\n        found := false\n        for _, str2 := range lst2 {\n      \
    \      if str1 == str2 {\n                found = true\n                break\n\
    \            }\n        }\n        if !found {\n            result = append(result,\
    \ str1)\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp4zchkicp_test.go:66: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp4zchkicp_test.go:66:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmp4zchkicp_test.go:66: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp4zchkicp_test.go:66: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp4zchkicp_test.go:66:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmp4zchkicp_test.go:66: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074760
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0;\
    \ i < len2; i++ {\n        j := i\n        for j < len1 && lst1[j] == lst2[i]\
    \ {\n            j++\n        }\n        if j == len1 {\n            result[i]\
    \ = lst2[i]\n        } else {\n            result[i] = lst1[j]\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 2 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 2\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0000ea040?, 0x2, 0x450329?},\
    \ {0xc0000f5db0, 0x4, 0x0?})\n\t/tmp/tmpdu2hxph0_test.go:41 +0x2b0\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmpdu2hxph0_test.go:58 +0x1f0\ntesting.tRunner(0xc0001924e0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074752
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) != len(lst2)\
    \ {\n        return nil\n    }\n    for _, x := range lst1 {\n        if strings.Count(x,\
    \ \"-\") > strings.Count(x, \"+\") {\n            result = append(result, x)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8jtemfc__test.go:28:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074759
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) != len(lst2)\
    \ {\n        return lst1\n    }\n    for i := 0; i < len(lst1); i++ {\n      \
    \  if lst1[i] != lst2[i] {\n            return lst1\n        }\n    }\n    return\
    \ lst1\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpw4mr49p__test.go:23:5: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074760
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) != len(lst2)\
    \ {\n        return lst1\n    }\n    for _, val := range lst1 {\n        if !contains(lst2,\
    \ val) {\n            result = append(result, val)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp92cmz1om_test.go:28:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074760
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] < lst2[i] {\n            result[i] = lst1[i]\n   \
    \     } else {\n            result[i] = lst2[i]\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmph2erqzno_test.go:59: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmph2erqzno_test.go:59:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmph2erqzno_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmph2erqzno_test.go:59: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmph2erqzno_test.go:59:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074754
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst1, lst2 = lst2, lst1\n        len1, len2 = len2, len1\n    }\n    result\
    \ := make([]string, len1)\n    for i := 0; i < len1; i++ {\n        j := 0\n \
    \       for ; j < len2; j++ {\n            if lst1[i] < lst2[j] {\n          \
    \      break\n            }\n        }\n        result[i] = lst1[i]\n    }\n \
    \   return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpap8y9555_test.go:66: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpap8y9555_test.go:66:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpap8y9555_test.go:66: expected '[hI hi hi]', got '[hi admin]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074760
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := range lst1\
    \ {\n        result[i] = lst1[i]\n    }\n    \n    for i := range lst2 {\n   \
    \     j := 0\n        for k := range result {\n            if result[k] == lst2[i]\
    \ {\n                j++\n            }\n        }\n        if j < len(result)\
    \ {\n            result[j] = lst2[i]\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__2\
    \ (0.00s)\n        tmpj043ih4s_test.go:68: expected '[hi admin]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n        tmpj043ih4s_test.go:68:\
    \ expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n\
    \        tmpj043ih4s_test.go:68: expected '[hI Hi]', got '[Hi admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpj043ih4s_test.go:68: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpj043ih4s_test.go:68: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074761
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n    if len(lst1) == 0 {\n\
    \        return result\n    }\n    if len(lst2) == 0 {\n        return result\n\
    \    }\n    if len(lst1) == 1 {\n        if lst1[0] == lst2[0] {\n           \
    \ return lst1\n        }\n        return lst2\n    }\n    if len(lst2) == 1 {\n\
    \        if lst1[0] == lst2[0] {\n            return lst1\n        }\n       \
    \ return lst2\n    }\n    if lst1[0] != lst2[0] {\n        return result\n   \
    \ }\n    result := []string{}\n    for _, val := range lst1 {\n        if !contains(lst2,\
    \ val) {\n            result = append(result, val)\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsgq83841_test.go:45:12: no new variables on left side of :=

    /tmp/tmpsgq83841_test.go:47:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074761
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   return lst2\n    }\n    return lst1\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpfab3puaw_test.go:55: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpfab3puaw_test.go:55:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpfab3puaw_test.go:55: expected '[hI hi hi]', got '[hi admin]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074751
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst2 = append([]string{}, lst2...)\n        len2 = len1\n    }\n    \n   \
    \ result := make([]string, len2)\n    for i := 0; i < len2; i++ {\n        result[i]\
    \ = lst2[i]\n    }\n    \n    for i := 0; i < len1; i++ {\n        j := 0\n  \
    \      for k := 0; k < len2; k++ {\n            if lst1[i] < lst2[k] {\n     \
    \           result[j] = lst1[i]\n                break\n            }\n      \
    \      j++\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x513700,\
    \ 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513700, 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc00018a510?, 0x1, 0x450329?},\
    \ {0xc000186bf8?, 0x0, 0x0?})\n\t/tmp/tmpcy9450t3_test.go:35 +0x25b\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmpcy9450t3_test.go:66 +0x60e\ntesting.tRunner(0xc000198ea0, 0x529040)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074761
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        result[i] = lst1[i]\n    }\n    \n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            break\n        }\n    }\n\
    \    \n    for i := 0; i < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n\
    \            break\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpb2z2k2w0_test.go:68: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpb2z2k2w0_test.go:68:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpb2z2k2w0_test.go:68: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpb2z2k2w0_test.go:68: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpb2z2k2w0_test.go:68:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpb2z2k2w0_test.go:68: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074761
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len == 0 || lst2Len == 0 {\n        return []string{}\n    }\n   \
    \ \n    result := []string{}\n    \n    result := append(result, lst1[0])\n  \
    \  \n    for i := 1; i < lst1Len; i++ {\n        if lst1[i] > lst1[i - 1] {\n\
    \            result := append(result, lst1[i])\n        }\n    }\n    \n    for\
    \ i := 1; i < lst2Len; i++ {\n        if lst2[i] > lst2[i - 1] {\n           \
    \ result := append(result, lst2[i])\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_hn28z_3_test.go:31:12: no new variables on left side of :=

    /tmp/tmp_hn28z_3_test.go:35:13: result declared but not used

    /tmp/tmp_hn28z_3_test.go:41:13: result declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074761
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) == 0 {\n        return lst2\n\
    \    }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpk5xvna93_test.go:274:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074755
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n    if len(lst1) == 0 {\n\
    \        return result\n    }\n    if len(lst2) == 0 {\n        return result\n\
    \    }\n    if len(lst1) > len(lst2) {\n        lst1, lst2 = lst2, lst1\n    }\n\
    \    for _, x := range lst1 {\n        if !contains(lst2, x) {\n            result\
    \ = append(result, x)\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph3f8yvxs_test.go:34:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074761
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    m := make(map[string]int)\n    for _, s := range\
    \ lst1 {\n        m[s]++\n    }\n    for _, s := range lst2 {\n        m[s]++\n\
    \    }\n    result := make([]string, 0, len(m))\n    for k := range m {\n    \
    \    if m[k] == len(lst1) {\n            result = append(result, k)\n        }\n\
    \    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpcwlobkd__test.go:60: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpcwlobkd__test.go:60: expected\
    \ '[hi admin]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpcwlobkd__test.go:60: expected '[4]', got '[1 2 3 5]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__4 (0.00s)\n        tmpcwlobkd__test.go:60: expected\
    \ '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n   \
    \     tmpcwlobkd__test.go:60: expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmpcwlobkd__test.go:60: expected '[hi admin]', got '[hi]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpcwlobkd__test.go:60:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    for _, val := range lst1 {\n\
    \        if !contains(lst2, val) {\n            result = append(result, val)\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprc0v_hn8_test.go:29:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074761
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    m := make(map[string]int)\n    for _, s := range\
    \ lst1 {\n        m[s] = m[s] + 1\n    }\n    for _, s := range lst2 {\n     \
    \   m[s] = m[s] + 1\n    }\n    result := make([]string, 0, len(m))\n    for k,\
    \ v := range m {\n        if v > len(lst2) {\n            result = append(result,\
    \ k)\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpgq4hh93k_test.go:60: expected '[hi hi]', got '[hi]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpgq4hh93k_test.go:60:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpgq4hh93k_test.go:60: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpgq4hh93k_test.go:60: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpgq4hh93k_test.go:60: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpgq4hh93k_test.go:60: expected '[hi admin]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__8 (0.00s)\n        tmpgq4hh93k_test.go:60: expected\
    \ '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074761
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst1, lst2 = lst2, lst1\n        len1, len2 = len2, len1\n    }\n    result\
    \ := make([]string, len1)\n    for i := 0; i < len1; i++ {\n        result[i]\
    \ = lst1[i]\n    }\n    for i := 0; i < len2; i++ {\n        if result[i] != lst2[i]\
    \ {\n            return result\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]string{}, []string{}), expected: []string{} },\n \
    \    { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    }), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513800,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513800, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0x62b7e0?, 0x8?, 0x51400000003?},\
    \ {0xc0000d8540?, 0x5e4ea0?, 0x5d4550?})\n\t/tmp/tmpqj022ax9_test.go:37 +0x166\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmpqj022ax9_test.go:58\
    \ +0x523\ntesting.tRunner(0xc0001924e0, 0x529140)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074761
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i, _ := range\
    \ lst1 {\n        total := 0\n        for _, v := range lst2 {\n            if\
    \ v < lst1[i] {\n                total++\n            }\n        }\n        if\
    \ total == len(lst1) {\n            result[i] = lst1[i]\n        }\n    }\n  \
    \  \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmptcgjfqry_test.go:65: expected '[hi hi]', got '[ ]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmptcgjfqry_test.go:65:\
    \ expected '[hI Hi]', got '[hi ]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmptcgjfqry_test.go:65: expected '[hI hi hi]', got '[hi admin]'\n   \
    \ --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmptcgjfqry_test.go:65:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074761
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0; i < len(lst1); i++\
    \ {\n        for j := i + 1; j < len(lst1); j++ {\n            if lst1[i] < lst1[j]\
    \ {\n                result[i] = lst1[j]\n                break\n            }\n\
    \        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpzammbiru_test.go:62: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpzammbiru_test.go:62:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpzammbiru_test.go:62: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpzammbiru_test.go:62: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpzammbiru_test.go:62:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpzammbiru_test.go:62: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074761
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len > lst2Len {\n        lst1, lst2 = lst2, lst1\n        lst1Len,\
    \ lst2Len = lst2Len, lst1Len\n    }\n    \n    result := make([]string, 0)\n \
    \   \n    for i := 0; i < lst1Len; i++ {\n        total := 0\n        for j :=\
    \ 0; j < lst2Len; j++ {\n            if lst1[i] == lst2[j] {\n               \
    \ total++\n            }\n        }\n        if total < lst2Len {\n          \
    \  result = append(result, lst1[i])\n        }\n    }\n    \n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpp53cqtzs_test.go:68: expected '[hi hi]', got '[admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpp53cqtzs_test.go:68:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpp53cqtzs_test.go:68: expected '[hI hi hi]', got '[hi admin]'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074761
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   len1, len2 = len2, len1\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        total := 0\n        for j := 0; j < len2; j++\
    \ {\n            total += lst1[i][0] == lst2[j][0]\n        }\n        if total\
    \ > len2 {\n            result[i] = lst1[i]\n        }\n    }\n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpssnf_bo4_test.go:35:13: invalid operation: total += lst1[i][0] == lst2[j][0]
    (mismatched types int and untyped bool)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074761
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    for _, s := range\
    \ lst1 {\n        if !contains(lst2, s) {\n            lst3 = append(lst3, s)\n\
    \        }\n    }\n    return lst3\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpf9wt8s34_test.go:25:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074753
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := []string{}\n    \n    for _, str1 := range\
    \ lst1 {\n        \n        for _, str2 := range lst2 {\n            \n      \
    \      if str1 == str2 {\n                \n                continue\n       \
    \     }\n            \n            if str1 > str2 {\n                \n      \
    \          break\n            }\n            \n            if str1 < str2 {\n\
    \                \n                break\n            }\n            \n      \
    \  }\n        \n        result = append(result, str1)\n    }\n    \n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpd0nhd2e4_test.go:78: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpd0nhd2e4_test.go:78:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpd0nhd2e4_test.go:78: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpd0nhd2e4_test.go:78:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074762
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := 0; i\
    \ < len(lst1); i++ {\n        result[i] = lst1[i]\n    }\n    \n    for i := 0;\
    \ i < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n            break\n \
    \       }\n    }\n    \n    for i := 0; i < len(lst1); i++ {\n        if lst1[i]\
    \ != lst2[i] {\n            result[i] = lst1[i]\n        }\n    }\n    \n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpse4yvu3t_test.go:69: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpse4yvu3t_test.go:69:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpse4yvu3t_test.go:69: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpse4yvu3t_test.go:69: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpse4yvu3t_test.go:69:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpse4yvu3t_test.go:69: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074762
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst1, lst2 = lst2, lst1\n        len1, len2 = len2, len1\n    }\n    result\
    \ := make([]string, len1)\n    for i := 0; i < len1; i++ {\n        result[i]\
    \ = lst1[i]\n    }\n    for i := 0; i < len2; i++ {\n        j := i\n        for\
    \ j < len1 && lst1[j] == lst2[j] {\n            j++\n        }\n        if j ==\
    \ len1 {\n            break\n        }\n        result[i] = lst1[j]\n    }\n \
    \   return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp0cb0g0r__test.go:70: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp0cb0g0r__test.go:70:\
    \ expected '[hi admin]', got '[admin admin]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp0cb0g0r__test.go:70: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmp0cb0g0r__test.go:70:\
    \ expected '[hI hi hi]', got '[hi admin]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074762
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ nil\n    }\n    \n    result := []string{}\n    \n    for _, str1 := range lst1\
    \ {\n        \n        for _, str2 := range lst2 {\n            \n           \
    \ if str1 == str2 {\n                \n                continue // skip the string\
    \ if its already in the result\n            }\n            \n            if str1\
    \ > str2 {\n                \n                break // break out of the inner\
    \ loop\n            }\n        }\n        \n        result = append(result, str1)\n\
    \    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpn1hlgmbv_test.go:72: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpn1hlgmbv_test.go:72:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpn1hlgmbv_test.go:72: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpn1hlgmbv_test.go:72: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpn1hlgmbv_test.go:72:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpn1hlgmbv_test.go:72: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074762
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst1, lst2 = lst2, lst1\n        len1, len2 = len2, len1\n    }\n    result\
    \ := []string{}\n    for i := 0; i < len1; i++ {\n        if lst1[i] < lst2[i]\
    \ {\n            result = append(result, lst1[i])\n        }\n    }\n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpi_pu7xwu_test.go:62: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpi_pu7xwu_test.go:62:\
    \ expected '[hi admin]', got '[admin]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmpi_pu7xwu_test.go:62: expected '[4]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__4 (0.00s)\n        tmpi_pu7xwu_test.go:62: expected\
    \ '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpi_pu7xwu_test.go:62: expected '[hI hi hi]', got '[admin]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpi_pu7xwu_test.go:62: expected\
    \ '[hi admin]', got '[admin]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074762
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, 0)\n    for _, val := range lst1 {\n\
    \        if lst2 != nil && len(val) < len(lst2) {\n            continue\n    \
    \    }\n        \n        for _, val2 := range lst2 {\n            if len(val)\
    \ == 0 || len(val2) == 0 {\n                continue\n            }\n        \
    \    \n            if val == val2 {\n                continue\n            }\n\
    \            \n            if val < val2 {\n                break\n          \
    \  }\n        }\n        \n        if lst2 != nil && len(val) < len(lst2) {\n\
    \            continue\n        }\n        \n        result = append(result, val)\n\
    \    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpxopmdjjv_test.go:78: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpxopmdjjv_test.go:78:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpxopmdjjv_test.go:78: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpxopmdjjv_test.go:78: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpxopmdjjv_test.go:78:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpxopmdjjv_test.go:78: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074762
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i, _ := range\
    \ lst1 {\n        result[i] = lst1[i]\n    }\n    \n    for i, _ := range lst2\
    \ {\n        if result[i] != lst2[i] {\n            return nil\n        }\n  \
    \  }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpu0wo57q4_test.go:63: expected '[hi hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpu0wo57q4_test.go:63: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpu0wo57q4_test.go:63: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpu0wo57q4_test.go:63: expected '[hI Hi]', got '[]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpu0wo57q4_test.go:63: expected\
    \ '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpu0wo57q4_test.go:63: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074762
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 || len(lst2) == 0 {\n     \
    \   return lst1\n    }\n    \n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    \n    if lst1Len > lst2Len {\n        lst1, lst2 = lst2, lst1\n        lst1Len,\
    \ lst2Len = lst2Len, lst1Len\n    }\n    \n    result := []string{}\n    \n  \
    \  for i := 0; i < lst1Len; i++ {\n        if lst1[i] < lst2[i] {\n          \
    \  result += lst1[i:]\n            break\n        }\n    }\n    \n    for i :=\
    \ 0; i < lst2Len; i++ {\n        if lst2[i] < lst1[i] {\n            result +=\
    \ lst2[i:]\n            break\n        }\n    }\n    \n    return result\n}\n\n\
    func TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpidllkcv3_test.go:39:13: invalid operation: operator + not defined on result
    (variable of type []string)

    /tmp/tmpidllkcv3_test.go:46:13: invalid operation: operator + not defined on result
    (variable of type []string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074762
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := []string{}\n    for _, val1 := range lst1 {\n    \
    \    for _, val2 := range lst2 {\n            if val1 == val2 {\n            \
    \    result = append(result, val1)\n            }\n        }\n    }\n    \n  \
    \  return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__2\
    \ (0.00s)\n        tmp_d4u6zur_test.go:60: expected '[hi admin]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n        tmp_d4u6zur_test.go:60:\
    \ expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n\
    \        tmp_d4u6zur_test.go:60: expected '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmp_d4u6zur_test.go:60: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmp_d4u6zur_test.go:60:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\n\
    FAIL\n"
  timestamp: 1660074762
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := make([]string, len(lst1))\n    \n    for i\
    \ := 0; i < len(lst1); i++ {\n        if lst1[i] < lst2[i] {\n            result[i]\
    \ = lst1[i]\n        } else {\n            result[i] = lst2[i]\n        }\n  \
    \  }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpyk_vrngo_test.go:62: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpyk_vrngo_test.go:62:\
    \ expected '[hI hi hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__8\
    \ (0.00s)\n        tmpyk_vrngo_test.go:62: expected '[]', got '[this]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074763
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i, _ := range lst1\
    \ {\n        result[i] = lst1[i]\n    }\n    \n    for _, val := range lst2 {\n\
    \        for i, _ := range result {\n            if val == result[i] {\n     \
    \           result[i] = val\n                break\n            }\n        }\n\
    \    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmph1tz7l3i_test.go:65: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmph1tz7l3i_test.go:65:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmph1tz7l3i_test.go:65: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmph1tz7l3i_test.go:65: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmph1tz7l3i_test.go:65:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmph1tz7l3i_test.go:65: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074763
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    \n    if len(lst1) != len(lst2) {\n   \
    \     return lst1\n    }\n    \n    \n    \n    \n    \n    \n    \n    \n   \
    \ \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n \
    \   \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpb5sdlwy5_test.go:276:6: expected ''('', found TestTotal_Match

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660074762
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst2\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    len1 := len(lst1)\n\
    \    len2 := len(lst2)\n    \n    if len1 == len2 {\n        for i := 0; i < len1;\
    \ i++ {\n            if lst1[i] < lst2[i] {\n                return lst1\n   \
    \         }\n        }\n        return lst2\n    }\n    \n    len1Len := len1\n\
    \    len2Len := len2\n    \n    if len1 > len2 {\n        len1Len = len2\n   \
    \     len2Len = len1\n    }\n    \n    len1Len -= len2Len\n    \n    result :=\
    \ make([]string, len1Len)\n    \n    i := 0\n    for i < len1Len {\n        result[i]\
    \ = lst1[i]\n        i++\n    }\n    \n    for i < len2Len {\n        result[i]\
    \ = lst2[i]\n        i++\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: makeslice: len\
    \ out of range [recovered]\n\tpanic: runtime error: makeslice: len out of range\n\
    \ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x503a80, 0x54a280})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x503a80, 0x54a280})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match({0xc0001d6040?, 0x2, 0x2?},\
    \ {0xc00019a7c0?, 0x4, 0x2?})\n\t/tmp/tmpb0fd53yy_test.go:52 +0x6f\ncommand-line-arguments_test.TestTotal_Match(0x0?)\n\
    \t/tmp/tmpb0fd53yy_test.go:77 +0x1ce\ntesting.tRunner(0xc000199040, 0x529140)\n\
    \t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439 +0x102\ncreated\
    \ by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074763
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i, _ := range lst1\
    \ {\n        result[i] = lst1[i]\n    }\n    \n    for _, item := range lst2 {\n\
    \        for i, _ := range result {\n            if item == result[i] {\n    \
    \            result[i] = item\n                break\n            }\n        }\n\
    \    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n \
    \ candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpn6jtgjc7_test.go:65: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpn6jtgjc7_test.go:65:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpn6jtgjc7_test.go:65: expected '[hI hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpn6jtgjc7_test.go:65:\
    \ expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074763
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    m := make(map[string]int)\n    for _, s := range\
    \ lst1 {\n        m[s]++\n    }\n    for _, s := range lst2 {\n        m[s]++\n\
    \    }\n    result := make([]string, 0)\n    for k, v := range m {\n        if\
    \ v > len(lst1) {\n            result = append(result, k)\n        }\n    }\n\
    \    if len(result) == 0 {\n        return lst1\n    }\n    return result\n}\n\
    \nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpr5_uu1u6_test.go:63: expected '[hi hi]', got '[hi]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpr5_uu1u6_test.go:63:\
    \ expected '[hi admin]', got '[hi]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpr5_uu1u6_test.go:63: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpr5_uu1u6_test.go:63:\
    \ expected '[hI hi hi]', got '[hi]'\n    --- FAIL: TestTotal_Match/test_num__7\
    \ (0.00s)\n        tmpr5_uu1u6_test.go:63: expected '[]', got '[this]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmpr5_uu1u6_test.go:63: expected\
    \ '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074763
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    for _, v := range\
    \ lst1 {\n        if !contains(lst2, v) {\n            lst3 = append(lst3, v)\n\
    \        }\n    }\n    return lst3\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2q_mvhuo_test.go:25:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074763
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) != len(lst2)\
    \ {\n        return result\n    }\n    for _, item := range lst1 {\n        if\
    \ lst2 != nil && len(item) >= len(lst2[0]) {\n            result = append(result,\
    \ item)\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpou592a4q_test.go:56: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpou592a4q_test.go:56:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpou592a4q_test.go:56: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpou592a4q_test.go:56: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpou592a4q_test.go:56:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpou592a4q_test.go:56: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074763
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len == 0 {\n        return lst2\n    }\n    if lst2Len == 0 {\n  \
    \      return lst1\n    }\n    if lst1Len > lst2Len {\n        return lst1\n \
    \   }\n    if lst2Len > lst1Len {\n        return lst2\n    }\n    \n    result\
    \ := make([]string, 0)\n    for i := 0; i < lst1Len; i++ {\n        if lst1[i]\
    \ > lst2[i] {\n            result = append(result, lst1[i])\n        } else {\n\
    \            result = append(result, lst2[i])\n        }\n    }\n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__2\
    \ (0.00s)\n        tmp3i4nod4t_test.go:70: expected '[hi admin]', got '[hi hi\
    \ admin project]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n       \
    \ tmp3i4nod4t_test.go:70: expected '[4]', got '[1 2 3 4 5]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmp3i4nod4t_test.go:70: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmp3i4nod4t_test.go:70:\
    \ expected '[hi admin]', got '[hI hi hii]'\n    --- FAIL: TestTotal_Match/test_num__7\
    \ (0.00s)\n        tmp3i4nod4t_test.go:70: expected '[]', got '[this]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__8 (0.00s)\n        tmp3i4nod4t_test.go:70: expected\
    \ '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074763
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i, v := range lst1\
    \ {\n        if lst1[i] != lst2[i] {\n            result[i] = lst1[i]\n      \
    \  }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp68nz1k37_test.go:28:12: v declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074752
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    if len(lst1) != len(lst2) {\n        return\
    \ lst1\n    }\n    \n    result := []string{}\n    \n    for _, v := range lst1\
    \ {\n        if !contains(lst2, v) {\n            result = append(result, v)\n\
    \        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t *testing.T)\
    \ {\n  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxv1jd69l_test.go:31:13: undefined: contains

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074763
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) == 0 {\n\
    \        return result\n    }\n    if len(lst2) == 0 {\n        return result\n\
    \    }\n    \n    len1 := len(lst1)\n    len2 := len(lst2)\n    if len1 == len2\
    \ {\n        for i := 0; i < len1; i++ {\n            if lst1[i] < lst2[i] {\n\
    \                result = append(result, lst1[i])\n            }\n        }\n\
    \        return result\n    }\n    \n    result := []string{}\n    for i := 0;\
    \ i < len1; i++ {\n        for j := 0; j < len2; j++ {\n            if lst1[i]\
    \ < lst2[j] {\n                result = append(result, lst1[i])\n            \
    \    break\n            }\n        }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4a_duxnd_test.go:42:12: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074763
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len > lst2Len {\n        return lst1\n    }\n    if lst1Len == lst2Len\
    \ {\n        return lst1\n    }\n    \n    result := make([]string, 0)\n    for\
    \ i := 0; i < lst1Len; i++ {\n        if lst1[i] != lst2[i] {\n            break\n\
    \        }\n        result = append(result, lst1[i])\n    }\n    return result\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmptq5qk4uu_test.go:63: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmptq5qk4uu_test.go:63:\
    \ expected '[hi admin]', got '[hi]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmptq5qk4uu_test.go:63: expected '[4]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__4 (0.00s)\n        tmptq5qk4uu_test.go:63: expected\
    \ '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmptq5qk4uu_test.go:63: expected '[hI hi hi]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__6 (0.00s)\n        tmptq5qk4uu_test.go:63: expected\
    \ '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmptq5qk4uu_test.go:63: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074763
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    for _, val :=\
    \ range lst1 {\n        if lst2 != nil {\n            for _, val2 := range lst2\
    \ {\n                if val == val2 {\n                    lst3 = append(lst3,\
    \ val)\n                }\n            }\n        }\n    }\n    return lst3\n\
    }\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__2\
    \ (0.00s)\n        tmpau6zwkt1_test.go:57: expected '[hi admin]', got '[hi hi\
    \ admin]'\n    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpau6zwkt1_test.go:57:\
    \ expected '[hI Hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n\
    \        tmpau6zwkt1_test.go:57: expected '[hI hi hi]', got '[hi hi]'\n    ---\
    \ FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpau6zwkt1_test.go:57: expected\
    \ '[hi admin]', got '[hi]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    \n    for i := 0; i\
    \ < len(lst1); i++ {\n        result[i] = lst1[i]\n    }\n    \n    for i := 0;\
    \ i < len(lst1); i++ {\n        if lst1[i] != lst2[i] {\n            break\n \
    \       }\n    }\n    \n    for i := 0; i < len(lst1); i++ {\n        if lst1[i]\
    \ != lst2[i] {\n            result[i] = lst1[i]\n        }\n    }\n    \n    return\
    \ result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpse4yvu3t_test.go:69: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpse4yvu3t_test.go:69:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpse4yvu3t_test.go:69: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpse4yvu3t_test.go:69: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpse4yvu3t_test.go:69:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpse4yvu3t_test.go:69: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660074762
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    \n    len1 := len(lst1)\n    len2 := len(lst2)\n\
    \    \n    if len1 == len2 {\n        return lst1\n    }\n    \n    result :=\
    \ make([]string, len1)\n    \n    for i := 0; i < len1; i++ {\n        if lst1[i]\
    \ < lst2[i] {\n            result[i] = lst1[i]\n        } else {\n           \
    \ result[i] = lst2[i]\n        }\n    }\n    \n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x5134c0,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x5134c0, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmp4vu1d2w5_test.go:34\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmp4vu1d2w5_test.go:59\
    \ +0x737\ntesting.tRunner(0xc0001a01a0, 0x528dd8)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660074763
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst1, lst2 = lst2, lst1\n        len1, len2 = len2, len1\n    }\n    result\
    \ := make([]string, len1)\n    for i := 0; i < len1; i++ {\n        total := 0\n\
    \        for j := 0; j < len2; j++ {\n            total += lst1[i][0] == lst2[j][0]\n\
    \        }\n        if total > 0 {\n            result[i] = lst1[i]\n        }\n\
    \    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkbhzvsxx_test.go:36:13: invalid operation: total += lst1[i][0] == lst2[j][0]
    (mismatched types int and untyped bool)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074763
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 {\n        return lst2\n  \
    \  }\n    if len(lst2) == 0 {\n        return lst1\n    }\n    \n    len1 := len(lst1)\n\
    \    len2 := len(lst2)\n    \n    if len1 == len2 {\n        \n        for i :=\
    \ 0; i < len1; i++ {\n            \n            if lst1[i] < lst2[i] {\n     \
    \           \n                lst1 = append(lst1[:i], lst1[i+1:]...)\n       \
    \         \n            }\n            \n        }\n        \n        return lst1\n\
    \    }\n    \n    return []string{}\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpeis_lyvj_test.go:72: expected '[hi hi]', got '[hi]'\n  \
    \  --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpeis_lyvj_test.go:72:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpeis_lyvj_test.go:72: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpeis_lyvj_test.go:72: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpeis_lyvj_test.go:72:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpeis_lyvj_test.go:72: expected '[hi admin]', got '[]'\n    --- FAIL:\
    \ TestTotal_Match/test_num__7 (0.00s)\n        tmpeis_lyvj_test.go:72: expected\
    \ '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n    \
    \    tmpeis_lyvj_test.go:72: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660074763
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    len1 := len(lst1)\n    len2 := len(lst2)\n  \
    \  if len1 == len2 {\n        return lst1\n    }\n    if len1 > len2 {\n     \
    \   lst2, lst1 = lst1, lst2\n    }\n    result := make([]string, len1)\n    for\
    \ i := 0; i < len1; i++ {\n        j := 0\n        for ; j < len2; j++ {\n   \
    \         if lst1[i] < lst2[j] {\n                break\n            }\n     \
    \   }\n        result[i] = lst1[i]\n    }\n    return result\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513620,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513620, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.total_match(...)\n\t/tmp/tmpqyplmco0_test.go:39\n\
    command-line-arguments_test.TestTotal_Match(0x0?)\n\t/tmp/tmpqyplmco0_test.go:59\
    \ +0x5fb\ntesting.tRunner(0xc0001a01a0, 0x528f38)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660074763
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len == 0 {\n        return lst2\n    }\n    if lst2Len == 0 {\n  \
    \      return lst1\n    }\n    if lst1Len > lst2Len {\n        return lst1\n \
    \   }\n    \n    result := make([]string, lst1Len)\n    for i := 0; i < lst1Len;\
    \ i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0; i < lst2Len; i++\
    \ {\n        if result[i] != lst2[i] {\n            break\n        }\n    }\n\
    \    for i := 0; i < lst2Len; i++ {\n        if result[i] != lst2[i] {\n     \
    \       break\n        }\n    }\n    return result[:i]\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp67p0mgt3_test.go:49:20: undefined: i

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074763
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    \n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        if lst1[i] != lst2[i] {\n            result[i] = lst1[i]\n  \
    \      }\n    }\n    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n\
    \  candidate := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpg7vpcbvy_test.go:57: expected '[hi hi]', got '[ admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpg7vpcbvy_test.go:57:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpg7vpcbvy_test.go:57: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmpg7vpcbvy_test.go:57: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmpg7vpcbvy_test.go:57:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmpg7vpcbvy_test.go:57: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074750
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst3 := make([]string, 0)\n    \n    if len(lst1)\
    \ == 0 {\n        return lst3\n    }\n    if len(lst2) == 0 {\n        return\
    \ lst3\n    }\n    \n    lst3 := append(lst3, lst1[0])\n    \n    if len(lst1)\
    \ > len(lst2) {\n        lst3 := append(lst3, lst1[1:])\n    }\n    if len(lst2)\
    \ > len(lst1) {\n        lst3 := append(lst3, lst2[1:])\n    }\n    \n    for\
    \ i := 1; i < len(lst1); i++ {\n        if lst1[i] < lst2[0] {\n            lst3\
    \ := append(lst3, lst1[i:])\n            break\n        }\n    }\n    for i :=\
    \ 1; i < len(lst2); i++ {\n        if lst2[i] < lst1[0] {\n            lst3 :=\
    \ append(lst3, lst2[i:])\n            break\n        }\n    }\n    \n    return\
    \ lst3\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0bryee7j_test.go:32:10: no new variables on left side of :=

    /tmp/tmp0bryee7j_test.go:35:9: lst3 declared but not used

    /tmp/tmp0bryee7j_test.go:35:34: cannot use lst1[1:] (value of type []string) as
    type string in argument to append

    /tmp/tmp0bryee7j_test.go:38:9: lst3 declared but not used

    /tmp/tmp0bryee7j_test.go:38:34: cannot use lst2[1:] (value of type []string) as
    type string in argument to append

    /tmp/tmp0bryee7j_test.go:43:13: lst3 declared but not used

    /tmp/tmp0bryee7j_test.go:43:38: cannot use lst1[i:] (value of type []string) as
    type string in argument to append

    /tmp/tmp0bryee7j_test.go:49:13: lst3 declared but not used

    /tmp/tmp0bryee7j_test.go:49:38: cannot use lst2[i:] (value of type []string) as
    type string in argument to append

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074763
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) == 0 || len(lst2) == 0 {\n     \
    \   return lst1\n    }\n    if len(lst1) > len(lst2) {\n        return lst1\n\
    \    }\n    \n    result := []string{}\n    for _, val := range lst1 {\n     \
    \   if val <= lst2[0] {\n            result = append(result, val)\n        }\n\
    \    }\n    \n    return append(result, lst2...)\n}\n\nfunc TestTotal_Match(t\
    \ *testing.T) {\n  candidate := total_match\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]string{}, []string{}), expected: []string{} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\", \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n   \
    \  { actual: candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"\
    5\"}), expected: []string{\"4\"} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\"\
    , \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hii\"}), expected: []string{\"hi\"\
    , \"admin\"} },\n     { actual: candidate([]string{}, []string{\"this\"}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"this\"}, []string{}), expected:\
    \ []string{} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpw0xvouzz_test.go:61: expected '[hi hi]', got '[hi admin\
    \ hi hi]'\n    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpw0xvouzz_test.go:61:\
    \ expected '[hi admin]', got '[hi admin hi hi admin project]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmpw0xvouzz_test.go:61: expected '[4]', got '[1 2 3 4 5]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmpw0xvouzz_test.go:61:\
    \ expected '[hI Hi]', got '[admin hI Hi]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpw0xvouzz_test.go:61: expected '[hI hi hi]', got '[admin\
    \ hI hi hi]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpw0xvouzz_test.go:61:\
    \ expected '[hi admin]', got '[admin hI hi hii]'\n    --- FAIL: TestTotal_Match/test_num__8\
    \ (0.00s)\n        tmpw0xvouzz_test.go:61: expected '[]', got '[this]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660074764
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    lst1Len := len(lst1)\n    lst2Len := len(lst2)\n\
    \    if lst1Len > lst2Len {\n        return lst1\n    }\n    if lst1Len == lst2Len\
    \ {\n        for i := 0; i < lst1Len; i++ {\n            if lst1[i] != lst2[i]\
    \ {\n                return lst1\n            }\n        }\n        return lst1\n\
    \    }\n    return lst2\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate\
    \ := total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]string{},\
    \ []string{}), expected: []string{} },\n     { actual: candidate([]string{\"hi\"\
    , \"admin\"}, []string{\"hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n\
    \     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"hi\"\
    , \"admin\", \"project\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{\"4\"}, []string{\"1\", \"2\", \"3\", \"4\", \"5\"}), expected:\
    \ []string{\"4\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"Hi\"}), expected: []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\"\
    , \"hi\", \"hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hI\", \"hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual:\
    \ candidate([]string{}, []string{\"this\"}), expected: []string{} },\n     { actual:\
    \ candidate([]string{\"this\"}, []string{}), expected: []string{} },\n   }\n\n\
    \tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t\
    \ *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\"\
    , tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\
    \t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmp65e7sprk_test.go:60: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmp65e7sprk_test.go:60:\
    \ expected '[hi admin]', got '[hi hi admin project]'\n    --- FAIL: TestTotal_Match/test_num__3\
    \ (0.00s)\n        tmp65e7sprk_test.go:60: expected '[4]', got '[1 2 3 4 5]'\n\
    \    --- FAIL: TestTotal_Match/test_num__4 (0.00s)\n        tmp65e7sprk_test.go:60:\
    \ expected '[hI Hi]', got '[hi admin]'\n    --- FAIL: TestTotal_Match/test_num__6\
    \ (0.00s)\n        tmp65e7sprk_test.go:60: expected '[hi admin]', got '[hI hi\
    \ hii]'\n    --- FAIL: TestTotal_Match/test_num__7 (0.00s)\n        tmp65e7sprk_test.go:60:\
    \ expected '[]', got '[this]'\n    --- FAIL: TestTotal_Match/test_num__8 (0.00s)\n\
    \        tmp65e7sprk_test.go:60: expected '[]', got '[this]'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660074764
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    result := []string{}\n    if len(lst1) != len(lst2)\
    \ {\n        return nil\n    }\n    for i := 0; i < len(lst1); i++ {\n       \
    \ if lst1[i] < lst2[i] {\n            result = append(result, lst1[i])\n     \
    \   } else {\n            result = append(result, lst2[i])\n        }\n    }\n\
    \    return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate :=\
    \ total_match\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmpq53u5at4_test.go:58: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmpq53u5at4_test.go:58:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmpq53u5at4_test.go:58: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__5\
    \ (0.00s)\n        tmpq53u5at4_test.go:58: expected '[hI hi hi]', got '[]'\n \
    \   --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n        tmpq53u5at4_test.go:58:\
    \ expected '[hi admin]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\n\
    FAIL\n"
  timestamp: 1660074764
- exit_code: 1
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    if len(lst1) != len(lst2) {\n        return nil\n\
    \    }\n    result := make([]string, len(lst1))\n    for i := 0; i < len(lst1);\
    \ i++ {\n        result[i] = lst1[i]\n    }\n    for i := 0; i < len(lst1); i++\
    \ {\n        if lst1[i] != lst2[i] {\n            break\n        }\n    }\n  \
    \  return result\n}\n\nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]string{}, []string{}), expected:\
    \ []string{} },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestTotal_Match (0.00s)\n    --- FAIL: TestTotal_Match/test_num__1\
    \ (0.00s)\n        tmphynl_zpf_test.go:59: expected '[hi hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__2 (0.00s)\n        tmphynl_zpf_test.go:59:\
    \ expected '[hi admin]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__3 (0.00s)\n\
    \        tmphynl_zpf_test.go:59: expected '[4]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__4\
    \ (0.00s)\n        tmphynl_zpf_test.go:59: expected '[hI Hi]', got '[hi admin]'\n\
    \    --- FAIL: TestTotal_Match/test_num__5 (0.00s)\n        tmphynl_zpf_test.go:59:\
    \ expected '[hI hi hi]', got '[]'\n    --- FAIL: TestTotal_Match/test_num__6 (0.00s)\n\
    \        tmphynl_zpf_test.go:59: expected '[hi admin]', got '[]'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660074759
- exit_code: 2
  program: "package total_match_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that accepts two lists of strings and returns the list that\
    \ has \n// total number of chars in the all strings of the list less than the\
    \ other list.\n// if the two lists have the same number of chars, return the first\
    \ list.\n// Examples\n// >>> total_match([]string{}, []string{})\n// []string{}\n\
    // >>> total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"})\n//\
    \ []string{\"hI\", \"Hi\"}\n// >>> total_match([]string{\"hi\", \"admin\"}, []string{\"\
    hi\", \"hi\", \"admin\", \"project\"})\n// []string{\"hi\", \"admin\"}\n// >>>\
    \ total_match([]string{\"hi\", \"admin\"}, []string{\"hI\", \"hi\", \"hi\"})\n\
    // []string{\"hI\", \"hi\", \"hi\"}\n// >>> total_match([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"})\n// []string{\"4\"}\nfunc total_match(lst1 []string,\
    \ lst2 []string) []string {\n    var result []string\n    if len(lst1) > len(lst2)\
    \ {\n        result = lst1\n    } else {\n        result = lst2\n    }\n    for\
    \ _, v := range result {\n        if v != \"\" {\n            total := 0\n   \
    \         for _, v1 := range result {\n                if v1 != \"\" {\n     \
    \               total += int(v[v1] != \"\")\n                }\n            }\n\
    \            if total > len(v) {\n                result = result[:len(v)]\n \
    \               break\n            }\n        }\n    }\n    return result\n}\n\
    \nfunc TestTotal_Match(t *testing.T) {\n  candidate := total_match\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]string{}, []string{}), expected: []string{}\
    \ },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hi\", \"\
    hi\"}), expected: []string{\"hi\", \"hi\"} },\n     { actual: candidate([]string{\"\
    hi\", \"admin\"}, []string{\"hi\", \"hi\", \"admin\", \"project\"}), expected:\
    \ []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{\"4\"}, []string{\"\
    1\", \"2\", \"3\", \"4\", \"5\"}), expected: []string{\"4\"} },\n     { actual:\
    \ candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"Hi\"}), expected:\
    \ []string{\"hI\", \"Hi\"} },\n     { actual: candidate([]string{\"hi\", \"admin\"\
    }, []string{\"hI\", \"hi\", \"hi\"}), expected: []string{\"hI\", \"hi\", \"hi\"\
    } },\n     { actual: candidate([]string{\"hi\", \"admin\"}, []string{\"hI\", \"\
    hi\", \"hii\"}), expected: []string{\"hi\", \"admin\"} },\n     { actual: candidate([]string{},\
    \ []string{\"this\"}), expected: []string{} },\n     { actual: candidate([]string{\"\
    this\"}, []string{}), expected: []string{} },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplc3e8og4_test.go:34:36: invalid argument: index v1 (variable of type string)
    must be integer

    /tmp/tmplc3e8og4_test.go:34:43: invalid operation: v[v1] != "" (mismatched types
    byte and untyped string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660074763
