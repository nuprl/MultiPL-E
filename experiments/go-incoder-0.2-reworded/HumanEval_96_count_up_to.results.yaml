language: go_test.go
name: HumanEval_96_count_up_to
results:
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n   \
    \     for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy3o_ucd1_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := make([]int, n+1)\n    primes[0] = 2\n    primes[1] =\
    \ 2\n    for i := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n       \
    \     if i % j == 0 {\n                break\n            }\n        }\n     \
    \   if j > i {\n            primes[i+1] = i\n        }\n    }\n    return primes\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz_p22gxs_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, 28\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpfb3a8uwy_test.go:81:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075124
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ prime := append(prime, 3)\n    for i := 4; i < n; i++ {\n        for j := 2;\
    \ j < i; j++ {\n            if i%j == 0 {\n                break\n           \
    \ }\n        }\n        if j == i {\n            prime = append(prime, i)\n  \
    \      }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2_ium4z4_test.go:25:11: no new variables on left side of :=

    /tmp/tmp2_ium4z4_test.go:26:11: no new variables on left side of :=

    /tmp/tmp2_ium4z4_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j\
    \ == 0 {\n                break\n            }\n        }\n        if j > i {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjcgv0q25_test.go:25:11: no new variables on left side of :=

    /tmp/tmpjcgv0q25_test.go:32:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j\
    \ == 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqna96diq_test.go:25:11: no new variables on left side of :=

    /tmp/tmpqna96diq_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ prime := append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2;\
    \ j < i; j++ {\n            if i % j == 0 {\n                break\n         \
    \   }\n        }\n        if j == i {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp64dexz0w_test.go:25:11: no new variables on left side of :=

    /tmp/tmp64dexz0w_test.go:26:11: no new variables on left side of :=

    /tmp/tmp64dexz0w_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    prime := make([]int,\
    \ 0, n)\n    prime := append(prime, 2)\n    prime := append(prime, 3)\n    prime\
    \ := append(prime, 5)\n    prime := append(prime, 7)\n    prime := append(prime,\
    \ 11)\n    prime := append(prime, 13)\n    prime := append(prime, 17)\n    prime\
    \ := append(prime, 19)\n    prime := append(prime, 29)\n    prime := append(prime,\
    \ 31)\n    prime := append(prime, 37)\n    prime := append(prime, 43)\n    prime\
    \ := append(prime, 59)\n    prime := append(prime, 61)\n    prime := append(prime,\
    \ 67)\n    prime := append(prime, 73)\n    prime := append(prime, 79)\n    prime\
    \ := append(prime, 83)\n    prime := append(prime, 89)\n    prime := append(prime,\
    \ 97)\n    prime := append(prime, 101)\n    prime := append(prime, 103)\n    prime\
    \ := append(prime, 107)\n    prime := append(prime, 109)\n    prime := append(prime,\
    \ 113)\n    prime := append(prime, 127)\n    prime := append(prime, 131)\n   \
    \ prime := append(prime, 137)\n    prime := append(prime, 139)\n    prime := append(prime,\
    \ 149)\n    prime := append(prime, 151)\n    prime := append(prime, 157)\n   \
    \ prime := append(prime, 163)\n    prime := append(prime, 167)\n    prime := append(prime,\
    \ 173)\n    prime := append(prime, 179)\n    prime := append(prime, 181)\n   \
    \ prime := append(prime, 191)\n    prime := append(prime, 193)\n    prime := append(prime,\
    \ 197)\n    prime := append(prime, 199)\n    prime := append(prime, 211)\n   \
    \ prime := append(prime, 223)\n    prime := append(prime, 227)\n    prime := append(prime,\
    \ 229)\n    prime := append(prime, 233)\n    prime := append(prime, 239)\n   \
    \ prime := append(prime, 241)\n    prime := append(prime, 251)\n    prime := append(prime,\
    \ 257)\n    prime := append(prime, 263)\n    prime := append(prime, 269)\n   \
    \ prime := append(prime, 271)\n    prime := append(prime, 277)\n    prime := append(prime,\
    \ 281)\n    prime := append(\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpu8ywencg_test.go:84:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075124
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    for i := 4; i < n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i%j == 0 {\n                break\n            }\n   \
    \     }\n        if i == j {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp819jh_h2_test.go:25:11: no new variables on left side of :=

    /tmp/tmp819jh_h2_test.go:26:11: no new variables on left side of :=

    /tmp/tmp819jh_h2_test.go:33:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for\
    \ i := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j ==\
    \ 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp1ia6hpnz_test.go:25:11: no new variables on left side of :=

    /tmp/tmp1ia6hpnz_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := make([]int, n)\n    primes[0] = 2\n    primes[1] = 2\n\
    \    for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ i%j == 0 {\n                break\n            }\n        }\n        if i ==\
    \ j {\n            primes[i] = i\n        }\n    }\n    return primes\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3df7tkn5_test.go:33:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ prime := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 21)\n    prime := append(prime, 23)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 41)\n    prime := append(prime, 43)\n    prime := append(prime, 47)\n    prime\
    \ := append(prime, 53)\n    prime := append(prime, 59)\n    prime := append(prime,\
    \ 61)\n    prime := append(prime, 67)\n    prime := append(prime, 71)\n    prime\
    \ := append(prime, 73)\n    prime := append(prime, 79)\n    prime := append(prime,\
    \ 83)\n    prime := append(prime, 89)\n    prime := append(prime, 97)\n    prime\
    \ := append(prime, 101)\n    prime := append(prime, 103)\n    prime := append(prime,\
    \ 107)\n    prime := append(prime, 109)\n    prime := append(prime, 113)\n   \
    \ prime := append(prime, 127)\n    prime := append(prime, 131)\n    prime := append(prime,\
    \ 137)\n    prime := append(prime, 139)\n    prime := append(prime, 149)\n   \
    \ prime := append(prime, 151)\n    prime := append(prime, 157)\n    prime := append(prime,\
    \ 163)\n    prime := append(prime, 167)\n    prime := append(prime, 173)\n   \
    \ prime := append(prime, 179)\n    prime := append(prime, 181)\n    prime := append(prime,\
    \ 191)\n    prime := append(prime, 193)\n    prime := append(prime, 197)\n   \
    \ prime := append(prime, 199)\n    prime := append(prime, 211)\n    prime := append(prime,\
    \ 223)\n    prime := append(prime, 227)\n    prime := append(prime, 229)\n   \
    \ prime := append(prime, 233)\n    prime := append(prime, 239)\n    prime := append(prime,\
    \ 241)\n    prime := append(prime, 251)\n    prime := append(prime, 257)\n   \
    \ prime := append(prime, 26\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp48ooxzs3_test.go:81:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075124
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 21)\n    prime := append(prime, 23)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 41)\n    prime := append(prime, 43)\n    prime := append(prime, 47)\n    prime\
    \ := append(prime, 53)\n    prime := append(prime, 59)\n    prime := append(prime,\
    \ 61)\n    prime := append(prime, 67)\n    prime := append(prime, 71)\n    prime\
    \ := append(prime, 73)\n    prime := append(prime, 79)\n    prime := append(prime,\
    \ 83)\n    prime := append(prime, 89)\n    prime := append(prime, 97)\n    prime\
    \ := append(prime, 101)\n    prime := append(prime, 103)\n    prime := append(prime,\
    \ 107)\n    prime := append(prime, 109)\n    prime := append(prime, 113)\n   \
    \ prime := append(prime, 127)\n    prime := append(prime, 131)\n    prime := append(prime,\
    \ 137)\n    prime := append(prime, 139)\n    prime := append(prime, 149)\n   \
    \ prime := append(prime, 151)\n    prime := append(prime, 157)\n    prime := append(prime,\
    \ 163)\n    prime := append(prime, 167)\n    prime := append(prime, 173)\n   \
    \ prime := append(prime, 179)\n    prime := append(prime, 181)\n    prime := append(prime,\
    \ 191)\n    prime := append(prime, 193)\n    prime := append(prime, 197)\n   \
    \ prime := append(prime, 199)\n    prime := append(prime, 211)\n    prime := append(prime,\
    \ 223)\n    prime := append(prime, 227)\n    prime := append(prime, 229)\n   \
    \ prime := append(prime, 233)\n    prime := append(prime, 239)\n    prime := append(prime,\
    \ 241)\n    prime := append(prime, 251)\n    prime := append(prime, 257)\n   \
    \ prime := append(prime, 263)\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph8mc7o7g_test.go:82:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075124
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := make([]int, n+1)\n    primes[0] = 2\n    primes[1] =\
    \ 2\n    for i := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n       \
    \     if i%j == 0 {\n                break\n            }\n        }\n       \
    \ if j > i {\n            primes[i] = j\n        }\n    }\n    return primes\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5a45sllq_test.go:33:12: undefined: j

    /tmp/tmp5a45sllq_test.go:34:25: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpugtrtfc1_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[i / 2] {\n            continue\n        }\n        for j := i *\
    \ i; j < n; j += i {\n            if j > n {\n                break\n        \
    \    }\n            prime[i / 2] = true\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7shvuj5e_test.go:26:12: non-boolean condition in if statement

    /tmp/tmp7shvuj5e_test.go:33:28: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[prime[len(prime)-1]-1] != i {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp9v1s8il4_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp9v1s8il4_test.go:40\
    \ +0xddd\ntesting.tRunner(0xc0001924e0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075126
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n     \
    \   }\n        for j := 1; j < i; j++ {\n            if prime[j-1] == 0 {\n  \
    \              prime = append(prime, j)\n                break\n            }\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 18 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpxy7ixa57_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpxy7ixa57_test.go:46\
    \ +0x12df\ntesting.tRunner(0xc0001031e0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075126
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 0 {\n        panic(\"count_up_to: n must be non-negative\"\
    )\n    }\n    result := make([]int, 0, n)\n    i := 2\n    for i <= n {\n    \
    \    if isprime(i) {\n            result = append(result, i)\n        }\n    \
    \    i++\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp39ndy6lv_test.go:30:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp58822wh_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    result := make([]int,\
    \ 0, n)\n    i := 2\n    for i < n {\n        if n%i == 0 {\n            result\
    \ = append(result, i)\n            n /= i\n        }\n        i++\n    }\n   \
    \ return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpponuocmy_test.go:61: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpponuocmy_test.go:61:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__2 (0.00s)\n        tmpponuocmy_test.go:61: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3\
    \ (0.00s)\n        tmpponuocmy_test.go:61: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]', got '[%!s(int=2)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmpponuocmy_test.go:61: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=2)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpponuocmy_test.go:61:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=2) %!s(int=3)]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmpponuocmy_test.go:61: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmpponuocmy_test.go:61: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075126
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := make([]int, n)\n    primes[0] = 2\n    primes[1] = 3\n\
    \    for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ primes[j] == i {\n                primes[j+1] = primes[j] + 1\n            \
    \    break\n            }\n        }\n    }\n    return primes[:n]\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 4 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmprsulf4ki_test.go:25\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmprsulf4ki_test.go:49\
    \ +0x1c5\ntesting.tRunner(0xc0001a0000, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075126
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[i / 2] {\n            continue\n        }\n        for j := i *\
    \ i; j < n; j += i {\n            if j > n {\n                break\n        \
    \    }\n            prime[i / 2] = true\n            break\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5s0n_vq0_test.go:26:12: non-boolean condition in if statement

    /tmp/tmp5s0n_vq0_test.go:33:28: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075128
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    prime := make([]int,\
    \ 0, n)\n    for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n    \
    \        if i%j == 0 {\n                break\n            }\n        }\n    \
    \    if i == j {\n            prime = append(prime, i)\n        }\n    }\n   \
    \ return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmph0x53c9d_test.go:34:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075128
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == n {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmp7rlnaze1_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp7rlnaze1_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp7rlnaze1_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075129
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n   \
    \     for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy3o_ucd1_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    result := make([]int,\
    \ 0, n)\n    for i := 2; i < n; i++ {\n        if isPrime(i) {\n            result\
    \ = append(result, i)\n        }\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpu18j518e_test.go:29:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075128
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ prime := append(prime, 3)\n    for i := 4; i < n; i++ {\n        for j := 2;\
    \ j < i; j++ {\n            if i % j == 0 {\n                break\n         \
    \   }\n        }\n        if j > i {\n            prime = append(prime, i)\n \
    \       }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6sh968rq_test.go:25:11: no new variables on left side of :=

    /tmp/tmp6sh968rq_test.go:26:11: no new variables on left side of :=

    /tmp/tmp6sh968rq_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    result := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n   \
    \     if isPrime(i) {\n            result = append(result, i)\n        }\n   \
    \ }\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjt6btkrk_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := make([]int, n+1)\n    primes[0] = 2\n    primes[1] =\
    \ 3\n    for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n        \
    \    if i*j > n {\n                break\n            }\n            if primes[i*j]\
    \ == 0 {\n                primes[i*j] = i\n            }\n        }\n    }\n \
    \   return primes\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp37w2srjf_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp37w2srjf_test.go:51\
    \ +0x173\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n     \
    \   }\n        for j := 0; j < prime[0]-1; j++ {\n            if i%prime[j] ==\
    \ 0 {\n                break\n            }\n        }\n        if j == prime[0]-1\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3sucun0e_test.go:34:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    result := make([]int, 0, n)\n    if n <= 0 {\n        return result\n\
    \    }\n    for i := 2; i <= n; i++ {\n        if isprime(i) {\n            result\
    \ = append(result, i)\n        }\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp21g3_9i5_test.go:29:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j\
    \ == 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqna96diq_test.go:25:11: no new variables on left side of :=

    /tmp/tmpqna96diq_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        for _, j := range prime {\n            if\
    \ i%j == 0 {\n                break\n            }\n            if j > i {\n \
    \               break\n            }\n            prime = append(prime, j)\n \
    \       }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpb5thy9qk_test.go:25:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 29)\n    prime := append(prime, 31)\n    prime := append(prime, 37)\n    prime\
    \ := append(prime, 43)\n    prime := append(prime, 49)\n    prime := append(prime,\
    \ 57)\n    prime := append(prime, 61)\n    prime := append(prime, 67)\n    prime\
    \ := append(prime, 73)\n    prime := append(prime, 79)\n    prime := append(prime,\
    \ 83)\n    prime := append(prime, 89)\n    prime := append(prime, 97)\n    prime\
    \ := append(prime, 101)\n    prime := append(prime, 103)\n    prime := append(prime,\
    \ 107)\n    prime := append(prime, 109)\n    prime := append(prime, 113)\n   \
    \ prime := append(prime, 127)\n    prime := append(prime, 131)\n    prime := append(prime,\
    \ 137)\n    prime := append(prime, 139)\n    prime := append(prime, 149)\n   \
    \ prime := append(prime, 151)\n    prime := append(prime, 157)\n    prime := append(prime,\
    \ 163)\n    prime := append(prime, 167)\n    prime := append(prime, 173)\n   \
    \ prime := append(prime, 179)\n    prime := append(prime, 181)\n    prime := append(prime,\
    \ 191)\n    prime := append(prime, 193)\n    prime := append(prime, 197)\n   \
    \ prime := append(prime, 199)\n    prime := append(prime, 211)\n    prime := append(prime,\
    \ 223)\n    prime := append(prime, 227)\n    prime := append(prime, 229)\n   \
    \ prime := append(prime, 233)\n    prime := append(prime, 239)\n    prime := append(prime,\
    \ 241)\n    prime := append(prime, 251)\n    prime := append(prime, 257)\n   \
    \ prime := append(prime, 263)\n    prime := append(prime, 269)\n    prime := append(prime,\
    \ 271)\n    prime := append(prime, 277)\n    prime := append(prime, 281)\n   \
    \ prime := append(prime, \nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpofy70qqp_test.go:82:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075128
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n     \
    \   }\n        for j := 0; j < i; j++ {\n            if prime[j] == 0 {\n    \
    \            prime = append(prime, j)\n            }\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp7hhuqjqi_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp7hhuqjqi_test.go:45\
    \ +0x1254\ntesting.tRunner(0xc000103520, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp58822wh_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp58822wh_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n   \
    \     if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuxsjxn2l_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[i / 2] {\n            continue\n        }\n        for j := i *\
    \ i; j < n; j += i {\n            prime[j] = true\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdrav4v6h_test.go:26:12: non-boolean condition in if statement

    /tmp/tmpdrav4v6h_test.go:30:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[len(prime)-1] < i {\n            prime = append(prime, i)\n    \
    \    }\n        for j := len(prime) - 1; j > 0; j-- {\n            if prime[j]\
    \ == i {\n                prime = append(prime, prime[j-1])\n                break\n\
    \            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 4 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpkb8xu_bc_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpkb8xu_bc_test.go:46\
    \ +0x1185\ntesting.tRunner(0xc0001a0000, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp58822wh_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j <\
    \ i; j++ {\n            if i % j == 0 {\n                break\n            }\n\
    \        }\n        if j == i {\n            prime = append(prime, i)\n      \
    \  }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqt50u2zg_test.go:25:11: no new variables on left side of :=

    /tmp/tmpqt50u2zg_test.go:26:11: no new variables on left side of :=

    /tmp/tmpqt50u2zg_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    result := make([]int,\
    \ 0, n)\n    i := 2\n    for ; i < n; i++ {\n        if isprime(i) {\n       \
    \     result = append(result, i)\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2,\
    \ 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n   \
    \  { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbf8dmsv2_test.go:30:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[prime[0]-1] != i {\n            prime = append(prime, i)\n     \
    \   }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpq6v7wp1o_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpq6v7wp1o_test.go:40\
    \ +0xdbb\ntesting.tRunner(0xc0001036c0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075130
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n   \
    \     for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == n {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpqx5n3erb_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmpqx5n3erb_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=6)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmpqx5n3erb_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=7)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__3 (0.00s)\n        tmpqx5n3erb_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=10)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmpqx5n3erb_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[%!s(int=22)]'\n    --- FAIL: TestCount_Up_To/test_num__7\
    \ (0.00s)\n        tmpqx5n3erb_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=18)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpqx5n3erb_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[%!s(int=47)]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n   \
    \     tmpqx5n3erb_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31)\
    \ %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61)\
    \ %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]',\
    \ got '[%!s(int=101)]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075130
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    result := make([]int, 0)\n    prime := make([]int, 0)\n    i :=\
    \ 2\n    for i <= n {\n        if i%2 == 0 {\n            prime = append(prime,\
    \ i)\n        }\n        if i%3 == 0 {\n            prime = append(prime, i)\n\
    \        }\n        if i%5 == 0 {\n            prime = append(prime, i)\n    \
    \    }\n        if i%7 == 0 {\n            prime = append(prime, i)\n        }\n\
    \        if i%11 == 0 {\n            prime = append(prime, i)\n        }\n   \
    \     if i%13 == 0 {\n            prime = append(prime, i)\n        }\n      \
    \  if i%17 == 0 {\n            prime = append(prime, i)\n        }\n        if\
    \ i%19 == 0 {\n            prime = append(prime, i)\n        }\n        if i%23\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        if i%29 ==\
    \ 0 {\n            prime = append(prime, i)\n        }\n        if i%31 == 0 {\n\
    \            prime = append(prime, i)\n        }\n        if i%37 == 0 {\n   \
    \         prime = append(prime, i)\n        }\n        if i%41 == 0 {\n      \
    \      prime = append(prime, i)\n        }\n        if i%43 == 0 {\n         \
    \   prime = append(prime, i)\n        }\n        if i%47 == 0 {\n            prime\
    \ = append(prime, i)\n        }\n        if i%53 == 0 {\n            prime = append(prime,\
    \ i)\n        }\n        if i%59 == 0 {\n            prime = append(prime, i)\n\
    \        }\n        if i%61 == 0 {\n            prime = append(prime, i)\n   \
    \     }\n        if i%67 == 0 {\n            prime = append(prime, i)\n      \
    \  }\n        if i%71 == 0 {\n            prime = append(prime, i)\n        }\n\
    \        if i%73 == 0 {\n            prime = append(prime, i)\n        }\n   \
    \     if i%79 == 0 {\n            prime = append(prime, i)\n        }\n      \
    \  if i%83 == 0 {\n            prime = append(prime, i)\n        }\n        if\
    \ i%89 == 0 {\n            prime = append(prime, i)\n        }\n        if i%97\
    \ == 0 {\n            prime = append(prime, i)\n        }\n        if i%101 ==\
    \ 0 {\n            prime = append(prime, i)\n        }\n        if i%103 == 0\
    \ {\n            prime = append(prime, i)\n        }\n        if i%107 == 0 {\n\
    \            prime = append(prime, i)\n        }\n        if i%111 == 0 {\n  \
    \          prime = \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_ccdr1ir_test.go:114:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075129
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i\
    \ % j == 0 {\n                break\n            }\n        }\n        if j >\
    \ i {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4f0jf47d_test.go:25:11: no new variables on left side of :=

    /tmp/tmp4f0jf47d_test.go:32:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075131
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := make([]int, n+1)\n    primes[0] = 2\n    primes[1] =\
    \ 2\n    for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n        \
    \    if primes[j] == i {\n                primes[j+1] = primes[j]\n          \
    \  }\n        }\n    }\n    return primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmplrufdgjv_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmplrufdgjv_test.go:48\
    \ +0x14e\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075131
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n   \
    \     if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuxsjxn2l_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    result := make([]int,\
    \ 0, n)\n    prime := make(map[int]bool)\n    for i := 2; i < n; i++ {\n     \
    \   if prime[i] {\n            result = append(result, i)\n        }\n       \
    \ for j := i * i; j < n; j += i {\n            prime[j] = true\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpxf1d7y43_test.go:62: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[%!s(int=4)]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n    \
    \    tmpxf1d7y43_test.go:62: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got\
    \ '[%!s(int=4)]'\n    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmpxf1d7y43_test.go:62:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=4) %!s(int=6)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmpxf1d7y43_test.go:62:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[%!s(int=4) %!s(int=6)\
    \ %!s(int=8) %!s(int=9)]'\n    --- FAIL: TestCount_Up_To/test_num__5 (0.00s)\n\
    \        tmpxf1d7y43_test.go:62: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=4) %!s(int=6)\
    \ %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=12) %!s(int=14) %!s(int=15) %!s(int=16)\
    \ %!s(int=18) %!s(int=20) %!s(int=21)]'\n    --- FAIL: TestCount_Up_To/test_num__7\
    \ (0.00s)\n        tmpxf1d7y43_test.go:62: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)]', got '[%!s(int=4) %!s(int=6)\
    \ %!s(int=8) %!s(int=9) %!s(int=10) %!s(int=12) %!s(int=14) %!s(int=15) %!s(int=16)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpxf1d7y43_test.go:62:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43)]', got '[%!s(int=4) %!s(int=6) %!s(int=8) %!s(int=9) %!s(int=10)\
    \ %!s(int=12) %!s(int=14) %!s(int=15) %!s(int=16) %!s(int=18) %!s(int=20) %!s(int=21)\
    \ %!s(int=22) %!s(int=24) %!s(int=25) %!s(int=26) %!s(int=27) %!s(int=28) %!s(int=30)\
    \ %!s(int=32) %!s(int=33) %!s(int=34) %!s(int=35) %!s(int=36) %!s(int=38) %!s(int=39)\
    \ %!s(int=40) %!s(int=42) %!s(int=44) %!s(int=45) %!s(int=46)]'\n    --- FAIL:\
    \ TestCount_Up_To/test_num__9 (0.00s)\n        tmpxf1d7y43_test.go:62: expected\
    \ '[%!s(int=2) %!s(int=3) %!s"
  timestamp: 1660075131
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    primes := make([]int,\
    \ n+1)\n    primes[0] = 2\n    primes[1] = 3\n    for i := 2; i <= n; i++ {\n\
    \        for j := 2; j < i; j++ {\n            if i % primes[j] == 0 {\n     \
    \           break\n            }\n        }\n        if j > i {\n            primes[i+1]\
    \ = i\n        }\n    }\n    return primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3rxuz7z7_test.go:36:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075132
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j\
    \ == 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqna96diq_test.go:25:11: no new variables on left side of :=

    /tmp/tmpqna96diq_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ prime := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, \nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps7g08dfo_test.go:82:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075131
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := make([]int, n+1)\n    primes[0] = 2\n    primes[1] =\
    \ 2\n    for i := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n       \
    \     if i % j == 0 {\n                break\n            }\n        }\n     \
    \   if j > i {\n            primes[i+1] = j\n        }\n    }\n    return primes\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4eu_12bq_test.go:33:12: undefined: j

    /tmp/tmp4eu_12bq_test.go:34:27: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075132
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[len(prime)-1] == i {\n            continue\n        }\n        for\
    \ j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n   \
    \         }\n        }\n        if j == i {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbsppmhcq_test.go:34:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075132
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[i / 2] {\n            continue\n        }\n        for j := i *\
    \ i; j < n; j += i {\n            if j > n {\n                break\n        \
    \    }\n            if prime[j] {\n                continue\n            }\n \
    \           prime = append(prime, j)\n        }\n    }\n    return prime\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5g1q9vli_test.go:26:12: non-boolean condition in if statement

    /tmp/tmp5g1q9vli_test.go:33:16: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075133
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        for _, j := range prime {\n            if\
    \ i%j == 0 {\n                break\n            }\n            if j == i {\n\
    \                prime = append(prime, i)\n                break\n           \
    \ }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpol_b1o5g_test.go:25:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075133
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j\
    \ == 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqna96diq_test.go:25:11: no new variables on left side of :=

    /tmp/tmpqna96diq_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := make([]int, n+1)\n    primes[0] = 2\n    primes[1] =\
    \ 3\n    for i := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n       \
    \     if i%j == 0 {\n                break\n            }\n        }\n       \
    \ if j > i {\n            primes[i+1] = i\n        }\n    }\n    return primes\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpef6wdrwg_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n    \
    \    if isprime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4i5ulrjw_test.go:26:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 29)\n    prime := append(prime, 31)\n    prime := append(prime, 37)\n    prime\
    \ := append(prime, 43)\n    prime := append(prime, 59)\n    prime := append(prime,\
    \ 61)\n    prime := append(prime, 67)\n    prime := append(prime, 73)\n    prime\
    \ := append(prime, 79)\n    prime := append(prime, 83)\n    prime := append(prime,\
    \ 89)\n    prime := append(prime, 97)\n    prime := append(prime, 101)\n    prime\
    \ := append(prime, 103)\n    prime := append(prime, 107)\n    prime := append(prime,\
    \ 109)\n    prime := append(prime, 113)\n    prime := append(prime, 127)\n   \
    \ prime := append(prime, 131)\n    prime := append(prime, 137)\n    prime := append(prime,\
    \ 139)\n    prime := append(prime, 149)\n    prime := append(prime, 151)\n   \
    \ prime := append(prime, 157)\n    prime := append(prime, 163)\n    prime := append(prime,\
    \ 167)\n    prime := append(prime, 173)\n    prime := append(prime, 179)\n   \
    \ prime := append(prime, 181)\n    prime := append(prime, 191)\n    prime := append(prime,\
    \ 193)\n    prime := append(prime, 197)\n    prime := append(prime, 199)\n   \
    \ prime := append(prime, 211)\n    prime := append(prime, 223)\n    prime := append(prime,\
    \ 227)\n    prime := append(prime, 229)\n    prime := append(prime, 233)\n   \
    \ prime := append(prime, 239)\n    prime := append(prime, 241)\n    prime := append(prime,\
    \ 251)\n    prime := append(prime, 257)\n    prime := append(prime, 263)\n   \
    \ prime := append(prime, 269)\n    prime := append(prime, 271)\n    prime := append(prime,\
    \ 277)\n    prime := append(prime, 281)\n    prime := append(prime, 283)\n   \
    \ prime := append(prime, \nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdil94p_2_test.go:82:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075133
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp58822wh_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := make([]int, n+1)\n    primes[0] = 2\n    primes[1] =\
    \ 2\n    for i := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n       \
    \     if i % j == 0 {\n                break\n            }\n        }\n     \
    \   if j > i {\n            primes[i+1] = i\n        }\n    }\n    return primes\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz_p22gxs_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    primes := make([]int,\
    \ n+1)\n    primes[0] = 2\n    primes[1] = 3\n    for i := 2; i <= n; i++ {\n\
    \        for j := 2; j < i; j++ {\n            if i % j == 0 {\n             \
    \   break\n            }\n        }\n        if j > i {\n            primes[i+1]\
    \ = i\n        }\n    }\n    return primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp307ube2u_test.go:36:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n     \
    \   }\n        for j := 0; j < i; j++ {\n            if prime[j] == 0 {\n    \
    \            prime = append(prime, j)\n            }\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp7hhuqjqi_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp7hhuqjqi_test.go:45\
    \ +0x1254\ntesting.tRunner(0xc000103520, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == n {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmp7rlnaze1_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp7rlnaze1_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp7rlnaze1_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075129
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[len(prime)-1] != i {\n            prime = append(prime, i)\n   \
    \     }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 34 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpmf43729b_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpmf43729b_test.go:40\
    \ +0xd1d\ntesting.tRunner(0xc000198ea0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075135
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    result := make([]int, 0, n)\n    if n < 2 {\n        return result\n\
    \    }\n    primes := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n      \
    \  if primes[i] != 0 {\n            continue\n        }\n        for j := 2; j\
    \ < i; j++ {\n            if i*j == n {\n                break\n            }\n\
    \            if primes[j] == 0 {\n                primes = append(primes, j)\n\
    \            }\n        }\n    }\n    for _, prime := range primes {\n       \
    \ result = append(result, prime)\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [2] with length 0 [recovered]\n\tpanic: runtime error: index out of range [2]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(0x5)\n\t/tmp/tmplx2_f1ym_test.go:30\
    \ +0x1f1\ncommand-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmplx2_f1ym_test.go:55\
    \ +0x46\ntesting.tRunner(0xc0001a0340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075135
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[len(prime)-1] < i {\n            prime = append(prime, i)\n    \
    \    }\n        for j := 0; j < len(prime); j++ {\n            if prime[j] ==\
    \ i {\n                prime = append(prime[:j], prime[j+1:]...)\n           \
    \     break\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmplvhf9ogw_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmplvhf9ogw_test.go:46\
    \ +0x1425\ntesting.tRunner(0xc0001a01a0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    for i := 4; i <= n; i++ {\n        if isPrime(i) {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpzunjw9jx_test.go:25:11: no new variables on left side of :=

    /tmp/tmpzunjw9jx_test.go:26:11: no new variables on left side of :=

    /tmp/tmpzunjw9jx_test.go:28:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    result := make([]int, 0)\n    for i := 2; i <= n; i++ {\n     \
    \   if isPrime(i) {\n            result = append(result, i)\n        }\n    }\n\
    \    return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpop4haur2_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7155zs9d_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[i - 2] == 0 {\n            prime[i - 2] = 1\n            for j :=\
    \ i * i; j < n; j += i {\n                prime[j] = 1\n            }\n      \
    \  }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpd9f5v6oi_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpd9f5v6oi_test.go:43\
    \ +0x31\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[i / 2] {\n            continue\n        }\n        for j := i *\
    \ i; j < n; j += i {\n            prime[j] = true\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdrav4v6h_test.go:26:12: non-boolean condition in if statement

    /tmp/tmpdrav4v6h_test.go:30:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp58822wh_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    result := make([]int, 0, n)\n    primes := make([]int, 0, n)\n\
    \    for i := 2; i < n; i++ {\n        if primes[i%primes[0]] == 0 {\n       \
    \     primes = append(primes, i)\n        }\n    }\n    for _, prime := range\
    \ primes {\n        if n%prime == 0 {\n            result = append(result, prime)\n\
    \            n /= prime\n        }\n    }\n    if n > 1 {\n        result = append(result,\
    \ n)\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x514920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x514920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp343rg1g4_test.go:27\n\
    command-line-arguments_test.TestCount_Up_To(0xc0001a0340?)\n\t/tmp/tmp343rg1g4_test.go:50\
    \ +0x1e05\ntesting.tRunner(0xc0001a0340, 0x52a240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp58822wh_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n    \
    \    prime := append(prime, i)\n    }\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    return prime\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdaivh0xh_test.go:26:9: prime declared but not used

    /tmp/tmpdaivh0xh_test.go:28:11: no new variables on left side of :=

    /tmp/tmpdaivh0xh_test.go:29:11: no new variables on left side of :=

    /tmp/tmpdaivh0xh_test.go:30:11: no new variables on left side of :=

    /tmp/tmpdaivh0xh_test.go:31:11: no new variables on left side of :=

    /tmp/tmpdaivh0xh_test.go:32:11: no new variables on left side of :=

    /tmp/tmpdaivh0xh_test.go:33:11: no new variables on left side of :=

    /tmp/tmpdaivh0xh_test.go:34:11: no new variables on left side of :=

    /tmp/tmpdaivh0xh_test.go:35:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 0 {\n        return []int{}\n    }\n    result := make([]int,\
    \ 0, n)\n    i := 2\n    for i < n {\n        if isPrime(i) {\n            result\
    \ = append(result, i)\n        }\n        i += 2\n    }\n    return result\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjxv70ask_test.go:30:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[i / 2] {\n            continue\n        }\n        for j := i *\
    \ i; j < n; j += i {\n            prime[j] = true\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdrav4v6h_test.go:26:12: non-boolean condition in if statement

    /tmp/tmpdrav4v6h_test.go:30:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp58822wh_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[i - 2] == 0 {\n            prime[i - 2] = 1\n            for j :=\
    \ i - 3; j > 0; j-- {\n                if prime[j] == 0 {\n                  \
    \  prime[j] = 1\n                    break\n                }\n            }\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpv1cpvlln_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpv1cpvlln_test.go:46\
    \ +0x31\ntesting.tRunner(0xc0001a0340, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n   \
    \     if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuxsjxn2l_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ prime := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 243)\n   \
    \ prime := append(prime, 247)\n    prime := append(prime, 251)\n    prime := append(prime,\
    \ 257)\n    prime := append(prime, 263)\n    prime := append(prime, 269)\n   \
    \ prime := append(prime, \nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2tg2xzyb_test.go:82:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075134
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[i / 2] {\n            continue\n        }\n        for j := i *\
    \ i; j < n; j += i {\n            prime[j] = true\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdrav4v6h_test.go:26:12: non-boolean condition in if statement

    /tmp/tmpdrav4v6h_test.go:30:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j\
    \ == 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqna96diq_test.go:25:11: no new variables on left side of :=

    /tmp/tmpqna96diq_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[len(prime)-1] != i {\n            prime = append(prime, i)\n   \
    \     }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 34 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc0001d6000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpmf43729b_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpmf43729b_test.go:40\
    \ +0xd1d\ntesting.tRunner(0xc000198ea0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for\
    \ i := 3; i <= n; i++ {\n        for _, j := range prime {\n            if i%j\
    \ == 0 {\n                break\n            }\n            if j > i {\n     \
    \           break\n            }\n            prime = append(prime, j)\n     \
    \   }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6rw0fxs4_test.go:25:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7155zs9d_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j\
    \ == 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqna96diq_test.go:25:11: no new variables on left side of :=

    /tmp/tmpqna96diq_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    result := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n  \
    \      if isprime(i) {\n            result = append(result, i)\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp29cvrwv7_test.go:26:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := make([]int, n+1)\n    primes[0] = 2\n    primes[1] =\
    \ 2\n    for i := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n       \
    \     if i % j == 0 {\n                break\n            }\n        }\n     \
    \   if j > i {\n            primes[i] = j\n        }\n    }\n    return primes\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7how3itd_test.go:33:12: undefined: j

    /tmp/tmp7how3itd_test.go:34:25: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075136
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        if isPrime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpz4h9c83g_test.go:25:11: no new variables on left side of :=

    /tmp/tmpz4h9c83g_test.go:27:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075136
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n   \
    \     if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuxsjxn2l_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    for i := 4; i < n; i++ {\n        for j := 2; j < i;\
    \ j++ {\n            if i % j == 0 {\n                break\n            }\n \
    \       }\n        if i == j {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiknfqcnl_test.go:25:11: no new variables on left side of :=

    /tmp/tmpiknfqcnl_test.go:26:11: no new variables on left side of :=

    /tmp/tmpiknfqcnl_test.go:33:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075136
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ prime := append(prime, 3)\n    for i := 4; i < n; i++ {\n        for j := 2;\
    \ j < i; j++ {\n            if i%j == 0 {\n                break\n           \
    \ }\n        }\n        if i == j {\n            prime = append(prime, i)\n  \
    \      }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphwsk8jkc_test.go:25:11: no new variables on left side of :=

    /tmp/tmphwsk8jkc_test.go:26:11: no new variables on left side of :=

    /tmp/tmphwsk8jkc_test.go:33:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075137
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := make([]int, n)\n    primes[0] = 2\n    primes[1] = 3\n\
    \    for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ primes[j] == i {\n                primes[j+1] = primes[j]\n            }\n \
    \       }\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp9_0o3uyj_test.go:25\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp9_0o3uyj_test.go:48\
    \ +0x165\ntesting.tRunner(0xc00019b040, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075138
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n   \
    \     if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuxsjxn2l_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ prime := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, \nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps7g08dfo_test.go:82:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075131
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        if prime[i] == 0 {\n            prime = append(prime,\
    \ i)\n            for j := i * i; j < n; j += i {\n                prime = append(prime,\
    \ j)\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7j_6os11_test.go:25:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075137
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[i / 2] {\n            continue\n        }\n        for j := i *\
    \ i; j < n; j += i {\n            if j > n {\n                break\n        \
    \    }\n            if prime[j] {\n                continue\n            }\n \
    \           prime = append(prime, j)\n        }\n    }\n    return prime\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5g1q9vli_test.go:26:12: non-boolean condition in if statement

    /tmp/tmp5g1q9vli_test.go:33:16: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075133
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == n {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmp7rlnaze1_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp7rlnaze1_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp7rlnaze1_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075129
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    result := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n  \
    \      if isPrime(i) {\n            result = append(result, i)\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7dv4zcax_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075138
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ prime := append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2;\
    \ j < i; j++ {\n            if i % j == 0 {\n                break\n         \
    \   }\n        }\n        if j > i {\n            prime = append(prime, i)\n \
    \       }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpxxp8g9qd_test.go:25:11: no new variables on left side of :=

    /tmp/tmpxxp8g9qd_test.go:26:11: no new variables on left side of :=

    /tmp/tmpxxp8g9qd_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075139
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == n {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmp7rlnaze1_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__2\
    \ (0.00s)\n        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3 (0.00s)\n        tmp7rlnaze1_test.go:60:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)]', got '[]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__5 (0.00s)\n        tmp7rlnaze1_test.go:60: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n\
    \        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7)\
    \ %!s(int=11) %!s(int=13) %!s(int=17)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__8\
    \ (0.00s)\n        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9\
    \ (0.00s)\n        tmp7rlnaze1_test.go:60: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29)\
    \ %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59)\
    \ %!s(int=61) %!s(int=67) %!s(int=71) %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89)\
    \ %!s(int=97)]', got '[]'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075129
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp58822wh_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[i / 2] {\n            continue\n        }\n        for j := i *\
    \ i; j < n; j += i {\n            if j > n {\n                break\n        \
    \    }\n            if prime[j] {\n                continue\n            }\n \
    \           prime = append(prime, j)\n        }\n    }\n    return prime\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5g1q9vli_test.go:26:12: non-boolean condition in if statement

    /tmp/tmp5g1q9vli_test.go:33:16: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075133
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n   \
    \     for j := 2; j < i; j++ {\n            if i % j == 0 {\n                break\n\
    \            }\n        }\n        if j == i {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpbeyqz_cn_test.go:31:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075139
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    if n < 0 {\n     \
    \   return nil\n    }\n    if n == 0 {\n        return prime\n    }\n    prime\
    \ := append(prime, 2)\n    prime := append(prime, 3)\n    prime := append(prime,\
    \ 5)\n    prime := append(prime, 7)\n    prime := append(prime, 11)\n    prime\
    \ := append(prime, 13)\n    prime := append(prime, 17)\n    prime := append(prime,\
    \ 19)\n    if n < 5 {\n        return prime\n    }\n    if n < 7 {\n        prime\
    \ := append(prime, 2)\n        prime := append(prime, 3)\n        prime := append(prime,\
    \ 5)\n        prime := append(prime, 7)\n        prime := append(prime, 11)\n\
    \        prime := append(prime, 13)\n        prime := append(prime, 17)\n    \
    \    prime := append(prime, 19)\n        return prime\n    }\n    if n < 11 {\n\
    \        prime := append(prime, 2)\n        prime := append(prime, 3)\n      \
    \  prime := append(prime, 5)\n        prime := append(prime, 7)\n        prime\
    \ := append(prime, 11)\n        prime := append(prime, 13)\n        prime := append(prime,\
    \ 17)\n        prime := append(prime, 19)\n        return prime\n    }\n    if\
    \ n < 13 {\n        prime := append(prime, 2)\n        prime := append(prime,\
    \ 3)\n        prime := append(prime, 5)\n        prime := append(prime, 7)\n \
    \       prime := append(prime, 11)\n        prime := append(prime, 13)\n     \
    \   prime := append(prime, 17)\n        prime := append(prime, 19)\n        return\
    \ prime\n    }\n    if n < 17 {\n        prime := append(prime, 2)\n        prime\
    \ := append(prime, 3)\n        prime := append(prime, 5)\n        prime := append(prime,\
    \ 7)\n        prime := append(prime, 11)\n        prime := append(prime, 13)\n\
    \        prime := append(prime, 17)\n        prime := append(prime, 19)\n    \
    \    return prime\n    }\n    if n < 19 {\n        prime := append(prime, 2)\n\
    \        prime := append(prime, 3)\n        prime := append(prime, 5)\n      \
    \  prime := append(prime, 7)\n        prime := append(prime, 11)\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp89qbnb2__test.go:101:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075137
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[i / 2] {\n            continue\n        }\n        for j := i *\
    \ i; j < n; j += i {\n            if j > n {\n                break\n        \
    \    }\n            prime[i / 2] = (j == n)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpewny0_vq_test.go:26:12: non-boolean condition in if statement

    /tmp/tmpewny0_vq_test.go:33:28: cannot use (j == n) (untyped bool value) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075139
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for\
    \ i := 3; i < n; i++ {\n        if isPrime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpv4menvcn_test.go:25:11: no new variables on left side of :=

    /tmp/tmpv4menvcn_test.go:27:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075139
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    result := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n  \
    \      if isPrime(i) {\n            result = append(result, i)\n        }\n  \
    \  }\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7dv4zcax_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075138
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ prime := append(prime, 3)\n    for i := 4; i < n; i++ {\n        for j := 2;\
    \ j < i; j++ {\n            if i%j == 0 {\n                break\n           \
    \ }\n        }\n        if i == j {\n            prime = append(prime, i)\n  \
    \      }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphwsk8jkc_test.go:25:11: no new variables on left side of :=

    /tmp/tmphwsk8jkc_test.go:26:11: no new variables on left side of :=

    /tmp/tmphwsk8jkc_test.go:33:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075137
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := make([]int, n+1)\n    primes[0] = 2\n    primes[1] =\
    \ 2\n    for i := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n       \
    \     if i%j == 0 {\n                break\n            }\n        }\n       \
    \ if j > i {\n            primes[i] = i\n        }\n    }\n    return primes\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphzg52j6q_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075139
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    result := make([]int, 0, n)\n    prime := make([]int, 0, n)\n \
    \   prime[0] = true\n    prime[1] = true\n    prime[2] = true\n    prime[3] =\
    \ true\n    prime[4] = true\n    prime[5] = true\n    prime[6] = true\n    prime[7]\
    \ = true\n    prime[8] = true\n    prime[9] = true\n    prime[10] = true\n   \
    \ prime[11] = true\n    prime[12] = true\n    prime[13] = true\n    prime[14]\
    \ = true\n    prime[15] = true\n    prime[16] = true\n    prime[17] = true\n \
    \   prime[18] = true\n    prime[19] = true\n    prime[20] = true\n    prime[21]\
    \ = true\n    prime[22] = true\n    prime[23] = true\n    prime[24] = true\n \
    \   prime[25] = true\n    prime[26] = true\n    prime[27] = true\n    prime[28]\
    \ = true\n    prime[29] = true\n    prime[30] = true\n    prime[31] = true\n \
    \   prime[32] = true\n    prime[33] = true\n    prime[34] = true\n    prime[35]\
    \ = true\n    prime[36] = true\n    prime[37] = true\n    prime[38] = true\n \
    \   prime[39] = true\n    prime[40] = true\n    prime[41] = true\n    prime[42]\
    \ = true\n    prime[43] = true\n    prime[44] = true\n    prime[45] = true\n \
    \   prime[46] = true\n    prime[47] = true\n    prime[48] = true\n    prime[49]\
    \ = true\n    prime[50] = true\n    prime[51] = true\n    prime[52] = true\n \
    \   prime[53] = true\n    prime[54] = true\n    prime[55] = true\n    prime[56]\
    \ = true\n    prime[57] = true\n    prime[58] = true\n    prime[59] = true\n \
    \   prime[60] = true\n    prime[61] = true\n    prime[62] = true\n    prime[63]\
    \ = true\n    prime[64] = true\n    prime[65] = true\n    prime[66] = true\n \
    \   prime[67] = true\n    prime[68] = true\n    prime[69] = true\n    prime[70]\
    \ = true\n    prime[71] = true\n    prime[72] = true\n    prime[73] = true\n \
    \   \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf4zd554v_test.go:101:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075137
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n   \
    \     if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuxsjxn2l_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2; j <\
    \ i; j++ {\n            if i % j == 0 {\n                break\n            }\n\
    \        }\n        if j > i {\n            prime = append(prime, i)\n       \
    \ }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpcjobi6ue_test.go:25:11: no new variables on left side of :=

    /tmp/tmpcjobi6ue_test.go:26:11: no new variables on left side of :=

    /tmp/tmpcjobi6ue_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075139
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    for i := 2; i <= n; i++ {\n      \
    \  if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n \
    \   return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuo91v7xo_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075139
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp58822wh_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[len(prime)-1] < i {\n            prime = append(prime, i)\n    \
    \    }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n \
    \ candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 18 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp8zs5wqbe_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp8zs5wqbe_test.go:40\
    \ +0xd1d\ntesting.tRunner(0xc000103520, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075140
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i\
    \ % j == 0 {\n                break\n            }\n        }\n        if j >\
    \ i {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4f0jf47d_test.go:25:11: no new variables on left side of :=

    /tmp/tmp4f0jf47d_test.go:32:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075131
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n   \
    \     if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuxsjxn2l_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7155zs9d_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j\
    \ == 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqna96diq_test.go:25:11: no new variables on left side of :=

    /tmp/tmpqna96diq_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := make([]int, n)\n    primes[0] = 2\n    primes[1] = 2\n\
    \    for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ primes[j] == i {\n                primes[j] = primes[j+1]\n            } else\
    \ {\n                break\n            }\n        }\n    }\n    return primes\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpcyr782pl_test.go:25\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpcyr782pl_test.go:50\
    \ +0x165\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075140
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n     \
    \   }\n        for j := 0; j < i; j++ {\n            if prime[j] == 0 {\n    \
    \            prime = append(prime, j)\n                break\n            }\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpgvsb4i36_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpgvsb4i36_test.go:46\
    \ +0x12b6\ntesting.tRunner(0xc0001a01a0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075140
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp58822wh_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp58822wh_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[i / 2] {\n            continue\n        }\n        for j := i *\
    \ i; j < n; j += i {\n            if j > n {\n                break\n        \
    \    }\n            if prime[j] {\n                continue\n            }\n \
    \           prime = append(prime, j)\n        }\n    }\n    return prime\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5g1q9vli_test.go:26:12: non-boolean condition in if statement

    /tmp/tmp5g1q9vli_test.go:33:16: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075133
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[prime[len(prime)-1]-1] == i {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpm3pwj8s__test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpm3pwj8s__test.go:40\
    \ +0xddd\ntesting.tRunner(0xc0001a01a0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075140
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp58822wh_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := make([]int, n)\n    primes[0] = 2\n    primes[1] = 2\n\
    \    for i := 2; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ primes[j] == i {\n                primes[j+1] = primes[j]\n            }\n \
    \       }\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 34 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc0001d8000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmplcw7jy24_test.go:25\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmplcw7jy24_test.go:48\
    \ +0x165\ntesting.tRunner(0xc000198ea0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075140
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    for i := 4; i < n; i++ {\n        for j := 0; j < len(prime);\
    \ j++ {\n            if prime[j] == i {\n                prime = append(prime,\
    \ i)\n                break\n            }\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp94hz5y57_test.go:25:11: no new variables on left side of :=

    /tmp/tmp94hz5y57_test.go:26:11: no new variables on left side of :=

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075139
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ prime := append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2;\
    \ j < i; j++ {\n            if i % j == 0 {\n                break\n         \
    \   }\n        }\n        if j == i {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp64dexz0w_test.go:25:11: no new variables on left side of :=

    /tmp/tmp64dexz0w_test.go:26:11: no new variables on left side of :=

    /tmp/tmp64dexz0w_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n   \
    \     if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpuxsjxn2l_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[len(prime)-1] < i {\n            prime = append(prime, i)\n    \
    \    }\n        for j := 0; j < len(prime); j++ {\n            if prime[j] ==\
    \ i {\n                prime = append(prime[:j], prime[j+1:]...)\n           \
    \     break\n            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 6 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmplvhf9ogw_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmplvhf9ogw_test.go:46\
    \ +0x1425\ntesting.tRunner(0xc0001a01a0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n    \
    \    if isprime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4i5ulrjw_test.go:26:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7155zs9d_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ prime := append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2;\
    \ j < i; j++ {\n            if i % j == 0 {\n                break\n         \
    \   }\n        }\n        if j == i {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp64dexz0w_test.go:25:11: no new variables on left side of :=

    /tmp/tmp64dexz0w_test.go:26:11: no new variables on left side of :=

    /tmp/tmp64dexz0w_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n     \
    \   }\n        for j := 0; j < prime[0]-1; j++ {\n            if i%prime[j] ==\
    \ 0 {\n                break\n            }\n        }\n        if j == prime[0]-1\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3sucun0e_test.go:34:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for\
    \ i := 3; i <= n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j\
    \ == 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn4b0znia_test.go:25:11: no new variables on left side of :=

    /tmp/tmpn4b0znia_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075139
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[i / 2] {\n            continue\n        }\n        for j := i *\
    \ i; j < n; j += i {\n            if j > n {\n                break\n        \
    \    }\n            if prime[j] {\n                continue\n            }\n \
    \           prime = append(prime, j)\n        }\n    }\n    return prime\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5g1q9vli_test.go:26:12: non-boolean condition in if statement

    /tmp/tmp5g1q9vli_test.go:33:16: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075133
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := make([]int, n)\n    primes[0] = 2\n    primes[1] = 3\n\
    \    primes[2] = 5\n    primes[3] = 7\n    primes[4] = 11\n    primes[5] = 13\n\
    \    primes[6] = 17\n    primes[7] = 19\n\n    for i := 6; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if primes[j] == i {\n             \
    \   primes[j] = primes[j+1]\n            }\n        }\n    }\n    return primes\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [5] with length 5 [recovered]\n\tpanic: runtime error: index out of range [5]\
    \ with length 5\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(0x5)\n\t/tmp/tmp5c4avfbk_test.go:30\
    \ +0x145\ncommand-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp5c4avfbk_test.go:51\
    \ +0x46\ntesting.tRunner(0xc000192680, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075140
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := make([]int, n)\n    primes[0] = 2\n    for i := 1; i\
    \ < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j == 0 {\n  \
    \              break\n            }\n        }\n        if j > i {\n         \
    \   primes[i] = j\n        }\n    }\n    return primes\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4rb69qr2_test.go:32:12: undefined: j

    /tmp/tmp4rb69qr2_test.go:33:25: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075140
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp58822wh_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    prime := make([]int,\
    \ 0, n)\n    prime := append(prime, 2)\n    for i := 3; i <= n; i++ {\n      \
    \  for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6yhsocyj_test.go:28:11: no new variables on left side of :=

    /tmp/tmp6yhsocyj_test.go:35:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075140
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 243)\n   \
    \ prime := append(prime, 247)\n    prime := append(prime, 251)\n    prime := append(prime,\
    \ 257)\n    prime := append(prime, 263)\n    prime := append(prime, 269)\n   \
    \ prime := append(prime, 27\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp94_a3n9p_test.go:81:30: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075140
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n    \
    \    if i%2 == 0 {\n            continue\n        }\n        for j := 3; j < i;\
    \ j++ {\n            if i%j == 0 {\n                break\n            }\n   \
    \     }\n        if i == j {\n            prime = append(prime, i)\n        }\n\
    \    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx75r3zbj_test.go:34:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075140
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    result := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n   \
    \     if n%i == 0 {\n            result = append(result, i)\n        }\n    }\n\
    \    return result\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\n    --- FAIL: TestCount_Up_To/test_num__0\
    \ (0.00s)\n        tmpwjzy1r9l_test.go:55: expected '[%!s(int=2) %!s(int=3)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__1 (0.00s)\n        tmpwjzy1r9l_test.go:55:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[%!s(int=2) %!s(int=3)]'\n\
    \    --- FAIL: TestCount_Up_To/test_num__2 (0.00s)\n        tmpwjzy1r9l_test.go:55:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5)]', got '[]'\n    --- FAIL: TestCount_Up_To/test_num__3\
    \ (0.00s)\n        tmpwjzy1r9l_test.go:55: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7)]', got '[%!s(int=2) %!s(int=5)]'\n    --- FAIL: TestCount_Up_To/test_num__5\
    \ (0.00s)\n        tmpwjzy1r9l_test.go:55: expected '[%!s(int=2) %!s(int=3) %!s(int=5)\
    \ %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17) %!s(int=19)]', got '[%!s(int=2)\
    \ %!s(int=11)]'\n    --- FAIL: TestCount_Up_To/test_num__7 (0.00s)\n        tmpwjzy1r9l_test.go:55:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17)]', got '[%!s(int=2) %!s(int=3) %!s(int=6) %!s(int=9)]'\n    ---\
    \ FAIL: TestCount_Up_To/test_num__8 (0.00s)\n        tmpwjzy1r9l_test.go:55: expected\
    \ '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13) %!s(int=17)\
    \ %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41) %!s(int=43)]',\
    \ got '[]'\n    --- FAIL: TestCount_Up_To/test_num__9 (0.00s)\n        tmpwjzy1r9l_test.go:55:\
    \ expected '[%!s(int=2) %!s(int=3) %!s(int=5) %!s(int=7) %!s(int=11) %!s(int=13)\
    \ %!s(int=17) %!s(int=19) %!s(int=23) %!s(int=29) %!s(int=31) %!s(int=37) %!s(int=41)\
    \ %!s(int=43) %!s(int=47) %!s(int=53) %!s(int=59) %!s(int=61) %!s(int=67) %!s(int=71)\
    \ %!s(int=73) %!s(int=79) %!s(int=83) %!s(int=89) %!s(int=97)]', got '[]'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.002s\nFAIL\n"
  timestamp: 1660075140
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j\
    \ == 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqna96diq_test.go:25:11: no new variables on left side of :=

    /tmp/tmpqna96diq_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    primes := make([]int,\
    \ n+1)\n    primes[0] = 2\n    primes[1] = 3\n    for i := 2; i <= n; i++ {\n\
    \        for j := 2; j < i; j++ {\n            if i % j == 0 {\n             \
    \   break\n            }\n        }\n        if j > i {\n            primes[i+1]\
    \ = i\n        }\n    }\n    return primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp307ube2u_test.go:36:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    for i := 2; i < n; i++ {\n       \
    \ for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvkc_mkwb_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075140
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i <= n; i++ {\n   \
    \     for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i != j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpt4uxp1lc_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075140
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    for\
    \ i := 3; i <= n; i++ {\n        if isPrime(i) {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphm7rww17_test.go:25:11: no new variables on left side of :=

    /tmp/tmphm7rww17_test.go:27:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075140
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[len(prime)-1] < i {\n            prime = append(prime, i)\n    \
    \    }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n \
    \ candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 18 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000160000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp8zs5wqbe_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp8zs5wqbe_test.go:40\
    \ +0xd1d\ntesting.tRunner(0xc000103520, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075140
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j\
    \ == 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqna96diq_test.go:25:11: no new variables on left side of :=

    /tmp/tmpqna96diq_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[i / 2] {\n            continue\n        }\n        for j := i *\
    \ i; j < n; j += i {\n            if j > n {\n                break\n        \
    \    }\n            if prime[j] {\n                continue\n            }\n \
    \           prime = append(prime, j)\n        }\n    }\n    return prime\n}\n\n\
    func TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5g1q9vli_test.go:26:12: non-boolean condition in if statement

    /tmp/tmp5g1q9vli_test.go:33:16: non-boolean condition in if statement

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075133
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[len(prime)-1] < i {\n            prime = append(prime, i)\n    \
    \    }\n        for j := len(prime) - 1; j > 0; j-- {\n            if prime[j]\
    \ == i {\n                prime = append(prime, prime[j-1])\n                break\n\
    \            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 4 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpkb8xu_bc_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpkb8xu_bc_test.go:46\
    \ +0x1185\ntesting.tRunner(0xc0001a0000, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i\
    \ % j == 0 {\n                break\n            }\n        }\n        if j >\
    \ i {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4f0jf47d_test.go:25:11: no new variables on left side of :=

    /tmp/tmp4f0jf47d_test.go:32:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075131
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    primes := make([]int,\
    \ n+1)\n    primes[0] = 2\n    primes[1] = 3\n    for i := 2; i <= n; i++ {\n\
    \        for j := 2; j < i; j++ {\n            if i % j == 0 {\n             \
    \   break\n            }\n        }\n        if j > i {\n            primes[i+1]\
    \ = i\n        }\n    }\n    return primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp307ube2u_test.go:36:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i < n; i++ {\n        for j := 2; j < i; j++ {\n            if i%j\
    \ == 0 {\n                break\n            }\n        }\n        if i == j {\n\
    \            prime = append(prime, i)\n        }\n    }\n    return prime\n}\n\
    \nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqna96diq_test.go:25:11: no new variables on left side of :=

    /tmp/tmpqna96diq_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp58822wh_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp58822wh_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[i / 2] {\n            continue\n        }\n        for j := i *\
    \ i; j < n; j += i {\n            prime[j] = true\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpdrav4v6h_test.go:26:12: non-boolean condition in if statement

    /tmp/tmpdrav4v6h_test.go:30:24: cannot use true (untyped bool constant) as int
    value in assignment

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075130
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 0; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7155zs9d_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[prime[len(prime)-1]-1] == i {\n            prime = append(prime,\
    \ i)\n        } else {\n            prime = append(prime, i)\n            prime\
    \ = append(prime, prime[len(prime)-1]+1)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [-1] [recovered]\n\tpanic: runtime error: index out of range [-1]\n\ngoroutine\
    \ 20 [running]:\ntesting.tRunner.func1.2({0x513920, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmps4bzfsph_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmps4bzfsph_test.go:43\
    \ +0x1355\ntesting.tRunner(0xc0001036c0, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075141
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ for i := 3; i <= n; i++ {\n        for j := 2; j < i; j++ {\n            if\
    \ i%j == 0 {\n                break\n            }\n        }\n        if i ==\
    \ j {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpmj3btxru_test.go:25:11: no new variables on left side of :=

    /tmp/tmpmj3btxru_test.go:32:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075140
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    for j := 2; j < i; j++ {\n            if i%j == 0 {\n                break\n\
    \            }\n        }\n        if i == j {\n            prime = append(prime,\
    \ i)\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp58822wh_test.go:31:17: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ prime := append(prime, 3)\n    for i := 4; i <= n; i++ {\n        for j := 2;\
    \ j < i; j++ {\n            if i % j == 0 {\n                break\n         \
    \   }\n        }\n        if j == i {\n            prime = append(prime, i)\n\
    \        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n\
    \  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp64dexz0w_test.go:25:11: no new variables on left side of :=

    /tmp/tmp64dexz0w_test.go:26:11: no new variables on left side of :=

    /tmp/tmp64dexz0w_test.go:33:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 21)\n    prime := append(prime, 23)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 41)\n    prime := append(prime, 43)\n    prime := append(prime, 47)\n    prime\
    \ := append(prime, 53)\n    prime := append(prime, 59)\n    prime := append(prime,\
    \ 61)\n    prime := append(prime, 67)\n    prime := append(prime, 71)\n    prime\
    \ := append(prime, 73)\n    prime := append(prime, 79)\n    prime := append(prime,\
    \ 83)\n    prime := append(prime, 89)\n    prime := append(prime, 97)\n    prime\
    \ := append(prime, 101)\n    prime := append(prime, 103)\n    prime := append(prime,\
    \ 107)\n    prime := append(prime, 109)\n    prime := append(prime, 113)\n   \
    \ prime := append(prime, 127)\n    prime := append(prime, 131)\n    prime := append(prime,\
    \ 137)\n    prime := append(prime, 139)\n    prime := append(prime, 149)\n   \
    \ prime := append(prime, 151)\n    prime := append(prime, 157)\n    prime := append(prime,\
    \ 163)\n    prime := append(prime, 167)\n    prime := append(prime, 173)\n   \
    \ prime := append(prime, 179)\n    prime := append(prime, 181)\n    prime := append(prime,\
    \ 191)\n    prime := append(prime, 193)\n    prime := append(prime, 197)\n   \
    \ prime := append(prime, 199)\n    prime := append(prime, 211)\n    prime := append(prime,\
    \ 223)\n    prime := append(prime, 227)\n    prime := append(prime, 229)\n   \
    \ prime := append(prime, 233)\n    prime := append(prime, 239)\n    prime := append(prime,\
    \ 241)\n    prime := append(prime, 251)\n    prime := append(prime, 257)\n   \
    \ prime := append(prime, 263)\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph8mc7o7g_test.go:82:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075124
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    prime := make([]int,\
    \ 0, n)\n    prime := append(prime, 2)\n    prime := append(prime, 3)\n    prime\
    \ := append(prime, 5)\n    prime := append(prime, 7)\n    prime := append(prime,\
    \ 11)\n    prime := append(prime, 13)\n    prime := append(prime, 17)\n    prime\
    \ := append(prime, 19)\n    prime := append(prime, 23)\n    prime := append(prime,\
    \ 29)\n    prime := append(prime, 31)\n    prime := append(prime, 37)\n    prime\
    \ := append(prime, 43)\n    prime := append(prime, 49)\n    prime := append(prime,\
    \ 57)\n    prime := append(prime, 61)\n    prime := append(prime, 67)\n    prime\
    \ := append(prime, 73)\n    prime := append(prime, 79)\n    prime := append(prime,\
    \ 83)\n    prime := append(prime, 89)\n    prime := append(prime, 97)\n    prime\
    \ := append(prime, 101)\n    prime := append(prime, 103)\n    prime := append(prime,\
    \ 107)\n    prime := append(prime, 109)\n    prime := append(prime, 113)\n   \
    \ prime := append(prime, 127)\n    prime := append(prime, 131)\n    prime := append(prime,\
    \ 137)\n    prime := append(prime, 139)\n    prime := append(prime, 149)\n   \
    \ prime := append(prime, 151)\n    prime := append(prime, 157)\n    prime := append(prime,\
    \ 163)\n    prime := append(prime, 167)\n    prime := append(prime, 173)\n   \
    \ prime := append(prime, 179)\n    prime := append(prime, 181)\n    prime := append(prime,\
    \ 191)\n    prime := append(prime, 193)\n    prime := append(prime, 197)\n   \
    \ prime := append(prime, 199)\n    prime := append(prime, 211)\n    prime := append(prime,\
    \ 223)\n    prime := append(prime, 227)\n    prime := append(prime, 229)\n   \
    \ prime := append(prime, 233)\n    prime := append(prime, 239)\n    prime := append(prime,\
    \ 241)\n    prime := append(prime, 251)\n    prime := append(prime, 257)\n   \
    \ prime := append(prime, 263)\n    prime := append(prime, 269)\n    prime := append(prime,\
    \ 271)\n    prime := append(prime\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp163qzi9c_test.go:83:26: missing '','' before newline in argument list

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075140
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0)\n    prime := append(prime, 2)\n    prime\
    \ := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 21)\n    prime := append(prime, 23)\n    prime := append(prime, 29)\n    prime\
    \ := append(prime, 31)\n    prime := append(prime, 37)\n    prime := append(prime,\
    \ 41)\n    prime := append(prime, 43)\n    prime := append(prime, 47)\n    prime\
    \ := append(prime, 53)\n    prime := append(prime, 59)\n    prime := append(prime,\
    \ 61)\n    prime := append(prime, 67)\n    prime := append(prime, 71)\n    prime\
    \ := append(prime, 73)\n    prime := append(prime, 79)\n    prime := append(prime,\
    \ 83)\n    prime := append(prime, 89)\n    prime := append(prime, 97)\n    prime\
    \ := append(prime, 101)\n    prime := append(prime, 103)\n    prime := append(prime,\
    \ 107)\n    prime := append(prime, 109)\n    prime := append(prime, 113)\n   \
    \ prime := append(prime, 127)\n    prime := append(prime, 131)\n    prime := append(prime,\
    \ 137)\n    prime := append(prime, 139)\n    prime := append(prime, 149)\n   \
    \ prime := append(prime, 151)\n    prime := append(prime, 157)\n    prime := append(prime,\
    \ 163)\n    prime := append(prime, 167)\n    prime := append(prime, 173)\n   \
    \ prime := append(prime, 179)\n    prime := append(prime, 181)\n    prime := append(prime,\
    \ 191)\n    prime := append(prime, 193)\n    prime := append(prime, 197)\n   \
    \ prime := append(prime, 199)\n    prime := append(prime, 211)\n    prime := append(prime,\
    \ 223)\n    prime := append(prime, 227)\n    prime := append(prime, 229)\n   \
    \ prime := append(prime, 233)\n    prime := append(prime, 239)\n    prime := append(prime,\
    \ 241)\n    prime := append(prime, 251)\n    prime := append(prime, 257)\n   \
    \ prime := append(prime, 263)\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmph8mc7o7g_test.go:82:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075124
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    result := make([]int, 0, n)\n    i := 2\n    for i <= n {\n   \
    \     if isprime(i) {\n            result = append(result, i)\n            i +=\
    \ 2\n        }\n    }\n    return result\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpvpysmr0m_test.go:27:12: undefined: isprime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075140
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    prime := make([]int,\
    \ 0, n)\n    for i := 2; i < n; i++ {\n        if prime[prime[0]] == 0 {\n   \
    \         prime = append(prime, i)\n        }\n        for j := 0; j < i; j++\
    \ {\n            if prime[j] == 0 {\n                prime = append(prime, j)\n\
    \            }\n        }\n    }\n    return prime\n}\n\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmpyqoa0e5m_test.go:29\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmpyqoa0e5m_test.go:48\
    \ +0x11f4\ntesting.tRunner(0xc000120340, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.007s\nFAIL\n"
  timestamp: 1660075141
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ prime := append(prime, 3)\n    prime := append(prime, 5)\n    prime := append(prime,\
    \ 7)\n    prime := append(prime, 11)\n    prime := append(prime, 13)\n    prime\
    \ := append(prime, 17)\n    prime := append(prime, 19)\n    prime := append(prime,\
    \ 23)\n    prime := append(prime, 29)\n    prime := append(prime, 31)\n    prime\
    \ := append(prime, 37)\n    prime := append(prime, 43)\n    prime := append(prime,\
    \ 49)\n    prime := append(prime, 57)\n    prime := append(prime, 61)\n    prime\
    \ := append(prime, 67)\n    prime := append(prime, 73)\n    prime := append(prime,\
    \ 79)\n    prime := append(prime, 83)\n    prime := append(prime, 89)\n    prime\
    \ := append(prime, 97)\n    prime := append(prime, 101)\n    prime := append(prime,\
    \ 103)\n    prime := append(prime, 107)\n    prime := append(prime, 109)\n   \
    \ prime := append(prime, 113)\n    prime := append(prime, 127)\n    prime := append(prime,\
    \ 131)\n    prime := append(prime, 137)\n    prime := append(prime, 139)\n   \
    \ prime := append(prime, 149)\n    prime := append(prime, 151)\n    prime := append(prime,\
    \ 157)\n    prime := append(prime, 163)\n    prime := append(prime, 167)\n   \
    \ prime := append(prime, 173)\n    prime := append(prime, 179)\n    prime := append(prime,\
    \ 181)\n    prime := append(prime, 191)\n    prime := append(prime, 193)\n   \
    \ prime := append(prime, 197)\n    prime := append(prime, 199)\n    prime := append(prime,\
    \ 211)\n    prime := append(prime, 223)\n    prime := append(prime, 227)\n   \
    \ prime := append(prime, 229)\n    prime := append(prime, 233)\n    prime := append(prime,\
    \ 239)\n    prime := append(prime, 241)\n    prime := append(prime, 251)\n   \
    \ prime := append(prime, 257)\n    prime := append(prime, 263)\n    prime := append(prime,\
    \ 269)\n    prime := append(prime, 271)\n    prime := append(prime, 277)\n   \
    \ prime := append(prime, \nfunc TestCount_Up_To(t *testing.T) {\n  candidate :=\
    \ count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmps7g08dfo_test.go:82:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075131
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if prime[prime[0]-1] == 0 {\n            prime = append(prime, i)\n     \
    \   }\n        for j := 0; j < i; j++ {\n            if prime[j] == 0 {\n    \
    \            prime = append(prime, j)\n            }\n        }\n    }\n    return\
    \ prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [0] with length 0 [recovered]\n\tpanic: runtime error: index out of range [0]\
    \ with length 0\n\ngoroutine 20 [running]:\ntesting.tRunner.func1.2({0x513920,\
    \ 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x513920, 0xc000162000})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp7hhuqjqi_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp7hhuqjqi_test.go:45\
    \ +0x1254\ntesting.tRunner(0xc000103520, 0x529240)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075130
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    primes := make([]int, n+1)\n    primes[0] = 2\n    primes[1] =\
    \ 2\n    for i := 2; i <= n; i++ {\n        for j := 2; j < i; j++ {\n       \
    \     if i*j > n {\n                break\n            }\n            if primes[i*j]\
    \ == 0 {\n                primes[i*j] = i\n            }\n        }\n    }\n \
    \   return primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate\
    \ := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5), expected:\
    \ []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3, 5} },\n \
    \    { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual: candidate(10),\
    \ expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0), expected: []int{}\
    \ },\n     { actual: candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19}\
    \ },\n     { actual: candidate(1), expected: []int{} },\n     { actual: candidate(18),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual:\
    \ candidate(101), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37,\
    \ 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestCount_Up_To (0.00s)\npanic: runtime error: index out of range\
    \ [1] with length 1 [recovered]\n\tpanic: runtime error: index out of range [1]\
    \ with length 1\n\ngoroutine 6 [running]:\ntesting.tRunner.func1.2({0x512440,\
    \ 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1389\
    \ +0x24e\ntesting.tRunner.func1()\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1392\
    \ +0x39f\npanic({0x512440, 0xc000014360})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:838\
    \ +0x207\ncommand-line-arguments_test.count_up_to(...)\n\t/tmp/tmp2exz_ukd_test.go:26\n\
    command-line-arguments_test.TestCount_Up_To(0x0?)\n\t/tmp/tmp2exz_ukd_test.go:51\
    \ +0x173\ntesting.tRunner(0xc0001924e0, 0x527d40)\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1439\
    \ +0x102\ncreated by testing.(*T).Run\n\t/home/a.guha/.conda/envs/polyglot/go/src/testing/testing.go:1486\
    \ +0x35f\nFAIL\tcommand-line-arguments\t0.008s\nFAIL\n"
  timestamp: 1660075141
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    for i := 2; i < n; i++ {\n    \
    \    if isPrime(i) {\n            prime = append(prime, i)\n        }\n    }\n\
    \    return prime\n}\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n\
    \     { actual: candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7),\
    \ expected: []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2,\
    \ 3, 5, 7} },\n     { actual: candidate(0), expected: []int{} },\n     { actual:\
    \ candidate(22), expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual:\
    \ candidate(1), expected: []int{} },\n     { actual: candidate(18), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53,\
    \ 59, 61, 67, 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\
    \t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"\
    %v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected\
    \ '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp97qh3602_test.go:26:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075125
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    if n < 2 {\n        return []int{}\n    }\n    primes := make([]int,\
    \ n+1)\n    primes[0] = 2\n    primes[1] = 3\n    for i := 2; i <= n; i++ {\n\
    \        for j := 2; j < i; j++ {\n            if i % j == 0 {\n             \
    \   break\n            }\n        }\n        if j > i {\n            primes[i+1]\
    \ = i\n        }\n    }\n    return primes[:n]\n}\n\nfunc TestCount_Up_To(t *testing.T)\
    \ {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(5),\
    \ expected: []int{2, 3} },\n     { actual: candidate(6), expected: []int{2, 3,\
    \ 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n     { actual:\
    \ candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual: candidate(0),\
    \ expected: []int{} },\n     { actual: candidate(22), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected: []int{} },\n \
    \    { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13, 17} },\n   \
    \  { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29,\
    \ 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83,\
    \ 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp307ube2u_test.go:36:12: undefined: j

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075135
- exit_code: 1
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    result := make([]int, 0, n)\n    prime := make([]int, 0, n)\n \
    \   prime := append(prime, 2)\n    prime := append(prime, 3)\n    prime := append(prime,\
    \ 5)\n    prime := append(prime, 7)\n    prime := append(prime, 11)\n    prime\
    \ := append(prime, 13)\n    prime := append(prime, 17)\n    prime := append(prime,\
    \ 19)\n    for i := 5; i <= n; i++ {\n        if prime[i] == 0 {\n           \
    \ prime = append(prime, i)\n        }\n    }\n    for i := 5; i <= n; i++ {\n\
    \        if prime[i] == 0 {\n            prime = append(prime, i)\n        }\n\
    \    }\n    for i := 5; i <= n; i++ {\n        if prime[i] == 0 {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    for i := 5; i <= n; i++ {\n\
    \        if prime[i] == 0 {\n            prime = append(prime, i)\n        }\n\
    \    }\n    for i := 5; i <= n; i++ {\n        if prime[i] == 0 {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    for i := 5; i <= n; i++ {\n\
    \        if prime[i] == 0 {\n            prime = append(prime, i)\n        }\n\
    \    }\n    for i := 5; i <= n; i++ {\n        if prime[i] == 0 {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    for i := 5; i <= n; i++ {\n\
    \        if prime[i] == 0 {\n            prime = append(prime, i)\n        }\n\
    \    }\n    for i := 5; i <= n; i++ {\n        if prime[i] == 0 {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    for i := 5; i <= n; i++ {\n\
    \        if prime[i] == 0 {\n            prime = append(prime, i)\n        }\n\
    \    }\n    for i := 5; i <= n; i++ {\n        if prime[i] == 0 {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    for i := 5; i <= n; i++ {\n\
    \        if prime[i] == 0 {\n            prime = append(prime, i)\n        }\n\
    \    }\n    for i := 5; i <= n; i++ {\n        if prime[i] == 0 {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    for i := 5; i <= n; i++ {\n\
    \        if prime[i] == 0 {\n            prime = append(prime, i)\n        }\n\
    \    }\n    for i := 5; i <= n; i++ {\n        if prime[i] == 0 {\n          \
    \  prime = append(prime, i)\n        }\n    }\n    for i := 5; i <= n; i++ {\n\
    \        if prime[i] == 0 {\n            prime = append(prime, i)\nfunc TestCount_Up_To(t\
    \ *testing.T) {\n  candidate := count_up_to\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate(5), expected: []int{2, 3} },\n     { actual: candidate(6), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(7), expected: []int{2, 3, 5} },\n\
    \     { actual: candidate(10), expected: []int{2, 3, 5, 7} },\n     { actual:\
    \ candidate(0), expected: []int{} },\n     { actual: candidate(22), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1), expected:\
    \ []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5, 7, 11, 13,\
    \ 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7, 11, 13, 17,\
    \ 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected: []int{2,\
    \ 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73,\
    \ 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprjznvggv_test.go:112:6: expected ''('', found TestCount_Up_To

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075140
- exit_code: 2
  program: "package count_up_to_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Implement a function that takes an non-negative integer and returns a list\
    \ of the first n\n// integers that are prime numbers and less than n.\n// for\
    \ example:\n// >>> count_up_to(5)\n// []int{2, 3}\n// >>> count_up_to(11)\n//\
    \ []int{2, 3, 5, 7}\n// >>> count_up_to(0)\n// PATCH list\n// >>> count_up_to(20)\n\
    // []int{2, 3, 5, 7, 11, 13, 17, 19}\n// >>> count_up_to(1)\n// PATCH list\n//\
    \ >>> count_up_to(18)\n// []int{2, 3, 5, 7, 11, 13, 17}\nfunc count_up_to(n int)\
    \ []int {\n    prime := make([]int, 0, n)\n    prime := append(prime, 2)\n   \
    \ prime := append(prime, 3)\n    for i := 4; i <= n; i++ {\n        if isPrime(i)\
    \ {\n            prime = append(prime, i)\n        }\n    }\n    return prime\n\
    }\n\nfunc TestCount_Up_To(t *testing.T) {\n  candidate := count_up_to\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate(5), expected: []int{2, 3} },\n     { actual:\
    \ candidate(6), expected: []int{2, 3, 5} },\n     { actual: candidate(7), expected:\
    \ []int{2, 3, 5} },\n     { actual: candidate(10), expected: []int{2, 3, 5, 7}\
    \ },\n     { actual: candidate(0), expected: []int{} },\n     { actual: candidate(22),\
    \ expected: []int{2, 3, 5, 7, 11, 13, 17, 19} },\n     { actual: candidate(1),\
    \ expected: []int{} },\n     { actual: candidate(18), expected: []int{2, 3, 5,\
    \ 7, 11, 13, 17} },\n     { actual: candidate(47), expected: []int{2, 3, 5, 7,\
    \ 11, 13, 17, 19, 23, 29, 31, 37, 41, 43} },\n     { actual: candidate(101), expected:\
    \ []int{2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67,\
    \ 71, 73, 79, 83, 89, 97} },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"\
    test num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_d4nlumi_test.go:25:11: no new variables on left side of :=

    /tmp/tmp_d4nlumi_test.go:26:11: no new variables on left side of :=

    /tmp/tmp_d4nlumi_test.go:28:12: undefined: isPrime

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075140
