language: go_test.go
name: HumanEval_156_int_to_mini_roman
results:
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n    }\n    roman_number := \"\"\n    for\
    \ _, roman_numeral := range romans {\n        if number >= roman_numeral {\n \
    \           roman_number = roman_numeral\n            break\n        }\n    }\n\
    \    return roman_number\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqvft4t96_test.go:30:22: invalid operation: number >= roman_numeral (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n    }\n    roman_number := romans[number]\n\
    \    return strings.ToLower(roman_number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp6nkux1ld_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 5:\n        roman_number = \"v\"\n   \
    \ case 10:\n        roman_number = \"i\"\n    case 20:\n        roman_number =\
    \ \"x\"\n    case 50:\n        roman_number = \"l\"\n    case 100:\n        roman_number\
    \ = \"c\"\n    case 200:\n        roman_number = \"d\"\n    case 500:\n      \
    \  roman_number = \"l\"\n    case 1000:\n        roman_number = \"m\"\n    case\
    \ 2000:\n        roman_number = \"c\"\n    case 5000:\n        roman_number =\
    \ \"l\"\n    case 10000:\n        roman_number = \"c\"\n    case 20000:\n    \
    \    roman_number = \"d\"\n    case 50000:\n        roman_number = \"l\"\n   \
    \ case 100000:\n        roman_number = \"m\"\n    case 200000:\n        roman_number\
    \ = \"c\"\n    case 500000:\n        roman_number = \"l\"\n    case 1000000:\n\
    \        roman_number = \"m\"\n    case 2000000:\n        roman_number = \"d\"\
    \n    case 5000000:\n        roman_number = \"l\"\n    case 10000000:\n      \
    \  roman_number = \"c\"\n    case 20000000:\n        roman_number = \"d\"\n  \
    \  case 50000000:\n        roman_number = \"l\"\n    case 100000000:\n       \
    \ roman_number = \"m\"\n    case 200000000:\n        roman_number = \"d\"\n  \
    \  case 500000000:\n        roman_number = \"l\"\n    case 1000000000:\n     \
    \   roman_number = \"c\"\n    case 2000000000:\n        roman_number = \"d\"\n\
    \    case 5000000000:\n        roman_number = \"l\"\n    case 10000000000:\n \
    \       roman_number = \"m\"\n    case 20000000000:\n        roman_number = \"\
    d\"\n    case 50000000000:\n        roman_number = \"l\"\n    case 100000000000:\n\
    \        roman_number = \"c\"\n    case 200000000000:\n        roman_number =\
    \ \"d\"\n    case 500000000000:\n        roman_number = \"l\"\n    case 1000000000000:\n\
    \        roman_number = \"m\"\n    case 2000000000000:\n        roman_number =\
    \ \"d\"\n    case 5000000000000:\n        roman_number = \"l\"\n    case 10000000000000:\n\
    \        roman_number = \"c\"\n    case 20000000000000:\n        roman_number\
    \ = \"d\"\n    case 50000000000000:\n        roman_number = \"l\"\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpt_rwryeg_test.go:104:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075537
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n  \
    \  case 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number\
    \ = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiuqg9dqn_test.go:101:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"\
    XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\"\
    , \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LII\"\
    , \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LX\", \"LXI\", \"\
    LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\"\
    , \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"\
    LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"\
    XC\", \"CC\", \"CI\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"\
    CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"\
    CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\"\
    , \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXX\"\
    , \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\"\
    , \"CXXXVIII\", \"CXXXIX\", \"CCC\", \"CCCI\", \"CCCII\", \"CCCIII\", \"CCCIV\"\
    , \"CCCV\", \"CCCVI\", \"CCCVII\", \"CCCVIII\", \"CCCIX\", \"CCCX\", \"CCCXI\"\
    , \"CCCXII\", \"CCCXIII\", \"CCCXIV\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpssq6v_mk_test.go:20:1136: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n  \
    \  case 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number\
    \ = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiuqg9dqn_test.go:101:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n\
    \        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\"\
    , \"CXXI\",\n        \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"\
    CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"\
    CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\"\
    , \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CIV\", \"CV\"\
    ,\n        \"CVI\", \"CVII\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n\
    \  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgzlh2fk6_test.go:34:24: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiiii\",\n        500: \"viiiiix\",\n        1000: \"viiiiiix\",\n    }\n\
    \n    roman_numeral := \"\"\n    for roman_numeral, number := range roman_numerals\
    \ {\n        if number <= number {\n            break\n        }\n    }\n\n  \
    \  if roman_numeral == \"\" {\n        fmt.Println(\"ERROR: No roman numeral for\
    \ number \", number)\n    }\n\n    return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsrj3pax3_test.go:30:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    roman_numerals := map[int]string{\n        1: \"\
    i\",\n        5: \"vi\",\n        10: \"viii\",\n        50: \"viivi\",\n    \
    \    100: \"viiii\",\n        500: \"viiivi\",\n        1000: \"viiii\",\n   \
    \ }\n    mini_roman_numerals := map[string]int{\n        \"i\": 1,\n        \"\
    vi\": 5,\n        \"vii\": 10,\n        \"viii\": 50,\n        \"viivi\": 100,\n\
    \        \"viiii\": 500,\n        \"viiivi\": 1000,\n    }\n    mini_roman_numerals_string\
    \ := map[string]string{\n        \"i\": \"i\",\n        \"vi\": \"vi\",\n    \
    \    \"vii\": \"vii\",\n        \"viii\": \"viii\",\n        \"viivi\": \"viivi\"\
    ,\n        \"viiii\": \"viiii\",\n        \"viiivi\": \"viiivi\",\n        \"\
    viiii\": \"viiii\",\n    }\n    mini_roman_numerals_string := map[string]string{\n\
    \        \"i\": \"i\",\n        \"vi\": \"vi\",\n        \"vii\": \"vii\",\n \
    \       \"viii\": \"viii\",\n        \"viivi\": \"viivi\",\n        \"viiii\"\
    : \"viiii\",\n        \"viiivi\": \"viiivi\",\n        \"viiii\": \"viiii\",\n\
    \    }\n    mini_roman_numerals_string := map[string]string{\n        \"i\": \"\
    i\",\n        \"vi\": \"vi\",\n        \"vii\": \"vii\",\n        \"viii\": \"\
    viii\",\n        \"viivi\": \"viivi\",\n        \"viiii\": \"viiii\",\n      \
    \  \"viiivi\": \"viiivi\",\n        \"viiii\": \"viiii\",\n    }\n    mini_roman_numerals_string\
    \ := map[string]string{\n        \"i\": \"i\",\n        \"vi\": \"vi\",\n    \
    \    \"vii\": \"vii\",\n        \"viii\": \"viii\",\n        \"viivi\": \"viivi\"\
    ,\n        \"viiii\": \"viiii\",\n        \"viiivi\": \"viiivi\",\n        \"\
    viiii\": \"viiii\",\n    }\n    mini_roman_numerals_string := map[string]string{\n\
    \        \"i\": \"i\",\n        \"vi\": \"vi\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7sm707ik_test.go:82:15: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viv\",\n        50000: \"viiv\",\n        100000: \"viv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        10000000: \"viv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\",\n     \
    \   5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n  \
    \      50000000000000000: \"viiv\",\n        10000000000000000000: \"viv\",\n\
    \        5000000000000000000: \"viiv\",\n        100000000000000000000: \"viv\"\
    ,\n        50000000000000000000: \"viiv\",\n        1000000000000000000000: \"\
    viv\",\n        500000000000000000000: \"viiv\",\n        10000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000: \"viiv\",\n        100000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000: \"viiv\",\n        1000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000: \"viiv\",\n        10000000000000000000000000:\
    \ \"viv\",\n    }\n\n    romanNumeral := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpax0kaofw_test.go:54:9: cannot use 10000000000000000000 (untyped int constant)
    as int value in map literal (overflows)

    /tmp/tmpax0kaofw_test.go:56:9: cannot use 100000000000000000000 (untyped int constant)
    as int value in map literal (overflows)

    /tmp/tmpax0kaofw_test.go:57:9: cannot use 50000000000000000000 (untyped int constant)
    as int value in map literal (overflows)

    /tmp/tmpax0kaofw_test.go:58:9: cannot use 1000000000000000000000 (untyped int
    constant) as int value in map literal (overflows)

    /tmp/tmpax0kaofw_test.go:59:9: cannot use 500000000000000000000 (untyped int constant)
    as int value in map literal (overflows)

    /tmp/tmpax0kaofw_test.go:60:9: cannot use 10000000000000000000000 (untyped int
    constant) as int value in map literal (overflows)

    /tmp/tmpax0kaofw_test.go:61:9: cannot use 5000000000000000000000 (untyped int
    constant) as int value in map literal (overflows)

    /tmp/tmpax0kaofw_test.go:62:9: cannot use 100000000000000000000000 (untyped int
    constant) as int value in map literal (overflows)

    /tmp/tmpax0kaofw_test.go:63:9: cannot use 50000000000000000000000 (untyped int
    constant) as int value in map literal (overflows)

    /tmp/tmpax0kaofw_test.go:64:9: cannot use 1000000000000000000000000 (untyped int
    constant) as int value in map literal (overflows)

    /tmp/tmpax0kaofw_test.go:64:9: too many errors

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n\
    \        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    romanNumerals[number]\
    \ = \"\"\n    return romanNumerals[number]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpgoph5n8j_test.go:59: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpgoph5n8j_test.go:59: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpgoph5n8j_test.go:59: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpgoph5n8j_test.go:59: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpgoph5n8j_test.go:59:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpgoph5n8j_test.go:59: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpgoph5n8j_test.go:59: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpgoph5n8j_test.go:59: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpgoph5n8j_test.go:59: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpgoph5n8j_test.go:59: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpgoph5n8j_test.go:59:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpgoph5n8j_test.go:59: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpgoph5n8j_test.go:59:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpgoph5n8j_test.go:59: expected 'm', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075539
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    roman_numerals := []string{\"M\", \"CM\", \"D\",\
    \ \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n\
    \    roman_numeral_string := \"\"\n    for _, roman_numeral := range roman_numerals\
    \ {\n        if number >= roman_numeral*100 {\n            number -= roman_numeral*100\n\
    \            roman_numeral_string += roman_numeral\n        }\n    }\n    return\
    \ roman_numeral_string\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpi7vgbbfr_test.go:25:22: invalid operation: roman_numeral * 100 (mismatched
    types string and untyped int)

    /tmp/tmpi7vgbbfr_test.go:26:23: invalid operation: roman_numeral * 100 (mismatched
    types string and untyped int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiii\",\n        500: \"viiii\",\n        1000: \"viiii\",\n        5000:\
    \ \"viiii\",\n        10000: \"viiii\",\n        50000: \"viiii\",\n        100000:\
    \ \"viiii\",\n        500000: \"viiii\",\n        1000000: \"viiii\",\n      \
    \  5000000: \"viiii\",\n        10000000: \"viiii\",\n        50000000: \"viiii\"\
    ,\n        100000000: \"viiii\",\n        500000000: \"viiii\",\n        1000000000:\
    \ \"viiii\",\n        5000000000: \"viiii\",\n        10000000000: \"viiii\",\n\
    \        50000000000: \"viiii\",\n        100000000000: \"viiii\",\n        500000000000:\
    \ \"viiii\",\n        1000000000000: \"viiii\",\n        5000000000000: \"viiii\"\
    ,\n        10000000000000: \"viiii\",\n        50000000000000: \"viiii\",\n  \
    \      100000000000000: \"viiii\",\n        500000000000000: \"viiii\",\n    \
    \    1000000000000000: \"viiii\",\n        5000000000000000: \"viiii\",\n    \
    \    1000000000000000000: \"viiii\",\n        50000000000000000: \"viiii\",\n\
    \        10000000000000000000: \"viiii\",\n        5000000000000000000: \"viiii\"\
    ,\n        100000000000000000000: \"viiii\",\n        50000000000000000000: \"\
    viiii\",\n        1000000000000000000000: \"viiii\",\n        500000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000: \"viiii\",\n        5000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000: \"viiii\",\n        50000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000: \"viiii\",\n        500000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000: \"viiii\",\n        5000000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000000: \"viiii\",\n        50000000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000000: \"viiii\",\n        500000000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000000: \"viiii\",\n        5000000000000000000000000000\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyo631ndu_test.go:73:37: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiiii\",\n        500: \"viiii\",\n        1000: \"viii\",\n        5000:\
    \ \"vii\",\n        10000: \"vi\",\n        50000: \"v\",\n        100000: \"\
    iv\",\n        500000: \"iv\",\n        1000000: \"iv\",\n        5000000: \"\
    iv\",\n        10000000: \"iv\",\n        50000000: \"iv\",\n        100000000:\
    \ \"iv\",\n        500000000: \"iv\",\n        1000000000: \"iv\",\n        5000000000:\
    \ \"iv\",\n        10000000000: \"iv\",\n        50000000000: \"iv\",\n      \
    \  100000000000: \"iv\",\n        500000000000: \"iv\",\n        1000000000000:\
    \ \"iv\",\n        5000000000000: \"iv\",\n        10000000000000: \"iv\",\n \
    \       50000000000000: \"iv\",\n        100000000000000: \"iv\",\n        500000000000000:\
    \ \"iv\",\n        1000000000000000: \"iv\",\n        5000000000000000: \"iv\"\
    ,\n        1000000000000000000: \"iv\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj1u45ofy_test.go:55:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"\
    XIII\", \"XIV\",\n        \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\"\
    , \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\",\n        \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"\
    XXXV\",\n        \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\"\
    , \"LI\", \"LII\", \"LIII\", \"LIIII\", \"LIIV\",\n        \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"\
    LXV\",\n        \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\",\
    \ \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\",\n        \"LXXVI\", \"LXXVII\",\
    \ \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\"\
    ,\n        \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\"\
    , \"C\", \"CI\", \"CII\", \"CIII\", \"CIIII\",\n        \"CIV\", \"CV\", \"CVI\"\
    , \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\"\
    , \"CXV\",\n        \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\",\n        \"CXXVI\", \"CXXVII\",\
    \ \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    ,\n        \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CC\"\
    , \"CCI\", \"CCII\", \"CCIII\", \"CCIV\",\n        \"CCV\", \"CCVI\", \"CCVII\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmphb3u103b_test.go:32:24: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n    }\n    roman, ok := romans[number]\n\
    \    if !ok {\n        fmt.Println(\"Invalid input\")\n    }\n    return roman\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmphbcf1ngi_test.go:61: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmphbcf1ngi_test.go:61: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmphbcf1ngi_test.go:61: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmphbcf1ngi_test.go:61: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmphbcf1ngi_test.go:61:\
    \ expected 'd', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmphbcf1ngi_test.go:61: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmphbcf1ngi_test.go:61: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmphbcf1ngi_test.go:61: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmphbcf1ngi_test.go:61: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmphbcf1ngi_test.go:61: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmphbcf1ngi_test.go:61:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmphbcf1ngi_test.go:61: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmphbcf1ngi_test.go:61: expected 'm', got 'd'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075539
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiii\",\n        500: \"viiii\",\n        1000: \"viiii\",\n        5000:\
    \ \"viiii\",\n        10000: \"viiii\",\n        50000: \"viiii\",\n        100000:\
    \ \"viiii\",\n        500000: \"viiii\",\n        1000000: \"viiii\",\n      \
    \  5000000: \"viiii\",\n        10000000: \"viiii\",\n        50000000: \"viiii\"\
    ,\n        100000000: \"viiii\",\n        500000000: \"viiii\",\n        1000000000:\
    \ \"viiii\",\n        5000000000: \"viiii\",\n        10000000000: \"viiii\",\n\
    \        50000000000: \"viiii\",\n        100000000000: \"viiii\",\n        500000000000:\
    \ \"viiii\",\n        1000000000000: \"viiii\",\n        5000000000000: \"viiii\"\
    ,\n        10000000000000: \"viiii\",\n        50000000000000: \"viiii\",\n  \
    \      100000000000000: \"viiii\",\n        500000000000000: \"viiii\",\n    \
    \    1000000000000000: \"viiii\",\n        5000000000000000: \"viiii\",\n    \
    \    1000000000000000000: \"viiii\",\n        50000000000000000: \"viiii\",\n\
    \        10000000000000000000: \"viiii\",\n        5000000000000000000: \"viiii\"\
    ,\n        100000000000000000000: \"viiii\",\n        50000000000000000000: \"\
    viiii\",\n        1000000000000000000000: \"viiii\",\n        500000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000: \"viiii\",\n        5000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000: \"viiii\",\n        50000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000: \"viiii\",\n        500000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000: \"viiii\",\n        5000000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000000: \"viiii\",\n        50000000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000000: \"viiii\",\n        500000000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000000: \"viiii\",\n        5000000000000000000000000000\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpquhcjrxs_test.go:73:37: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n\
    \        500: \"c\",\n        1000: \"d\",\n    }\n    romanNumerals[number] =\
    \ \"\"\n    romanNumerals[number / 1000] = \"c\"\n    romanNumerals[number / 100]\
    \ = \"x\"\n    romanNumerals[number / 10] = \"l\"\n    romanNumerals[number %\
    \ 10] = \"i\"\n    return romanNumerals[number]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpj3rkwqg1_test.go:62: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpj3rkwqg1_test.go:62: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpj3rkwqg1_test.go:62: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpj3rkwqg1_test.go:62: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpj3rkwqg1_test.go:62:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmpj3rkwqg1_test.go:62: expected 'iv', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmpj3rkwqg1_test.go:62: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpj3rkwqg1_test.go:62: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmpj3rkwqg1_test.go:62: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpj3rkwqg1_test.go:62: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpj3rkwqg1_test.go:62:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmpj3rkwqg1_test.go:62: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpj3rkwqg1_test.go:62: expected 'm', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075539
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiii\",\n        500: \"viiii\",\n        1000: \"viiii\",\n        5000:\
    \ \"viiii\",\n        10000: \"viiii\",\n        50000: \"viiii\",\n        100000:\
    \ \"viiii\",\n        500000: \"viiii\",\n        1000000: \"viiii\",\n      \
    \  5000000: \"viiii\",\n        10000000: \"viiii\",\n        50000000: \"viiii\"\
    ,\n        100000000: \"viiii\",\n        500000000: \"viiii\",\n        1000000000:\
    \ \"viiii\",\n        5000000000: \"viiii\",\n        10000000000: \"viiii\",\n\
    \        50000000000: \"viiii\",\n        100000000000: \"viiii\",\n        500000000000:\
    \ \"viiii\",\n        1000000000000: \"viiii\",\n        5000000000000: \"viiii\"\
    ,\n        10000000000000: \"viiii\",\n        50000000000000: \"viiii\",\n  \
    \      100000000000000: \"viiii\",\n        500000000000000: \"viiii\",\n    \
    \    1000000000000000: \"viiii\",\n        5000000000000000: \"viiii\",\n    \
    \    1000000000000000000: \"viiii\",\n    }\n    romanNumerals[number] = \"i\"\
    \n    return romanNumerals[number]\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpklwwwyws_test.go:84: expected 'xix', got 'i'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpklwwwyws_test.go:84: expected\
    \ 'clii', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n \
    \       tmpklwwwyws_test.go:84: expected 'ccli', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpklwwwyws_test.go:84: expected 'cdxxvi', got 'i'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpklwwwyws_test.go:84:\
    \ expected 'd', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmpklwwwyws_test.go:84: expected 'iv', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmpklwwwyws_test.go:84: expected 'xliii', got 'i'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpklwwwyws_test.go:84:\
    \ expected 'xc', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n\
    \        tmpklwwwyws_test.go:84: expected 'xciv', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpklwwwyws_test.go:84: expected 'dxxxii', got 'i'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpklwwwyws_test.go:84:\
    \ expected 'cm', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmpklwwwyws_test.go:84: expected 'cmxciv', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpklwwwyws_test.go:84: expected 'm', got 'i'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075539
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n\n    romanNumeral := \"\"\n\
    \    for romanNumeral, number := range romanNumerals {\n        if number >= number\
    \ {\n            break\n        }\n    }\n\n    if romanNumeral == \"\" {\n  \
    \      fmt.Println(\"Error: no roman numeral for number \", number)\n    }\n\n\
    \    return romanNumerals[number]\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp4vl_zxmt_test.go:30:9: romanNumeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"viv\",\n\
    \        500: \"viv\",\n        1000: \"vi\",\n    }\n    roman, ok := romans[number]\n\
    \    if !ok {\n        fmt.Println(\"Invalid input\")\n    }\n    return roman\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpt65idels_test.go:61: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpt65idels_test.go:61: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpt65idels_test.go:61: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpt65idels_test.go:61: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpt65idels_test.go:61:\
    \ expected 'd', got 'viv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmpt65idels_test.go:61: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmpt65idels_test.go:61: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpt65idels_test.go:61: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmpt65idels_test.go:61: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpt65idels_test.go:61: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpt65idels_test.go:61:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmpt65idels_test.go:61: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpt65idels_test.go:61: expected 'm', got 'vi'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075539
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"vii\",\n        100: \"\
    vi\",\n        500: \"vii\",\n        1000: \"vi\",\n        5000: \"vii\",\n\
    \        10000: \"vii\",\n        50000: \"viii\",\n        100000: \"viii\",\n\
    \        500000: \"viii\",\n        1000000: \"viii\",\n        5000000: \"viii\"\
    ,\n        10000000: \"viii\",\n        50000000: \"viii\",\n        100000000:\
    \ \"viii\",\n        500000000: \"viii\",\n        1000000000: \"viii\",\n   \
    \     5000000000: \"viii\",\n        10000000000: \"viii\",\n        50000000000:\
    \ \"viii\",\n        100000000000: \"viii\",\n        500000000000: \"viii\",\n\
    \        1000000000000: \"viii\",\n        5000000000000: \"viii\",\n        10000000000000:\
    \ \"viii\",\n        50000000000000: \"viii\",\n        100000000000000: \"viii\"\
    ,\n        500000000000000: \"viii\",\n        1000000000000000: \"viii\",\n \
    \       5000000000000000: \"viii\",\n        1000000000000000000: \"viii\",\n\
    \    }\n    romanNumeral := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptekplww8_test.go:55:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viiii\",\n        5000: \"viiiii\"\
    ,\n    }\n    roman_numeral := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_hv7vlq0_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n\
    \        500: \"c\",\n        1000: \"d\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp90kp2m64_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := []string{\"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\",\
    \ \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"\
    XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\"\
    , \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"\
    XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LIII\", \"\
    LIIII\", \"LIIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\"\
    , \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"\
    LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\"\
    , \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"\
    XC\", \"C\", \"CI\", \"CII\", \"CIII\", \"CIIII\", \"CIV\", \"CV\", \"CVI\", \"\
    CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"\
    CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\",\
    \ \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\"\
    , \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\",\
    \ \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\"\
    , \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp328x5kae_test.go:19:1184: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075539
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viv\",\n        50000: \"viiv\",\n        100000: \"viv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        10000000: \"viv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\",\n     \
    \   5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n  \
    \  }\n\n    roman_numeral_string := \"\"\n    for roman_numeral, numeral_string\
    \ := range roman_numerals {\n        if number >= roman_numeral {\n          \
    \  roman_numeral_string = numeral_string\n            break\n        }\n    }\n\
    \n    return strings.ToLower(roman_numeral_string)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_vcb03ht_test.go:63:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viiii\",\n    }\n    romanNumerals[number]\
    \ = \"\"\n    romanNumerals[number/1000] = \"v\"\n    romanNumerals[number/500]\
    \ = \"vi\"\n    romanNumerals[number/100] = \"vii\"\n    romanNumerals[number/50]\
    \ = \"viii\"\n    romanNumerals[number/5] = \"viv\"\n    romanNumerals[number/4]\
    \ = \"vii\"\n    romanNumerals[number/3] = \"vi\"\n    romanNumerals[number/2]\
    \ = \"vi\"\n    romanNumerals[number/1] = \"i\"\n    return romanNumerals[number]\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp7fbnlaqa_test.go:67: expected 'xix', got 'i'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp7fbnlaqa_test.go:67: expected\
    \ 'clii', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n \
    \       tmp7fbnlaqa_test.go:67: expected 'ccli', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp7fbnlaqa_test.go:67: expected 'cdxxvi', got 'i'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp7fbnlaqa_test.go:67:\
    \ expected 'd', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmp7fbnlaqa_test.go:67: expected 'iv', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmp7fbnlaqa_test.go:67: expected 'xliii', got 'i'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp7fbnlaqa_test.go:67:\
    \ expected 'xc', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n\
    \        tmp7fbnlaqa_test.go:67: expected 'xciv', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmp7fbnlaqa_test.go:67: expected 'dxxxii', got 'i'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp7fbnlaqa_test.go:67:\
    \ expected 'cm', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmp7fbnlaqa_test.go:67: expected 'cmxciv', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp7fbnlaqa_test.go:67: expected 'm', got 'i'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075540
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n        10000: \"\
    c\",\n        50000: \"c\",\n        100000: \"c\",\n        500000: \"c\",\n\
    \        1000000: \"c\",\n        5000000: \"c\",\n        10000000: \"c\",\n\
    \        50000000: \"c\",\n        100000000: \"c\",\n        500000000: \"c\"\
    ,\n        1000000000: \"c\",\n        5000000000: \"c\",\n        10000000000:\
    \ \"c\",\n        50000000000: \"c\",\n        100000000000: \"c\",\n        500000000000:\
    \ \"c\",\n        1000000000000: \"c\",\n        5000000000000: \"c\",\n     \
    \   10000000000000: \"c\",\n        50000000000000: \"c\",\n        100000000000000:\
    \ \"c\",\n        500000000000000: \"c\",\n        1000000000000000: \"c\",\n\
    \        5000000000000000: \"c\",\n        1000000000000000000: \"c\",\n    }\n\
    \    roman_number := \"\"\n    for roman_number, number := range romans {\n  \
    \      if number <= number {\n            break\n        }\n    }\n    return\
    \ roman_number\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate :=\
    \ int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp711caa0f_test.go:55:9: roman_number declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vii\",\n\
    \        10000: \"viii\",\n        100000: \"viv\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwlijy91d_test.go:32:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := \"\"\n\
    \    for romanNumeral, number := range romanNumerals {\n        if number <= number\
    \ {\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s%v\", romanNumeral,\
    \ number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp20u9xe99_test.go:29:9: romanNumeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n    }\n\n    roman_numeral\
    \ := \"\"\n    for roman_numeral, number := range roman_numerals {\n        if\
    \ number <= number {\n            break\n        }\n    }\n\n    if roman_numeral\
    \ == \"\" {\n        fmt.Println(\"Roman numeral not found\")\n    }\n\n    return\
    \ roman_numerals[number]\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpym06tu1s_test.go:30:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 5:\n        roman_number = \"v\"\n   \
    \ case 10:\n        roman_number = \"i\"\n    case 20:\n        roman_number =\
    \ \"n\"\n    case 50:\n        roman_number = \"c\"\n    case 100:\n        roman_number\
    \ = \"d\"\n    case 200:\n        roman_number = \"h\"\n    case 400:\n      \
    \  roman_number = \"x\"\n    case 1000:\n        roman_number = \"m\"\n    }\n\
    \    return roman_number\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpdcgyly84_test.go:69: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpdcgyly84_test.go:69: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpdcgyly84_test.go:69: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpdcgyly84_test.go:69: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpdcgyly84_test.go:69:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpdcgyly84_test.go:69: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpdcgyly84_test.go:69: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpdcgyly84_test.go:69: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpdcgyly84_test.go:69: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpdcgyly84_test.go:69: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpdcgyly84_test.go:69:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpdcgyly84_test.go:69: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpdcgyly84_test.go:69:\
    \ expected 'cmxciv', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075540
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"viv\",\n\
    \        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\",\n   \
    \     10000: \"viv\",\n        50000: \"viiv\",\n        100000: \"viv\",\n  \
    \      500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        10000000: \"viv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\",\n     \
    \   5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n  \
    \  }\n\n    roman, ok := romans[number]\n    if !ok {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpdxzafp9f_test.go:88: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpdxzafp9f_test.go:88: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpdxzafp9f_test.go:88: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpdxzafp9f_test.go:88: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpdxzafp9f_test.go:88:\
    \ expected 'd', got 'viiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmpdxzafp9f_test.go:88: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmpdxzafp9f_test.go:88: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpdxzafp9f_test.go:88: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmpdxzafp9f_test.go:88: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpdxzafp9f_test.go:88: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpdxzafp9f_test.go:88:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmpdxzafp9f_test.go:88: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpdxzafp9f_test.go:88: expected 'm', got 'viv'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075541
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    roman_number += int_to_roman(number)\n\
    \    return strings.ToLower(roman_number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp8a_dstuq_test.go:20:21: undefined: int_to_roman

    /tmp/tmp8a_dstuq_test.go:21:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := \"\"\n\
    \    for roman_numeral, number := range roman_numerals {\n        if number >=\
    \ number {\n            break\n        }\n    }\n    if roman_numeral == \"\"\
    \ {\n        fmt.Println(\"Error: No roman numeral for number \", number)\n  \
    \  }\n    return roman_numerals[number]\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpn3gkqf6q_test.go:29:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vii\",\n\
    \        10000: \"viii\",\n        100000: \"viv\",\n    }\n\n    roman_number\
    \ := number / 1000\n    roman_numeral := roman_numerals[roman_number]\n\n    number\
    \ -= roman_number * 1000\n\n    roman_numeral += roman_numerals[number]\n\n  \
    \  return roman_numeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpvpa9cao9_test.go:68: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpvpa9cao9_test.go:68: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpvpa9cao9_test.go:68: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpvpa9cao9_test.go:68: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpvpa9cao9_test.go:68:\
    \ expected 'd', got 'viv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmpvpa9cao9_test.go:68: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmpvpa9cao9_test.go:68: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpvpa9cao9_test.go:68: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmpvpa9cao9_test.go:68: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpvpa9cao9_test.go:68: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpvpa9cao9_test.go:68:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmpvpa9cao9_test.go:68: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpvpa9cao9_test.go:68: expected 'm', got 'i'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075541
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiiii\",\n        500: \"viiiiix\",\n        1000: \"viiiiiix\",\n      \
    \  5000: \"viiiiiix\",\n        10000: \"viiiiiix\",\n        50000: \"viiiiiix\"\
    ,\n        100000: \"viiiiiix\",\n        500000: \"viiiiiix\",\n        1000000:\
    \ \"viiiiiix\",\n        5000000: \"viiiiiix\",\n        10000000: \"viiiiiix\"\
    ,\n        50000000: \"viiiiiix\",\n        100000000: \"viiiiiix\",\n       \
    \ 500000000: \"viiiiiix\",\n        1000000000: \"viiiiiix\",\n        5000000000:\
    \ \"viiiiiix\",\n        10000000000: \"viiiiiix\",\n        50000000000: \"viiiiiix\"\
    ,\n        100000000000: \"viiiiiix\",\n        500000000000: \"viiiiiix\",\n\
    \        1000000000000: \"viiiiiix\",\n        5000000000000: \"viiiiiix\",\n\
    \        10000000000000: \"viiiiiix\",\n        50000000000000: \"viiiiiix\",\n\
    \        100000000000000: \"viiiiiix\",\n        500000000000000: \"viiiiiix\"\
    ,\n        1000000000000000: \"viiiiiix\",\n        5000000000000000: \"viiiiiix\"\
    ,\n        10000000000000000: \"viiiiiix\",\n        5000000000000000: \"viiiiiix\"\
    ,\n        1000000000000000000: \"viiiiiix\",\n        50000000000000000: \"viiiiiix\"\
    ,\n        10000000000000000000: \"viiiiiix\",\n        5000000000000000000: \"\
    viiiiiix\",\n        100000000000000000000: \"viiiiiix\",\n        50000000000000000000:\
    \ \"viiiiiix\",\n        1000000000000000000000: \"viiiiiix\",\n        500000000000000000000:\
    \ \"viiiiiix\",\n        10000000000000000000000: \"viiiiiix\",\n        5000000000000000000000:\
    \ \"viiiiiix\",\n        100000000000000000000000: \"viiiiiix\",\n        50000000000000000000000:\
    \ \"viiiiiix\",\n        1000000000000000000000000: \"viiiiiix\",\n        500000000000000000000000:\
    \ \"viiiiiix\",\n        10000000000000000000000000: \"viiiiiix\",\n    }\n\n\
    \    roman_\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp4g4dueqi_test.go:72:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    romans := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"l\",\n        50: \"x\",\n        100: \"c\"\
    ,\n        500: \"d\",\n        1000: \"m\",\n    }\n    result := \"\"\n    for\
    \ _, romanNum := range romans {\n        if number >= romanNum {\n           \
    \ result += romans[romanNum]\n            number -= romanNum\n        }\n    }\n\
    \    return strings.ToLower(result)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpkz8at8zp_test.go:33:22: invalid operation: number >= romanNum (mismatched
    types int and string)

    /tmp/tmpkz8at8zp_test.go:34:30: cannot use romanNum (variable of type string)
    as type int in map index

    /tmp/tmpkz8at8zp_test.go:35:13: invalid operation: number -= romanNum (mismatched
    types int and string)

    /tmp/tmpkz8at8zp_test.go:38:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\"\
    ,\n        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n  \
    \  roman_number := roman_numerals[number]\n    return strings.ToLower(roman_number)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpqk0oyi5v_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"viii\",\n        50: \"vii\",\n        100: \"\
    vi\",\n        500: \"viii\",\n        1000: \"viii\",\n        5000: \"vii\"\
    ,\n        10000: \"vi\",\n        50000: \"viii\",\n        100000: \"viii\"\
    ,\n        500000: \"vii\",\n        1000000: \"vi\",\n        5000000: \"viii\"\
    ,\n        10000000: \"viii\",\n        50000000: \"vii\",\n        100000000:\
    \ \"vi\",\n        500000000: \"viii\",\n        1000000000: \"viii\",\n     \
    \   5000000000: \"vii\",\n        10000000000: \"vi\",\n        50000000000: \"\
    viii\",\n        100000000000: \"viii\",\n        500000000000: \"vii\",\n   \
    \     1000000000000: \"vi\",\n        5000000000000: \"viii\",\n        10000000000000:\
    \ \"viii\",\n        50000000000000: \"vii\",\n        100000000000000: \"vi\"\
    ,\n        500000000000000: \"viii\",\n        1000000000000000: \"viii\",\n \
    \       5000000000000000: \"vii\",\n        1000000000000000000: \"vi\",\n   \
    \     50000000000000000: \"viii\",\n        10000000000000000000: \"viii\",\n\
    \        5000000000000000000: \"vii\",\n        100000000000000000000: \"vi\"\
    ,\n        50000000000000000000: \"viii\",\n        1000000000000000000000: \"\
    viii\",\n        500000000000000000000: \"vii\",\n        10000000000000000000000:\
    \ \"vi\",\n        5000000000000000000000: \"viii\",\n        100000000000000000000000:\
    \ \"viii\",\n        50000000000000000000000: \"vii\",\n        1000000000000000000000000:\
    \ \"vi\",\n        500000000000000000000000: \"viii\",\n        10000000000000000000000000:\
    \ \"viii\",\n        5000000000000000000000000: \"vii\",\n        100000000000000000000000000:\
    \ \"vi\",\n        50000000000000000000000000: \"viii\",\n        1000000000000000000000000000:\
    \ \"viii\",\n        500000000000000000000000000: \"vii\",\n        10000000000000000000000000000:\
    \ \"vi\",\n        5000000000000000000000000000: \"viii\",\n        100000000000000000000000000000:\
    \ \"viii\",\n        50000000000000000000000000000: \"vii\",\n        1000000000000000000000000000000:\
    \ \"vi\",\n        500000000000000000000000000000: \"viii\",\n        10000000000000000000000000000000:\
    \ \"viii\",\n        5000000000000000000000000000000: \"vii\",\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqnf5f27p_test.go:80:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n\
    \        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\"\
    , \"CXXI\",\n        \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"\
    CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"\
    CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\"\
    , \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\"\
    ,\n        \"CCVII\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpemmat3hj_test.go:34:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 5:\n        roman_number = \"v\"\n   \
    \ case 10:\n        roman_number = \"i\"\n    case 20:\n        roman_number =\
    \ \"x\"\n    case 50:\n        roman_number = \"l\"\n    case 100:\n        roman_number\
    \ = \"c\"\n    case 200:\n        roman_number = \"d\"\n    case 500:\n      \
    \  roman_number = \"l\"\n    case 1000:\n        roman_number = \"m\"\n    }\n\
    \    return roman_number\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpecp52d3w_test.go:69: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpecp52d3w_test.go:69: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpecp52d3w_test.go:69: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpecp52d3w_test.go:69: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpecp52d3w_test.go:69:\
    \ expected 'd', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpecp52d3w_test.go:69: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpecp52d3w_test.go:69: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpecp52d3w_test.go:69: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpecp52d3w_test.go:69: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpecp52d3w_test.go:69: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpecp52d3w_test.go:69:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpecp52d3w_test.go:69: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpecp52d3w_test.go:69:\
    \ expected 'cmxciv', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075541
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\"I\", \"II\", \"III\", \"IV\", \"V\"\
    , \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\"\
    , \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"\
    XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\"\
    , \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\"\
    , \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LIII\", \"LIIII\"\
    , \"LIIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\", \"LXI\", \"\
    LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\"\
    , \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"\
    LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"\
    XC\", \"C\", \"CI\", \"CII\", \"CIII\", \"CIIII\", \"CIV\", \"CV\", \"CVI\", \"\
    CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"\
    CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\",\
    \ \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\"\
    , \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\",\
    \ \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\"\
    , \"CXII\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpoi10uabs_test.go:19:1177: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 2:\n        roman_number = \"ix\"\n  \
    \  case 3:\n        roman_number = \"lb\"\n    case 4:\n        roman_number =\
    \ \"c\"\n    case 5:\n        roman_number = \"d\"\n    case 6:\n        roman_number\
    \ = \"i\"\n    case 7:\n        roman_number = \"v\"\n    case 8:\n        roman_number\
    \ = \"f\"\n    case 9:\n        roman_number = \"e\"\n    case 10:\n        roman_number\
    \ = \"g\"\n    case 11:\n        roman_number = \"h\"\n    case 12:\n        roman_number\
    \ = \"k\"\n    case 13:\n        roman_number = \"m\"\n    case 14:\n        roman_number\
    \ = \"n\"\n    case 15:\n        roman_number = \"x\"\n    case 16:\n        roman_number\
    \ = \"l\"\n    case 17:\n        roman_number = \"c\"\n    case 18:\n        roman_number\
    \ = \"d\"\n    case 19:\n        roman_number = \"i\"\n    case 20:\n        roman_number\
    \ = \"v\"\n    case 21:\n        roman_number = \"f\"\n    case 22:\n        roman_number\
    \ = \"e\"\n    case 23:\n        roman_number = \"g\"\n    case 24:\n        roman_number\
    \ = \"h\"\n    case 25:\n        roman_number = \"k\"\n    case 26:\n        roman_number\
    \ = \"m\"\n    case 27:\n        roman_number = \"n\"\n    case 28:\n        roman_number\
    \ = \"x\"\n    case 29:\n        roman_number = \"l\"\n    case 30:\n        roman_number\
    \ = \"c\"\n    case 31:\n        roman_number = \"d\"\n    case 32:\n        roman_number\
    \ = \"i\"\n    case 33:\n        roman_number = \"v\"\n    case 34:\n        roman_number\
    \ = \"f\"\n    case 35:\n        roman_number = \"e\"\n    case 36:\n        roman_number\
    \ = \"g\"\n    case 37:\n        roman_number = \"h\"\n    case 38:\n        roman_number\
    \ = \"k\"\n    case 39:\n        roman_number = \"m\"\n    case 40:\n        roman_number\
    \ = \"n\"\n    case 41:\n        roman_number = \"x\"\n    case 42:\n        roman_number\
    \ = \"l\"\n    case 43:\n        roman_number = \"c\"\n    case 44:\n        roman_number\
    \ = \"d\"\n    case 45:\n        roman_number = \"i\"\n    case \nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpi0k9fhx0_test.go:112:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    ix\",\n        500: \"ixi\",\n        1000: \"ixii\",\n    }\n    romanNumerals[number]\
    \ = \"\"\n    return romanNumerals[number]\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpkorqiqje_test.go:58: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpkorqiqje_test.go:58: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpkorqiqje_test.go:58: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpkorqiqje_test.go:58: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpkorqiqje_test.go:58:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpkorqiqje_test.go:58: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpkorqiqje_test.go:58: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpkorqiqje_test.go:58: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpkorqiqje_test.go:58: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpkorqiqje_test.go:58: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpkorqiqje_test.go:58:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpkorqiqje_test.go:58: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpkorqiqje_test.go:58:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpkorqiqje_test.go:58: expected 'm', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiii\",\n        500: \"viiii\",\n        1000: \"viiii\",\n        5000:\
    \ \"viiii\",\n        10000: \"viiii\",\n        50000: \"viiii\",\n        100000:\
    \ \"viiii\",\n        500000: \"viiii\",\n        1000000: \"viiii\",\n      \
    \  5000000: \"viiii\",\n        10000000: \"viiii\",\n        50000000: \"viiii\"\
    ,\n        100000000: \"viiii\",\n        500000000: \"viiii\",\n        1000000000:\
    \ \"viiii\",\n        5000000000: \"viiii\",\n        10000000000: \"viiii\",\n\
    \        50000000000: \"viiii\",\n        100000000000: \"viiii\",\n        500000000000:\
    \ \"viiii\",\n        1000000000000: \"viiii\",\n        5000000000000: \"viiii\"\
    ,\n        10000000000000: \"viiii\",\n        50000000000000: \"viiii\",\n  \
    \      100000000000000: \"viiii\",\n        500000000000000: \"viiii\",\n    \
    \    1000000000000000: \"viiii\",\n        5000000000000000: \"viiii\",\n    \
    \    1000000000000000000: \"viiii\",\n        50000000000000000: \"viiii\",\n\
    \        10000000000000000000: \"viiii\",\n        5000000000000000000: \"viiii\"\
    ,\n        100000000000000000000: \"viiii\",\n        50000000000000000000: \"\
    viiii\",\n        1000000000000000000000: \"viiii\",\n        500000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000: \"viiii\",\n        5000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000: \"viiii\",\n        50000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000: \"viiii\",\n        500000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000: \"viiii\",\n        5000000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000000: \"viiii\",\n        50000000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000000: \"viiii\",\n        500000000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000000: \"viiii\",\n        5000000000000000000000000000\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpquhcjrxs_test.go:73:37: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\"\
    , \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    mini_num :=\
    \ []string{\"m\", \"c\", \"d\", \"c\", \"x\", \"l\", \"xl\", \"x\", \"i\", \"\
    v\", \"i\"}\n    roman_num_index := 0\n    mini_num_index := 0\n    roman_num\
    \ := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\"\
    , \"IX\", \"V\", \"IV\", \"I\"}\n    mini_num := []string{\"m\", \"c\", \"d\"\
    , \"c\", \"x\", \"l\", \"xl\", \"x\", \"i\", \"v\", \"i\"}\n    roman_num_index\
    \ := 0\n    mini_num_index := 0\n    roman_num := []string{\"M\", \"CM\", \"D\"\
    , \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n\
    \    mini_num := []string{\"m\", \"c\", \"d\", \"c\", \"x\", \"l\", \"xl\", \"\
    x\", \"i\", \"v\", \"i\"}\n    roman_num_index := 0\n    mini_num_index := 0\n\
    \    roman_num := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\"\
    , \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    mini_num := []string{\"m\"\
    , \"c\", \"d\", \"c\", \"x\", \"l\", \"xl\", \"x\", \"i\", \"v\", \"i\"}\n   \
    \ roman_num_index := 0\n    mini_num_index := 0\n    roman_num := []string{\"\
    M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\"\
    , \"IV\", \"I\"}\n    mini_num := []string{\"m\", \"c\", \"d\", \"c\", \"x\",\
    \ \"l\", \"xl\", \"x\", \"i\", \"v\", \"i\"}\n    roman_num_index := 0\n    mini_num_index\
    \ := 0\n    roman_num := []string{\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\"\
    , \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    mini_num := []string{\"\
    m\", \"c\", \"d\", \"c\", \"x\", \"l\", \"xl\", \"x\", \"i\", \"v\", \"i\"}\n\
    \    roman_num_index := 0\n    mini_num_index := 0\n    roman_num := []string{\"\
    M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\"\
    , \"IV\", \"I\"}\n    mini\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpvg8pi9p4_test.go:45:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    mini_roman_numerals :=\
    \ map[string]int{\n        \"I\": 1,\n        \"V\": 5,\n        \"X\": 10,\n\
    \        \"L\": 50,\n        \"C\": 100,\n        \"D\": 500,\n        \"M\":\
    \ 1000,\n    }\n    roman_number := roman_numerals[number]\n    mini_roman_number\
    \ := mini_roman_numerals[roman_number]\n    return fmt.Sprintf(\"%c\", mini_roman_number)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpxyrby9j6_test.go:68: expected 'xix', got '\0'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpxyrby9j6_test.go:68: expected\
    \ 'clii', got '\0'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n\
    \        tmpxyrby9j6_test.go:68: expected 'ccli', got '\0'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpxyrby9j6_test.go:68: expected 'cdxxvi', got '\0'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpxyrby9j6_test.go:68:\
    \ expected 'd', got '\u01F4'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5\
    \ (0.00s)\n        tmpxyrby9j6_test.go:68: expected 'i', got '\x01'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpxyrby9j6_test.go:68: expected\
    \ 'iv', got '\0'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n  \
    \      tmpxyrby9j6_test.go:68: expected 'xliii', got '\0'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8\
    \ (0.00s)\n        tmpxyrby9j6_test.go:68: expected 'xc', got '\0'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpxyrby9j6_test.go:68: expected\
    \ 'xciv', got '\0'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n\
    \        tmpxyrby9j6_test.go:68: expected 'dxxxii', got '\0'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpxyrby9j6_test.go:68: expected 'cm', got '\0'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpxyrby9j6_test.go:68:\
    \ expected 'cmxciv', got '\0'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpxyrby9j6_test.go:68: expected 'm', got '\u03E8'\nFAIL\n\
    FAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075541
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n        5000: \"viiivi\"\
    ,\n        10000: \"viiivii\",\n        50000: \"vivvi\",\n        100000: \"\
    vivvii\",\n        500000: \"viviv\",\n        1000000: \"vivivi\",\n        5000000:\
    \ \"vivivii\",\n        10000000: \"viviviii\",\n        50000000: \"viviivi\"\
    ,\n        100000000: \"viviivii\",\n        500000000: \"viviiivi\",\n      \
    \  1000000000: \"viviiivii\",\n        5000000000: \"vivivvi\",\n        10000000000:\
    \ \"vivivvii\",\n        50000000000: \"viviviv\",\n        100000000000: \"vivivivi\"\
    ,\n        500000000000: \"viviiviv\",\n        1000000000000: \"viviivivi\",\n\
    \        5000000000000: \"viviiiviv\",\n        10000000000000: \"viviiivivi\"\
    ,\n        50000000000000: \"vivivviv\",\n        100000000000000: \"vivivvivi\"\
    ,\n        500000000000000: \"viviviviv\",\n        1000000000000000: \"vivivivivi\"\
    ,\n        5000000000000000: \"viviiviviv\",\n        10000000000000000: \"viviivivivi\"\
    ,\n        5000000000000000: \"viviiivivi\",\n        10000000000000000: \"viviiivivi\"\
    ,\n        50000000000000000: \"vivivvivi\",\n        100000000000000000: \"vivivvivii\"\
    ,\n        500000000000000000: \"viviviviv\",\n        100000000000000000: \"\
    vivivivivi\",\n        50000000000000000: \"viviiviviv\",\n        100000000000000000:\
    \ \"viviivivivi\",\n        500000000000000000: \"viviiivivi\",\n        100000000000000000:\
    \ \"viviiivivi\",\n        5000000000000000000: \"vivivvivi\",\n        100000000000000000:\
    \ \"vivivvivii\",\n        50000000000000000000: \"viviviviv\",\n        100000000000000000:\
    \ \"vivivivivi\",\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate :=\
    \ int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8eed3qrl_test.go:67:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"IV\", \"V\"\
    , \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\", \"\
    MM\",\n        \"MMM\",\n    }\n    roman_numerals_lower := []string{\n      \
    \  \"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\",\
    \ \"d\", \"cm\", \"m\", \"mm\",\n        \"mmm\",\n    }\n    roman_numerals_upper\
    \ := []string{\n        \"I\", \"IV\", \"V\", \"IX\", \"X\", \"XL\", \"L\", \"\
    XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\", \"MM\",\n        \"MMM\",\n    }\n\
    \    roman_numerals_lower_upper := []string{\n        \"i\", \"iv\", \"v\", \"\
    ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\", \"mm\"\
    ,\n        \"mmm\",\n    }\n    roman_numerals_lower_upper_roman := []string{\n\
    \        \"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"\
    cd\", \"d\", \"cm\", \"m\", \"mm\",\n        \"mmm\",\n    }\n    roman_numerals_lower_upper_roman_roman\
    \ := []string{\n        \"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"\
    xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\", \"mm\",\n        \"mmm\",\n    }\n\
    \    roman_numerals_lower_upper_roman_roman_roman := []string{\n        \"i\"\
    , \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"cd\", \"d\", \"\
    cm\", \"m\", \"mm\",\n        \"mmm\",\n    }\n    roman_numerals_lower_upper_roman_roman_roman_roman\
    \ := []string{\n        \"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"\
    xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\", \"mm\",\n        \"mmm\",\n    }\n\
    \    roman_numerals_lower_upper_roman_roman_roman_roman_roman := []string{\n \
    \       \"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"xc\", \"c\", \"\
    cd\", \"d\", \"cm\", \"m\", \"mm\",\n        \"mmm\",\n    }\n    roman_numerals_lower_upper_roman_roman_roman_roman_roman\
    \ := []string{\n        \"i\", \"iv\", \"v\", \"ix\", \"x\", \"xl\", \"l\", \"\
    xc\", \"c\", \"cd\", \"d\", \"cm\", \"m\", \"mm\",\n        \"mmm\",\n    }\n\
    \    roman_numerals_lower_upper_\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n\
    \  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpn7oqtol4_test.go:60:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075541
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    roman_number\
    \ := \"\"\n    for roman_number != \"\" {\n        roman_number += romans[number%1000]\n\
    \        number /= 1000\n    }\n    return strings.ToLower(roman_number)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp2odn5yrg_test.go:34:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"x\"\n    case 2:\n        roman_num = \"ix\"\n    case 3:\n\
    \        roman_num = \"lb\"\n    case 4:\n        roman_num = \"c\"\n    case\
    \ 5:\n        roman_num = \"d\"\n    case 6:\n        roman_num = \"mi\"\n   \
    \ case 7:\n        roman_num = \"f\"\n    case 8:\n        roman_num = \"v\"\n\
    \    case 9:\n        roman_num = \"x\"\n    case 10:\n        roman_num = \"\
    c\"\n    case 11:\n        roman_num = \"d\"\n    case 12:\n        roman_num\
    \ = \"mi\"\n    case 13:\n        roman_num = \"f\"\n    case 14:\n        roman_num\
    \ = \"v\"\n    case 15:\n        roman_num = \"x\"\n    case 16:\n        roman_num\
    \ = \"c\"\n    case 17:\n        roman_num = \"d\"\n    case 18:\n        roman_num\
    \ = \"mi\"\n    case 19:\n        roman_num = \"f\"\n    case 20:\n        roman_num\
    \ = \"v\"\n    case 21:\n        roman_num = \"x\"\n    case 22:\n        roman_num\
    \ = \"c\"\n    case 23:\n        roman_num = \"d\"\n    case 24:\n        roman_num\
    \ = \"mi\"\n    case 25:\n        roman_num = \"f\"\n    case 26:\n        roman_num\
    \ = \"v\"\n    case 27:\n        roman_num = \"x\"\n    case 28:\n        roman_num\
    \ = \"c\"\n    case 29:\n        roman_num = \"d\"\n    case 30:\n        roman_num\
    \ = \"mi\"\n    case 31:\n        roman_num = \"f\"\n    case 32:\n        roman_num\
    \ = \"v\"\n    case 33:\n        roman_num = \"x\"\n    case 34:\n        roman_num\
    \ = \"c\"\n    case 35:\n        roman_num = \"d\"\n    case 36:\n        roman_num\
    \ = \"mi\"\n    case 37:\n        roman_num = \"f\"\n    case 38:\n        roman_num\
    \ = \"v\"\n    case 39:\n        roman_num = \"x\"\n    case 40:\n        roman_num\
    \ = \"c\"\n    case 41:\n        roman_num = \"d\"\n    case 42:\n        roman_num\
    \ = \"mi\"\n    case 43:\n        roman_num = \"f\"\n    case 44:\n        roman_num\
    \ = \"v\"\n    case 45:\n        roman_num = \"x\"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1fdkvs2f_test.go:111:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075541
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n        \"X\", \"XI\", \"\
    XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\",\n   \
    \     \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\",\n        \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\", \"LIX\",\n        \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\",\n        \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    , \"LXXVIII\", \"LXXIX\",\n        \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\",\n\
    \        \"XC\", \"C\", \"CI\", \"CII\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"\
    CVI\", \"CVII\", \"CVIII\", \"CIX\",\n        \"XC\", \"C\", \"CI\", \"CII\",\
    \ \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\",\n\
    \        \"XXC\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"\
    CCVI\", \"CCVII\", \"CCVIII\", \"CXX\",\n        \"CCC\", \"CCCI\", \"CCCII\"\
    , \"CCCIII\", \"CCCIV\", \"CCCV\", \"CCCVI\", \"CCCVII\", \"CCCVIII\", \"CXXX\"\
    ,\n        \"CCXX\", \"CCXXX\", \"CCXXXI\", \"CCXXXII\", \"CCXXXIII\", \"CCXXXIV\"\
    , \"CCXXXV\", \"CCXXXVI\", \"CCXXXVII\", \"CCXXXVIII\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpie6f7_j0_test.go:32:103: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075541
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 5:\n        roman_number = \"v\"\n   \
    \ case 10:\n        roman_number = \"i\"\n    case 50:\n        roman_number =\
    \ \"l\"\n    case 100:\n        roman_number = \"c\"\n    case 500:\n        roman_number\
    \ = \"d\"\n    case 1000:\n        roman_number = \"m\"\n    }\n    return roman_number\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp90p27_ny_test.go:65: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp90p27_ny_test.go:65: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp90p27_ny_test.go:65: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp90p27_ny_test.go:65: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp90p27_ny_test.go:65:\
    \ expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmp90p27_ny_test.go:65: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmp90p27_ny_test.go:65: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp90p27_ny_test.go:65: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmp90p27_ny_test.go:65: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmp90p27_ny_test.go:65: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp90p27_ny_test.go:65:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmp90p27_ny_test.go:65: expected 'cmxciv', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    result\
    \ := \"\"\n    for num, _ := range romans {\n        if number >= num {\n    \
    \        result += romans[num]\n            number -= num\n        }\n    }\n\
    \    return strings.ToLower(result)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplrtp8tcm_test.go:36:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viiii\",\n        5000: \"viiiii\"\
    ,\n        10000: \"vivvi\",\n        50000: \"vivvii\",\n        100000: \"vivviii\"\
    ,\n        500000: \"vivviiii\",\n        1000000: \"vivviv\",\n        5000000:\
    \ \"vivvivi\",\n        10000000: \"vivvivii\",\n        50000000: \"vivviviii\"\
    ,\n        100000000: \"vivviviiii\",\n        500000000: \"vivviviiiii\",\n \
    \       1000000000: \"vivviviv\",\n        5000000000: \"vivvivivi\",\n      \
    \  10000000000: \"vivvivivii\",\n        50000000000: \"vivviviviii\",\n     \
    \   100000000000: \"vivviviviiii\",\n        500000000000: \"vivviviviiiii\",\n\
    \        1000000000000: \"vivviviviv\",\n        5000000000000: \"vivvivivivi\"\
    ,\n        10000000000000: \"vivvivivivii\",\n        50000000000000: \"vivviviviviii\"\
    ,\n        100000000000000: \"vivviviviviiii\",\n        500000000000000: \"vivviviviviiiii\"\
    ,\n        1000000000000000: \"vivviviviviv\",\n        5000000000000000: \"vivvivivivivi\"\
    ,\n        10000000000000000: \"vivvivivivivii\",\n        5000000000000000: \"\
    vivviviviviviii\",\n        10000000000000000: \"vivviviviviviiii\",\n       \
    \ 5000000000000000: \"vivviviviviviiiii\",\n        100000000000000000: \"vivviviviviviv\"\
    ,\n        50000000000000000: \"vivvivivivivi\",\n        1000000000000000000:\
    \ \"vivvivivivivii\",\n        500000000000000000: \"vivviviviviviii\",\n    \
    \    10000000000000000000: \"vivviviviviviiii\",\n        5000000000000000000:\
    \ \"vivviviviviviiiii\",\n        100\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp7etiifij_test.go:62:12: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075541
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n    }\n\n    result := \"\"\n    for num,\
    \ res := range romans {\n        if num == number {\n            result = res\n\
    \            break\n        }\n    }\n\n    return result\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpzl4mmde1_test.go:66: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpzl4mmde1_test.go:66: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpzl4mmde1_test.go:66: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpzl4mmde1_test.go:66: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpzl4mmde1_test.go:66:\
    \ expected 'd', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmpzl4mmde1_test.go:66: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmpzl4mmde1_test.go:66: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpzl4mmde1_test.go:66: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmpzl4mmde1_test.go:66: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpzl4mmde1_test.go:66: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpzl4mmde1_test.go:66:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmpzl4mmde1_test.go:66: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpzl4mmde1_test.go:66: expected 'm', got 'd'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return \"\"\n    }\n\n    romanNumerals := map[int]string{\n\
    \        1: \"I\",\n        5: \"V\",\n        10: \"X\",\n        50: \"L\",\n\
    \        100: \"C\",\n        500: \"D\",\n        1000: \"M\",\n    }\n\n   \
    \ romanNumeral := \"\"\n    for romanNumeral, number := range romanNumerals {\n\
    \        if number >= number {\n            romanNumeral += romanNumerals[number]\n\
    \        }\n    }\n\n    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprrrt4saj_test.go:37:13: invalid operation: romanNumeral += romanNumerals[number]
    (mismatched types int and string)

    /tmp/tmprrrt4saj_test.go:37:43: cannot use number (variable of type string) as
    type int in map index

    /tmp/tmprrrt4saj_test.go:41:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n    }\n    roman_number := \"\"\n    for\
    \ number > 0 {\n        roman_number += romans[number%100]\n        number /=\
    \ 100\n    }\n    return strings.ToLower(roman_number)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsyvhbbo8_test.go:33:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    result\
    \ := \"\"\n    for num, res := range romans {\n        if num >= number {\n  \
    \          result = res\n            break\n        }\n    }\n    return result\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpgonmgbz__test.go:65: expected 'xix', got 'c'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpgonmgbz__test.go:65: expected\
    \ 'clii', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n \
    \       tmpgonmgbz__test.go:65: expected 'ccli', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpgonmgbz__test.go:65: expected 'cdxxvi', got 'c'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpgonmgbz__test.go:65:\
    \ expected 'd', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpgonmgbz__test.go:65: expected 'i', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpgonmgbz__test.go:65: expected 'iv', got 'l'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpgonmgbz__test.go:65: expected\
    \ 'xliii', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n\
    \        tmpgonmgbz__test.go:65: expected 'xc', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpgonmgbz__test.go:65: expected 'xciv', got 'c'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpgonmgbz__test.go:65:\
    \ expected 'dxxxii', got 'd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpgonmgbz__test.go:65: expected 'cm', got 'd'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpgonmgbz__test.go:65:\
    \ expected 'cmxciv', got 'd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpgonmgbz__test.go:65: expected 'm', got 'd'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp47lawrce_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n        10000: \"\
    c\",\n        100000: \"c\",\n        1000000: \"m\",\n        500000: \"m\",\n\
    \        10000001: \"m\",\n        10000000: \"m\",\n        100000000: \"m\"\
    ,\n        1000000000: \"m\",\n        10000000000: \"m\",\n        100000000000:\
    \ \"m\",\n        1000000000000: \"m\",\n        10000000000000: \"m\",\n    \
    \    100000000000000: \"m\",\n        1000000000000000: \"m\",\n        10000000000000000:\
    \ \"m\",\n        100000000000000000: \"m\",\n        1000000000000000000: \"\
    m\",\n    }\n\n    roman, ok := romans[number]\n    if !ok {\n        fmt.Println(\"\
    int_to_mini_roman: number too large\")\n    }\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "int_to_mini_roman: number too large\nint_to_mini_roman: number too large\n\
    int_to_mini_roman: number too large\nint_to_mini_roman: number too large\nint_to_mini_roman:\
    \ number too large\nint_to_mini_roman: number too large\nint_to_mini_roman: number\
    \ too large\nint_to_mini_roman: number too large\nint_to_mini_roman: number too\
    \ large\nint_to_mini_roman: number too large\nint_to_mini_roman: number too large\n\
    --- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpgforljtm_test.go:80: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpgforljtm_test.go:80: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpgforljtm_test.go:80: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpgforljtm_test.go:80: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpgforljtm_test.go:80:\
    \ expected 'd', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmpgforljtm_test.go:80: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmpgforljtm_test.go:80: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpgforljtm_test.go:80: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmpgforljtm_test.go:80: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpgforljtm_test.go:80: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpgforljtm_test.go:80:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmpgforljtm_test.go:80: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpgforljtm_test.go:80: expected 'm', got 'd'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vi\",\n\
    \    }\n    romanNumeral := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7hs8zsvu_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"vii\",\n        100: \"\
    vi\",\n        500: \"viii\",\n        1000: \"viii\",\n        5000: \"viii\"\
    ,\n        10000: \"viii\",\n        50000: \"viii\",\n        100000: \"viii\"\
    ,\n        500000: \"viii\",\n        1000000: \"viii\",\n        5000000: \"\
    viii\",\n        10000000: \"viii\",\n        50000000: \"viii\",\n        100000000:\
    \ \"viii\",\n        500000000: \"viii\",\n        1000000000: \"viii\",\n   \
    \     5000000000: \"viii\",\n        10000000000: \"viii\",\n        50000000000:\
    \ \"viii\",\n        100000000000: \"viii\",\n        500000000000: \"viii\",\n\
    \        1000000000000: \"viii\",\n        5000000000000: \"viii\",\n        10000000000000:\
    \ \"viii\",\n        50000000000000: \"viii\",\n        100000000000000: \"viii\"\
    ,\n        500000000000000: \"viii\",\n        1000000000000000: \"viii\",\n \
    \       5000000000000000: \"viii\",\n        1000000000000000000: \"viii\",\n\
    \    }\n    romanNumeralsInt := map[string]int{\n        \"i\": 1,\n        \"\
    vi\": 5,\n        \"viii\": 10,\n        \"vii\": 50,\n        \"vi\": 100,\n\
    \        \"viiii\": 500,\n        \"vii\": 1000,\n        \"viiiii\": 5000,\n\
    \        \"viiii\": 10000,\n        \"viiiiii\": 50000,\n        \"viiiiiii\"\
    : 100000,\n        \"viiiiiiii\": 500000,\n        \"viiiiiiiii\": 1000000,\n\
    \        \"viiiiiiiiii\": 5000000,\n        \"viiiiiiiiiii\": 10000000,\n    \
    \    \"viiiiiiiiiiii\": 50000000,\n        \"viiiiiiiiiiiii\": 100000000,\n  \
    \      \"viiiiiiiiiiiiii\": 500000000,\n        \"viiiiiiiiiiiiiii\": 1000000000,\n\
    \        \"viiiiiiiiiiiiiiii\": 5000000000,\n        \"viiiiiiiiiiiiiiiii\": 10000000000,\n\
    \        \"viiiiiiiiiiiiiiiiii\": 50000000000,\n        \"viiiiiii\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp2yiz6kh2_test.go:77:9: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n    }\n    roman_number := \"\"\n    for\
    \ roman_number == \"\" && number > 0 {\n        roman_number = romans[number%100]\n\
    \        number /= 100\n    }\n    return roman_number\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpuanh3r6s_test.go:62: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpuanh3r6s_test.go:62: expected\
    \ 'clii', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n \
    \       tmpuanh3r6s_test.go:62: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpuanh3r6s_test.go:62: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpuanh3r6s_test.go:62:\
    \ expected 'd', got 'vi'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmpuanh3r6s_test.go:62: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmpuanh3r6s_test.go:62: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpuanh3r6s_test.go:62: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmpuanh3r6s_test.go:62: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpuanh3r6s_test.go:62: expected 'dxxxii', got 'vi'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpuanh3r6s_test.go:62:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmpuanh3r6s_test.go:62: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpuanh3r6s_test.go:62: expected 'm', got 'l'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075543
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\",\n        \"XII\", \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\",\n    \
    \    \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"\
    XXVIII\",\n        \"XXIX\", \"XXX\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\",\
    \ \"XXVII\", \"XXVIII\",\n        \"XXIX\", \"XL\", \"L\", \"LI\", \"LXI\", \"\
    LXII\", \"LXIII\", \"LXIV\", \"LXV\",\n        \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\",\n        \"LXXIV\", \"LXXV\"\
    , \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\",\n        \"LXXIII\"\
    , \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\",\n      \
    \  \"LXXX\", \"XC\", \"C\", \"CI\", \"CIX\", \"CX\", \"CXX\", \"CXXX\", \"CC\"\
    , \"CCI\",\n        \"CCIX\", \"CCX\", \"CCXX\", \"CCXXX\", \"CD\", \"D\", \"\
    DI\", \"DII\", \"DIIX\", \"DX\",\n        \"DXX\", \"DXXX\", \"DC\", \"DCI\",\
    \ \"DCIX\", \"DCX\", \"DCXX\", \"DCXXX\", \"DD\",\n        \"DDI\", \"DDII\",\
    \ \"DDIIX\", \"DDIX\", \"DDIXX\", \"DDIXXX\", \"DE\", \"DEI\", \"DEIX\",\n   \
    \     \"DEX\", \"DEXX\", \"DEXXX\", \"DF\", \"DII\", \"DIII\", \"DIIII\", \"DIIV\"\
    , \"DIV\",\n        \"DIVI\", \"DIVII\", \"DIVIII\", \"DIVIV\", \"DIVV\", \"DIVVI\"\
    , \"DIVVII\", \"DIVVIII\",\n        \"DIVIX\", \"DIX\", \"DIXX\", \"DIXXX\", \"\
    DJ\", \"DZ\", \"DZI\", \"DZII\", \"DZIII\",\n        \"DZIV\", \"DZV\", \"DZVI\"\
    , \"DZVII\", \"DZVIII\", \"DZIX\", \"DZX\", \"DZXX\",\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv5idkbjr_test.go:36:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    result\
    \ := \"\"\n    for num, _ := range romans {\n        if number >= num {\n    \
    \        result += romans[num]\n            number -= num\n        }\n    }\n\
    \    return strings.ToLower(result)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmplrtp8tcm_test.go:36:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\",\
    \ \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"\
    XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\"\
    , \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"\
    XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LIII\", \"\
    LIIII\", \"LIIV\", \"LIV\", \"LIVI\", \"LIVII\", \"LIVIII\", \"LIVIV\", \"LIVV\"\
    , \"LIVVI\", \"LIVVII\", \"LIVVIII\", \"LIVVIV\", \"LIVVV\", \"LIVVVI\", \"LIVVVII\"\
    , \"LIVVVIII\", \"LIVVVIV\", \"LIVVVV\", \"LIVVVI\", \"LIVVVII\", \"LIVVVIII\"\
    , \"LIVVVIV\", \"LIVVVV\", \"LIVVVI\", \"LIVVVII\", \"LIVVVIII\", \"LIVVVIV\"\
    , \"LIVVVV\", \"LIVVVI\", \"LIVVVII\", \"LIVVVIII\", \"LIVVVIV\", \"LIVVVV\",\
    \ \"LIVVVI\", \"LIVVVII\", \"LIVVVIII\", \"LIVVVIV\", \"LIVVVV\", \"LIVVVI\",\
    \ \"LIVVVII\", \"LIVVVIII\", \"LIVVVIV\", \"LIVVVV\", \"LIVVVI\", \"LIVVVII\"\
    , \"LIVVVIII\", \"LIVVVIV\", \"LIVVVV\", \"LIVVVI\", \"LIVVVII\", \"LIVVVIII\"\
    , \"LIVVVIV\", \"LIVVVV\", \"LIVVVI\", \"LIVVVII\", \"LIVVVIII\", \"LIVVVIV\"\
    , \"LIVVVV\", \"LIVVVI\", \"LIVVVII\", \"LIVVVIII\", \"LIVVVIV\", \"LIVVVV\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptb40fl4v_test.go:19:1007: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"ix\",\n\
    \        500: \"ixi\",\n        1000: \"ixii\",\n    }\n    result := \"\"\n \
    \   for roman, roman := range romans {\n        if number >= roman {\n       \
    \     result += romans[roman]\n            number -= roman\n        }\n    }\n\
    \    return strings.ToLower(result)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: "# command-line-arguments_test [command-line-arguments.test]\n/tmp/tmpk7b5m_g0_test.go:29:16:\
    \ roman redeclared in this block\n\t/tmp/tmpk7b5m_g0_test.go:29:9: other declaration\
    \ of roman\n/tmp/tmpk7b5m_g0_test.go:35:12: undefined: strings\n"
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    roman_number := \"\"\n    for\
    \ num, _ := range romans {\n        if number >= num {\n            roman_number\
    \ = romans[num]\n            break\n        }\n    }\n    return strings.ToLower(roman_number)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpfshb1w_j_test.go:35:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viiii\",\n    }\n    romanNumeralsInverse\
    \ := map[string]int{\n        \"i\": 1,\n        \"vi\": 5,\n        \"vii\":\
    \ 10,\n        \"viii\": 50,\n        \"viv\": 100,\n        \"viivi\": 500,\n\
    \        \"viiii\": 1000,\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    romanNumeralInverse := romanNumeralsInverse[romanNumeral]\n    romanNumeralString\
    \ := fmt.Sprintf(\"%c\", romanNumeralInverse)\n    return strings.ToLower(romanNumeralString)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp22_p5k7a_test.go:40:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpszcenp2e_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiii\",\n        500: \"viiii\",\n        1000: \"viiii\",\n        5000:\
    \ \"viiii\",\n        10000: \"viiii\",\n        50000: \"viiii\",\n        100000:\
    \ \"viiii\",\n        500000: \"viiii\",\n        1000000: \"viiii\",\n      \
    \  5000000: \"viiii\",\n        10000000: \"viiii\",\n        50000000: \"viiii\"\
    ,\n        100000000: \"viiii\",\n        500000000: \"viiii\",\n        1000000000:\
    \ \"viiii\",\n        5000000000: \"viiii\",\n        10000000000: \"viiii\",\n\
    \        50000000000: \"viiii\",\n        100000000000: \"viiii\",\n        500000000000:\
    \ \"viiii\",\n        1000000000000: \"viiii\",\n        5000000000000: \"viiii\"\
    ,\n        10000000000000: \"viiii\",\n        50000000000000: \"viiii\",\n  \
    \      100000000000000: \"viiii\",\n        500000000000000: \"viiii\",\n    \
    \    1000000000000000: \"viiii\",\n        5000000000000000: \"viiii\",\n    \
    \    1000000000000000000: \"viiii\",\n        50000000000000000: \"viiii\",\n\
    \        10000000000000000000: \"viiii\",\n        5000000000000000000: \"viiii\"\
    ,\n        100000000000000000000: \"viiii\",\n        50000000000000000000: \"\
    viiii\",\n        1000000000000000000000: \"viiii\",\n        500000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000: \"viiii\",\n        5000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000: \"viiii\",\n        50000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000: \"viiii\",\n        500000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000: \"viiii\",\n        5000000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000000: \"viiii\",\n        50000000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000000: \"viiii\",\n        500000000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000000: \"viiii\",\n        5000000000000000000000000000\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpquhcjrxs_test.go:73:37: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n\
    \        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"\
    LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\"\
    , \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\",\n        \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    ,\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"\
    CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\",\n   \
    \     \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    , \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\", \"CXXXIX\", \"CC\"\
    , \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\",\n        \"CCVII\"\
    , \"CCV\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp50v6obyd_test.go:34:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    roman, ok := romans[number]\n\
    \    if !ok {\n        fmt.Println(\"Invalid input\")\n    }\n    return roman\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp2pij8dq5_test.go:61: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp2pij8dq5_test.go:61: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp2pij8dq5_test.go:61:\
    \ expected 'd', got 'D'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp2pij8dq5_test.go:61: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp2pij8dq5_test.go:61: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmp2pij8dq5_test.go:61: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp2pij8dq5_test.go:61:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp2pij8dq5_test.go:61:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'm', got 'M'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075543
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n\
    \        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"\
    LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\"\
    , \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\",\n        \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    ,\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"\
    CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\",\n   \
    \     \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    , \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\", \"CXXXIX\", \"CC\"\
    , \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\",\n        \"CCVII\"\
    , \"CCV\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp50v6obyd_test.go:34:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"x\"\n    case 2:\n        roman_num = \"c\"\n    case 3:\n\
    \        roman_num = \"d\"\n    case 4:\n        roman_num = \"m\"\n    case 5:\n\
    \        roman_num = \"l\"\n    case 6:\n        roman_num = \"xl\"\n    case\
    \ 7:\n        roman_num = \"xc\"\n    case 8:\n        roman_num = \"xd\"\n  \
    \  case 9:\n        roman_num = \"xm\"\n    case 10:\n        roman_num = \"xl\"\
    \n    case 11:\n        roman_num = \"xc\"\n    case 12:\n        roman_num =\
    \ \"xd\"\n    case 13:\n        roman_num = \"xm\"\n    case 14:\n        roman_num\
    \ = \"l\"\n    case 15:\n        roman_num = \"c\"\n    case 16:\n        roman_num\
    \ = \"d\"\n    case 17:\n        roman_num = \"m\"\n    case 18:\n        roman_num\
    \ = \"l\"\n    case 19:\n        roman_num = \"xl\"\n    case 20:\n        roman_num\
    \ = \"xc\"\n    case 21:\n        roman_num = \"xd\"\n    case 22:\n        roman_num\
    \ = \"xm\"\n    case 23:\n        roman_num = \"l\"\n    case 24:\n        roman_num\
    \ = \"c\"\n    case 25:\n        roman_num = \"d\"\n    case 26:\n        roman_num\
    \ = \"m\"\n    case 27:\n        roman_num = \"l\"\n    case 28:\n        roman_num\
    \ = \"xl\"\n    case 29:\n        roman_num = \"xc\"\n    case 30:\n        roman_num\
    \ = \"xd\"\n    case 31:\n        roman_num = \"xm\"\n    case 32:\n        roman_num\
    \ = \"l\"\n    case 33:\n        roman_num = \"c\"\n    case 34:\n        roman_num\
    \ = \"d\"\n    case 35:\n        roman_num = \"m\"\n    case 36:\n        roman_num\
    \ = \"l\"\n    case 37:\n        roman_num = \"xl\"\n    case 38:\n        roman_num\
    \ = \"xc\"\n    case 39:\n        roman_num = \"xd\"\n    case 40:\n        roman_num\
    \ = \"xm\"\n    case 41:\n        roman_num = \"l\"\n    case 42:\n        roman_num\
    \ = \"c\"\n    case 43:\n        roman_num = \"d\"\n    case 44:\n        roman_num\
    \ = \"m\"\n    case 45\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqxuuwvw5_test.go:109:12: expected '':'', found newline

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n    }\n\n    roman_number\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_number)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp9sa41g53_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\"\
    ,\n        500: \"c\",\n        1000: \"d\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpryj9v5tx_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiii\",\n        500: \"viiii\",\n        1000: \"viiii\",\n        5000:\
    \ \"viiii\",\n        10000: \"viiii\",\n        50000: \"viiii\",\n        100000:\
    \ \"viiii\",\n        500000: \"viiii\",\n        1000000: \"viiii\",\n      \
    \  5000000: \"viiii\",\n        10000000: \"viiii\",\n        50000000: \"viiii\"\
    ,\n        100000000: \"viiii\",\n        500000000: \"viiii\",\n        1000000000:\
    \ \"viiii\",\n        5000000000: \"viiii\",\n        10000000000: \"viiii\",\n\
    \        50000000000: \"viiii\",\n        100000000000: \"viiii\",\n        500000000000:\
    \ \"viiii\",\n        1000000000000: \"viiii\",\n        5000000000000: \"viiii\"\
    ,\n        10000000000000: \"viiii\",\n        50000000000000: \"viiii\",\n  \
    \      100000000000000: \"viiii\",\n        500000000000000: \"viiii\",\n    \
    \    1000000000000000: \"viiii\",\n        5000000000000000: \"viiii\",\n    \
    \    1000000000000000000: \"viiii\",\n        50000000000000000: \"viiii\",\n\
    \        10000000000000000000: \"viiii\",\n        5000000000000000000: \"viiii\"\
    ,\n        100000000000000000000: \"viiii\",\n        50000000000000000000: \"\
    viiii\",\n        1000000000000000000000: \"viiii\",\n        500000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000: \"viiii\",\n        5000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000: \"viiii\",\n        50000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000: \"viiii\",\n        500000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000: \"viiii\",\n        5000000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000000: \"viiii\",\n        50000000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000000: \"viiii\",\n        500000000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000000: \"viiii\",\n        5000000000000000000000000000\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyo631ndu_test.go:73:37: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"x\"\n    case 5:\n        roman_num = \"v\"\n    case 10:\n\
    \        roman_num = \"i\"\n    case 20:\n        roman_num = \"x\"\n    case\
    \ 50:\n        roman_num = \"l\"\n    case 100:\n        roman_num = \"c\"\n \
    \   case 200:\n        roman_num = \"d\"\n    case 500:\n        roman_num = \"\
    l\"\n    case 1000:\n        roman_num = \"c\"\n    case 2000:\n        roman_num\
    \ = \"d\"\n    case 5000:\n        roman_num = \"l\"\n    case 10000:\n      \
    \  roman_num = \"c\"\n    case 20000:\n        roman_num = \"d\"\n    case 50000:\n\
    \        roman_num = \"l\"\n    case 100000:\n        roman_num = \"c\"\n    case\
    \ 200000:\n        roman_num = \"d\"\n    case 500000:\n        roman_num = \"\
    l\"\n    case 1000000:\n        roman_num = \"c\"\n    case 2000000:\n       \
    \ roman_num = \"d\"\n    case 5000000:\n        roman_num = \"l\"\n    case 10000000:\n\
    \        roman_num = \"c\"\n    case 20000000:\n        roman_num = \"d\"\n  \
    \  case 50000000:\n        roman_num = \"l\"\n    case 100000000:\n        roman_num\
    \ = \"c\"\n    case 200000000:\n        roman_num = \"d\"\n    case 500000000:\n\
    \        roman_num = \"l\"\n    case 1000000000:\n        roman_num = \"c\"\n\
    \    case 2000000000:\n        roman_num = \"d\"\n    case 5000000000:\n     \
    \   roman_num = \"l\"\n    case 10000000000:\n        roman_num = \"c\"\n    case\
    \ 20000000000:\n        roman_num = \"d\"\n    case 50000000000:\n        roman_num\
    \ = \"l\"\n    case 100000000000:\n        roman_num = \"c\"\n    case 200000000000:\n\
    \        roman_num = \"d\"\n    case 500000000000:\n        roman_num = \"l\"\n\
    \    case 1000000000000:\n        roman_num = \"c\"\n    case 2000000000000:\n\
    \        roman_num = \"d\"\n    case 5000000000000:\n        roman_num = \"l\"\
    \n    case 10000000000000:\n        roman_num = \"c\"\n    case 20000000000000:\n\
    \        roman_num = \"d\"\n    case 50000000000000:\n        roman_num\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpns7gw_l6_test.go:103:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return \"\"\n    }\n\n    roman_numerals := []string{\"\
    I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\"\
    , \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"\
    XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"\
    XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\",\
    \ \"LII\", \"LIII\", \"LIIII\", \"LIIV\", \"LIV\", \"LIVI\", \"LIVII\", \"LIVIII\"\
    , \"LIIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\"\
    , \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"\
    LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"\
    LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\"\
    , \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIII\", \"CIIII\"\
    , \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"\
    CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\"\
    , \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"\
    CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\"\
    , \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"\
    CC\", \"CCI\", \"CCII\", \"CCIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\"\
    , \"CIX\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmputoe9vz__test.go:24:1111: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viv\",\n        50000: \"viiv\",\n        100000: \"viv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        10000000: \"viv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\",\n     \
    \   5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n  \
    \  }\n    romanNumeral := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsh816rh3_test.go:55:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n\
    \        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"\
    LXVI\", \"LXVII\",\n        \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\"\
    , \"LXXIII\", \"LXXIV\", \"LXXV\",\n        \"LXXVI\", \"LXXVII\", \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\",\n        \"LXXXIV\"\
    , \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\"\
    ,\n        \"CI\", \"CII\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\",\n        \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\",\n        \"CIX\", \"CX\", \"CXI\"\
    , \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\",\n        \"CXVIII\"\
    , \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\",\n\
    \        \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\"\
    , \"CXIV\", \"CXV\",\n        \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\"\
    , \"CXI\", \"CXII\", \"CXIII\", \"CXIV\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmprags6t7k_test.go:34:73: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"vii\",\n        100: \"\
    vi\",\n        500: \"viii\",\n        1000: \"viii\",\n        5000: \"viii\"\
    ,\n        10000: \"viii\",\n        50000: \"viii\",\n        100000: \"viii\"\
    ,\n        500000: \"viii\",\n        1000000: \"viii\",\n        5000000: \"\
    viii\",\n        10000000: \"viii\",\n        50000000: \"viii\",\n        100000000:\
    \ \"viii\",\n        500000000: \"viii\",\n        1000000000: \"viii\",\n   \
    \     5000000000: \"viii\",\n        10000000000: \"viii\",\n        50000000000:\
    \ \"viii\",\n        100000000000: \"viii\",\n        500000000000: \"viii\",\n\
    \        1000000000000: \"viii\",\n        5000000000000: \"viii\",\n        10000000000000:\
    \ \"viii\",\n        50000000000000: \"viii\",\n        100000000000000: \"viii\"\
    ,\n        500000000000000: \"viii\",\n        1000000000000000: \"viii\",\n \
    \       5000000000000000: \"viii\",\n        1000000000000000000: \"viii\",\n\
    \        50000000000000000: \"viii\",\n        10000000000000000000: \"viii\"\
    ,\n        5000000000000000000: \"viii\",\n        100000000000000000000: \"viii\"\
    ,\n        50000000000000000000: \"viii\",\n        1000000000000000000000: \"\
    viii\",\n        500000000000000000000: \"viii\",\n        10000000000000000000000:\
    \ \"viii\",\n        5000000000000000000000: \"viii\",\n        100000000000000000000000:\
    \ \"viii\",\n        50000000000000000000000: \"viii\",\n        1000000000000000000000000:\
    \ \"viii\",\n        500000000000000000000000: \"viii\",\n        10000000000000000000000000:\
    \ \"viii\",\n        5000000000000000000000000: \"viii\",\n        100000000000000000000000000:\
    \ \"viii\",\n        50000000000000000000000000: \"viii\",\n        1000000000000000000000000000:\
    \ \"viii\",\n        500000000000000000000000000: \"viii\",\n        10000000000000000000000000000:\
    \ \"viii\",\n        5000000000000000000000000000: \"viii\",\n        100000000000000000000000000000:\
    \ \"viii\",\n        50000000000000000000000000000: \"viii\",\n        1000000000000000000000000000000:\
    \ \"viii\",\n        500000000000000000000000000000: \"viii\",\n        10000000000000000000000000000000:\
    \ \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_v80ifzm_test.go:78:43: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := \"\"\n\
    \    for romanNumeral, number := range romanNumerals {\n        if number <= number\
    \ {\n            break\n        }\n    }\n    if romanNumeral == \"\" {\n    \
    \    fmt.Println(\"Invalid input\")\n    }\n    return romanNumerals[number]\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp3on7gf4q_test.go:29:9: romanNumeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n        \"X\", \"XI\", \"XII\", \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\",\n        \"XX\"\
    , \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\",\n        \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"\
    LIX\",\n        \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\"\
    , \"LXVII\", \"LXVIII\", \"LXIX\",\n        \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\"\
    , \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\",\n      \
    \  \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\"\
    , \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\",\n        \"XC\", \"C\", \"CI\", \"CII\"\
    , \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\",\n\
    \        \"XC\", \"C\", \"CI\", \"CII\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"\
    CVI\", \"CVII\", \"CVIII\", \"CIX\",\n        \"XXC\", \"CC\", \"CCI\", \"CCII\"\
    , \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\",\n \
    \       \"XXXC\", \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\"\
    , \"CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"XLC\", \"LCC\", \"\
    LCCI\", \"LCCII\", \"LCCIII\", \"LCCIV\", \"LCCV\", \"LCCVI\", \"LCCV\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptti5pcm0_test.go:32:76: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viiv\",\n        50000: \"viiv\",\n        100000: \"viiv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viiv\",\n        5000000: \"\
    viiv\",\n        10000000: \"viiv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viiv\",\n        500000000: \"viiv\",\n        1000000000: \"viiv\",\n   \
    \     5000000000: \"viiv\",\n        10000000000: \"viiv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viiv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viiv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viiv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viiv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viiv\",\n \
    \       5000000000000000: \"viiv\",\n        1000000000000000000: \"viiv\",\n\
    \        50000000000000000: \"viiv\",\n        10000000000000000000: \"viiv\"\
    ,\n        5000000000000000000: \"viiv\",\n        100000000000000000000: \"viiv\"\
    ,\n        50000000000000000000: \"viiv\",\n        1000000000000000000000: \"\
    viiv\",\n        500000000000000000000: \"viiv\",\n        10000000000000000000000:\
    \ \"viiv\",\n        5000000000000000000000: \"viiv\",\n        100000000000000000000000:\
    \ \"viiv\",\n        50000000000000000000000: \"viiv\",\n        1000000000000000000000000:\
    \ \"viiv\",\n        500000000000000000000000: \"viiv\",\n        10000000000000000000000000:\
    \ \"viiv\",\n        5000000000000000000000000: \"viiv\",\n        100000000000000000000000000:\
    \ \"viiv\",\n        50000000000000000000000000: \"viiv\",\n        1000000000000000000000000000:\
    \ \"viiv\",\n        500000000000000000000000000: \"viiv\",\n        10000000000000000000000000000:\
    \ \"viiv\",\n        5000000000000000000000000000: \"viiv\",\n        100000000000000000000000000000:\
    \ \"viiv\",\n        50000000000000000000000000000: \"viiv\",\n        1000000000000000000000000000000:\
    \ \"viiv\",\n        500000000000000000000000000000: \"viiv\",\n        10000000000000000000000000000000\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_jylpam8_test.go:78:41: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 2:\n        roman_number = \"ix\"\n  \
    \  case 3:\n        roman_number = \"lb\"\n    case 4:\n        roman_number =\
    \ \"c\"\n    case 5:\n        roman_number = \"d\"\n    case 6:\n        roman_number\
    \ = \"mi\"\n    case 7:\n        roman_number = \"i\"\n    case 8:\n        roman_number\
    \ = \"vi\"\n    case 9:\n        roman_number = \"vix\"\n    case 10:\n      \
    \  roman_number = \"ix\"\n    case 11:\n        roman_number = \"lbi\"\n    case\
    \ 12:\n        roman_number = \"c\"\n    case 13:\n        roman_number = \"d\"\
    \n    case 14:\n        roman_number = \"mi\"\n    case 15:\n        roman_number\
    \ = \"i\"\n    case 16:\n        roman_number = \"vi\"\n    case 17:\n       \
    \ roman_number = \"vix\"\n    case 18:\n        roman_number = \"ix\"\n    case\
    \ 19:\n        roman_number = \"lbi\"\n    case 20:\n        roman_number = \"\
    c\"\n    case 21:\n        roman_number = \"d\"\n    case 22:\n        roman_number\
    \ = \"mi\"\n    case 23:\n        roman_number = \"i\"\n    case 24:\n       \
    \ roman_number = \"vi\"\n    case 25:\n        roman_number = \"vix\"\n    case\
    \ 26:\n        roman_number = \"ix\"\n    case 27:\n        roman_number = \"\
    lbi\"\n    case 28:\n        roman_number = \"c\"\n    case 29:\n        roman_number\
    \ = \"d\"\n    case 30:\n        roman_number = \"mi\"\n    case 31:\n       \
    \ roman_number = \"i\"\n    case 32:\n        roman_number = \"vi\"\n    case\
    \ 33:\n        roman_number = \"vix\"\n    case 34:\n        roman_number = \"\
    ix\"\n    case 35:\n        roman_number = \"lbi\"\n    case 36:\n        roman_number\
    \ = \"c\"\n    case 37:\n        roman_number = \"d\"\n    case 38:\n        roman_number\
    \ = \"mi\"\n    case 39:\n        roman_number = \"i\"\n    case 40:\n       \
    \ roman_number = \"vi\"\n    case 41:\n        roman_number = \"vix\"\n    case\
    \ 42:\n        roman_number = \"ix\"\n    case 43:\n        roman_number = \"\
    lbi\"\n    case 44:\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp39bh0upn_test.go:109:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viv\",\n        50000: \"viiv\",\n        100000: \"viv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        10000000: \"viv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\",\n     \
    \   5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n  \
    \      50000000000000000: \"viiv\",\n        10000000000000000000: \"viv\",\n\
    \        5000000000000000000: \"viiv\",\n        100000000000000000000: \"viv\"\
    ,\n        50000000000000000000: \"viiv\",\n        1000000000000000000000: \"\
    viv\",\n        500000000000000000000: \"viiv\",\n        10000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000: \"viiv\",\n        100000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000: \"viiv\",\n        1000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000: \"viiv\",\n        10000000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000000: \"viiv\",\n        100000000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000000: \"viiv\",\n        1000000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000000: \"viiv\",\n        10000000000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000000000: \"viiv\",\n        100000000000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000000000: \"viiv\",\n        1000000000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000000000: \"viiv\",\n        10000000000000000000000000000000\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqnpr9jni_test.go:78:41: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n\
    \        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\"\
    , \"CXXI\",\n        \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"\
    CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"\
    CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\"\
    , \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CV\", \"CVI\"\
    ,\n        \"CVII\", \"CVIII\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppsq4yepq_test.go:34:17: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    ix\",\n        500: \"ixi\",\n        1000: \"ixii\",\n    }\n    romanNumeral\
    \ := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprv6ttaer_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := \"\"\n\
    \    for romanNumeral, number := range romanNumerals {\n        if number >= number\
    \ {\n            break\n        }\n    }\n    return fmt.Sprintf(\"%s%v\", romanNumeral,\
    \ number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsau_j3cw_test.go:29:9: romanNumeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n\
    \        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    romanNumeral\
    \ := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp0xzgob4z_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"x\"\n    case 5:\n        roman_num = \"v\"\n    case 10:\n\
    \        roman_num = \"i\"\n    case 20:\n        roman_num = \"x\"\n    case\
    \ 50:\n        roman_num = \"l\"\n    case 100:\n        roman_num = \"c\"\n \
    \   case 200:\n        roman_num = \"d\"\n    case 400:\n        roman_num = \"\
    l\"\n    case 1000:\n        roman_num = \"m\"\n    case 2000:\n        roman_num\
    \ = \"c\"\n    case 4000:\n        roman_num = \"l\"\n    case 10000:\n      \
    \  roman_num = \"d\"\n    case 20000:\n        roman_num = \"c\"\n    case 40000:\n\
    \        roman_num = \"l\"\n    case 100000:\n        roman_num = \"m\"\n    case\
    \ 200000:\n        roman_num = \"c\"\n    case 400000:\n        roman_num = \"\
    l\"\n    case 1000000:\n        roman_num = \"m\"\n    case 2000000:\n       \
    \ roman_num = \"c\"\n    case 4000000:\n        roman_num = \"l\"\n    case 10000000:\n\
    \        roman_num = \"m\"\n    case 20000000:\n        roman_num = \"c\"\n  \
    \  case 40000000:\n        roman_num = \"l\"\n    case 100000000:\n        roman_num\
    \ = \"m\"\n    case 200000000:\n        roman_num = \"c\"\n    case 400000000:\n\
    \        roman_num = \"l\"\n    case 1000000000:\n        roman_num = \"m\"\n\
    \    case 2000000000:\n        roman_num = \"c\"\n    case 4000000000:\n     \
    \   roman_num = \"l\"\n    case 10000000000:\n        roman_num = \"m\"\n    case\
    \ 20000000000:\n        roman_num = \"c\"\n    case 40000000000:\n        roman_num\
    \ = \"l\"\n    case 100000000000:\n        roman_num = \"m\"\n    case 200000000000:\n\
    \        roman_num = \"c\"\n    case 400000000000:\n        roman_num = \"l\"\n\
    \    case 1000000000000:\n        roman_num = \"m\"\n    case 2000000000000:\n\
    \        roman_num = \"c\"\n    case 4000000000000:\n        roman_num = \"l\"\
    \n    case 10000000000000:\n        roman_num = \"m\"\n    case 20000000000000:\n\
    \        roman_num = \"c\"\n    case 40000000000000:\n        roman_num\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgi8asmz4_test.go:103:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral_string :=\
    \ \"\"\n    for roman_numeral, numeral_string := range roman_numerals {\n    \
    \    if number >= roman_numeral {\n            roman_numeral_string += numeral_string\n\
    \            number -= roman_numeral\n        }\n    }\n    return roman_numeral_string\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpbi1yo2a0_test.go:64: expected 'xix', got 'IVX'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpbi1yo2a0_test.go:64:\
    \ expected 'clii', got 'IVXL'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpbi1yo2a0_test.go:64: expected 'ccli', got 'IVXLC'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpbi1yo2a0_test.go:64:\
    \ expected 'cdxxvi', got 'CIVXL'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4\
    \ (0.00s)\n        tmpbi1yo2a0_test.go:64: expected 'd', got 'XLCIV'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpbi1yo2a0_test.go:64:\
    \ expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmpbi1yo2a0_test.go:64: expected 'iv', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmpbi1yo2a0_test.go:64: expected 'xliii', got 'IVX'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpbi1yo2a0_test.go:64:\
    \ expected 'xc', got 'IVXL'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n\
    \        tmpbi1yo2a0_test.go:64: expected 'xciv', got 'IVXL'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpbi1yo2a0_test.go:64: expected 'dxxxii', got 'IVXLC'\n  \
    \  --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpbi1yo2a0_test.go:64:\
    \ expected 'cm', got 'IVXLCD'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12\
    \ (0.00s)\n        tmpbi1yo2a0_test.go:64: expected 'cmxciv', got 'XLCDIV'\n \
    \   --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpbi1yo2a0_test.go:64:\
    \ expected 'm', got 'VXLCDI'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    roman,\
    \ ok := romans[number]\n    if !ok {\n        fmt.Println(\"int_to_mini_roman:\
    \ number too large\")\n    }\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "int_to_mini_roman: number too large\nint_to_mini_roman: number too large\n\
    int_to_mini_roman: number too large\nint_to_mini_roman: number too large\nint_to_mini_roman:\
    \ number too large\nint_to_mini_roman: number too large\nint_to_mini_roman: number\
    \ too large\nint_to_mini_roman: number too large\nint_to_mini_roman: number too\
    \ large\nint_to_mini_roman: number too large\nint_to_mini_roman: number too large\n\
    --- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp89tvqgd4_test.go:62: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp89tvqgd4_test.go:62: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp89tvqgd4_test.go:62: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp89tvqgd4_test.go:62: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp89tvqgd4_test.go:62:\
    \ expected 'd', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmp89tvqgd4_test.go:62: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmp89tvqgd4_test.go:62: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp89tvqgd4_test.go:62: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmp89tvqgd4_test.go:62: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmp89tvqgd4_test.go:62: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp89tvqgd4_test.go:62:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmp89tvqgd4_test.go:62: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp89tvqgd4_test.go:62: expected 'm', got 'd'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n\n    roman,\
    \ ok := romans[number]\n    if !ok {\n        fmt.Printf(\"ERROR: number %d is\
    \ not in valid range\\n\", number)\n    }\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "ERROR: number 19 is not in valid range\nERROR: number 152 is not in valid\
    \ range\nERROR: number 251 is not in valid range\nERROR: number 426 is not in\
    \ valid range\nERROR: number 4 is not in valid range\nERROR: number 43 is not\
    \ in valid range\nERROR: number 90 is not in valid range\nERROR: number 94 is\
    \ not in valid range\nERROR: number 532 is not in valid range\nERROR: number 900\
    \ is not in valid range\nERROR: number 994 is not in valid range\n--- FAIL: TestInt_To_Mini_Roman\
    \ (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpr_c4swl4_test.go:63:\
    \ expected 'xix', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n\
    \        tmpr_c4swl4_test.go:63: expected 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpr_c4swl4_test.go:63: expected 'ccli', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpr_c4swl4_test.go:63: expected\
    \ 'cdxxvi', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n\
    \        tmpr_c4swl4_test.go:63: expected 'd', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpr_c4swl4_test.go:63: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpr_c4swl4_test.go:63: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpr_c4swl4_test.go:63: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpr_c4swl4_test.go:63: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpr_c4swl4_test.go:63:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpr_c4swl4_test.go:63: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpr_c4swl4_test.go:63:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpr_c4swl4_test.go:63: expected 'm', got 'd'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n\
    \        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n        10000:\
    \ \"m\",\n        50000: \"m\",\n        100000: \"b\",\n        500000: \"b\"\
    ,\n        1000000: \"y\",\n        5000000: \"y\",\n        10000000: \"z\",\n\
    \        50000000: \"z\",\n    }\n    romanNumeralsLength := len(romanNumerals)\n\
    \    romanNumeral := \"\"\n    romanNumeralLength := 0\n    for number > 0 {\n\
    \        romanNumeralLength++\n        number -= romanNumerals[number]\n    }\n\
    \    for romanNumeralLength > 0 {\n        romanNumeral += romanNumerals[romanNumeralLength]\n\
    \        romanNumeralLength--\n    }\n    return strings.ToLower(romanNumeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmptbnaf3yk_test.go:37:5: romanNumeralsLength declared but not used

    /tmp/tmptbnaf3yk_test.go:42:9: invalid operation: number -= romanNumerals[number]
    (mismatched types int and string)

    /tmp/tmptbnaf3yk_test.go:48:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXI\",\n        \"XXII\", \"XXIII\", \"XXIV\", \"XXV\"\
    , \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\",\n        \"XXI\", \"XXII\"\
    , \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\",\n \
    \       \"XXX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"\
    XXVII\", \"XXVIII\",\n        \"XXIX\", \"XXX\", \"XXI\", \"XXII\", \"XXIII\"\
    , \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\",\n        \"XXVIII\", \"XXIX\", \"XXX\"\
    , \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\",\n        \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\"\
    ,\n        \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXI\", \"XXII\"\
    , \"XXIII\", \"XXIV\",\n        \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\"\
    , \"XXX\", \"XXI\", \"XXII\", \"XXIII\",\n        \"XXIV\", \"XXV\", \"XXVI\"\
    , \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXI\", \"XXII\",\n        \"XXIII\"\
    , \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXI\"\
    ,\n        \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\",\n        \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\"\
    , \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\",\n        \"XXX\", \"XXI\", \"XXII\"\
    , \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiom8zb_u_test.go:35:31: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    roman,\
    \ ok := romans[number]\n    if !ok {\n        fmt.Println(\"Invalid input\")\n\
    \    }\n    return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp0l3zxi9x_test.go:62: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp0l3zxi9x_test.go:62: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp0l3zxi9x_test.go:62: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp0l3zxi9x_test.go:62: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp0l3zxi9x_test.go:62:\
    \ expected 'd', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmp0l3zxi9x_test.go:62: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmp0l3zxi9x_test.go:62: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp0l3zxi9x_test.go:62: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmp0l3zxi9x_test.go:62: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmp0l3zxi9x_test.go:62: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp0l3zxi9x_test.go:62:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmp0l3zxi9x_test.go:62: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp0l3zxi9x_test.go:62: expected 'm', got 'd'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    result\
    \ := \"\"\n    for num, res := range romans {\n        if num >= number {\n  \
    \          result = res + result\n        }\n    }\n    return result\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpas91t02k_test.go:64: expected 'xix', got 'ddccl'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpas91t02k_test.go:64:\
    \ expected 'clii', got 'ddc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpas91t02k_test.go:64: expected 'ccli', got 'ddc'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpas91t02k_test.go:64:\
    \ expected 'cdxxvi', got 'cdd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4\
    \ (0.00s)\n        tmpas91t02k_test.go:64: expected 'd', got 'ddc'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpas91t02k_test.go:64: expected\
    \ 'i', got 'lviiddccl'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmpas91t02k_test.go:64: expected 'iv', got 'ddccllvi'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpas91t02k_test.go:64: expected\
    \ 'xliii', got 'dccld'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n\
    \        tmpas91t02k_test.go:64: expected 'xc', got 'ddcc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpas91t02k_test.go:64: expected 'xciv', got 'dccd'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpas91t02k_test.go:64:\
    \ expected 'dxxxii', got 'dd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpas91t02k_test.go:64: expected 'cm', got 'dd'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpas91t02k_test.go:64:\
    \ expected 'cmxciv', got 'dd'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpas91t02k_test.go:64: expected 'm', got 'dd'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"viii\",\n        50: \"vii\",\n        100: \"\
    vi\",\n        500: \"viii\",\n        1000: \"viii\",\n        5000: \"viii\"\
    ,\n        10000: \"viii\",\n        50000: \"viii\",\n        100000: \"viii\"\
    ,\n        500000: \"viii\",\n        1000000: \"viii\",\n        5000000: \"\
    viii\",\n        10000000: \"viii\",\n        50000000: \"viii\",\n        100000000:\
    \ \"viii\",\n        500000000: \"viii\",\n        1000000000: \"viii\",\n   \
    \     5000000000: \"viii\",\n        10000000000: \"viii\",\n        50000000000:\
    \ \"viii\",\n        100000000000: \"viii\",\n        500000000000: \"viii\",\n\
    \        1000000000000: \"viii\",\n        5000000000000: \"viii\",\n        10000000000000:\
    \ \"viii\",\n        50000000000000: \"viii\",\n        100000000000000: \"viii\"\
    ,\n        500000000000000: \"viii\",\n        1000000000000000: \"viii\",\n \
    \       5000000000000000: \"viii\",\n        1000000000000000000: \"viii\",\n\
    \        50000000000000000: \"viii\",\n        10000000000000000000: \"viii\"\
    ,\n        5000000000000000000: \"viii\",\n        100000000000000000000: \"viii\"\
    ,\n        50000000000000000000: \"viii\",\n        1000000000000000000000: \"\
    viii\",\n        500000000000000000000: \"viii\",\n        10000000000000000000000:\
    \ \"viii\",\n        5000000000000000000000: \"viii\",\n        100000000000000000000000:\
    \ \"viii\",\n        50000000000000000000000: \"viii\",\n        1000000000000000000000000:\
    \ \"viii\",\n        500000000000000000000000: \"viii\",\n        10000000000000000000000000:\
    \ \"viii\",\n        5000000000000000000000000: \"viii\",\n        100000000000000000000000000:\
    \ \"viii\",\n        50000000000000000000000000: \"viii\",\n        1000000000000000000000000000:\
    \ \"viii\",\n        500000000000000000000000000: \"viii\",\n        10000000000000000000000000000:\
    \ \"viii\",\n        5000000000000000000000000000: \"viii\",\n        100000000000000000000000000000:\
    \ \"viii\",\n        50000000000000000000000000000: \"viii\",\n        1000000000000000000000000000000:\
    \ \"viii\",\n        500000000000000000000000000000: \"viii\",\n        10000000000000000000000000000000:\
    \ \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpao6sn4u7_test.go:78:43: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiiii\",\n        500: \"viiiiix\",\n        1000: \"viiiiiix\",\n      \
    \  5000: \"viiiiiix\",\n        10000: \"viiiiiix\",\n        50000: \"viiiiiix\"\
    ,\n        100000: \"viiiiiix\",\n        500000: \"viiiiiix\",\n        1000000:\
    \ \"viiiiiix\",\n        5000000: \"viiiiiix\",\n        10000000: \"viiiiiix\"\
    ,\n        50000000: \"viiiiiix\",\n        100000000: \"viiiiiix\",\n       \
    \ 500000000: \"viiiiiix\",\n        1000000000: \"viiiiiix\",\n        5000000000:\
    \ \"viiiiiix\",\n        10000000000: \"viiiiiix\",\n        50000000000: \"viiiiiix\"\
    ,\n        100000000000: \"viiiiiix\",\n        500000000000: \"viiiiiix\",\n\
    \        1000000000000: \"viiiiiix\",\n        5000000000000: \"viiiiiix\",\n\
    \        10000000000000: \"viiiiiix\",\n        50000000000000: \"viiiiiix\",\n\
    \        100000000000000: \"viiiiiix\",\n        500000000000000: \"viiiiiix\"\
    ,\n        1000000000000000: \"viiiiiix\",\n        5000000000000000: \"viiiiiix\"\
    ,\n        10000000000000000: \"viiiiiix\",\n        5000000000000000: \"viiiiiix\"\
    ,\n        100000000000000000: \"viiiiiix\",\n        50000000000000000: \"viiiiiix\"\
    ,\n        1000000000000000000: \"viiiiiix\",\n        500000000000000000: \"\
    viiiiiix\",\n        10000000000000000000: \"viiiiiix\",\n        5000000000000000000:\
    \ \"viiiiiix\",\n        100000000000000000000: \"viiiiiix\",\n        50000000000000000000:\
    \ \"viiiiiix\",\n        1000000000000000000000: \"viiiiiix\",\n        500000000000000000000:\
    \ \"viiiiiix\",\n        10000000000000000000000: \"viiiiiix\",\n        5000000000000000000000:\
    \ \"viiiiiix\",\n        100000000000000000000000: \"viiiiiix\",\n        50000000000000000000000:\
    \ \"viiiiiix\",\n        1000000000000000000000000: \"viiiiiix\",\n        500000000000000000000000:\
    \ \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp10f7a29e_test.go:69:35: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viiv\",\n        50000: \"viiv\",\n        100000: \"viiv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        10000000: \"viiv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\",\n     \
    \   5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n  \
    \  }\n\n    romanNumeral := romanNumerals[number]\n    if romanNumeral == \"\"\
    \ {\n        fmt.Printf(\"ERROR: number too large, must be <= 1000\\n\")\n   \
    \ }\n    return romanNumeral\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n\
    \  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "ERROR: number too large, must be <= 1000\nERROR: number too large, must\
    \ be <= 1000\nERROR: number too large, must be <= 1000\nERROR: number too large,\
    \ must be <= 1000\nERROR: number too large, must be <= 1000\nERROR: number too\
    \ large, must be <= 1000\nERROR: number too large, must be <= 1000\nERROR: number\
    \ too large, must be <= 1000\nERROR: number too large, must be <= 1000\nERROR:\
    \ number too large, must be <= 1000\nERROR: number too large, must be <= 1000\n\
    --- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp87wtizk9_test.go:88: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp87wtizk9_test.go:88: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp87wtizk9_test.go:88: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp87wtizk9_test.go:88: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp87wtizk9_test.go:88:\
    \ expected 'd', got 'viiv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmp87wtizk9_test.go:88: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmp87wtizk9_test.go:88: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp87wtizk9_test.go:88: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmp87wtizk9_test.go:88: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmp87wtizk9_test.go:88: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp87wtizk9_test.go:88:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmp87wtizk9_test.go:88: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp87wtizk9_test.go:88: expected 'm', got 'viv'\nFAIL\nFAIL\t\
    command-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075546
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    ix\",\n        500: \"ixi\",\n        1000: \"ixii\",\n    }\n    romanNumeral\
    \ := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprv6ttaer_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n  \
    \  case 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number\
    \ = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiuqg9dqn_test.go:101:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n\
    \        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"\
    LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\"\
    , \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\",\n        \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    ,\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"\
    CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CIV\",\
    \ \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n\
    \        \"CXIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"\
    CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CIV\",\
    \ \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n\
    \        \"CXIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"\
    \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp92cx8ymg_test.go:34:62: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"\
    XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\"\
    , \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LIII\"\
    , \"LIIII\", \"LIIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"LIX\", \"LX\",\
    \ \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\"\
    , \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"\
    LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\",\
    \ \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"\
    LXXXIX\", \"XC\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"\
    CM\", \"M\", \"MM\", \"MMM\", \"MMMM\", \"MMMMM\", \"MMMMMM\", \"MMMMMMM\", \"\
    MMMMMMMM\", \"MMMMMMMMM\", \"MMMMMMMMMM\", \"MMMMMMMMMMM\", \"MMMMMMMMMMMM\",\
    \ \"MMMMMMMMMMMMM\", \"MMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMM\"\
    , \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"\
    MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM\", \"\
    MMMMMMMM\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnfal75rn_test.go:20:1411: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\"\
    ,\n        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n  \
    \  roman_numeral := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsl805vh2_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n\n    roman_number := roman_numerals[number]\n\
    \    return strings.ToLower(roman_number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmphsfr4142_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp_5nfdwfy_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiii\",\n        500: \"viiii\",\n        1000: \"viiii\",\n        5000:\
    \ \"viiii\",\n        10000: \"viiii\",\n        50000: \"viiii\",\n        100000:\
    \ \"viiii\",\n        500000: \"viiii\",\n        1000000: \"viiii\",\n      \
    \  5000000: \"viiii\",\n        10000000: \"viiii\",\n        50000000: \"viiii\"\
    ,\n        100000000: \"viiii\",\n        500000000: \"viiii\",\n        1000000000:\
    \ \"viiii\",\n        5000000000: \"viiii\",\n        10000000000: \"viiii\",\n\
    \        50000000000: \"viiii\",\n        100000000000: \"viiii\",\n        500000000000:\
    \ \"viiii\",\n        1000000000000: \"viiii\",\n        5000000000000: \"viiii\"\
    ,\n        10000000000000: \"viiii\",\n        50000000000000: \"viiii\",\n  \
    \      100000000000000: \"viiii\",\n        500000000000000: \"viiii\",\n    \
    \    1000000000000000: \"viiii\",\n        5000000000000000: \"viiii\",\n    \
    \    1000000000000000000: \"viiii\",\n        50000000000000000: \"viiii\",\n\
    \        10000000000000000000: \"viiii\",\n        5000000000000000000: \"viiii\"\
    ,\n        100000000000000000000: \"viiii\",\n        50000000000000000000: \"\
    viiii\",\n        1000000000000000000000: \"viiii\",\n        500000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000: \"viiii\",\n        5000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000: \"viiii\",\n        50000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000: \"viiii\",\n        500000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000: \"viiii\",\n        5000000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000000: \"viiii\",\n        50000000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000000: \"viiii\",\n        500000000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000000: \"viiii\",\n        5000000000000000000000000000\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpquhcjrxs_test.go:73:37: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 2:\n        roman_number = \"ix\"\n  \
    \  case 3:\n        roman_number = \"lb\"\n    case 4:\n        roman_number =\
    \ \"c\"\n    case 5:\n        roman_number = \"d\"\n    case 6:\n        roman_number\
    \ = \"mi\"\n    case 7:\n        roman_number = \"f\"\n    case 8:\n        roman_number\
    \ = \"v\"\n    case 9:\n        roman_number = \"x\"\n    case 10:\n        roman_number\
    \ = \"c\"\n    case 11:\n        roman_number = \"d\"\n    case 12:\n        roman_number\
    \ = \"mi\"\n    case 13:\n        roman_number = \"f\"\n    case 14:\n       \
    \ roman_number = \"v\"\n    case 15:\n        roman_number = \"x\"\n    case 16:\n\
    \        roman_number = \"c\"\n    case 17:\n        roman_number = \"d\"\n  \
    \  case 18:\n        roman_number = \"mi\"\n    case 19:\n        roman_number\
    \ = \"f\"\n    case 20:\n        roman_number = \"v\"\n    case 21:\n        roman_number\
    \ = \"x\"\n    case 22:\n        roman_number = \"c\"\n    case 23:\n        roman_number\
    \ = \"d\"\n    case 24:\n        roman_number = \"mi\"\n    case 25:\n       \
    \ roman_number = \"f\"\n    case 26:\n        roman_number = \"v\"\n    case 27:\n\
    \        roman_number = \"x\"\n    case 28:\n        roman_number = \"c\"\n  \
    \  case 29:\n        roman_number = \"d\"\n    case 30:\n        roman_number\
    \ = \"mi\"\n    case 31:\n        roman_number = \"f\"\n    case 32:\n       \
    \ roman_number = \"v\"\n    case 33:\n        roman_number = \"x\"\n    case 34:\n\
    \        roman_number = \"c\"\n    case 35:\n        roman_number = \"d\"\n  \
    \  case 36:\n        roman_number = \"mi\"\n    case 37:\n        roman_number\
    \ = \"f\"\n    case 38:\n        roman_number = \"v\"\n    case 39:\n        roman_number\
    \ = \"x\"\n    case 40:\n        roman_number = \"c\"\n    case 41:\n        roman_number\
    \ = \"d\"\n    case 42:\n        roman_number = \"mi\"\n    case 43:\n       \
    \ roman_number = \"f\"\n    case 44:\n        roman_number = \"v\"\n    case 45:\n\
    \        roman_number = \"x\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnlviqury_test.go:111:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viv\",\n        50000: \"viiv\",\n        100000: \"viv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        10000000: \"viv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\",\n     \
    \   5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n  \
    \  }\n    roman_numeral := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjpk432sl_test.go:55:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpszcenp2e_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    romanNumeral += string(number % 10)\n    return strings.ToLower(romanNumeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpy4_t_qog_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vi\",\n\
    \        10000: \"vi\",\n        50000: \"vi\",\n        100000: \"vi\",\n   \
    \     500000: \"vi\",\n        1000000: \"vi\",\n        5000000: \"vi\",\n  \
    \      10000000: \"vi\",\n        50000000: \"vi\",\n        100000000: \"vi\"\
    ,\n        500000000: \"vi\",\n        1000000000: \"vi\",\n        5000000000:\
    \ \"vi\",\n        10000000000: \"vi\",\n        50000000000: \"vi\",\n      \
    \  100000000000: \"vi\",\n        500000000000: \"vi\",\n        1000000000000:\
    \ \"vi\",\n        5000000000000: \"vi\",\n        10000000000000: \"vi\",\n \
    \       50000000000000: \"vi\",\n        100000000000000: \"vi\",\n        500000000000000:\
    \ \"vi\",\n        1000000000000000: \"vi\",\n        5000000000000000: \"vi\"\
    ,\n        1000000000000000000: \"vi\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpo8ihuf8l_test.go:55:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"viii\",\n        50: \"vii\",\n        100: \"\
    vi\",\n        500: \"viii\",\n        1000: \"viii\",\n        5000: \"viii\"\
    ,\n        10000: \"viii\",\n        50000: \"viii\",\n        100000: \"viii\"\
    ,\n        500000: \"viii\",\n        1000000: \"viii\",\n        5000000: \"\
    viii\",\n        10000000: \"viii\",\n        50000000: \"viii\",\n        100000000:\
    \ \"viii\",\n        500000000: \"viii\",\n        1000000000: \"viii\",\n   \
    \     5000000000: \"viii\",\n        10000000000: \"viii\",\n        50000000000:\
    \ \"viii\",\n        100000000000: \"viii\",\n        500000000000: \"viii\",\n\
    \        1000000000000: \"viii\",\n        5000000000000: \"viii\",\n        10000000000000:\
    \ \"viii\",\n        50000000000000: \"viii\",\n        100000000000000: \"viii\"\
    ,\n        500000000000000: \"viii\",\n        1000000000000000: \"viii\",\n \
    \       5000000000000000: \"viii\",\n        1000000000000000000: \"viii\",\n\
    \    }\n\n    roman_numeral := \"\"\n    for roman_numeral, number := range roman_numerals\
    \ {\n        if number <= number {\n            break\n        }\n    }\n\n  \
    \  if number > 0 {\n        roman_numeral = roman_numeral[:len(roman_numeral)-len(roman_numeral)%10]\n\
    \    }\n\n    return fmt.Sprintf(\"%s%v\", roman_numeral, number)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwhy2si5t_test.go:56:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n    }\n\n    roman_number\
    \ := roman_numerals[number]\n\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n\n    return roman_number\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp33exw1e2_test.go:64: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp33exw1e2_test.go:64: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp33exw1e2_test.go:64: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp33exw1e2_test.go:64: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp33exw1e2_test.go:64:\
    \ expected 'd', got 'viv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmp33exw1e2_test.go:64: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmp33exw1e2_test.go:64: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp33exw1e2_test.go:64: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmp33exw1e2_test.go:64: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmp33exw1e2_test.go:64: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp33exw1e2_test.go:64:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmp33exw1e2_test.go:64: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp33exw1e2_test.go:64: expected 'm', got 'vi'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075547
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n    }\n    roman_numeral_string\
    \ := \"\"\n    for _, roman_numeral := range roman_numerals {\n        if number\
    \ >= roman_numeral {\n            roman_numeral_string = roman_numerals[roman_numeral]\n\
    \            break\n        }\n    }\n    return strings.ToLower(roman_numeral_string)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpx_b2mg0h_test.go:30:22: invalid operation: number >= roman_numeral (mismatched
    types int and string)

    /tmp/tmpx_b2mg0h_test.go:31:51: cannot use roman_numeral (variable of type string)
    as type int in map index

    /tmp/tmpx_b2mg0h_test.go:35:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viv\",\n        50000: \"viiv\",\n        100000: \"viv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        10000000: \"viv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\",\n     \
    \   5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n  \
    \      50000000000000000: \"viiv\",\n        10000000000000000000: \"viv\",\n\
    \        5000000000000000000: \"viiv\",\n        100000000000000000000: \"viv\"\
    ,\n        50000000000000000000: \"viiv\",\n        1000000000000000000000: \"\
    viv\",\n        500000000000000000000: \"viiv\",\n        10000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000: \"viiv\",\n        100000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000: \"viiv\",\n        1000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000: \"viiv\",\n        10000000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000000: \"viiv\",\n        100000000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000000: \"viiv\",\n        1000000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000000: \"viiv\",\n        10000000000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000000000: \"viiv\",\n        100000000000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000000000: \"viiv\",\n        1000000000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000000000: \"viiv\",\n        10000000000000000000000000000000\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqibzoj_7_test.go:78:41: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\",\n    }\n    roman_number := 0\n    for _, roman_letter :=\
    \ range romans {\n        roman_number += int(number/len(romans))\n        number\
    \ %= len(romans)\n        if number == 0 {\n            return roman_letter\n\
    \        }\n    }\n    return fmt.Sprintf(\"%v\", number)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpctraojbp_test.go:61: expected 'xix', got '19'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpctraojbp_test.go:61: expected\
    \ 'clii', got '2'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n \
    \       tmpctraojbp_test.go:61: expected 'ccli', got '11'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpctraojbp_test.go:61: expected 'cdxxvi', got '6'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpctraojbp_test.go:61:\
    \ expected 'd', got '20'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpctraojbp_test.go:61: expected 'i', got '1'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpctraojbp_test.go:61: expected 'iv', got '4'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpctraojbp_test.go:61: expected\
    \ 'xliii', got '13'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n\
    \        tmpctraojbp_test.go:61: expected 'xc', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpctraojbp_test.go:61: expected 'xciv', got '4'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpctraojbp_test.go:61:\
    \ expected 'dxxxii', got '22'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpctraojbp_test.go:61: expected 'cm', got 'I'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpctraojbp_test.go:61:\
    \ expected 'cmxciv', got '4'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpctraojbp_test.go:61: expected 'm', got '10'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiii\",\n        500: \"viiii\",\n        1000: \"viiii\",\n        5000:\
    \ \"viiii\",\n        10000: \"viiii\",\n        50000: \"viiii\",\n        100000:\
    \ \"viiii\",\n        500000: \"viiii\",\n        1000000: \"viiii\",\n      \
    \  5000000: \"viiii\",\n        10000000: \"viiii\",\n        50000000: \"viiii\"\
    ,\n        100000000: \"viiii\",\n        500000000: \"viiii\",\n        1000000000:\
    \ \"viiii\",\n        5000000000: \"viiii\",\n        10000000000: \"viiii\",\n\
    \        50000000000: \"viiii\",\n        100000000000: \"viiii\",\n        500000000000:\
    \ \"viiii\",\n        1000000000000: \"viiii\",\n        5000000000000: \"viiii\"\
    ,\n        10000000000000: \"viiii\",\n        50000000000000: \"viiii\",\n  \
    \      100000000000000: \"viiii\",\n        500000000000000: \"viiii\",\n    \
    \    1000000000000000: \"viiii\",\n        5000000000000000: \"viiii\",\n    \
    \    1000000000000000000: \"viiii\",\n        50000000000000000: \"viiii\",\n\
    \        10000000000000000000: \"viiii\",\n        5000000000000000000: \"viiii\"\
    ,\n        100000000000000000000: \"viiii\",\n        50000000000000000000: \"\
    viiii\",\n        1000000000000000000000: \"viiii\",\n        500000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000: \"viiii\",\n        5000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000: \"viiii\",\n        50000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000: \"viiii\",\n        500000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000: \"viiii\",\n        5000000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000000: \"viiii\",\n        50000000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000000: \"viiii\",\n        500000000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000000: \"viiii\",\n        5000000000000000000000000000\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpquhcjrxs_test.go:73:37: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := \"\"\n\
    \    for romanNumeral, numeral := range romanNumerals {\n        if number >=\
    \ numeral {\n            number -= numeral\n            break\n        }\n   \
    \ }\n    return fmt.Sprintf(\"%c%c\", romanNumerals[number], romanNumerals[number])\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpr2skvrg2_test.go:28:5: romanNumeral declared but not used

    /tmp/tmpr2skvrg2_test.go:29:9: romanNumeral declared but not used

    /tmp/tmpr2skvrg2_test.go:30:22: invalid operation: number >= numeral (mismatched
    types int and string)

    /tmp/tmpr2skvrg2_test.go:31:13: invalid operation: number -= numeral (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viiii\",\n        5000: \"viiiii\"\
    ,\n    }\n    romanNumerals[number] = \"\"\n    romanNumerals[number / 1000] =\
    \ \"vi\"\n    romanNumerals[number / 500] = \"vii\"\n    romanNumerals[number\
    \ / 100] = \"viii\"\n    romanNumerals[number / 50] = \"viiii\"\n    romanNumerals[number\
    \ / 10] = \"viv\"\n    romanNumerals[number / 5] = \"viivi\"\n    romanNumerals[number\
    \ / 2] = \"viiii\"\n    romanNumerals[number / 1] = \"viiiii\"\n    romanNumerals[number\
    \ / 10] = \"viv\"\n    romanNumerals[number / 5] = \"viivi\"\n    romanNumerals[number\
    \ / 2] = \"viiii\"\n    romanNumerals[number / 1] = \"viiiii\"\n    romanNumerals[number\
    \ / 10] = \"viv\"\n    romanNumerals[number / 5] = \"viivi\"\n    romanNumerals[number\
    \ / 2] = \"viiii\"\n    romanNumerals[number / 1] = \"viiiii\"\n    romanNumerals[number\
    \ / 10] = \"viv\"\n    romanNumerals[number / 5] = \"viivi\"\n    romanNumerals[number\
    \ / 2] = \"viiii\"\n    romanNumerals[number / 1] = \"viiiii\"\n    romanNumerals[number\
    \ / 10] = \"viv\"\n    romanNumerals[number / 5] = \"viivi\"\n    romanNumerals[number\
    \ / 2] = \"viiii\"\n    romanNumerals[number / 1] = \"viiiii\"\n    romanNumerals[number\
    \ / 10] = \"viv\"\n    romanNumerals[number / 5] = \"viivi\"\n    romanNumerals[number\
    \ / 2] = \"viiii\"\n    romanNumerals[number / 1] = \"viiiii\"\n    romanNumerals[number\
    \ / 10] = \"viv\"\n    romanNumerals[\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiwe1v400_test.go:60:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"IV\", \"V\", \"IX\"\
    , \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\",\n        \"M\",\
    \ \"MM\", \"MMM\",\n    }\n    result := \"\"\n    for _, romanIndex := range\
    \ romans {\n        result += romanIndex\n        if number >= romanIndex {\n\
    \            number -= romanIndex\n        }\n    }\n    return strings.ToLower(result)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprptmwdna_test.go:26:22: invalid operation: number >= romanIndex (mismatched
    types int and string)

    /tmp/tmprptmwdna_test.go:27:13: invalid operation: number -= romanIndex (mismatched
    types int and string)

    /tmp/tmprptmwdna_test.go:30:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    roman, ok := romans[number]\n\
    \    if !ok {\n        fmt.Println(\"Invalid input\")\n    }\n    return roman\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\n\
    Invalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid input\nInvalid\
    \ input\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp2pij8dq5_test.go:61: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp2pij8dq5_test.go:61: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp2pij8dq5_test.go:61:\
    \ expected 'd', got 'D'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp2pij8dq5_test.go:61: expected 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp2pij8dq5_test.go:61: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmp2pij8dq5_test.go:61: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp2pij8dq5_test.go:61:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp2pij8dq5_test.go:61:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmp2pij8dq5_test.go:61: expected 'm', got 'M'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075543
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n\
    \        500: \"c\",\n        1000: \"d\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp90kp2m64_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp47lawrce_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    int_to_mini_roman: Invalid input\")\n    }\n\n    roman_numerals := []string{\n\
    \        \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"\
    IX\", \"X\", \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"\
    XVIII\", \"XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"\
    XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\"\
    , \"XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\",\
    \ \"L\", \"LI\", \"LII\", \"LIII\", \"LIIII\", \"LIIV\", \"LV\", \"LVI\", \"LVII\"\
    , \"LVIII\", \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\"\
    , \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"\
    LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\",\
    \ \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\"\
    , \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIII\"\
    , \"CIIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"\
    CXI\", \"CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\"\
    , \"CXIX\", \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"\
    CXXVI\", \"CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\",\
    \ \"CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"\
    CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\", \"\
    CCVII\", \"CCV\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpq1129at7_test.go:24:1078: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 2:\n        roman_number = \"ix\"\n  \
    \  case 3:\n        roman_number = \"lb\"\n    case 4:\n        roman_number =\
    \ \"c\"\n    case 5:\n        roman_number = \"d\"\n    case 6:\n        roman_number\
    \ = \"ix\"\n    case 7:\n        roman_number = \"lb\"\n    case 8:\n        roman_number\
    \ = \"c\"\n    case 9:\n        roman_number = \"d\"\n    case 10:\n        roman_number\
    \ = \"ix\"\n    case 11:\n        roman_number = \"lb\"\n    case 12:\n      \
    \  roman_number = \"c\"\n    case 13:\n        roman_number = \"d\"\n    case\
    \ 14:\n        roman_number = \"ix\"\n    case 15:\n        roman_number = \"\
    lb\"\n    case 16:\n        roman_number = \"c\"\n    case 17:\n        roman_number\
    \ = \"d\"\n    case 18:\n        roman_number = \"ix\"\n    case 19:\n       \
    \ roman_number = \"lb\"\n    case 20:\n        roman_number = \"c\"\n    case\
    \ 21:\n        roman_number = \"d\"\n    case 22:\n        roman_number = \"ix\"\
    \n    case 23:\n        roman_number = \"lb\"\n    case 24:\n        roman_number\
    \ = \"c\"\n    case 25:\n        roman_number = \"d\"\n    case 26:\n        roman_number\
    \ = \"ix\"\n    case 27:\n        roman_number = \"lb\"\n    case 28:\n      \
    \  roman_number = \"c\"\n    case 29:\n        roman_number = \"d\"\n    case\
    \ 30:\n        roman_number = \"ix\"\n    case 31:\n        roman_number = \"\
    lb\"\n    case 32:\n        roman_number = \"c\"\n    case 33:\n        roman_number\
    \ = \"d\"\n    case 34:\n        roman_number = \"ix\"\n    case 35:\n       \
    \ roman_number = \"lb\"\n    case 36:\n        roman_number = \"c\"\n    case\
    \ 37:\n        roman_number = \"d\"\n    case 38:\n        roman_number = \"ix\"\
    \n    case 39:\n        roman_number = \"lb\"\n    case 40:\n        roman_number\
    \ = \"c\"\n    case 41:\n        roman_number = \"d\"\n    case 42:\n        roman_number\
    \ = \"ix\"\n    case 43:\n        roman_number = \"lb\"\n    case 44:\n      \
    \  roman_number = \"c\"\n    case 45:\n        roman_\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpmm1yp02d_test.go:111:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vii\",\n\
    \        10000: \"viii\",\n        100000: \"viv\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwlijy91d_test.go:32:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075540
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"x\"\n    case 2:\n        roman_num = \"x\"\n    case 3:\n\
    \        roman_num = \"x\"\n    case 4:\n        roman_num = \"x\"\n    case 5:\n\
    \        roman_num = \"x\"\n    case 6:\n        roman_num = \"x\"\n    case 7:\n\
    \        roman_num = \"x\"\n    case 8:\n        roman_num = \"x\"\n    case 9:\n\
    \        roman_num = \"x\"\n    case 10:\n        roman_num = \"x\"\n    case\
    \ 11:\n        roman_num = \"x\"\n    case 12:\n        roman_num = \"x\"\n  \
    \  case 13:\n        roman_num = \"x\"\n    case 14:\n        roman_num = \"x\"\
    \n    case 15:\n        roman_num = \"x\"\n    case 16:\n        roman_num = \"\
    x\"\n    case 17:\n        roman_num = \"x\"\n    case 18:\n        roman_num\
    \ = \"x\"\n    case 19:\n        roman_num = \"x\"\n    case 20:\n        roman_num\
    \ = \"x\"\n    case 21:\n        roman_num = \"x\"\n    case 22:\n        roman_num\
    \ = \"x\"\n    case 23:\n        roman_num = \"x\"\n    case 24:\n        roman_num\
    \ = \"x\"\n    case 25:\n        roman_num = \"x\"\n    case 26:\n        roman_num\
    \ = \"x\"\n    case 27:\n        roman_num = \"x\"\n    case 28:\n        roman_num\
    \ = \"x\"\n    case 29:\n        roman_num = \"x\"\n    case 30:\n        roman_num\
    \ = \"x\"\n    case 31:\n        roman_num = \"x\"\n    case 32:\n        roman_num\
    \ = \"x\"\n    case 33:\n        roman_num = \"x\"\n    case 34:\n        roman_num\
    \ = \"x\"\n    case 35:\n        roman_num = \"x\"\n    case 36:\n        roman_num\
    \ = \"x\"\n    case 37:\n        roman_num = \"x\"\n    case 38:\n        roman_num\
    \ = \"x\"\n    case 39:\n        roman_num = \"x\"\n    case 40:\n        roman_num\
    \ = \"x\"\n    case 41:\n        roman_num = \"x\"\n    case 42:\n        roman_num\
    \ = \"x\"\n    case 43:\n        roman_num = \"x\"\n    case 44:\n        roman_num\
    \ = \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpidila2n5_test.go:108:21: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\",\n        \"\
    XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\"\
    ,\n        \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\",\n        \"XXIX\", \"XXX\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\"\
    , \"XXVII\", \"XXVIII\",\n        \"XXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"\
    LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\",\n        \"LVII\", \"LVIII\", \"LX\"\
    , \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\",\n        \"LXVII\"\
    , \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\",\n\
    \        \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"\
    LXXIII\",\n        \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"\
    LXXIX\", \"LXXX\",\n        \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    , \"LXXVIII\", \"LXXIX\",\n        \"LXXX\", \"LXXIII\", \"LXXIV\", \"LXXV\",\
    \ \"LXXVI\", \"LXXVII\", \"LXXVIII\",\n        \"LXXIX\", \"LXXX\", \"LXXIII\"\
    , \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\",\n        \"LXXVIII\", \"LXXIX\"\
    , \"LXXX\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\",\n        \"LXXVII\", \"\
    LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXIII\", \"LXXIV\", \"LXXV\",\n        \"LXXVI\"\
    , \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXIII\", \"LXXIV\",\n     \
    \   \"LXXV\", \"LXX\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate :=\
    \ int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp002i3yem_test.go:35:17: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    ix\",\n        500: \"ixi\",\n        1000: \"ixii\",\n    }\n    romanNumeral\
    \ := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprv6ttaer_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n\
    \        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\",\
    \ \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\"\
    , \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\"\
    ,\n        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\"\
    , \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8l8t_zot_test.go:34:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_numeral := roman_numerals[number]\n\
    \    mini_roman_numeral := \"\"\n    for _, letter := range roman_numeral {\n\
    \        mini_roman_numeral += letter\n    }\n    return mini_roman_numeral\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp93q_8xat_test.go:31:9: invalid operation: mini_roman_numeral += letter
    (mismatched types string and rune)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 2:\n        roman_number = \"ix\"\n  \
    \  case 3:\n        roman_number = \"lb\"\n    case 4:\n        roman_number =\
    \ \"c\"\n    case 5:\n        roman_number = \"d\"\n    case 6:\n        roman_number\
    \ = \"mi\"\n    case 7:\n        roman_number = \"f\"\n    case 8:\n        roman_number\
    \ = \"v\"\n    case 9:\n        roman_number = \"x\"\n    case 10:\n        roman_number\
    \ = \"c\"\n    case 11:\n        roman_number = \"d\"\n    case 12:\n        roman_number\
    \ = \"mi\"\n    case 13:\n        roman_number = \"f\"\n    case 14:\n       \
    \ roman_number = \"v\"\n    case 15:\n        roman_number = \"x\"\n    case 16:\n\
    \        roman_number = \"c\"\n    case 17:\n        roman_number = \"d\"\n  \
    \  case 18:\n        roman_number = \"mi\"\n    case 19:\n        roman_number\
    \ = \"f\"\n    case 20:\n        roman_number = \"v\"\n    case 21:\n        roman_number\
    \ = \"x\"\n    case 22:\n        roman_number = \"c\"\n    case 23:\n        roman_number\
    \ = \"d\"\n    case 24:\n        roman_number = \"mi\"\n    case 25:\n       \
    \ roman_number = \"f\"\n    case 26:\n        roman_number = \"v\"\n    case 27:\n\
    \        roman_number = \"x\"\n    case 28:\n        roman_number = \"c\"\n  \
    \  case 29:\n        roman_number = \"d\"\n    case 30:\n        roman_number\
    \ = \"mi\"\n    case 31:\n        roman_number = \"f\"\n    case 32:\n       \
    \ roman_number = \"v\"\n    case 33:\n        roman_number = \"x\"\n    case 34:\n\
    \        roman_number = \"c\"\n    case 35:\n        roman_number = \"d\"\n  \
    \  case 36:\n        roman_number = \"mi\"\n    case 37:\n        roman_number\
    \ = \"f\"\n    case 38:\n        roman_number = \"v\"\n    case 39:\n        roman_number\
    \ = \"x\"\n    case 40:\n        roman_number = \"c\"\n    case 41:\n        roman_number\
    \ = \"d\"\n    case 42:\n        roman_number = \"mi\"\n    case 43:\n       \
    \ roman_number = \"f\"\n    case 44:\n        roman_number = \"v\"\n    case 45:\n\
    \        roman_number = \"x\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpnlviqury_test.go:111:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075545
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viv\",\n        50000: \"viiv\",\n        100000: \"viv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        10000000: \"viv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\",\n     \
    \   5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n  \
    \      50000000000000000: \"viiv\",\n        10000000000000000000: \"viv\",\n\
    \        5000000000000000000: \"viiv\",\n        100000000000000000000: \"viv\"\
    ,\n        50000000000000000000: \"viiv\",\n        1000000000000000000000: \"\
    viv\",\n        500000000000000000000: \"viiv\",\n        10000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000: \"viiv\",\n        100000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000: \"viiv\",\n        1000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000: \"viiv\",\n        10000000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000000: \"viiv\",\n        100000000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000000: \"viiv\",\n        1000000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000000: \"viiv\",\n        10000000000000000000000000000:\
    \ \"viv\",\n        5000000000000000000000000000: \"viiv\",\n        100000000000000000000000000000:\
    \ \"viv\",\n        50000000000000000000000000000: \"viiv\",\n        1000000000000000000000000000000:\
    \ \"viv\",\n        500000000000000000000000000000: \"viiv\",\n        10000000000000000000000000000000\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqibzoj_7_test.go:78:41: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n\
    \        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"\
    LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\"\
    , \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\",\n        \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    ,\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"\
    CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\",\n   \
    \     \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\"\
    , \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\", \"CXXXIX\", \"CC\"\
    , \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\",\n        \"CCVII\"\
    , \"CCV\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp50v6obyd_test.go:34:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeralsString :=\
    \ \"\"\n    for romanNumeral, roman := range romanNumerals {\n        if number\
    \ >= romanNumeral {\n            romanNumeralsString += roman\n            number\
    \ -= romanNumeral\n        }\n    }\n    return romanNumeralsString\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpvq3v7ax5_test.go:64: expected 'xix', got 'IVX'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpvq3v7ax5_test.go:64:\
    \ expected 'clii', got 'IVXL'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpvq3v7ax5_test.go:64: expected 'ccli', got 'IVXLC'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpvq3v7ax5_test.go:64:\
    \ expected 'cdxxvi', got 'IVXLC'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4\
    \ (0.00s)\n        tmpvq3v7ax5_test.go:64: expected 'd', got 'D'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmpvq3v7ax5_test.go:64: expected\
    \ 'i', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n    \
    \    tmpvq3v7ax5_test.go:64: expected 'iv', got 'I'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmpvq3v7ax5_test.go:64: expected 'xliii', got 'IVX'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpvq3v7ax5_test.go:64:\
    \ expected 'xc', got 'IVXL'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n\
    \        tmpvq3v7ax5_test.go:64: expected 'xciv', got 'IVXL'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpvq3v7ax5_test.go:64: expected 'dxxxii', got 'CIVXL'\n  \
    \  --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpvq3v7ax5_test.go:64:\
    \ expected 'cm', got 'IVXLCD'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12\
    \ (0.00s)\n        tmpvq3v7ax5_test.go:64: expected 'cmxciv', got 'CDIVXL'\n \
    \   --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpvq3v7ax5_test.go:64:\
    \ expected 'm', got 'IVXLCD'\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n        \"X\", \"XI\", \"\
    XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\",\n   \
    \     \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\",\n        \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\", \"LIX\",\n        \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\",\n        \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    , \"LXXVIII\", \"LXXIX\",\n        \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\",\n\
    \        \"XC\", \"C\", \"CI\", \"CII\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"\
    CVI\", \"CVII\", \"CVIII\", \"CIX\",\n        \"XC\", \"C\", \"CI\", \"CII\",\
    \ \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\",\n\
    \        \"XXC\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"\
    CCVI\", \"CCVII\", \"CCVIII\", \"CIX\",\n        \"XXXC\", \"CCC\", \"CCCI\",\
    \ \"CCCII\", \"CCCIII\", \"CCCIV\", \"CCCV\", \"CCCVI\", \"CCCVII\", \"CCCVIII\"\
    , \"CIX\",\n        \"XLC\", \"LCC\", \"LCCI\", \"LCCII\", \"LCCIII\", \"LCCIV\"\
    , \"LCCV\", \"LCCVI\", \"LCCVII\", \"LCC\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp_86s58ve_test.go:32:86: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"I\",\n  \
    \      5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    roman_number := roman_numerals[number]\n\
    \    return strings.ToLower(roman_number)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpiomvmrcm_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"XIII\",\
    \ \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\", \"\
    XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"XXIX\"\
    , \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\", \"\
    XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LIII\", \"\
    LIIII\", \"LIIV\", \"LIV\", \"LIVI\", \"LIVII\", \"LIVIII\", \"LIVIV\", \"LIVV\"\
    , \"LIVVI\", \"LIVVII\", \"LIVVIII\", \"LIVVIV\", \"LIVVV\", \"LIVVVI\", \"LIVVVII\"\
    , \"LIVVVIII\", \"LIVVVIV\", \"LIVVVV\", \"LIVVVI\", \"LIVVVII\", \"LIVVVIII\"\
    , \"LIVVVIV\", \"LIVVVV\", \"LIVVVI\", \"LIVVVII\", \"LIVVVIII\", \"LIVVVIV\"\
    , \"LIVVVV\", \"LIVVVI\", \"LIVVVII\", \"LIVVVIII\", \"LIVVVIV\", \"LIVVVV\",\
    \ \"LIVVVI\", \"LIVVVII\", \"LIVVVIII\", \"LIVVVIV\", \"LIVVVV\", \"LIVVVI\",\
    \ \"LIVVVII\", \"LIVVVIII\", \"LIVVVIV\", \"LIVVVV\", \"LIVVVI\", \"LIVVVII\"\
    , \"LIVVVIII\", \"LIVVVIV\", \"LIVVVV\", \"LIVVVI\", \"LIVVVII\", \"LIVVVIII\"\
    , \"LIVVVIV\", \"LIVVVV\", \"LIVVVI\", \"LIVVVII\", \"LIVVVIII\", \"LIVVVIV\"\
    , \"LIVVVV\", \"LIVVVI\", \"LIVVVII\", \"LIVVVIII\", \"LIVVVIV\", \"LIVVVV\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptb40fl4v_test.go:19:1007: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n\
    \        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n        10000:\
    \ \"c\",\n        50000: \"c\",\n        100000: \"x\",\n        500000: \"x\"\
    ,\n        1000000: \"ix\",\n        5000000: \"ix\",\n        10000000: \"iv\"\
    ,\n        50000000: \"iv\",\n        100000000: \"v\",\n        500000000: \"\
    v\",\n        1000000000: \"vi\",\n        5000000000: \"vi\",\n        10000000000:\
    \ \"vii\",\n        50000000000: \"vii\",\n        100000000000: \"ix\",\n   \
    \     500000000000: \"ix\",\n        1000000000000: \"ix\",\n        5000000000000:\
    \ \"ix\",\n        10000000000000: \"ix\",\n        50000000000000: \"ix\",\n\
    \        100000000000000: \"ix\",\n        500000000000000: \"ix\",\n        1000000000000000:\
    \ \"ix\",\n        5000000000000000: \"ix\",\n        1000000000000000000: \"\
    ix\",\n    }\n    romanNumerals[number] = \"\"\n    return romanNumerals[number]\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpud3cbk06_test.go:84: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpud3cbk06_test.go:84: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpud3cbk06_test.go:84: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpud3cbk06_test.go:84: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpud3cbk06_test.go:84:\
    \ expected 'd', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmpud3cbk06_test.go:84: expected 'i', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpud3cbk06_test.go:84: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpud3cbk06_test.go:84: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpud3cbk06_test.go:84: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpud3cbk06_test.go:84: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpud3cbk06_test.go:84:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpud3cbk06_test.go:84: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpud3cbk06_test.go:84:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpud3cbk06_test.go:84: expected 'm', got ''\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075548
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vii\",\n\
    \        10000: \"viii\",\n        50000: \"viv\",\n        100000: \"vi\",\n\
    \        500000: \"vii\",\n        1000000: \"viii\",\n        5000000: \"viv\"\
    ,\n        10000000: \"vi\",\n        50000000: \"vii\",\n        100000000: \"\
    viii\",\n        500000000: \"viv\",\n        1000000000: \"vi\",\n        5000000000:\
    \ \"vii\",\n        10000000000: \"viii\",\n        50000000000: \"viv\",\n  \
    \      100000000000: \"vi\",\n        500000000000: \"vii\",\n        1000000000000:\
    \ \"viii\",\n        5000000000000: \"viv\",\n        10000000000000: \"vi\",\n\
    \        50000000000000: \"vii\",\n        100000000000000: \"viii\",\n      \
    \  500000000000000: \"viv\",\n        1000000000000000: \"vi\",\n        5000000000000000:\
    \ \"vii\",\n        1000000000000000000: \"viii\",\n    }\n    roman_numeral :=\
    \ roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5ed4qirk_test.go:55:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n\
    \        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\"\
    , \"CXXI\",\n        \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"\
    CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"\
    CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\"\
    , \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\"\
    ,\n        \"CCVII\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpm1p8xn3t_test.go:34:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 5:\n        roman_number = \"v\"\n   \
    \ case 10:\n        roman_number = \"i\"\n    case 50:\n        roman_number =\
    \ \"l\"\n    case 100:\n        roman_number = \"c\"\n    case 500:\n        roman_number\
    \ = \"d\"\n    case 1000:\n        roman_number = \"m\"\n    }\n    return roman_number\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp90p27_ny_test.go:65: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp90p27_ny_test.go:65: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp90p27_ny_test.go:65: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp90p27_ny_test.go:65: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp90p27_ny_test.go:65:\
    \ expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmp90p27_ny_test.go:65: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmp90p27_ny_test.go:65: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp90p27_ny_test.go:65: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmp90p27_ny_test.go:65: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmp90p27_ny_test.go:65: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp90p27_ny_test.go:65:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmp90p27_ny_test.go:65: expected 'cmxciv', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075542
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiiii\",\n        500: \"viiiiix\",\n        1000: \"viiiiiix\",\n      \
    \  5000: \"viiiiiiix\",\n        10000: \"viiiiiiiix\",\n        50000: \"viiiiiiiiix\"\
    ,\n        100000: \"viiiiiiiiiix\",\n        500000: \"viiiiiiiiiiix\",\n   \
    \     1000000: \"viiiiiiiiiiiix\",\n        5000000: \"viiiiiiiiiiiiix\",\n  \
    \      10000000: \"viiiiiiiiiiiiiix\",\n        50000000: \"viiiiiiiiiiiiiiix\"\
    ,\n        100000000: \"viiiiiiiiiiiiiiiix\",\n        500000000: \"viiiiiiiiiiiiiiiiix\"\
    ,\n        1000000000: \"viiiiiiiiiiiiiiiiiix\",\n        5000000000: \"viiiiiiiiiiiiiiiiiiix\"\
    ,\n        10000000000: \"viiiiiiiiiiiiiiiiiiiix\",\n        50000000000: \"viiiiiiiiiiiiiiiiiiiiix\"\
    ,\n        100000000000: \"viiiiiiiiiiiiiiiiiiiiiix\",\n        500000000000:\
    \ \"viiiiiiiiiiiiiiiiiiiiiiix\",\n        1000000000000: \"viiiiiiiiiiiiiiiiiiiiiiiix\"\
    ,\n        5000000000000: \"viiiiiiiiiiiiiiiiiiiiiiiiix\",\n        10000000000000:\
    \ \"viiiiiiiiiiiiiiiiiiiiiiiiiix\",\n        50000000000000: \"viiiiiiiiiiiiiiiiiiiiiiiiiiix\"\
    ,\n        100000000000000: \"viiiiiiiiiiiiiiiiiiiiiiiiiiiix\",\n        500000000000000:\
    \ \"viiiiiiiiiiiiiiiiiiiiiiiiiiiiix\",\n        1000000000000000: \"viiiiiiiiiiiiiiiiiiiiiiiiiiiiiix\"\
    ,\n        5000000000000000: \"viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiix\",\n        1000000000000000000:\
    \ \"viiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiix\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp0xdw4gsu_test.go:52:30: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 2:\n        roman_number = \"ix\"\n  \
    \  case 3:\n        roman_number = \"lb\"\n    case 4:\n        roman_number =\
    \ \"c\"\n    case 5:\n        roman_number = \"d\"\n    case 6:\n        roman_number\
    \ = \"i\"\n    case 7:\n        roman_number = \"v\"\n    case 8:\n        roman_number\
    \ = \"f\"\n    case 9:\n        roman_number = \"m\"\n    case 10:\n        roman_number\
    \ = \"b\"\n    case 11:\n        roman_number = \"g\"\n    case 12:\n        roman_number\
    \ = \"y\"\n    case 13:\n        roman_number = \"k\"\n    case 14:\n        roman_number\
    \ = \"j\"\n    case 15:\n        roman_number = \"q\"\n    case 16:\n        roman_number\
    \ = \"x\"\n    case 17:\n        roman_number = \"c\"\n    case 18:\n        roman_number\
    \ = \"m\"\n    case 19:\n        roman_number = \"b\"\n    case 20:\n        roman_number\
    \ = \"g\"\n    case 21:\n        roman_number = \"y\"\n    case 22:\n        roman_number\
    \ = \"k\"\n    case 23:\n        roman_number = \"j\"\n    case 24:\n        roman_number\
    \ = \"q\"\n    case 25:\n        roman_number = \"x\"\n    case 26:\n        roman_number\
    \ = \"v\"\n    case 27:\n        roman_number = \"f\"\n    case 28:\n        roman_number\
    \ = \"m\"\n    case 29:\n        roman_number = \"b\"\n    case 30:\n        roman_number\
    \ = \"g\"\n    case 31:\n        roman_number = \"y\"\n    case 32:\n        roman_number\
    \ = \"k\"\n    case 33:\n        roman_number = \"j\"\n    case 34:\n        roman_number\
    \ = \"q\"\n    case 35:\n        roman_number = \"x\"\n    case 36:\n        roman_number\
    \ = \"v\"\n    case 37:\n        roman_number = \"f\"\n    case 38:\n        roman_number\
    \ = \"m\"\n    case 39:\n        roman_number = \"b\"\n    case 40:\n        roman_number\
    \ = \"g\"\n    case 41:\n        roman_number = \"y\"\n    case 42:\n        roman_number\
    \ = \"k\"\n    case 43:\n        roman_number = \"j\"\n    case 44:\n        roman_number\
    \ = \"q\"\n    case 45:\n        roman_number = \"x\"\n    case 46:\n        \n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpceafys70_test.go:113:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n        5000: \"viiivi\"\
    ,\n        10000: \"viiivii\",\n        50000: \"vivvi\",\n        100000: \"\
    vivvii\",\n        500000: \"viviv\",\n        1000000: \"vivivi\",\n        5000000:\
    \ \"vivivii\",\n        10000000: \"viviviii\",\n        50000000: \"viviivi\"\
    ,\n        100000000: \"viviivii\",\n        500000000: \"viviiivi\",\n      \
    \  1000000000: \"viviiivii\",\n        5000000000: \"vivivvi\",\n        10000000000:\
    \ \"vivivvii\",\n        50000000000: \"viviviv\",\n        100000000000: \"vivivivi\"\
    ,\n        500000000000: \"viviiviv\",\n        1000000000000: \"viviivivi\",\n\
    \        5000000000000: \"viviiiviv\",\n        10000000000000: \"viviiivivi\"\
    ,\n        50000000000000: \"vivivviv\",\n        100000000000000: \"vivivvivi\"\
    ,\n        500000000000000: \"viviviviv\",\n        1000000000000000: \"vivivivivi\"\
    ,\n        5000000000000000: \"viviiviviv\",\n        10000000000000000: \"viviivivivi\"\
    ,\n        5000000000000000: \"viviiivivi\",\n        10000000000000000: \"viviiivivi\"\
    ,\n        50000000000000000: \"vivivvivi\",\n        100000000000000000: \"vivivvivii\"\
    ,\n        500000000000000000: \"viviviviv\",\n        100000000000000000: \"\
    vivivivivi\",\n        50000000000000000: \"viviiviviv\",\n        1000000000000000000:\
    \ \"viviivivivi\",\n        500000000000000000: \"viviiivivi\",\n        10000000000000000000:\
    \ \"viviiivivi\",\n        5000000000000000000: \"vivivvivi\",\n        100000000000000000000:\
    \ \"vivivvivii\",\n        50000000000000000000: \"viviviviv\",\n        1000000000000000000000:\
    \ \"vivivivivi\",\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate :=\
    \ int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpdd_39qty_test.go:68:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n\
    \        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXIII\",\n        \"XXIV\", \"XXV\", \"XXVI\"\
    , \"XXVII\", \"XXVIII\", \"XXIX\", \"XL\", \"L\", \"LI\", \"LXI\",\n        \"\
    LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\"\
    , \"LXX\",\n        \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\"\
    , \"LXXVII\", \"LXXVIII\",\n        \"LXXIX\", \"LXXX\", \"LXXIII\", \"LXXIV\"\
    , \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\",\n        \"LXXIX\", \"LXXX\",\
    \ \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\",\n     \
    \   \"LXXIX\", \"LXXX\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    , \"LXXVIII\",\n        \"LXXIX\", \"LXXX\", \"LXXIII\", \"LXXIV\", \"LXXV\",\
    \ \"LXXVI\", \"LXXVII\", \"LXXVIII\",\n        \"LXXIX\", \"LXXX\", \"LXXIII\"\
    , \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\",\n        \"LXXIX\"\
    , \"LXXX\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\"\
    ,\n        \"LXXIX\", \"LXXX\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"\
    LXXVII\", \"LXXVIII\",\n        \"LXXIX\", \"LXXX\", \"LXXIII\", \"LXXIV\", \"\
    LXX\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpcqendjqi_test.go:33:45: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n        5000: \"viiivi\"\
    ,\n        10000: \"viiivii\",\n        50000: \"vivvi\",\n        100000: \"\
    vivvii\",\n        500000: \"viviv\",\n        1000000: \"vivivi\",\n        5000000:\
    \ \"vivivii\",\n        10000000: \"viviviii\",\n        50000000: \"viviivi\"\
    ,\n        100000000: \"viviivii\",\n        500000000: \"viviiivi\",\n      \
    \  1000000000: \"viviiivii\",\n        5000000000: \"vivivvi\",\n        10000000000:\
    \ \"vivivvii\",\n        50000000000: \"viviviv\",\n        100000000000: \"vivivivi\"\
    ,\n        500000000000: \"viviiviv\",\n        1000000000000: \"viviivivi\",\n\
    \        5000000000000: \"viviiiviv\",\n        10000000000000: \"viviiivivi\"\
    ,\n        50000000000000: \"vivivviv\",\n        100000000000000: \"vivivvivi\"\
    ,\n        500000000000000: \"viviviviv\",\n        1000000000000000: \"vivivivivi\"\
    ,\n        5000000000000000: \"viviiviviv\",\n        10000000000000000: \"viviivivivi\"\
    ,\n        5000000000000000: \"viviiivivi\",\n        10000000000000000: \"viviiivivi\"\
    ,\n        50000000000000000: \"vivivvivi\",\n        100000000000000000: \"vivivvivii\"\
    ,\n        500000000000000000: \"viviviviv\",\n        100000000000000000: \"\
    vivivivivi\",\n        50000000000000000: \"viviiviviv\",\n        1000000000000000000:\
    \ \"viviivivivi\",\n        500000000000000000: \"viviiivivi\",\n        10000000000000000000:\
    \ \"viviiivivi\",\n        5000000000000000000: \"vivivvivi\",\n        100000000000000000000:\
    \ \"vivivvivi\",\n        50000000000000000000: \"viviviviv\",\n        1000000000000000000000:\
    \ \"vivivivivi\",\n        \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpf4cmvxkd_test.go:68:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n        5000: \"viiivi\"\
    ,\n        10000: \"viiivii\",\n        50000: \"vivvi\",\n        100000: \"\
    vivvii\",\n        500000: \"viviv\",\n        1000000: \"vivivi\",\n        5000000:\
    \ \"vivivii\",\n        10000000: \"viviviii\",\n        50000000: \"viviviiii\"\
    ,\n        100000000: \"viviviiiii\",\n        500000000: \"viviviiiiii\",\n \
    \       1000000000: \"viviviiiiiii\",\n        5000000000: \"viviviiiiiiii\",\n\
    \        10000000000: \"viviviiiiiiiii\",\n        50000000000: \"viviviiiiiiiiii\"\
    ,\n        100000000000: \"viviviiiiiiiiiii\",\n        500000000000: \"viviviiiiiiiiiiii\"\
    ,\n        1000000000000: \"viviviiiiiiiiiiiii\",\n        5000000000000: \"viviviiiiiiiiiiiiii\"\
    ,\n        10000000000000: \"viviviiiiiiiiiiiiiii\",\n        50000000000000:\
    \ \"viviviiiiiiiiiiiiiiii\",\n        100000000000000: \"viviviiiiiiiiiiiiiiiii\"\
    ,\n        500000000000000: \"viviviiiiiiiiiiiiiiiiii\",\n        1000000000000000:\
    \ \"viviviiiiiiiiiiiiiiiiiii\",\n        5000000000000000: \"viviviiiiiiiiiiiiiiiiiiii\"\
    ,\n        1000000000000000000: \"viviviiiiiiiiiiiiiiiiiiiii\",\n    }\n    roman_numeral_string\
    \ := \"\"\n    for roman_numeral, roman_numeral_string := range roman_numerals\
    \ {\n        if number >= roman_numeral {\n            break\n        }\n    }\n\
    \    return roman_numeral_string\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpwi194byi_test.go:55:24: roman_numeral_string declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n\
    \        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n    romanNumeralsString\
    \ := \"\"\n    for romanNumeral, roman := range romanNumerals {\n        if number\
    \ >= romanNumeral {\n            romanNumeralsString += roman\n            number\
    \ -= romanNumeral\n        }\n    }\n    return romanNumeralsString\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpogk51vbv_test.go:65: expected 'xix', got 'ivil'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpogk51vbv_test.go:65:\
    \ expected 'clii', got 'ivill'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpogk51vbv_test.go:65: expected 'ccli', got 'ivillc'\n   \
    \ --- FAIL: TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpogk51vbv_test.go:65:\
    \ expected 'cdxxvi', got 'ivillc'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4\
    \ (0.00s)\n        tmpogk51vbv_test.go:65: expected 'd', got 'llcivi'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmpogk51vbv_test.go:65:\
    \ expected 'iv', got 'i'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n\
    \        tmpogk51vbv_test.go:65: expected 'xliii', got 'ivil'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8\
    \ (0.00s)\n        tmpogk51vbv_test.go:65: expected 'xc', got 'ivill'\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmpogk51vbv_test.go:65:\
    \ expected 'xciv', got 'ivill'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpogk51vbv_test.go:65: expected 'dxxxii', got 'ivillc'\n \
    \   --- FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpogk51vbv_test.go:65:\
    \ expected 'cm', got 'ccivill'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12\
    \ (0.00s)\n        tmpogk51vbv_test.go:65: expected 'cmxciv', got 'ccivill'\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__13 (0.00s)\n        tmpogk51vbv_test.go:65:\
    \ expected 'm', got 'ivillcc'\nFAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viv\",\n        50000: \"viiv\",\n        100000: \"viv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        10000000: \"viv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\",\n     \
    \   5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n  \
    \  }\n    roman_numeral := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpjpk432sl_test.go:55:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075546
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"x\"\n    case 2:\n        roman_num = \"ix\"\n    case 3:\n\
    \        roman_num = \"lb\"\n    case 4:\n        roman_num = \"c\"\n    case\
    \ 5:\n        roman_num = \"d\"\n    case 6:\n        roman_num = \"mi\"\n   \
    \ case 7:\n        roman_num = \"f\"\n    case 8:\n        roman_num = \"v\"\n\
    \    case 9:\n        roman_num = \"x\"\n    case 10:\n        roman_num = \"\
    c\"\n    case 11:\n        roman_num = \"d\"\n    case 12:\n        roman_num\
    \ = \"mi\"\n    case 13:\n        roman_num = \"f\"\n    case 14:\n        roman_num\
    \ = \"v\"\n    case 15:\n        roman_num = \"x\"\n    case 16:\n        roman_num\
    \ = \"c\"\n    case 17:\n        roman_num = \"d\"\n    case 18:\n        roman_num\
    \ = \"mi\"\n    case 19:\n        roman_num = \"f\"\n    case 20:\n        roman_num\
    \ = \"v\"\n    case 21:\n        roman_num = \"x\"\n    case 22:\n        roman_num\
    \ = \"c\"\n    case 23:\n        roman_num = \"d\"\n    case 24:\n        roman_num\
    \ = \"mi\"\n    case 25:\n        roman_num = \"f\"\n    case 26:\n        roman_num\
    \ = \"v\"\n    case 27:\n        roman_num = \"x\"\n    case 28:\n        roman_num\
    \ = \"c\"\n    case 29:\n        roman_num = \"d\"\n    case 30:\n        roman_num\
    \ = \"mi\"\n    case 31:\n        roman_num = \"f\"\n    case 32:\n        roman_num\
    \ = \"v\"\n    case 33:\n        roman_num = \"x\"\n    case 34:\n        roman_num\
    \ = \"c\"\n    case 35:\n        roman_num = \"d\"\n    case 36:\n        roman_num\
    \ = \"mi\"\n    case 37:\n        roman_num = \"f\"\n    case 38:\n        roman_num\
    \ = \"v\"\n    case 39:\n        roman_num = \"x\"\n    case 40:\n        roman_num\
    \ = \"c\"\n    case 41:\n        roman_num = \"d\"\n    case 42:\n        roman_num\
    \ = \"mi\"\n    case 43:\n        roman_num = \"f\"\n    case 44:\n        roman_num\
    \ = \"v\"\n    case 45:\n        roman_num = \"x\"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp1fdkvs2f_test.go:111:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075541
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n\
    \        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\",\
    \ \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\"\
    , \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\"\
    ,\n        \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\"\
    , \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp8l8t_zot_test.go:34:18: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075547
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiii\",\n        500: \"viiii\",\n        1000: \"viiii\",\n        5000:\
    \ \"viiii\",\n        10000: \"viiii\",\n        50000: \"viiii\",\n        100000:\
    \ \"viiii\",\n        500000: \"viiii\",\n        1000000: \"viiii\",\n      \
    \  5000000: \"viiii\",\n        10000000: \"viiii\",\n        50000000: \"viiii\"\
    ,\n        100000000: \"viiii\",\n        500000000: \"viiii\",\n        1000000000:\
    \ \"viiii\",\n        5000000000: \"viiii\",\n        10000000000: \"viiii\",\n\
    \        50000000000: \"viiii\",\n        100000000000: \"viiii\",\n        500000000000:\
    \ \"viiii\",\n        1000000000000: \"viiii\",\n        5000000000000: \"viiii\"\
    ,\n        10000000000000: \"viiii\",\n        50000000000000: \"viiii\",\n  \
    \      100000000000000: \"viiii\",\n        500000000000000: \"viiii\",\n    \
    \    1000000000000000: \"viiii\",\n        5000000000000000: \"viiii\",\n    \
    \    1000000000000000000: \"viiii\",\n        50000000000000000: \"viiii\",\n\
    \        10000000000000000000: \"viiii\",\n        5000000000000000000: \"viiii\"\
    ,\n        100000000000000000000: \"viiii\",\n        50000000000000000000: \"\
    viiii\",\n        1000000000000000000000: \"viiii\",\n        500000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000: \"viiii\",\n        5000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000: \"viiii\",\n        50000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000: \"viiii\",\n        500000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000: \"viiii\",\n        5000000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000000: \"viiii\",\n        50000000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000000: \"viiii\",\n        500000000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000000: \"viiii\",\n        5000000000000000000000000000\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpquhcjrxs_test.go:73:37: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n    }\n    romanNumerals[1000]\
    \ = \"v\"\n    romanNumerals[500] = \"vi\"\n    romanNumerals[100] = \"vii\"\n\
    \    romanNumerals[50] = \"viii\"\n    romanNumerals[10] = \"ix\"\n    romanNumerals[1]\
    \ = \"i\"\n\n    romanNumerals[4] = \"x\"\n    romanNumerals[6] = \"xix\"\n  \
    \  romanNumerals[9] = \"xixi\"\n    romanNumerals[400] = \"xixix\"\n    romanNumerals[900]\
    \ = \"xixixi\"\n    romanNumerals[4000] = \"xixixii\"\n    romanNumerals[9000]\
    \ = \"xixixiii\"\n\n    romanNumerals[400] = \"xx\"\n    romanNumerals[800] =\
    \ \"xxi\"\n    romanNumerals[1000] = \"xxii\"\n    romanNumerals[4000] = \"xxiii\"\
    \n    romanNumerals[8000] = \"xxiiii\"\n\n    romanNumerals[100] = \"xxx\"\n \
    \   romanNumerals[500] = \"xxvi\"\n    romanNumerals[1000] = \"xxvii\"\n    romanNumerals[5000]\
    \ = \"xxviii\"\n    romanNumerals[10000] = \"xxviv\"\n    romanNumerals[100000]\
    \ = \"xxvivi\"\n    romanNumerals[1000000] = \"xxvivii\"\n    romanNumerals[10000000]\
    \ = \"xxviviii\"\n\n    romanNumerals[50] = \"xxxvi\"\n    romanNumerals[100]\
    \ = \"xxxvii\"\n    romanNumerals[500] = \"xxxviii\"\n    romanNumerals[1000]\
    \ = \"xxxviv\"\n    romanNumerals[5000] = \"xxxvivi\"\n    romanNumerals[10000]\
    \ = \"xxxvivii\"\n    romanNumerals[100000] = \"xxxviviii\"\n    romanNumerals[1000000]\
    \ = \"xxxviviii\"\n    romanNumeral\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpx8xj1ka0_test.go:67:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\",\n        \"X\", \"XI\", \"XII\", \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\",\n        \"XX\"\
    , \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\",\n        \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\", \"\
    LIX\",\n        \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\"\
    , \"LXVII\", \"LXVIII\", \"LXIX\",\n        \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\"\
    , \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\",\n      \
    \  \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\"\
    , \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\",\n        \"XC\", \"C\", \"CI\", \"CII\"\
    , \"CII\", \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\",\n\
    \        \"XC\", \"C\", \"CI\", \"CII\", \"CII\", \"CIII\", \"CIV\", \"CV\", \"\
    CVI\", \"CVII\", \"CVIII\", \"CIX\",\n        \"XXC\", \"CC\", \"CCI\", \"CCII\"\
    , \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CXX\",\n  \
    \      \"CCC\", \"CCCI\", \"CCCII\", \"CCCIII\", \"CCCIV\", \"CCCV\", \"CCCVI\"\
    , \"CCCVII\", \"CCCVIII\", \"CXXX\",\n        \"CCXX\", \"CCXXX\", \"CCXXXI\"\
    , \"CCXXXII\", \"CCXXXIII\", \"CCXXXIV\", \"CCXXXV\", \"CCXXXVI\", \"CCXXXVII\"\
    , \"CCXXXVIII\", \"CC\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpetm0dj_s_test.go:32:116: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"ix\",\n\
    \        500: \"ixi\",\n        1000: \"ixii\",\n    }\n    roman, ok := romans[number]\n\
    \    if !ok {\n        fmt.Println(\"Invalid input\")\n    }\n    return strings.ToLower(roman)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpj4hzejhc_test.go:32:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\"\
    ,\n        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n    }\n  \
    \  roman_numeral := roman_numerals[number]\n    if number < 1 || number > 1000\
    \ {\n        fmt.Println(\"Invalid input\")\n    }\n    return roman_numeral\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmpdialxw83_test.go:62: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmpdialxw83_test.go:62: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmpdialxw83_test.go:62: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmpdialxw83_test.go:62: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmpdialxw83_test.go:62:\
    \ expected 'd', got 'c'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmpdialxw83_test.go:62: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmpdialxw83_test.go:62: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmpdialxw83_test.go:62: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmpdialxw83_test.go:62: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmpdialxw83_test.go:62: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmpdialxw83_test.go:62:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmpdialxw83_test.go:62: expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpdialxw83_test.go:62: expected 'm', got 'd'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n     \
    \   500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n        10000: \"\
    c\",\n        50000: \"c\",\n        100000: \"c\",\n        500000: \"c\",\n\
    \        1000000: \"m\",\n        5000000: \"m\",\n        10000000: \"m\",\n\
    \        50000000: \"m\",\n        100000000: \"m\",\n        500000000: \"m\"\
    ,\n        1000000000: \"m\",\n        5000000000: \"m\",\n        10000000000:\
    \ \"m\",\n        50000000000: \"m\",\n        100000000000: \"m\",\n        500000000000:\
    \ \"m\",\n        1000000000000: \"m\",\n        5000000000000: \"m\",\n     \
    \   10000000000000: \"m\",\n        50000000000000: \"m\",\n        100000000000000:\
    \ \"m\",\n        500000000000000: \"m\",\n        1000000000000000: \"m\",\n\
    \        5000000000000000: \"m\",\n        1000000000000000000: \"m\",\n    }\n\
    \    roman_number := number\n    roman_number -= int('0')\n    roman_number /=\
    \ int('10')\n    roman_number -= int('0')\n    roman_number /= int('100')\n  \
    \  roman_number -= int('0')\n    roman_number /= int('1000')\n    roman_number\
    \ -= int('0')\n    roman_number /= int('10000')\n    roman_number -= int('0')\n\
    \    roman_number /= int('100000')\n    roman_number -= int('0')\n    roman_number\
    \ /= int('1000000')\n    roman_number -= int('0')\n    roman_number /= int('5000000')\n\
    \    roman_number -= int('0')\n    roman_number /= int('10000000')\n    roman_number\
    \ -= int('0')\n    roman_number /= int('50000000')\n    roman_number -= int('0')\n\
    \    roman_number /= int('100000000')\n    roman_number -= int('0')\n    roman_number\
    \ /= int('500000000')\n    roman_number -= int('0')\n    roman_number /= int('1000000000')\n\
    \    roman_number -= int('0')\n    roman_number /= int('5000000000')\n    roman_number\
    \ -= int('0')\n    roman_number /= int('10000000000')\n    roman_number -= int('0')\n\
    \    roman_number /= int('5\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpl859rjzb_test.go:56:25: illegal rune literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    roman_numerals := []string{\"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"\
    XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\"\
    , \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LII\", \"LIII\"\
    , \"LIIII\", \"LIIV\", \"LIV\", \"LIVI\", \"LIVII\", \"LIVIII\", \"LIIX\", \"\
    LX\", \"L\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\"\
    , \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"\
    LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"\
    LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\"\
    , \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIII\", \"CIIII\", \"CIV\", \"\
    CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\"\
    , \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\", \"CXXI\"\
    , \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"CXXVII\", \"CXXVIII\"\
    , \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\", \"CXXXIV\", \"CXXXV\"\
    , \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"CXL\", \"CL\", \"CLI\"\
    , \"CLII\", \"CLIII\", \"CLIIII\", \"CLIIV\", \"CLIV\", \"CLIVI\", \"CLIVII\"\
    , \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv1pd_7j9_test.go:22:1132: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    romanNumerals := map[int]string{\n        1: \"i\"\
    ,\n        5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"\
    c\",\n        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n      \
    \  10000: \"c\",\n        50000: \"c\",\n        100000: \"x\",\n        500000:\
    \ \"x\",\n        1000000: \"ix\",\n        5000000: \"ix\",\n        10000000:\
    \ \"iv\",\n        50000000: \"iv\",\n        100000000: \"v\",\n        500000000:\
    \ \"v\",\n        1000000000: \"vi\",\n        5000000000: \"vi\",\n        10000000000:\
    \ \"i\",\n        50000000000: \"i\",\n        100000000000: \"ii\",\n       \
    \ 500000000000: \"ii\",\n        1000000000000: \"ii\",\n        5000000000000:\
    \ \"ii\",\n        10000000000000: \"ii\",\n        50000000000000: \"ii\",\n\
    \        100000000000000: \"ii\",\n        500000000000000: \"ii\",\n        1000000000000000:\
    \ \"ii\",\n        5000000000000000: \"ii\",\n        1000000000000000000: \"\
    i\",\n        50000000000000000: \"i\",\n        10000000000000000000: \"ii\"\
    ,\n        5000000000000000000: \"ii\",\n        100000000000000000000: \"ii\"\
    ,\n        50000000000000000000: \"ii\",\n        1000000000000000000000: \"ii\"\
    ,\n        500000000000000000000: \"ii\",\n        10000000000000000000000: \"\
    ii\",\n        5000000000000000000000: \"ii\",\n        100000000000000000000000:\
    \ \"ii\",\n        50000000000000000000000: \"ii\",\n        1000000000000000000000000:\
    \ \"ii\",\n        500000000000000000000000: \"ii\",\n        10000000000000000000000000:\
    \ \"ii\",\n        5000000000000000000000000: \"ii\",\n        100000000000000000000000000:\
    \ \"ii\",\n        50000000000000000000000000: \"ii\",\n        1000000000000000000000000000:\
    \ \"ii\",\n        500000000000000000000000000: \"ii\",\n        10000000000000000000000000000:\
    \ \"ii\",\n        5000000000000000000000000000: \"ii\",\n        100000000000000000000000000000:\
    \ \"ii\",\n        50000000000000000000000000000: \"ii\",\n        1000000000000000000000000000000:\
    \ \"ii\",\n        500000000000000000000000000000: \"ii\",\n        10000000000000000000000000000000:\
    \ \"ii\",\n        5000000000000000000000000000000: \"ii\",\n        100000000000000000000000000000000:\
    \ \"ii\",\n        50000000000000000000000000000000: \"ii\",\n        1000000000000000000000000000000000:\
    \ \"ii\",\n        50000000000000000\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpsxg1f31p_test.go:86:26: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075548
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n        5000: \"viiivi\"\
    ,\n        10000: \"viiivii\",\n        50000: \"vivvi\",\n        100000: \"\
    vivvii\",\n        500000: \"viviv\",\n        1000000: \"vivivi\",\n        5000000:\
    \ \"vivivii\",\n        10000000: \"viviviii\",\n        50000000: \"viviviiii\"\
    ,\n        100000000: \"viviviiiii\",\n        500000000: \"viviviiiiii\",\n \
    \       1000000000: \"viviviiiiiii\",\n        5000000000: \"viviviiiiiiii\",\n\
    \        10000000000: \"viviviiiiiiiii\",\n        50000000000: \"viviviiiiiiiiii\"\
    ,\n        100000000000: \"viviviiiiiiiiiii\",\n        500000000000: \"viviviiiiiiiiiiii\"\
    ,\n        1000000000000: \"viviviiiiiiiiiiiii\",\n        5000000000000: \"viviviiiiiiiiiiiiii\"\
    ,\n        10000000000000: \"viviviiiiiiiiiiiiiii\",\n        50000000000000:\
    \ \"viviviiiiiiiiiiiiiiii\",\n        100000000000000: \"viviviiiiiiiiiiiiiiiii\"\
    ,\n        500000000000000: \"viviviiiiiiiiiiiiiiiiii\",\n        1000000000000000:\
    \ \"viviviiiiiiiiiiiiiiiiiii\",\n        5000000000000000: \"viviviiiiiiiiiiiiiiiiiiii\"\
    ,\n        1000000000000000000: \"viviviiiiiiiiiiiiiiiiiiiii\",\n    }\n    roman_numeral\
    \ := \"\"\n    for roman_numeral, number := range roman_numerals {\n        if\
    \ number >= number {\n            break\n        }\n    }\n    if number > 1000\
    \ {\n        fmt.Println(\"int_to_mini_roman: number too large\")\n    }\n   \
    \ return roman_numerals[number]\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpswnj1tb4_test.go:54:5: roman_numeral declared but not used

    /tmp/tmpswnj1tb4_test.go:55:9: roman_numeral declared but not used

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vii\",\n\
    \        10000: \"viii\",\n        100000: \"viv\",\n    }\n    romanNumeral :=\
    \ romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpe8urx1mj_test.go:32:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"I\",\n        5:\
    \ \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n      \
    \  500: \"D\",\n        1000: \"M\",\n    }\n    roman_number := \"\"\n    for\
    \ roman_number == \"\" {\n        roman_number = romans[number]\n        number\
    \ -= roman_number\n    }\n    return roman_number\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmppweyg2rd_test.go:31:9: invalid operation: number -= roman_number (mismatched
    types int and string)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\",\n\
    \        500: \"c\",\n        1000: \"d\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp90kp2m64_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := []string{\n        \"I\", \"II\", \"III\", \"IV\"\
    , \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n        \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\"\
    , \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\"\
    , \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"XL\", \"L\", \"LI\"\
    , \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"LVII\", \"LVIII\",\n\
    \        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"\
    LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\"\
    , \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\",\n        \"LXXVIII\"\
    , \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\"\
    ,\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"\
    CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\", \"CVI\", \"CVII\"\
    , \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"CXIII\", \"CXIV\"\
    , \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CIX\", \"CXC\", \"CXCI\",\n    \
    \    \"CXCII\", \"CXCIII\", \"CXCIV\", \"CXCV\", \"CXCVI\", \"CXCVII\", \"CXCVIII\"\
    , \"CXCIX\",\n        \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CCV\"\
    , \"CCVI\", \"CCVII\", \"CCVIII\",\n        \"CCIX\", \"CCC\", \"CCCI\", \"CCCII\"\
    , \"CCCIII\", \"CCCIV\", \"CCCV\", \"CCCVI\", \"CCCVII\",\n        \"CCCVIII\"\
    , \"CCCIX\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5it370hk_test.go:34:20: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n\
    \        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"XC\", \"XCI\", \"XCII\", \"XCII\",\n        \"XCIII\", \"XCIV\", \"\
    XCV\", \"XCVI\", \"XCVII\", \"XCVIII\", \"XCIX\", \"XCXX\", \"XCXXI\",\n     \
    \   \"XCXXII\", \"XCXXIII\", \"XCXXIV\", \"XCXXV\", \"XCXXVI\", \"XCXXVII\", \"\
    XCXXVIII\",\n        \"XCXXIX\", \"XCXXX\", \"XCXXXI\", \"XCXXXII\", \"XCXXXIII\"\
    , \"XCXXXIV\", \"XCXXXV\",\n        \"XCXXXVI\", \"XCXXXVII\", \"XCXXXVIII\",\
    \ \"XCXXXIX\", \"C\", \"CC\", \"CCI\", \"CCII\",\n        \"CCIII\", \"CCIV\"\
    , \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6tm_ajic_test.go:33:54: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"viii\",\n        50: \"viiii\",\n        100:\
    \ \"viiii\",\n        500: \"viiii\",\n        1000: \"viiii\",\n        5000:\
    \ \"viiii\",\n        10000: \"viiii\",\n        50000: \"viiii\",\n        100000:\
    \ \"viiii\",\n        500000: \"viiii\",\n        1000000: \"viiii\",\n      \
    \  5000000: \"viiii\",\n        10000000: \"viiii\",\n        50000000: \"viiii\"\
    ,\n        100000000: \"viiii\",\n        500000000: \"viiii\",\n        1000000000:\
    \ \"viiii\",\n        5000000000: \"viiii\",\n        10000000000: \"viiii\",\n\
    \        50000000000: \"viiii\",\n        100000000000: \"viiii\",\n        500000000000:\
    \ \"viiii\",\n        1000000000000: \"viiii\",\n        5000000000000: \"viiii\"\
    ,\n        10000000000000: \"viiii\",\n        50000000000000: \"viiii\",\n  \
    \      100000000000000: \"viiii\",\n        500000000000000: \"viiii\",\n    \
    \    1000000000000000: \"viiii\",\n        5000000000000000: \"viiii\",\n    \
    \    1000000000000000000: \"viiii\",\n        50000000000000000: \"viiii\",\n\
    \        10000000000000000000: \"viiii\",\n        5000000000000000000: \"viiii\"\
    ,\n        100000000000000000000: \"viiii\",\n        50000000000000000000: \"\
    viiii\",\n        1000000000000000000000: \"viiii\",\n        500000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000: \"viiii\",\n        5000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000: \"viiii\",\n        50000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000: \"viiii\",\n        500000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000: \"viiii\",\n        5000000000000000000000000:\
    \ \"viiii\",\n        100000000000000000000000000: \"viiii\",\n        50000000000000000000000000:\
    \ \"viiii\",\n        1000000000000000000000000000: \"viiii\",\n        500000000000000000000000000:\
    \ \"viiii\",\n        10000000000000000000000000000: \"viiii\",\n        5000000000000000000000000000\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpyo631ndu_test.go:73:37: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n  \
    \  case 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number\
    \ = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiuqg9dqn_test.go:101:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    roman_numerals := []string{\"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\", \"\
    XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"XX\", \"XXI\"\
    , \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\", \"XXVIII\", \"\
    XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"XXXV\", \"XXXVI\"\
    , \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\", \"LXI\", \"LXII\"\
    , \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\", \"LXIX\", \"\
    XC\", \"C\", \"CI\", \"CIX\", \"CX\", \"CXI\", \"CXII\", \"CXIII\", \"CXIV\",\
    \ \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CC\", \"CCI\", \"CCII\"\
    , \"CCIII\", \"CCIV\", \"CCV\", \"CCVI\", \"CCVII\", \"CCVIII\", \"CCIX\", \"\
    CD\", \"D\", \"DI\", \"DII\", \"DIII\", \"DIIII\", \"DIIV\", \"DIV\", \"DIVI\"\
    , \"DIVII\", \"DIVIII\", \"DIVIV\", \"DIVV\", \"DIVVI\", \"DIVVII\", \"DIVVIII\"\
    , \"DIVIX\", \"CM\", \"M\", \"MI\", \"MII\", \"MIII\", \"MIIV\", \"MIV\", \"MIVI\"\
    , \"MIVII\", \"MIVIII\", \"MIVIV\", \"MIVV\", \"MIVVI\", \"MIVVII\", \"MIVVIII\"\
    , \"MIVIX\", \"MN\", \"N\", \"NI\", \"NII\", \"NIII\", \"NIV\", \"NIVI\", \"NIVII\"\
    , \"NIVIII\", \"NIVIV\", \"NIVV\", \"NIVVI\", \"NIVVII\", \"NIVVIII\", \"NIVIX\"\
    , \"NO\", \"O\", \"OI\", \"OII\", \"OIII\", \"OIV\", \"OIVI\", \"OIVII\", \"OIVIII\"\
    , \"OIVIV\", \"OIVV\", \"OIVVI\", \"OIVVII\", \"OIVVIII\", \"OIVIX\", \"OO\",\
    \ \"OOI\", \"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpgg8hw8_r_test.go:22:1129: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    ix\",\n        500: \"ixi\",\n        1000: \"ixii\",\n    }\n    romanNumeral\
    \ := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n}\n\nfunc\
    \ TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprv6ttaer_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    romans := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\"\
    ,\n        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n        10000:\
    \ \"c\",\n        50000: \"c\",\n        100000: \"x\",\n        500000: \"x\"\
    ,\n        1000000: \"ix\",\n        5000000: \"ix\",\n        10000000: \"iv\"\
    ,\n        50000000: \"iv\",\n        100000000: \"v\",\n        500000000: \"\
    v\",\n        1000000000: \"vi\",\n        5000000000: \"vi\",\n        10000000000:\
    \ \"i\",\n        50000000000: \"i\",\n        100000000000: \"ii\",\n       \
    \ 500000000000: \"ii\",\n        1000000000000: \"ii\",\n        5000000000000:\
    \ \"ii\",\n        10000000000000: \"ii\",\n        50000000000000: \"ii\",\n\
    \        100000000000000: \"ii\",\n        500000000000000: \"ii\",\n        1000000000000000:\
    \ \"ii\",\n        5000000000000000: \"ii\",\n        1000000000000000000: \"\
    ii\",\n        50000000000000000: \"ii\",\n        10000000000000000000: \"ii\"\
    ,\n        5000000000000000000: \"ii\",\n        100000000000000000000: \"ii\"\
    ,\n        50000000000000000000: \"ii\",\n        1000000000000000000000: \"ii\"\
    ,\n        500000000000000000000: \"ii\",\n        10000000000000000000000: \"\
    ii\",\n        5000000000000000000000: \"ii\",\n        100000000000000000000000:\
    \ \"ii\",\n        50000000000000000000000: \"ii\",\n        1000000000000000000000000:\
    \ \"ii\",\n        500000000000000000000000: \"ii\",\n        10000000000000000000000000:\
    \ \"ii\",\n        5000000000000000000000000: \"ii\",\n        100000000000000000000000000:\
    \ \"ii\",\n        50000000000000000000000000: \"ii\",\n        1000000000000000000000000000:\
    \ \"ii\",\n        500000000000000000000000000: \"ii\",\n        10000000000000000000000000000:\
    \ \"ii\",\n        5000000000000000000000000000: \"ii\",\n        100000000000000000000000000000:\
    \ \"ii\",\n        50000000000000000000000000000: \"ii\",\n        1000000000000000000000000000000:\
    \ \"ii\",\n        500000000000000000000000000000: \"ii\",\n        10000000000000000000000000000000:\
    \ \"ii\",\n        5000000000000000000000000000000: \"ii\",\n        100000000000000000000000000000000:\
    \ \"ii\",\n        50000000000000000000000000000000: \"ii\",\n        1000000000000000000000000000000000:\
    \ \"ii\",\n        500000000000000000000000000000000: \"\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp3mzvdrpb_test.go:86:44: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := []string{\n        \"I\", \"II\", \"III\"\
    , \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\", \"XI\", \"XII\",\n\
    \        \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"XIX\", \"\
    XX\", \"XXI\", \"XXII\",\n        \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\",\n        \"XXXII\", \"XXXIII\", \"\
    XXXIV\", \"XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\",\n        \"\
    XL\", \"L\", \"LI\", \"LII\", \"LII\", \"LIII\", \"LIV\", \"LV\", \"LVI\", \"\
    LVII\", \"LVIII\",\n        \"LIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"\
    LXIV\", \"LXV\", \"LXVI\", \"LXVII\", \"LXVIII\",\n        \"LXIX\", \"LXX\",\
    \ \"LXXI\", \"LXXII\", \"LXXIII\", \"LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\"\
    ,\n        \"LXXVIII\", \"LXXIX\", \"LXXX\", \"LXXXI\", \"LXXXII\", \"LXXXIII\"\
    , \"LXXXIV\", \"LXXXV\",\n        \"LXXXVI\", \"LXXXVII\", \"LXXXVIII\", \"LXXXIX\"\
    , \"XC\", \"C\", \"CI\", \"CII\", \"CII\",\n        \"CIII\", \"CIV\", \"CV\"\
    , \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"CXII\",\n        \"\
    CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\", \"CXX\"\
    , \"CXXI\",\n        \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"\
    CXXVII\", \"CXXVIII\", \"CXXIX\",\n        \"CXXX\", \"CXXXI\", \"CXXXII\", \"\
    CXXXIII\", \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\",\n        \"CXXXVIII\"\
    , \"CXXXIX\", \"CC\", \"CCI\", \"CCII\", \"CCIII\", \"CCIV\", \"CV\", \"CVI\"\
    ,\n        \"CVII\", \"CVIII\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmppsq4yepq_test.go:34:17: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n        return \"\"\n    }\n\n    roman_numerals := []string{\"\
    I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\", \"X\"\
    , \"XI\", \"XII\", \"XIII\", \"XIV\", \"XV\", \"XVI\", \"XVII\", \"XVIII\", \"\
    XIX\", \"XX\", \"XXI\", \"XXII\", \"XXIII\", \"XXIV\", \"XXV\", \"XXVI\", \"XXVII\"\
    , \"XXVIII\", \"XXIX\", \"XXX\", \"XXXI\", \"XXXII\", \"XXXIII\", \"XXXIV\", \"\
    XXXV\", \"XXXVI\", \"XXXVII\", \"XXXVIII\", \"XXXIX\", \"XL\", \"L\", \"LI\",\
    \ \"LII\", \"LIII\", \"LIIII\", \"LIIV\", \"LIV\", \"LIVI\", \"LIVII\", \"LIVIII\"\
    , \"LIIX\", \"LX\", \"LXI\", \"LXII\", \"LXIII\", \"LXIV\", \"LXV\", \"LXVI\"\
    , \"LXVII\", \"LXVIII\", \"LXIX\", \"LXX\", \"LXXI\", \"LXXII\", \"LXXIII\", \"\
    LXXIV\", \"LXXV\", \"LXXVI\", \"LXXVII\", \"LXXVIII\", \"LXXIX\", \"LXXX\", \"\
    LXXXI\", \"LXXXII\", \"LXXXIII\", \"LXXXIV\", \"LXXXV\", \"LXXXVI\", \"LXXXVII\"\
    , \"LXXXVIII\", \"LXXXIX\", \"XC\", \"C\", \"CI\", \"CII\", \"CIII\", \"CIIII\"\
    , \"CIV\", \"CV\", \"CVI\", \"CVII\", \"CVIII\", \"CIX\", \"CX\", \"CXI\", \"\
    CXII\", \"CXIII\", \"CXIV\", \"CXV\", \"CXVI\", \"CXVII\", \"CXVIII\", \"CXIX\"\
    , \"CXX\", \"CXXI\", \"CXXII\", \"CXXIII\", \"CXXIV\", \"CXXV\", \"CXXVI\", \"\
    CXXVII\", \"CXXVIII\", \"CXXIX\", \"CXXX\", \"CXXXI\", \"CXXXII\", \"CXXXIII\"\
    , \"CXXXIV\", \"CXXXV\", \"CXXXVI\", \"CXXXVII\", \"CXXXVIII\", \"CXXXIX\", \"\
    CXL\", \"CL\", \"CLI\", \"CLII\", \"CLIII\", \"CLIIII\", \"CLIIV\", \"CLIV\",\
    \ \"CLIVI\", \"CLIV\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate :=\
    \ int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp5efi0mxf_test.go:24:1117: string literal not terminated

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    roman_number := \"\"\n    switch number {\n    case\
    \ 1:\n        roman_number = \"x\"\n    case 2:\n        roman_number = \"ix\"\
    \n    case 3:\n        roman_number = \"lb\"\n    case 4:\n        roman_number\
    \ = \"c\"\n    case 5:\n        roman_number = \"d\"\n    case 6:\n        roman_number\
    \ = \"i\"\n    case 7:\n        roman_number = \"v\"\n    case 8:\n        roman_number\
    \ = \"f\"\n    case 9:\n        roman_number = \"v\"\n    case 10:\n        roman_number\
    \ = \"x\"\n    case 11:\n        roman_number = \"c\"\n    case 12:\n        roman_number\
    \ = \"lb\"\n    case 13:\n        roman_number = \"c\"\n    case 14:\n       \
    \ roman_number = \"d\"\n    case 15:\n        roman_number = \"i\"\n    case 16:\n\
    \        roman_number = \"v\"\n    case 17:\n        roman_number = \"f\"\n  \
    \  case 18:\n        roman_number = \"v\"\n    case 19:\n        roman_number\
    \ = \"x\"\n    case 20:\n        roman_number = \"c\"\n    case 21:\n        roman_number\
    \ = \"lb\"\n    case 22:\n        roman_number = \"c\"\n    case 23:\n       \
    \ roman_number = \"d\"\n    case 24:\n        roman_number = \"i\"\n    case 25:\n\
    \        roman_number = \"v\"\n    case 26:\n        roman_number = \"f\"\n  \
    \  case 27:\n        roman_number = \"v\"\n    case 28:\n        roman_number\
    \ = \"x\"\n    case 29:\n        roman_number = \"c\"\n    case 30:\n        roman_number\
    \ = \"lb\"\n    case 31:\n        roman_number = \"c\"\n    case 32:\n       \
    \ roman_number = \"d\"\n    case 33:\n        roman_number = \"i\"\n    case 34:\n\
    \        roman_number = \"v\"\n    case 35:\n        roman_number = \"f\"\n  \
    \  case 36:\n        roman_number = \"v\"\n    case 37:\n        roman_number\
    \ = \"x\"\n    case 38:\n        roman_number = \"c\"\n    case 39:\n        roman_number\
    \ = \"lb\"\n    case 40:\n        roman_number = \"c\"\n    case 41:\n       \
    \ roman_number = \"d\"\n    case 42:\n        roman_number = \"i\"\n    case 43:\n\
    \        roman_number = \"v\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv6ii4ixi_test.go:110:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"l\",\n        50: \"l\",\n        100: \"c\"\
    ,\n        500: \"c\",\n        1000: \"d\",\n        5000: \"d\",\n        10000:\
    \ \"c\",\n        50000: \"c\",\n        100000: \"x\",\n        500000: \"x\"\
    ,\n        1000000: \"ix\",\n        5000000: \"ix\",\n        10000000: \"iv\"\
    ,\n        50000000: \"iv\",\n        100000000: \"v\",\n        500000000: \"\
    v\",\n        1000000000: \"vi\",\n        5000000000: \"vi\",\n        10000000000:\
    \ \"vi\",\n        50000000000: \"vi\",\n        100000000000: \"vi\",\n     \
    \   500000000000: \"vi\",\n        1000000000000: \"vi\",\n        5000000000000:\
    \ \"vi\",\n        10000000000000: \"vi\",\n        50000000000000: \"vi\",\n\
    \        100000000000000: \"vi\",\n        500000000000000: \"vi\",\n        1000000000000000:\
    \ \"vi\",\n        5000000000000000: \"vi\",\n        1000000000000000000: \"\
    vi\",\n    }\n    roman_numeral := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpytu2stdd_test.go:55:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n        5000: \"vi\",\n\
    \        10000: \"vi\",\n        50000: \"vi\",\n        100000: \"vi\",\n   \
    \     500000: \"vi\",\n        1000000: \"vi\",\n        5000000: \"vi\",\n  \
    \      10000000: \"vi\",\n        50000000: \"vi\",\n        100000000: \"vi\"\
    ,\n        500000000: \"vi\",\n        1000000000: \"vi\",\n        5000000000:\
    \ \"vi\",\n        10000000000: \"vi\",\n        50000000000: \"vi\",\n      \
    \  100000000000: \"vi\",\n        500000000000: \"vi\",\n        1000000000000:\
    \ \"vi\",\n        5000000000000: \"vi\",\n        10000000000000: \"vi\",\n \
    \       50000000000000: \"vi\",\n        100000000000000: \"vi\",\n        500000000000000:\
    \ \"vi\",\n        1000000000000000: \"vi\",\n        5000000000000000: \"vi\"\
    ,\n        1000000000000000000: \"vi\",\n    }\n\n    roman_numeral := roman_numerals[number]\n\
    \n    return strings.ToLower(roman_numeral)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpq6aom9m8_test.go:57:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    if number < 1 || number > 1000 {\n        fmt.Println(\"\
    Invalid input\")\n    }\n    roman_num := \"\"\n    switch number {\n    case\
    \ 1:\n        roman_num = \"I\"\n    case 2:\n        roman_num = \"II\"\n   \
    \ case 3:\n        roman_num = \"III\"\n    case 4:\n        roman_num = \"IV\"\
    \n    case 5:\n        roman_num = \"V\"\n    case 6:\n        roman_num = \"\
    VI\"\n    case 7:\n        roman_num = \"VII\"\n    case 8:\n        roman_num\
    \ = \"VIII\"\n    case 9:\n        roman_num = \"IX\"\n    case 10:\n        roman_num\
    \ = \"X\"\n    case 11:\n        roman_num = \"XI\"\n    case 12:\n        roman_num\
    \ = \"XII\"\n    case 13:\n        roman_num = \"XIII\"\n    case 14:\n      \
    \  roman_num = \"XIV\"\n    case 15:\n        roman_num = \"XV\"\n    case 16:\n\
    \        roman_num = \"XVI\"\n    case 17:\n        roman_num = \"XVII\"\n   \
    \ case 18:\n        roman_num = \"XVIII\"\n    case 19:\n        roman_num = \"\
    XIX\"\n    case 20:\n        roman_num = \"XX\"\n    case 21:\n        roman_num\
    \ = \"XXI\"\n    case 22:\n        roman_num = \"XXII\"\n    case 23:\n      \
    \  roman_num = \"XXIII\"\n    case 24:\n        roman_num = \"XXIV\"\n    case\
    \ 25:\n        roman_num = \"XXV\"\n    case 26:\n        roman_num = \"XXVI\"\
    \n    case 27:\n        roman_num = \"XXVII\"\n    case 28:\n        roman_num\
    \ = \"XXVIII\"\n    case 29:\n        roman_num = \"XXIX\"\n    case 30:\n   \
    \     roman_num = \"XXX\"\n    case 31:\n        roman_num = \"XXXI\"\n    case\
    \ 32:\n        roman_num = \"XXXII\"\n    case 33:\n        roman_num = \"XXXIII\"\
    \n    case 34:\n        roman_num = \"XXXIV\"\n    case 35:\n        roman_num\
    \ = \"XXXV\"\n    case 36:\n        roman_num = \"XXXVI\"\n    case 37:\n    \
    \    roman_num = \"XXXVII\"\n    case 38:\n        roman_num = \"XXXVIII\"\n \
    \   case 39:\n        \nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpomz1zvcm_test.go:102:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := []string{\n        \"I\", \"IV\", \"V\"\
    , \"IX\", \"X\", \"XL\", \"L\", \"XC\", \"C\", \"CD\", \"D\", \"CM\", \"M\"\n\
    \    }\n    romanNumeralIndex := 0\n    romanNumeralIndex := romanNumeralIndex\
    \ + number/100\n    romanNumeralIndex := romanNumeralIndex % 10\n    romanNumeralIndex\
    \ := romanNumeralIndex + number%100/10\n    romanNumeralIndex := romanNumeralIndex\
    \ % 10\n    romanNumeralIndex := romanNumeralIndex + number%100\n    return romanNumerals[romanNumeralIndex]\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpbg7zetg2_test.go:20:78: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := []string{\"M\", \"CM\", \"D\", \"CD\", \"\
    C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"}\n    roman_number\
    \ := roman_number[:number%100]\n    number /= 100\n    roman_number := append(roman_number,\
    \ roman_number[:number%10]...)\n    number /= 10\n    roman_number := append(roman_number,\
    \ roman_number[:number]...)\n    return string(roman_number)\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp7876asd6_test.go:20:18: no new variables on left side of :=

    /tmp/tmp7876asd6_test.go:22:18: no new variables on left side of :=

    /tmp/tmp7876asd6_test.go:24:18: no new variables on left side of :=

    /tmp/tmp7876asd6_test.go:25:19: cannot convert roman_number (variable of type
    []string) to type string

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"x\"\n    case 5:\n        roman_num = \"v\"\n    case 10:\n\
    \        roman_num = \"i\"\n    case 20:\n        roman_num = \"x\"\n    case\
    \ 50:\n        roman_num = \"l\"\n    case 100:\n        roman_num = \"c\"\n \
    \   case 200:\n        roman_num = \"d\"\n    case 500:\n        roman_num = \"\
    l\"\n    case 1000:\n        roman_num = \"m\"\n    }\n    return roman_num\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp4ipz4a9i_test.go:69: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp4ipz4a9i_test.go:69: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp4ipz4a9i_test.go:69: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp4ipz4a9i_test.go:69: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n        tmp4ipz4a9i_test.go:69:\
    \ expected 'd', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n\
    \        tmp4ipz4a9i_test.go:69: expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmp4ipz4a9i_test.go:69: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmp4ipz4a9i_test.go:69: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmp4ipz4a9i_test.go:69: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmp4ipz4a9i_test.go:69: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmp4ipz4a9i_test.go:69:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp4ipz4a9i_test.go:69: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp4ipz4a9i_test.go:69:\
    \ expected 'cmxciv', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075550
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n    }\n    roman_numeral\
    \ := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n}\n\n\
    func TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpp71f63gr_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_numerals := map[int]string{\n        1: \"i\",\n  \
    \      5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viv\",\n        50000: \"viiv\",\n        100000: \"viv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        10000000: \"viv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\",\n     \
    \   5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n  \
    \  }\n\n    roman_numeral := roman_numerals[number]\n    return strings.ToLower(roman_numeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmprheoalsq_test.go:56:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075550
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpszcenp2e_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viv\",\n        1000: \"vi\",\n    }\n    romanNumerals[1000]\
    \ = \"v\"\n    romanNumerals[5000] = \"vi\"\n    romanNumerals[10000] = \"vii\"\
    \n    romanNumerals[50000] = \"viii\"\n    romanNumerals[1000000] = \"viv\"\n\
    \    romanNumerals[5000000] = \"viv\"\n    romanNumerals[100000000] = \"vi\"\n\
    \    romanNumerals[500000000] = \"vii\"\n    romanNumerals[10000000000] = \"viii\"\
    \n    romanNumerals[5000000000] = \"viii\"\n    romanNumerals[100000000000] =\
    \ \"viv\"\n    romanNumerals[50000000000] = \"viv\"\n    romanNumerals[1000000000000]\
    \ = \"vi\"\n    romanNumerals[5000000000000] = \"vii\"\n    romanNumerals[100000000000000]\
    \ = \"viii\"\n    romanNumerals[50000000000000] = \"viii\"\n    romanNumerals[1000000000000000]\
    \ = \"viv\"\n    romanNumerals[500000000000000] = \"viv\"\n    romanNumerals[10000000000000000]\
    \ = \"vi\"\n    romanNumerals[5000000000000000] = \"vii\"\n    romanNumerals[100000000000000000]\
    \ = \"viii\"\n    romanNumerals[50000000000000000] = \"viii\"\n    romanNumerals[1000000000000000000]\
    \ = \"viv\"\n    romanNumerals[500000000000000000] = \"viv\"\n    romanNumerals[10000000000000000000]\
    \ = \"vi\"\n    romanNumerals[1000000000000000000] = \"v\"\n    romanNumerals[50000000000000000]\
    \ = \"vi\"\n    romanNumerals[10000000000000000000] = \"vii\"\n    romanNumerals[500000000000000000]\
    \ = \"viii\"\n    romanNumerals[100000000000000000000] = \"viv\"\n    romanNumerals[50000000000000000000]\
    \ = \"viv\"\n    romanNumerals[1000000000000000000000] = \"vi\"\n    romanNumerals[500000000000000000000]\
    \ = \"vii\"\n    romanNumeral\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpzj2xa2_y_test.go:62:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"I\"\n    case 2:\n        roman_number = \"II\"\n  \
    \  case 3:\n        roman_number = \"III\"\n    case 4:\n        roman_number\
    \ = \"IV\"\n    case 5:\n        roman_number = \"V\"\n    case 6:\n        roman_number\
    \ = \"VI\"\n    case 7:\n        roman_number = \"VII\"\n    case 8:\n       \
    \ roman_number = \"VIII\"\n    case 9:\n        roman_number = \"IX\"\n    case\
    \ 10:\n        roman_number = \"X\"\n    case 11:\n        roman_number = \"XI\"\
    \n    case 12:\n        roman_number = \"XII\"\n    case 13:\n        roman_number\
    \ = \"XIII\"\n    case 14:\n        roman_number = \"XIV\"\n    case 15:\n   \
    \     roman_number = \"XV\"\n    case 16:\n        roman_number = \"XVI\"\n  \
    \  case 17:\n        roman_number = \"XVII\"\n    case 18:\n        roman_number\
    \ = \"XVIII\"\n    case 19:\n        roman_number = \"XIX\"\n    case 20:\n  \
    \      roman_number = \"XX\"\n    case 21:\n        roman_number = \"XXI\"\n \
    \   case 22:\n        roman_number = \"XXII\"\n    case 23:\n        roman_number\
    \ = \"XXIII\"\n    case 24:\n        roman_number = \"XXIV\"\n    case 25:\n \
    \       roman_number = \"XXV\"\n    case 26:\n        roman_number = \"XXVI\"\n\
    \    case 27:\n        roman_number = \"XXVII\"\n    case 28:\n        roman_number\
    \ = \"XXVIII\"\n    case 29:\n        roman_number = \"XXIX\"\n    case 30:\n\
    \        roman_number = \"XXX\"\n    case 31:\n        roman_number = \"XXXI\"\
    \n    case 32:\n        roman_number = \"XXXII\"\n    case 33:\n        roman_number\
    \ = \"XXXIII\"\n    case 34:\n        roman_number = \"XXXIV\"\n    case 35:\n\
    \        roman_number = \"XXXV\"\n    case 36:\n        roman_number = \"XXXVI\"\
    \n    case 37:\n        roman_number = \"XXXVII\"\n    case 38:\n        roman_number\
    \ = \"XXXVIII\"\n    case 39:\n        roman_number = \"XXXIX\"\n    case 40:\n\
    \        roman_number = \"XL\"\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n \
    \ candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpiuqg9dqn_test.go:101:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075538
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"I\",\n   \
    \     5: \"V\",\n        10: \"X\",\n        50: \"L\",\n        100: \"C\",\n\
    \        500: \"D\",\n        1000: \"M\",\n    }\n    romanNumeral := romanNumerals[number]\n\
    \    return strings.ToLower(romanNumeral)\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpszcenp2e_test.go:29:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075543
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_num := \"\"\n    switch number {\n    case 1:\n   \
    \     roman_num = \"x\"\n    case 5:\n        roman_num = \"v\"\n    case 10:\n\
    \        roman_num = \"i\"\n    case 20:\n        roman_num = \"x\"\n    case\
    \ 50:\n        roman_num = \"l\"\n    case 100:\n        roman_num = \"c\"\n \
    \   case 200:\n        roman_num = \"d\"\n    case 500:\n        roman_num = \"\
    l\"\n    case 1000:\n        roman_num = \"m\"\n    case 2000:\n        roman_num\
    \ = \"c\"\n    case 5000:\n        roman_num = \"l\"\n    case 10000:\n      \
    \  roman_num = \"c\"\n    case 20000:\n        roman_num = \"d\"\n    case 50000:\n\
    \        roman_num = \"l\"\n    case 100000:\n        roman_num = \"m\"\n    case\
    \ 200000:\n        roman_num = \"c\"\n    case 500000:\n        roman_num = \"\
    l\"\n    case 1000000:\n        roman_num = \"m\"\n    case 2000000:\n       \
    \ roman_num = \"c\"\n    case 5000000:\n        roman_num = \"l\"\n    case 10000000:\n\
    \        roman_num = \"m\"\n    case 20000000:\n        roman_num = \"c\"\n  \
    \  case 50000000:\n        roman_num = \"l\"\n    default:\n        fmt.Println(\"\
    Error: number too large\")\n    }\n    return roman_num\n}\n\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Error: number too large\nError: number too large\nError: number too large\n\
    Error: number too large\nError: number too large\nError: number too large\nError:\
    \ number too large\nError: number too large\nError: number too large\nError: number\
    \ too large\nError: number too large\n--- FAIL: TestInt_To_Mini_Roman (0.00s)\n\
    \    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmp616yg96g_test.go:99:\
    \ expected 'xix', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n\
    \        tmp616yg96g_test.go:99: expected 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmp616yg96g_test.go:99: expected 'ccli', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmp616yg96g_test.go:99: expected\
    \ 'cdxxvi', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n\
    \        tmp616yg96g_test.go:99: expected 'd', got 'l'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__5\
    \ (0.00s)\n        tmp616yg96g_test.go:99: expected 'i', got 'x'\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__6 (0.00s)\n        tmp616yg96g_test.go:99: expected\
    \ 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7 (0.00s)\n    \
    \    tmp616yg96g_test.go:99: expected 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8\
    \ (0.00s)\n        tmp616yg96g_test.go:99: expected 'xc', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__9 (0.00s)\n        tmp616yg96g_test.go:99: expected\
    \ 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10 (0.00s)\n \
    \       tmp616yg96g_test.go:99: expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmp616yg96g_test.go:99: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmp616yg96g_test.go:99:\
    \ expected 'cmxciv', got ''\nFAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075550
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 5:\n        roman_number = \"v\"\n   \
    \ case 10:\n        roman_number = \"i\"\n    case 50:\n        roman_number =\
    \ \"l\"\n    case 100:\n        roman_number = \"c\"\n    case 500:\n        roman_number\
    \ = \"d\"\n    case 1000:\n        roman_number = \"m\"\n    }\n    return roman_number\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestInt_To_Mini_Roman (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0\
    \ (0.00s)\n        tmp90p27_ny_test.go:65: expected 'xix', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__1 (0.00s)\n        tmp90p27_ny_test.go:65: expected\
    \ 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2 (0.00s)\n  \
    \      tmp90p27_ny_test.go:65: expected 'ccli', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__3\
    \ (0.00s)\n        tmp90p27_ny_test.go:65: expected 'cdxxvi', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__5 (0.00s)\n        tmp90p27_ny_test.go:65:\
    \ expected 'i', got 'x'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6 (0.00s)\n\
    \        tmp90p27_ny_test.go:65: expected 'iv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__7\
    \ (0.00s)\n        tmp90p27_ny_test.go:65: expected 'xliii', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__8 (0.00s)\n        tmp90p27_ny_test.go:65: expected\
    \ 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9 (0.00s)\n    \
    \    tmp90p27_ny_test.go:65: expected 'xciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__10\
    \ (0.00s)\n        tmp90p27_ny_test.go:65: expected 'dxxxii', got ''\n    ---\
    \ FAIL: TestInt_To_Mini_Roman/test_num__11 (0.00s)\n        tmp90p27_ny_test.go:65:\
    \ expected 'cm', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__12 (0.00s)\n\
    \        tmp90p27_ny_test.go:65: expected 'cmxciv', got ''\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075542
- exit_code: 2
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viiv\",\n        1000: \"viv\",\n        5000: \"viiv\"\
    ,\n        10000: \"viv\",\n        50000: \"viiv\",\n        100000: \"viv\"\
    ,\n        500000: \"viiv\",\n        1000000: \"viv\",\n        5000000: \"viiv\"\
    ,\n        10000000: \"viv\",\n        50000000: \"viiv\",\n        100000000:\
    \ \"viv\",\n        500000000: \"viiv\",\n        1000000000: \"viv\",\n     \
    \   5000000000: \"viiv\",\n        10000000000: \"viv\",\n        50000000000:\
    \ \"viiv\",\n        100000000000: \"viv\",\n        500000000000: \"viiv\",\n\
    \        1000000000000: \"viv\",\n        5000000000000: \"viiv\",\n        10000000000000:\
    \ \"viv\",\n        50000000000000: \"viiv\",\n        100000000000000: \"viv\"\
    ,\n        500000000000000: \"viiv\",\n        1000000000000000: \"viv\",\n  \
    \      5000000000000000: \"viiv\",\n        1000000000000000000: \"viv\",\n  \
    \  }\n    romanNumeral := romanNumerals[number]\n    return strings.ToLower(romanNumeral)\n\
    }\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate := int_to_mini_roman\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate(19), expected: \"xix\" },\n   \
    \  { actual: candidate(152), expected: \"clii\" },\n     { actual: candidate(251),\
    \ expected: \"ccli\" },\n     { actual: candidate(426), expected: \"cdxxvi\" },\n\
    \     { actual: candidate(500), expected: \"d\" },\n     { actual: candidate(1),\
    \ expected: \"i\" },\n     { actual: candidate(4), expected: \"iv\" },\n     {\
    \ actual: candidate(43), expected: \"xliii\" },\n     { actual: candidate(90),\
    \ expected: \"xc\" },\n     { actual: candidate(94), expected: \"xciv\" },\n \
    \    { actual: candidate(532), expected: \"dxxxii\" },\n     { actual: candidate(900),\
    \ expected: \"cm\" },\n     { actual: candidate(994), expected: \"cmxciv\" },\n\
    \     { actual: candidate(1000), expected: \"m\" },\n   }\n\n\tfor i, tc := range\
    \ tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\
    \t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\
    \t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\
    \t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmpsh816rh3_test.go:55:12: undefined: strings

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075544
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romanNumerals := map[int]string{\n        1: \"i\",\n   \
    \     5: \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"\
    viv\",\n        500: \"viivi\",\n        1000: \"viivii\",\n        5000: \"viiivi\"\
    ,\n        10000: \"viiivii\",\n        50000: \"vivvi\",\n        100000: \"\
    vivvii\",\n        500000: \"viviv\",\n        1000000: \"vivivi\",\n        5000000:\
    \ \"vivivii\",\n        10000000: \"viviviii\",\n        50000000: \"viviivi\"\
    ,\n        100000000: \"viviivii\",\n        500000000: \"viviiivi\",\n      \
    \  1000000000: \"viviiivii\",\n        5000000000: \"vivivvi\",\n        10000000000:\
    \ \"vivivvii\",\n        50000000000: \"viviviv\",\n        100000000000: \"vivivivi\"\
    ,\n        500000000000: \"viviiviv\",\n        1000000000000: \"viviivivi\",\n\
    \        5000000000000: \"viviiiviv\",\n        10000000000000: \"viviiivivi\"\
    ,\n        50000000000000: \"vivivviv\",\n        100000000000000: \"vivivvivi\"\
    ,\n        500000000000000: \"vivivivvi\",\n        1000000000000000: \"vivivivii\"\
    ,\n        5000000000000000: \"viviiviv\",\n        10000000000000000: \"viviivivi\"\
    ,\n        5000000000000000: \"viviiiviv\",\n        10000000000000000: \"viviiivivi\"\
    ,\n        50000000000000000: \"vivivviv\",\n        100000000000000000: \"vivivvivi\"\
    ,\n        500000000000000000: \"viviviviv\",\n        100000000000000000: \"\
    vivivivivi\",\n        50000000000000000: \"viviiviviv\",\n        1000000000000000000:\
    \ \"viviivivivi\",\n        500000000000000000: \"viviiivivi\",\n        10000000000000000000:\
    \ \"viviiivivi\",\n        5000000000000000000: \"vivivvivi\",\n        100000000000000000000:\
    \ \"vivivvivi\",\n        50000000000000000000: \"viviviviv\",\n        1000000000000000000000:\
    \ \"vivivivivi\",\n        500000000000000000000\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpklhsmb9o_test.go:67:30: missing '','' before newline in composite literal

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 5:\n        roman_number = \"v\"\n   \
    \ case 10:\n        roman_number = \"i\"\n    case 20:\n        roman_number =\
    \ \"x\"\n    case 50:\n        roman_number = \"l\"\n    case 100:\n        roman_number\
    \ = \"c\"\n    case 200:\n        roman_number = \"d\"\n    case 500:\n      \
    \  roman_number = \"l\"\n    case 1000:\n        roman_number = \"c\"\n    case\
    \ 2000:\n        roman_number = \"d\"\n    case 5000:\n        roman_number =\
    \ \"l\"\n    case 10000:\n        roman_number = \"c\"\n    case 20000:\n    \
    \    roman_number = \"d\"\n    case 50000:\n        roman_number = \"l\"\n   \
    \ case 100000:\n        roman_number = \"c\"\n    case 200000:\n        roman_number\
    \ = \"d\"\n    case 500000:\n        roman_number = \"l\"\n    case 1000000:\n\
    \        roman_number = \"c\"\n    case 2000000:\n        roman_number = \"d\"\
    \n    case 5000000:\n        roman_number = \"l\"\n    case 10000000:\n      \
    \  roman_number = \"c\"\n    case 20000000:\n        roman_number = \"d\"\n  \
    \  case 50000000:\n        roman_number = \"l\"\n    case 100000000:\n       \
    \ roman_number = \"c\"\n    case 200000000:\n        roman_number = \"d\"\n  \
    \  case 500000000:\n        roman_number = \"l\"\n    case 1000000000:\n     \
    \   roman_number = \"c\"\n    case 2000000000:\n        roman_number = \"d\"\n\
    \    case 5000000000:\n        roman_number = \"l\"\n    case 10000000000:\n \
    \       roman_number = \"c\"\n    case 20000000000:\n        roman_number = \"\
    d\"\n    case 50000000000:\n        roman_number = \"l\"\n    case 100000000000:\n\
    \        roman_number = \"c\"\n    case 200000000000:\n        roman_number =\
    \ \"d\"\n    case 500000000000:\n        roman_number = \"l\"\n    case 10000000000000:\n\
    \        roman_number = \"c\"\n    case 2000000000000:\n        roman_number =\
    \ \"d\"\n    case 5000000000000:\n        roman_number = \"l\"\n    case 100000000000000:\n\
    \        roman_number = \"c\"\n    case 20000000000000:\n        roman_number\
    \ = \"d\"\n    case 50000000000000:\n        roman_\nfunc TestInt_To_Mini_Roman(t\
    \ *testing.T) {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\t\
    actual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
    \  { actual: candidate(19), expected: \"xix\" },\n     { actual: candidate(152),\
    \ expected: \"clii\" },\n     { actual: candidate(251), expected: \"ccli\" },\n\
    \     { actual: candidate(426), expected: \"cdxxvi\" },\n     { actual: candidate(500),\
    \ expected: \"d\" },\n     { actual: candidate(1), expected: \"i\" },\n     {\
    \ actual: candidate(4), expected: \"iv\" },\n     { actual: candidate(43), expected:\
    \ \"xliii\" },\n     { actual: candidate(90), expected: \"xc\" },\n     { actual:\
    \ candidate(94), expected: \"xciv\" },\n     { actual: candidate(532), expected:\
    \ \"dxxxii\" },\n     { actual: candidate(900), expected: \"cm\" },\n     { actual:\
    \ candidate(994), expected: \"cmxciv\" },\n     { actual: candidate(1000), expected:\
    \ \"m\" },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp6dcajd6l_test.go:103:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    roman_number := \"\"\n    switch number {\n    case 1:\n\
    \        roman_number = \"x\"\n    case 2:\n        roman_number = \"c\"\n   \
    \ case 3:\n        roman_number = \"m\"\n    case 4:\n        roman_number = \"\
    l\"\n    case 5:\n        roman_number = \"x\"\n    case 6:\n        roman_number\
    \ = \"c\"\n    case 7:\n        roman_number = \"m\"\n    case 8:\n        roman_number\
    \ = \"l\"\n    case 9:\n        roman_number = \"x\"\n    case 10:\n        roman_number\
    \ = \"c\"\n    case 11:\n        roman_number = \"m\"\n    case 12:\n        roman_number\
    \ = \"l\"\n    case 13:\n        roman_number = \"x\"\n    case 14:\n        roman_number\
    \ = \"c\"\n    case 15:\n        roman_number = \"m\"\n    case 16:\n        roman_number\
    \ = \"l\"\n    case 17:\n        roman_number = \"x\"\n    case 18:\n        roman_number\
    \ = \"c\"\n    case 19:\n        roman_number = \"m\"\n    case 20:\n        roman_number\
    \ = \"l\"\n    case 21:\n        roman_number = \"x\"\n    case 22:\n        roman_number\
    \ = \"c\"\n    case 23:\n        roman_number = \"m\"\n    case 24:\n        roman_number\
    \ = \"l\"\n    case 25:\n        roman_number = \"x\"\n    case 26:\n        roman_number\
    \ = \"c\"\n    case 27:\n        roman_number = \"m\"\n    case 28:\n        roman_number\
    \ = \"l\"\n    case 29:\n        roman_number = \"x\"\n    case 30:\n        roman_number\
    \ = \"c\"\n    case 31:\n        roman_number = \"m\"\n    case 32:\n        roman_number\
    \ = \"l\"\n    case 33:\n        roman_number = \"x\"\n    case 34:\n        roman_number\
    \ = \"c\"\n    case 35:\n        roman_number = \"m\"\n    case 36:\n        roman_number\
    \ = \"l\"\n    case 37:\n        roman_number = \"x\"\n    case 38:\n        roman_number\
    \ = \"c\"\n    case 39:\n        roman_number = \"m\"\n    case 40:\n        roman_number\
    \ = \"l\"\n    case 41:\n        roman_number = \"x\"\n    case 42:\n        roman_number\
    \ = \"c\"\n    case 43:\n        roman_number = \"m\"\n    case 44:\n        roman_number\
    \ = \"l\"\n    case 45:\n        roman_number\nfunc TestInt_To_Mini_Roman(t *testing.T)\
    \ {\n  candidate := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19),\
    \ expected: \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n\
    \     { actual: candidate(251), expected: \"ccli\" },\n     { actual: candidate(426),\
    \ expected: \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n\
    \     { actual: candidate(1), expected: \"i\" },\n     { actual: candidate(4),\
    \ expected: \"iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n\
    \     { actual: candidate(90), expected: \"xc\" },\n     { actual: candidate(94),\
    \ expected: \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n\
    \     { actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqzxb_32n_test.go:111:6: expected ''('', found TestInt_To_Mini_Roman

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075549
- exit_code: 1
  program: "package int_to_mini_roman_test\n\nimport (\n    \"testing\"\n    \"fmt\"\
    \n)\n\n// Given a positive integer, obtain its roman numeral equivalent as a string,\n\
    // and return it in lowercase.\n// Restrictions: 1 <= num <= 1000\n// Examples:\n\
    // >>> int_to_mini_roman(19)\n// \"xix\"\n// >>> int_to_mini_roman(152)\n// \"\
    clii\"\n// >>> int_to_mini_roman(426)\n// \"cdxxvi\"\nfunc int_to_mini_roman(number\
    \ int) string {\n    romans := map[int]string{\n        1: \"i\",\n        5:\
    \ \"vi\",\n        10: \"vii\",\n        50: \"viii\",\n        100: \"viv\",\n\
    \        500: \"viv\",\n        1000: \"vi\",\n    }\n    roman, ok := romans[number]\n\
    \    if !ok {\n        fmt.Printf(\"Invalid number %v\\n\", number)\n    }\n \
    \   return roman\n}\n\nfunc TestInt_To_Mini_Roman(t *testing.T) {\n  candidate\
    \ := int_to_mini_roman\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate(19), expected:\
    \ \"xix\" },\n     { actual: candidate(152), expected: \"clii\" },\n     { actual:\
    \ candidate(251), expected: \"ccli\" },\n     { actual: candidate(426), expected:\
    \ \"cdxxvi\" },\n     { actual: candidate(500), expected: \"d\" },\n     { actual:\
    \ candidate(1), expected: \"i\" },\n     { actual: candidate(4), expected: \"\
    iv\" },\n     { actual: candidate(43), expected: \"xliii\" },\n     { actual:\
    \ candidate(90), expected: \"xc\" },\n     { actual: candidate(94), expected:\
    \ \"xciv\" },\n     { actual: candidate(532), expected: \"dxxxii\" },\n     {\
    \ actual: candidate(900), expected: \"cm\" },\n     { actual: candidate(994),\
    \ expected: \"cmxciv\" },\n     { actual: candidate(1000), expected: \"m\" },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "Invalid number 19\nInvalid number 152\nInvalid number 251\nInvalid number\
    \ 426\nInvalid number 4\nInvalid number 43\nInvalid number 90\nInvalid number\
    \ 94\nInvalid number 532\nInvalid number 900\nInvalid number 994\n--- FAIL: TestInt_To_Mini_Roman\
    \ (0.00s)\n    --- FAIL: TestInt_To_Mini_Roman/test_num__0 (0.00s)\n        tmpbogrxis6_test.go:61:\
    \ expected 'xix', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__1 (0.00s)\n\
    \        tmpbogrxis6_test.go:61: expected 'clii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__2\
    \ (0.00s)\n        tmpbogrxis6_test.go:61: expected 'ccli', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__3 (0.00s)\n        tmpbogrxis6_test.go:61: expected\
    \ 'cdxxvi', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__4 (0.00s)\n\
    \        tmpbogrxis6_test.go:61: expected 'd', got 'viv'\n    --- FAIL: TestInt_To_Mini_Roman/test_num__6\
    \ (0.00s)\n        tmpbogrxis6_test.go:61: expected 'iv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__7 (0.00s)\n        tmpbogrxis6_test.go:61: expected\
    \ 'xliii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__8 (0.00s)\n \
    \       tmpbogrxis6_test.go:61: expected 'xc', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__9\
    \ (0.00s)\n        tmpbogrxis6_test.go:61: expected 'xciv', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__10 (0.00s)\n        tmpbogrxis6_test.go:61:\
    \ expected 'dxxxii', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__11\
    \ (0.00s)\n        tmpbogrxis6_test.go:61: expected 'cm', got ''\n    --- FAIL:\
    \ TestInt_To_Mini_Roman/test_num__12 (0.00s)\n        tmpbogrxis6_test.go:61:\
    \ expected 'cmxciv', got ''\n    --- FAIL: TestInt_To_Mini_Roman/test_num__13\
    \ (0.00s)\n        tmpbogrxis6_test.go:61: expected 'm', got 'vi'\nFAIL\nFAIL\t\
    command-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075550
