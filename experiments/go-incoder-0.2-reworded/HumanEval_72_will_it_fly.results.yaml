language: go_test.go
name: HumanEval_72_will_it_fly
results:
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe3wgn7ft_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe3wgn7ft_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe3wgn7ft_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe3wgn7ft_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if len(q) == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1]\
    \ {\n        return false\n    }\n    max := 0\n    for _, v := range q {\n  \
    \      max += v\n    }\n    if max > w {\n        return false\n    }\n    return\
    \ will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpezivw3_7_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max == 0 {\n        return true\n\
    \    }\n    if max < w {\n        return false\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum += v\n    }\n    if sum < max {\n        return\
    \ false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n \
    \ candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpx3x9uzk8_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpx3x9uzk8_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpx3x9uzk8_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpx3x9uzk8_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    return\
    \ sum <= w && sum == max\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmphlsen5q__test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075148
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max == w {\n        return true\n\
    \    }\n    if max > w {\n        return false\n    }\n    for i := range q {\n\
    \        if q[i] > max {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpzc_wn8pi_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpzc_wn8pi_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp95rdgq1a_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075146
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if len(q) == 0 {\n  \
    \      return true\n    }\n    if q[len(q)-1] != len(q)/2 {\n        return false\n\
    \    }\n    max := 0\n    for _, v := range q {\n        max += v\n    }\n   \
    \ if max > w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum > w {\n        return true\n    }\n\
    \    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpowtyrgao_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpowtyrgao_test.go:66:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpowtyrgao_test.go:66: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcphcl05o_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpcphcl05o_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    return will_it_fly(q[1:], w)\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpb10x4iu5_test.go:55: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpb10x4iu5_test.go:55:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if len(q) == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1]\
    \ {\n        return false\n    }\n    return will_it_fly(q[1:], w)\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmplyfj7rym_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe3wgn7ft_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe3wgn7ft_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp3ddld33s_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp3ddld33s_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if len(q) == 0 {\n  \
    \      return true\n    }\n    if w == 0 {\n        return false\n    }\n    if\
    \ q[0] < w {\n        return false\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    if max < w {\n        return true\n    }\n    return will_it_fly(q[1:], w)\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpzsr_uhpz_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpzsr_uhpz_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075148
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[len(q)-1] < w {\n        return false\n    }\n    max := q[0]\n    for\
    \ _, v := range q[1:] {\n        if v > max {\n            return false\n    \
    \    }\n        max = v\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp0ivbdqge_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp0ivbdqge_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Your code here\n    if q == nil || len(q) == 0\
    \ {\n        return true\n    }\n    max := 0\n    for _, v := range q {\n   \
    \     max = max+v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum = sum+v\n    }\n    if sum < max\
    \ {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp3w3h0t_0_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp3w3h0t_0_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 2
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if len(q) == 0 {\n  \
    \      return true\n    }\n    if w == 0 {\n        return false\n    }\n    if\
    \ q[len(q)-1] < w {\n        return false\n    }\n    if q[len(q)-1] == w {\n\
    \        return will_it_fly(q[:len(q)-1], w-q)\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp5im31434_test.go:35:42: invalid operation: w - q (mismatched types int
    and []int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    max := q[0]\n    for _, v := range\
    \ q[1:] {\n        if v > max {\n            max = v\n        }\n    }\n    if\
    \ max <= w {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpj3k28_is_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpj3k28_is_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.007s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    return true\n}\n\
    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp7e9vxweu_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp7e9vxweu_test.go:47:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp7e9vxweu_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    for _, v := range q {\n        if v != 0 {\n            if v != q[len(q)-1]\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpx0xk3llp_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075148
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    return will_it_fly(q[:len(q)-1], w-max)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpif3y7gn3_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__1 (0.00s)\n        tmpif3y7gn3_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp95rdgq1a_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075146
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp95rdgq1a_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075146
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpkypq__a5_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpkypq__a5_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075148
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if len(q) == 1 {\n        return q[0] == w\n    }\n    if q[0] != w {\n    \
    \    return false\n    }\n    max := 0\n    for _, v := range q[1:] {\n      \
    \  if v > max {\n            max = v\n        }\n    }\n    return q[len(q)-1]\
    \ <= max\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpfpth9yue_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpfpth9yue_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp95rdgq1a_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075146
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp95rdgq1a_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075146
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // Write your code here.\n    \n    // Write your code here.\n    \n    //\
    \ Write your code here.\n    \n    // Write your code here.\n    \n    // Write\
    \ your code here.\n    \n    // Write your code here.\n    \n    // Write your\
    \ code here.\n    \n    // Write your code here.\n    \n    // Write your code\
    \ here.\n    \n    // Write your code here.\n    \n    // Write your code here.\n\
    \    \n    // Write your code here.\n    \n    // Write your code here.\n    \n\
    \    // \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpv490i7rk_test.go:171:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075146
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqrs0twf3_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpqrs0twf3_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpacmwarqv_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpacmwarqv_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075150
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if len(q) == 1 {\n        return q[0] == w\n    }\n    if q[0] != w {\n    \
    \    return false\n    }\n    return will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp5azomsdv_test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp5azomsdv_test.go:54:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075150
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpzr7x9h2z_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpzr7x9h2z_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpmettgr34_test.go:57: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpmettgr34_test.go:57:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.007s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w && sum == max\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp_zibvs4u_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp_zibvs4u_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    return will_it_fly(q[1:], w) || will_it_fly(q, w-max)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpxo8cqjhf_test.go:58: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpxo8cqjhf_test.go:58:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[len(q)-1] != 0 {\n        return false\n    }\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpl45h6j40_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpl45h6j40_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpl45h6j40_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    if sum == max {\n        return true\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpph49u9nn_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpph49u9nn_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpph49u9nn_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpzr7x9h2z_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpzr7x9h2z_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Your code here\n    max := 0\n    for _, v := range\
    \ q {\n        if v > max {\n            max = v\n        }\n    }\n    if max\
    \ > w {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n\
    \        sum += v\n    }\n    if sum < max {\n        return false\n    }\n  \
    \  return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp9o8cw9g2_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp9o8cw9g2_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp95rdgq1a_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075146
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcphcl05o_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpcphcl05o_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    max -= w\n    for i := 0; i < len(q); i++\
    \ {\n        if q[i] > max {\n            return false\n        }\n    }\n   \
    \ return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmph2t24dc3_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w && sum == max\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp_zibvs4u_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp_zibvs4u_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if len(q) == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1]\
    \ {\n        return false\n    }\n    max := 0\n    for i := 0; i < len(q); i++\
    \ {\n        if max < q[i] {\n            max = q[i]\n        }\n    }\n    if\
    \ max > w {\n        return false\n    }\n    return will_it_fly(q[1:], w)\n}\n\
    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpbxffcegk_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        if v > max {\n            max =\
    \ v\n        }\n    }\n    if w > max {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    return sum <=\
    \ w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpox3mjuhr_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpox3mjuhr_test.go:61:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpacmwarqv_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpacmwarqv_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075150
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        if v > max {\n            max =\
    \ v\n        }\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    return sum <=\
    \ w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp774lixq0_test.go:61: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp774lixq0_test.go:61:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpzr7x9h2z_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpzr7x9h2z_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    if q[len(q)-1] == 0 {\n      \
    \  return false\n    }\n    if q[len(q)-1] == 1 {\n        return will_it_fly(q[:len(q)-1],\
    \ w-1)\n    }\n    return will_it_fly(q[:len(q)-1], w) && will_it_fly(q[len(q)-1:],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc020170388\
    \ stack=[0xc020170000, 0xc040170000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 20 [running]:\ncommand-line-arguments_test.will_it_fly({0xc04016fe28?,\
    \ 0x0?, 0x3?}, 0x9?)\n\t/tmp/tmppp8ox7pw_test.go:23 +0x11d fp=0xc020170398 sp=0xc020170390\
    \ pc=0x4ef77d\ncommand-line-arguments_test.will_it_fly({0xc04016fe28, 0x1, 0x3},\
    \ 0x9)\n\t/tmp/tmppp8ox7pw_test.go:36 +0x74 fp=0xc0201703d0 sp=0xc020170398 pc=0x4ef6d4\n\
    command-line-arguments_test.will_it_fly({0xc04016fe28, 0x1, 0x3}, 0x9)\n\t/tmp/tmppp8ox7pw_test.go:36\
    \ +0xbe fp=0xc020170408 sp=0xc0201703d0 pc=0x4ef71e\ncommand-line-arguments_test.will_it_fly({0xc04016fe28,\
    \ 0x1, 0x3}, 0x9)\n\t/tmp/tmppp8ox7pw_test.go:36 +0xbe fp=0xc020170440 sp=0xc020170408\
    \ pc=0x4ef71e\ncommand-line-arguments_test.will_it_fly({0xc04016fe28, 0x1, 0x3},\
    \ 0x9)\n\t/tmp/tmppp8ox7pw_test.go:36 +0xbe fp=0xc020170478 sp=0xc020170440 pc=0x4ef71e\n\
    command-line-arguments_test.will_it_fly({0xc04016fe28, 0x1, 0x3}, 0x9)\n\t/tmp/tmppp8ox7pw_test.go:36\
    \ +0xbe fp=0xc0201704b0 sp=0xc020170478 pc=0x4ef71e\ncommand-line-arguments_test.will_it_fly({0xc04016fe28,\
    \ 0x1, 0x3}, 0x9)\n\t/tmp/tmppp8ox7pw_test.go:36 +0xbe fp=0xc0201704e8 sp=0xc0201704b0\
    \ pc=0x4ef71e\ncommand-line-arguments_test.will_it_fly({0xc04016fe28, 0x1, 0x3},\
    \ 0x9)\n\t/tmp/tmppp8ox7pw_test.go:36 +0xbe fp=0xc020170520 sp=0xc0201704e8 pc=0x4ef71e\n\
    command-line-arguments_test.will_it_fly({0xc04016fe28, 0x1, 0x3}, 0x9)\n\t/tmp/tmppp8ox7pw_test.go:36\
    \ +0xbe fp=0xc020170558 sp=0xc020170520 pc=0x4ef71e\ncommand-line-arguments_test.will_it_fly({0xc04016fe28,\
    \ 0x1, 0x3}, 0x9)\n\t/tmp/tmppp8ox7pw_test.go:36 +0xbe fp=0xc020170590 sp=0xc020170558\
    \ pc=0x4ef71e\ncommand-line-arguments_test.will_it_fly({0xc04016fe28, 0x1, 0x3},\
    \ 0x9)"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if len(q) == 0 {\n  \
    \      return true\n    }\n    max := 0\n    for _, v := range q {\n        max\
    \ += v\n    }\n    if max > w {\n        return false\n    }\n    sum := 0\n \
    \   for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n     \
    \   return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpxcus8mrw_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpxcus8mrw_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpkjiit5s1_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpkjiit5s1_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpkjiit5s1_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    for _, v := range q {\n        if v != 0 {\n            if v != q[len(q)-1]\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpx0xk3llp_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075148
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if q == nil || w == 0\
    \ {\n        return false\n    }\n    if len(q) == 0 {\n        return true\n\
    \    }\n    max := 0\n    for _, v := range q {\n        max += v\n    }\n   \
    \ if max > w {\n        return false\n    }\n    return will_it_fly(q[1:], w)\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp9_okehje_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp9_okehje_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpe1s9pxxr_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpe1s9pxxr_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpe1s9pxxr_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe3wgn7ft_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe3wgn7ft_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmptm63qxbr_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmptm63qxbr_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcphcl05o_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpcphcl05o_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    if q[0] == q[len(q)-1] {\n   \
    \     return will_it_fly(q[1:], w-1)\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmps6rx81s__test.go:54: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe3wgn7ft_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe3wgn7ft_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpzr7x9h2z_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpzr7x9h2z_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcphcl05o_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpcphcl05o_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max = max * 10 + v\n    }\n   \
    \ return max <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpkmk3qlyr_test.go:52: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpohsthg2r_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpohsthg2r_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe3wgn7ft_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe3wgn7ft_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[0] != 0 {\n        return false\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    return\
    \ sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpk1rfa76h_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpk1rfa76h_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpk1rfa76h_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpidahi12o_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpidahi12o_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpidahi12o_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075154
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[0] != 0 {\n        return false\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    return will_it_fly(q[1:], w)\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpsbczodfm_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpsbczodfm_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpsbczodfm_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075154
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    if max < 0 {\n        return true\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < 0 {\n        return false\n    }\n    return sum == max\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpzi63tkcj_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpzi63tkcj_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075155
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        if v > max {\n            max =\
    \ v\n        }\n    }\n    if w == max {\n        return true\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < w {\n\
    \        return false\n    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpwfiy_u4i_test.go:64: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpwfiy_u4i_test.go:64:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpwfiy_u4i_test.go:64: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075155
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max = max + v\n    }\n    if max < w {\n        return\
    \ false\n    }\n    sum := 0\n    for _, v := range q {\n        sum = sum + v\n\
    \    }\n    if sum < max {\n        return false\n    }\n    return true\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpftxfdlkm_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpftxfdlkm_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpftxfdlkm_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpftxfdlkm_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075155
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum > max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqme5c4ox_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpqme5c4ox_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075156
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    if max == 0 {\n        return true\n    }\n    if max < w {\n        return\
    \ false\n    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n  \
    \  }\n    if sum < max {\n        return false\n    }\n    return true\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpw3kl4nja_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpw3kl4nja_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpw3kl4nja_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075156
- exit_code: 0
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if len(q) == 0 {\n  \
    \      return true\n    }\n    if len(q) == 1 {\n        return q[0] == q[0]\n\
    \    }\n    if q[0] != q[len(q)-1] {\n        return false\n    }\n    max :=\
    \ 0\n    for i := 0; i < len(q); i++ {\n        max += q[i]\n    }\n    if max\
    \ > w {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.004s\n"
  timestamp: 1660075155
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcphcl05o_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpcphcl05o_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpidahi12o_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpidahi12o_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpidahi12o_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075154
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp95rdgq1a_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075146
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpacmwarqv_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpacmwarqv_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075150
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max = max+v\n    }\n    if max%w != 0 {\n        return\
    \ false\n    }\n    for _, v := range q {\n        if v != q[len(q)-1] {\n   \
    \         return false\n        }\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpmqhu0ntt_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpmqhu0ntt_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075156
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe3wgn7ft_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe3wgn7ft_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpacmwarqv_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpacmwarqv_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075150
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpzr7x9h2z_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpzr7x9h2z_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqrs0twf3_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpqrs0twf3_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpohsthg2r_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpohsthg2r_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe3wgn7ft_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe3wgn7ft_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max = max+v\n    }\n    if max%w == 0 {\n        return\
    \ true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n \
    \ candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpjdg6gge6_test.go:53: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpjdg6gge6_test.go:53:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpjdg6gge6_test.go:53: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpjdg6gge6_test.go:53:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075156
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptk2gflia_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075154
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpe1s9pxxr_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpe1s9pxxr_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpe1s9pxxr_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max = max * 10 + v\n    }\n   \
    \ if max > w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum > max {\n        return false\n   \
    \ }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpqd4aluz1_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075156
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpohsthg2r_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpohsthg2r_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp95rdgq1a_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075146
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpzr7x9h2z_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpzr7x9h2z_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpkjiit5s1_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpkjiit5s1_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpkjiit5s1_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[len(q)-1] != len(q)/2 {\n        return false\n    }\n    max := 0\n  \
    \  for _, v := range q {\n        max += v\n    }\n    if max > w {\n        return\
    \ false\n    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpkepnspub_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpkepnspub_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpkepnspub_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075156
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp95rdgq1a_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075146
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n        if sum > w {\n            return false\n        }\n \
    \   }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqodtz42r_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpqodtz42r_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075156
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe3wgn7ft_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe3wgn7ft_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    \n    max := 0\n   \
    \ for _, v := range q {\n        max += v\n    }\n    \n    if max > w {\n   \
    \     return false\n    }\n    \n    sum := 0\n    for _, v := range q {\n   \
    \     sum += v\n    }\n    \n    if sum < max {\n        return true\n    }\n\
    \    \n    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpqydxxb46_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpqydxxb46_test.go:65:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpqydxxb46_test.go:65: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075156
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max == 0 {\n        return true\n\
    \    }\n    if max < w {\n        return false\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum += v\n    }\n    if sum > w {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp7qhct201_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp7qhct201_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp7qhct201_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075156
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[len(q)-1] == 0 {\n        return false\n    }\n    if q[len(q)-1] == 1\
    \ {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1] ==\
    \ 2 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 3 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 4 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 5 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 6 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 7 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 8 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 9 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 10 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 11 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 12 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 13 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 14 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 15 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 16 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 17 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 18 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 19 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == 20 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if \nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpa7le8wju_test.go:91:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075154
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqrs0twf3_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpqrs0twf3_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    return true\n}\n\
    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp7e9vxweu_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp7e9vxweu_test.go:47:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp7e9vxweu_test.go:47: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum > max {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpnqbnq363_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpnqbnq363_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpnqbnq363_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075156
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpacmwarqv_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpacmwarqv_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075150
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpzr7x9h2z_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpzr7x9h2z_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 2
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max = max(max, v)\n    }\n    if\
    \ max < w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < w {\n        return false\n    }\n\
    \    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments_test [command-line-arguments.test]

    /tmp/tmp04pg7bpm_test.go:28:12: v declared but not used

    /tmp/tmp04pg7bpm_test.go:29:15: invalid operation: cannot call non-function max
    (variable of type int)

    '
  stdout: "FAIL\tcommand-line-arguments [build failed]\nFAIL\n"
  timestamp: 1660075155
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp95rdgq1a_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075146
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpohsthg2r_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpohsthg2r_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if q == nil || w == 0\
    \ {\n        return true\n    }\n    max := 0\n    for _, v := range q {\n   \
    \     max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmph0jeaq6u_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmph0jeaq6u_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075156
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe3wgn7ft_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe3wgn7ft_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max = max+v\n    }\n    if max == w {\n        return\
    \ true\n    }\n    if max < w {\n        return false\n    }\n    return true\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpauixv2jp_test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpauixv2jp_test.go:56:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpauixv2jp_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpauixv2jp_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075156
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    max := q[0]\n    for _, v := range\
    \ q[1:] {\n        if v > max {\n            max = v\n        }\n    }\n    if\
    \ max == 0 {\n        return false\n    }\n    if max < w {\n        return false\n\
    \    }\n    return will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp17b_jb3q_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp17b_jb3q_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmp17b_jb3q_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075156
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpzr7x9h2z_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpzr7x9h2z_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpkypq__a5_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpkypq__a5_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075148
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    if len(q) == 0 {\n \
    \       return true\n    }\n    if q[len(q)-1] != 0 {\n        return false\n\
    \    }\n    max := 0\n    for _, v := range q {\n        max += v\n    }\n   \
    \ if max > w {\n        return false\n    }\n    if max == w {\n        return\
    \ true\n    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpcru75adl_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpcru75adl_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpcru75adl_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075156
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpkjiit5s1_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpkjiit5s1_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpkjiit5s1_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n        if sum > w {\n            return false\n        }\n \
    \   }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqodtz42r_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpqodtz42r_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075156
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max = max + v\n    }\n    if max > w {\n        return\
    \ false\n    }\n    sum := 0\n    for _, v := range q {\n        sum = sum + v\n\
    \    }\n    if sum < max {\n        return true\n    }\n    return false\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpllnlxhku_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpllnlxhku_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpllnlxhku_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075158
- exit_code: 0
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    for i := 0; i < len(q); i++ {\n        if\
    \ q[i] != q[len(q)-1-i] {\n            return false\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: OK
  stderr: ''
  stdout: "ok  \tcommand-line-arguments\t0.007s\n"
  timestamp: 1660075158
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp95rdgq1a_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075146
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    if max < 0 {\n        return true\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < 0 {\n        return true\n    }\n    return sum == max\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpovir_6xu_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpovir_6xu_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075158
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max = max * 10 + v\n    }\n    if max > w {\n      \
    \  return false\n    }\n    sum := 0\n    for _, v := range q {\n        sum +=\
    \ v\n    }\n    if sum < max {\n        return false\n    }\n    return true\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpo7dxge_d_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075158
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if len(q) == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1]\
    \ {\n        return false\n    }\n    max := 0\n    for i := 0; i < len(q); i++\
    \ {\n        max += q[i]\n    }\n    if max > w {\n        return false\n    }\n\
    \    return will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n\
    \  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpiivu83u6_test.go:61: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075158
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max == 0 {\n        return true\n\
    \    }\n    if max < w {\n        return false\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum += v\n    }\n    if sum < max {\n        return\
    \ false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n \
    \ candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmptmvak2fe_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmptmvak2fe_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmptmvak2fe_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmptmvak2fe_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    if max <= w {\n        return true\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < w {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmppi_2xxsy_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmppi_2xxsy_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmppi_2xxsy_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Your code here\n    \n    // Write your test here\n\
    \    \n    // Return your result here\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpnkfo7rr8_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpnkfo7rr8_test.go:50:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpnkfo7rr8_test.go:50: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptk2gflia_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075154
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    max := 0\n    for _, v := range\
    \ q {\n        max += v\n    }\n    if max > w {\n        return false\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ > w {\n        return true\n    }\n    return will_it_fly(q[1:], w)\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp0t2qsml8_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmp0t2qsml8_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp95rdgq1a_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075146
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    max := q[0]\n    for _, v := range\
    \ q[1:] {\n        if v > max {\n            max = v\n        }\n    }\n    return\
    \ max == w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp_6a3hnij_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp_6a3hnij_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe3wgn7ft_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe3wgn7ft_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    if max < w {\n        return true\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmplflxo_xa_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmplflxo_xa_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    max := q[len(q)-1]\n    for i\
    \ := range q {\n        if q[i] > max {\n            max = q[i]\n        }\n \
    \   }\n    if max == 0 {\n        return true\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w-max) && will_it_fly(q[len(q)-1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmp8qb8cah3_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp8qb8cah3_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmp8qb8cah3_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if len(q) == 1 {\n        return q[0] == q[0]\n    }\n    if q[0] != q[len(q)-1]\
    \ {\n        return false\n    }\n    max := 0\n    for _, v := range q {\n  \
    \      max += v\n    }\n    return max == w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpn1955ayp_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    if max < w {\n        return true\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum += v\n    }\n    if sum < max {\n        return\
    \ true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n \
    \ candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpja5cs70g_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__5 (0.00s)\n        tmpja5cs70g_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpep857ij9_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpep857ij9_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpep857ij9_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe3wgn7ft_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe3wgn7ft_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpacmwarqv_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpacmwarqv_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075150
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpe1s9pxxr_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpe1s9pxxr_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpe1s9pxxr_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpacmwarqv_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpacmwarqv_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075150
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcphcl05o_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpcphcl05o_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpacmwarqv_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpacmwarqv_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075150
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum > max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmppe6fatny_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmppe6fatny_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max == w {\n        return true\n\
    \    }\n    if max < w {\n        return false\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum += v\n    }\n    if sum < max {\n        return\
    \ false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n \
    \ candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpyguuslmt_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpyguuslmt_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpyguuslmt_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpyguuslmt_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    return\
    \ sum <= w && sum == max\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmphlsen5q__test.go:56: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075148
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    if len(q) == 0 {\n \
    \       return true\n    }\n    if q[0] != 0 {\n        return false\n    }\n\
    \    max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max\
    \ > w {\n        return false\n    }\n    return will_it_fly(q[1:], w)\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp93mug0ev_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp93mug0ev_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmp93mug0ev_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpep857ij9_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpep857ij9_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpep857ij9_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n        if sum > w {\n            return false\n        }\n \
    \   }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpxccc_tye_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpxccc_tye_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[len(q)-1] == 0 {\n        return false\n    }\n    if q[len(q)-1] == w\
    \ {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w) || will_it_fly(q, w-(q[len(q)-1]))\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpzzz25xr4_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpzzz25xr4_test.go:54:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpzzz25xr4_test.go:54: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpzr7x9h2z_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpzr7x9h2z_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpkypq__a5_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpkypq__a5_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075148
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    for _, v := range q {\n        if v != 0 {\n            if v != q[len(q)-1]\
    \ {\n                return false\n            }\n        }\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpx0a_odq4_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe3wgn7ft_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe3wgn7ft_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max < w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < w {\n        return true\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp2wd6hhka_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmp2wd6hhka_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpidahi12o_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpidahi12o_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpidahi12o_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075154
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpkjiit5s1_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpkjiit5s1_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpkjiit5s1_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    if sum == max {\n        return true\n\
    \    }\n    if sum > max {\n        return true\n    }\n    return false\n}\n\n\
    func TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpft95sidg_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpft95sidg_test.go:65:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpft95sidg_test.go:65: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[len(q)-1] < w {\n        return false\n    }\n    max := q[0]\n    for\
    \ _, v := range q[1:] {\n        if v > max {\n            return false\n    \
    \    }\n        max = v\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmp0ivbdqge_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmp0ivbdqge_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpkjiit5s1_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpkjiit5s1_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpkjiit5s1_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqrs0twf3_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpqrs0twf3_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpidahi12o_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpidahi12o_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpidahi12o_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075154
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if len(q) == 0 {\n  \
    \      return true\n    }\n    if len(q) == 1 {\n        return q[0] == q[0]\n\
    \    }\n    max := 0\n    for _, v := range q {\n        max += v\n    }\n   \
    \ if max > w {\n        return false\n    }\n    sum := 0\n    for _, v := range\
    \ q {\n        sum += v\n    }\n    if sum < max {\n        return false\n   \
    \ }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate :=\
    \ will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\
    \t}\n   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected:\
    \ true },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n    \
    \ { actual: candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpq_qezt37_test.go:66: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpq_qezt37_test.go:66:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075160
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max < w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpn_e6kzw2_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpn_e6kzw2_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpn_e6kzw2_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpn_e6kzw2_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075160
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return true\n    }\n    return false\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpe1s9pxxr_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpe1s9pxxr_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpe1s9pxxr_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    if max == w {\n        return true\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpxapv31jd_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpxapv31jd_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075160
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpkjiit5s1_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpkjiit5s1_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpkjiit5s1_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    if max > w {\n        return false\n    }\n    for _, v := range q {\n  \
    \      if v < max {\n            return false\n        }\n    }\n    return true\n\
    }\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype\
    \ test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpuvfcktx9_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075160
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpzr7x9h2z_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpzr7x9h2z_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp95rdgq1a_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075146
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpohsthg2r_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpohsthg2r_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if q == nil || w == 0\
    \ {\n        return true\n    }\n    max := 0\n    for _, v := range q {\n   \
    \     max += v\n    }\n    if max > w {\n        return false\n    }\n    sum\
    \ := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum < max {\n\
    \        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmph0jeaq6u_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmph0jeaq6u_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075156
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if len(q) == 0 {\n  \
    \      return true\n    }\n    if w == 0 {\n        return false\n    }\n    if\
    \ q[len(q)-1] == 0 {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n   \
    \ if q[0] == 0 {\n        return will_it_fly(q[1:], w)\n    }\n    if q[len(q)-1]\
    \ == q[0] {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ < q[0] {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ > q[0] {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == q[0] {\n        return will_it_fly(q[1:], w)\n    }\n    if q[len(q)-1] <\
    \ q[0] {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ > q[0] {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == q[0] {\n        return will_it_fly(q[1:], w)\n    }\n    if q[len(q)-1] <\
    \ q[0] {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ > q[0] {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == q[0] {\n        return will_it_fly(q[1:], w)\n    }\n    if q[len(q)-1] <\
    \ q[0] {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ > q[0] {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == q[0] {\n        return will_it_fly(q[1:], w)\n    }\n    if q[len(q)-1] <\
    \ q[0] {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ > q[0] {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ == q[0] {\n        return will_it_fly(q[1:], w)\n    }\n    if q[len(q)-1] <\
    \ q[0] {\n        return will_it_fly(q[:len(q)-1], w)\n    }\n    if q[len(q)-1]\
    \ > q[0] {\n        return will_it_fly(q[:\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmpqbngh007_test.go:90:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075160
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    if q[len(q)-1] == 0 {\n      \
    \  return false\n    }\n    max := 0\n    for _, v := range q {\n        max +=\
    \ v\n    }\n    if max > w {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w) && will_it_fly(q[len(q)-1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "runtime: goroutine stack exceeds 1000000000-byte limit\nruntime: sp=0xc0201e0388\
    \ stack=[0xc0201e0000, 0xc0401e0000]\nfatal error: stack overflow\n\nruntime stack:\n\
    runtime.throw({0x520348?, 0x5e3ea0?})\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/panic.go:992\
    \ +0x71\nruntime.newstack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/stack.go:1101\
    \ +0x5cc\nruntime.morestack()\n\t/home/a.guha/.conda/envs/polyglot/go/src/runtime/asm_amd64.s:547\
    \ +0x8b\n\ngoroutine 6 [running]:\ncommand-line-arguments_test.will_it_fly({0xc0401dfe28?,\
    \ 0x0?, 0x3?}, 0x9?)\n\t/tmp/tmpf1m0c3r4_test.go:23 +0x114 fp=0xc0201e0398 sp=0xc0201e0390\
    \ pc=0x4ef774\ncommand-line-arguments_test.will_it_fly({0xc0401dfe28, 0x1, 0x3},\
    \ 0x9)\n\t/tmp/tmpf1m0c3r4_test.go:40 +0x9a fp=0xc0201e03d0 sp=0xc0201e0398 pc=0x4ef6fa\n\
    command-line-arguments_test.will_it_fly({0xc0401dfe28, 0x1, 0x3}, 0x9)\n\t/tmp/tmpf1m0c3r4_test.go:40\
    \ +0xe5 fp=0xc0201e0408 sp=0xc0201e03d0 pc=0x4ef745\ncommand-line-arguments_test.will_it_fly({0xc0401dfe28,\
    \ 0x1, 0x3}, 0x9)\n\t/tmp/tmpf1m0c3r4_test.go:40 +0xe5 fp=0xc0201e0440 sp=0xc0201e0408\
    \ pc=0x4ef745\ncommand-line-arguments_test.will_it_fly({0xc0401dfe28, 0x1, 0x3},\
    \ 0x9)\n\t/tmp/tmpf1m0c3r4_test.go:40 +0xe5 fp=0xc0201e0478 sp=0xc0201e0440 pc=0x4ef745\n\
    command-line-arguments_test.will_it_fly({0xc0401dfe28, 0x1, 0x3}, 0x9)\n\t/tmp/tmpf1m0c3r4_test.go:40\
    \ +0xe5 fp=0xc0201e04b0 sp=0xc0201e0478 pc=0x4ef745\ncommand-line-arguments_test.will_it_fly({0xc0401dfe28,\
    \ 0x1, 0x3}, 0x9)\n\t/tmp/tmpf1m0c3r4_test.go:40 +0xe5 fp=0xc0201e04e8 sp=0xc0201e04b0\
    \ pc=0x4ef745\ncommand-line-arguments_test.will_it_fly({0xc0401dfe28, 0x1, 0x3},\
    \ 0x9)\n\t/tmp/tmpf1m0c3r4_test.go:40 +0xe5 fp=0xc0201e0520 sp=0xc0201e04e8 pc=0x4ef745\n\
    command-line-arguments_test.will_it_fly({0xc0401dfe28, 0x1, 0x3}, 0x9)\n\t/tmp/tmpf1m0c3r4_test.go:40\
    \ +0xe5 fp=0xc0201e0558 sp=0xc0201e0520 pc=0x4ef745\ncommand-line-arguments_test.will_it_fly({0xc0401dfe28,\
    \ 0x1, 0x3}, 0x9)\n\t/tmp/tmpf1m0c3r4_test.go:40 +0xe5 fp=0xc0201e0590 sp=0xc0201e0558\
    \ pc=0x4ef745\ncommand-line-arguments_test.will_it_fly({0xc0401dfe28, 0x1, 0x3},\
    \ 0x9)\n"
  timestamp: 1660075162
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // Write your code here\n    \n    //\
    \ Write your code here\n    \n    // Write your code here\n    \n    // Write\
    \ your code here\n    \n    // Write your code here\n    \n    // Write your code\
    \ here\n    \n    // Write your code here\n    \n    // Write your code here\n\
    \    \n    // Write your code here\n    \n    // Write your code here\n    \n\
    \    // Write your code here\n    \n    // \nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp81e0dsi5_test.go:171:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075160
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpqrs0twf3_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpqrs0twf3_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpkjiit5s1_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpkjiit5s1_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpkjiit5s1_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n        if sum > w {\n            return false\n        }\n \
    \   }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpxccc_tye_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpxccc_tye_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcphcl05o_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpcphcl05o_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if w == 0 {\n        return false\n    }\n    if q[len(q)-1] != len(q)-1 {\n\
    \        return false\n    }\n    if q[0] != 0 {\n        return false\n    }\n\
    \    return will_it_fly(q[1:], w-int(q[0]))\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpyff7jwm6_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpyff7jwm6_test.go:57:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpyff7jwm6_test.go:57: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075161
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpacmwarqv_test.go:59: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpacmwarqv_test.go:59:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075150
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    if len(q) == 0 {\n  \
    \      return true\n    }\n    if q[len(q)-1] < w {\n        return false\n  \
    \  }\n    max := 0\n    for _, v := range q {\n        max += v\n    }\n    if\
    \ max > w {\n        return false\n    }\n    return will_it_fly(q[:len(q)-1],\
    \ w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\t\
    type test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmptp_e3vq7_test.go:59: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmptp_e3vq7_test.go:59:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075161
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[len(q)-1] != len(q)/2 {\n        return false\n    }\n    if w == 0 {\n\
    \        return true\n    }\n    max := 0\n    for _, v := range q {\n       \
    \ if v > max {\n            max = v\n        }\n    }\n    return max <= w\n}\n\
    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test\
    \ struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests\
    \ := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n\
    \     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpylwig1m5_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpylwig1m5_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpylwig1m5_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.004s\nFAIL\n"
  timestamp: 1660075161
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    if max > w {\n        return false\n    }\n    sum := 0\n    for _, v :=\
    \ range q {\n        sum += v\n    }\n    if sum < max {\n        return false\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpdcw6czbz_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpdcw6czbz_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075161
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpkjiit5s1_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpkjiit5s1_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpkjiit5s1_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075152
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp95rdgq1a_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075146
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    if len(q) == 0 {\n \
    \       return true\n    }\n    if q[0] < w {\n        return false\n    }\n \
    \   max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max <\
    \ w {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n\
    \        sum += v\n    }\n    return sum <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T)\
    \ {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\
    \t\texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpjdmc7lng_test.go:63: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpjdmc7lng_test.go:63:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075161
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    return true\n}\n\nfunc\
    \ TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\ttype test struct\
    \ {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n\
    \     { actual: candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual:\
    \ candidate([]int{1, 2}, 5), expected: false },\n     { actual: candidate([]int{3},\
    \ 5), expected: true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected:\
    \ false },\n     { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n\
    \     { actual: candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc\
    \ := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T)\
    \ {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected)\
    \ {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\
    \t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpep857ij9_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpep857ij9_test.go:46:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpep857ij9_test.go:46: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.005s\nFAIL\n"
  timestamp: 1660075159
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpzr7x9h2z_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpzr7x9h2z_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.006s\nFAIL\n"
  timestamp: 1660075151
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe3wgn7ft_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe3wgn7ft_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max > w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpe3wgn7ft_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpe3wgn7ft_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.004s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcphcl05o_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpcphcl05o_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    if sum\
    \ < max {\n        return false\n    }\n    if sum == max {\n        return true\n\
    \    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpjm6ge7ja_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__3 (0.00s)\n        tmpjm6ge7ja_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\n    --- FAIL: TestWill_It_Fly/test_num__4\
    \ (0.00s)\n        tmpjm6ge7ja_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.006s\nFAIL\n"
  timestamp: 1660075161
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here.\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmptk2gflia_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075154
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n\
    \    \n    \n    \nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: SyntaxError
  stderr: '# command-line-arguments

    /tmp/tmp95rdgq1a_test.go:279:6: expected ''('', found TestWill_It_Fly

    '
  stdout: "FAIL\tcommand-line-arguments [setup failed]\nFAIL\n"
  timestamp: 1660075146
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max < w {\n        return false\n\
    \    }\n    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n   \
    \ if sum < max {\n        return false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmppzcyksl0_test.go:60: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmppzcyksl0_test.go:60:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmppzcyksl0_test.go:60: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmppzcyksl0_test.go:60:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075161
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max < w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpn_e6kzw2_test.go:62: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpn_e6kzw2_test.go:62:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__3\
    \ (0.00s)\n        tmpn_e6kzw2_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpn_e6kzw2_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075160
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ if q[len(q)-1] != len(q)/2 {\n        return false\n    }\n    max := 0\n  \
    \  for _, v := range q {\n        max += v\n    }\n    if max < w {\n        return\
    \ false\n    }\n    return will_it_fly(q[:len(q)-1], w)\n}\n\nfunc TestWill_It_Fly(t\
    \ *testing.T) {\n  candidate := will_it_fly\n\ttype test struct {\n\t\tactual\
    \   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n     { actual:\
    \ candidate([]int{3, 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1,\
    \ 2}, 5), expected: false },\n     { actual: candidate([]int{3}, 5), expected:\
    \ true },\n     { actual: candidate([]int{3, 2, 3}, 1), expected: false },\n \
    \    { actual: candidate([]int{1, 2, 3}, 6), expected: false },\n     { actual:\
    \ candidate([]int{5}, 5), expected: true },\n   }\n\n\tfor i, tc := range tests\
    \ {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i), func(t *testing.T) {\n\t\t\t\
    if fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\
    \tt.Errorf(\"expected '%s', got '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t\
    })\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__0\
    \ (0.00s)\n        tmpn3w2to89_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__2 (0.00s)\n        tmpn3w2to89_test.go:58:\
    \ expected '%!s(bool=true)', got '%!s(bool=false)'\n    --- FAIL: TestWill_It_Fly/test_num__5\
    \ (0.00s)\n        tmpn3w2to89_test.go:58: expected '%!s(bool=true)', got '%!s(bool=false)'\n\
    FAIL\nFAIL\tcommand-line-arguments\t0.003s\nFAIL\n"
  timestamp: 1660075161
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) <= 1 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum < max {\n        return false\n    }\n    return\
    \ true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate := will_it_fly\n\
    \ttype test struct {\n\t\tactual   interface{}\n\t\texpected interface{}\n\t}\n\
    \   tests := []test{\n     { actual: candidate([]int{3, 2, 3}, 9), expected: true\
    \ },\n     { actual: candidate([]int{1, 2}, 5), expected: false },\n     { actual:\
    \ candidate([]int{3}, 5), expected: true },\n     { actual: candidate([]int{3,\
    \ 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1, 2, 3}, 6),\
    \ expected: false },\n     { actual: candidate([]int{5}, 5), expected: true },\n\
    \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\"\
    , i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
    %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
    \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpcphcl05o_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpcphcl05o_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075147
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        max += v\n    }\n    if max == 0 {\n        return true\n\
    \    }\n    if max > w {\n        return false\n    }\n    sum := 0\n    for _,\
    \ v := range q {\n        sum += v\n    }\n    if sum < max {\n        return\
    \ false\n    }\n    return true\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n \
    \ candidate := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\
    \texpected interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3,\
    \ 2, 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpspxvv867_test.go:63: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpspxvv867_test.go:63:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075161
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    // Write your code here\n    max := 0\n    for _,\
    \ v := range q {\n        if v > max {\n            max = v\n        }\n    }\n\
    \    sum := 0\n    for _, v := range q {\n        sum += v\n    }\n    return\
    \ sum <= w && max <= w\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpxo_eq5w1_test.go:56: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpxo_eq5w1_test.go:56:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.005s\nFAIL\n"
  timestamp: 1660075161
- exit_code: 1
  program: "package will_it_fly_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\
    \n// Write a function that returns true if the object q will fly, and false otherwise.\n\
    // The object q will fly if it's balanced (it is a palindromic list) and the sum\
    \ of its elements is less than or equal the maximum possible weight w.\n// Example:\n\
    // >>> will_it_fly([]int{1, 2}, 5)\n// false\n// # 1+2 is less than the maximum\
    \ possible weight, but it's unbalanced.\n// >>> will_it_fly([]int{3, 2, 3}, 1)\n\
    // false\n// # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\
    // >>> will_it_fly([]int{3, 2, 3}, 9)\n// true\n// # 3+2+3 is less than the maximum\
    \ possible weight, and it's balanced.\n// >>> will_it_fly([]int{3}, 5)\n// true\n\
    // # 3 is less than the maximum possible weight, and it's balanced.\nfunc will_it_fly(q\
    \ []int, w int) bool {\n    if len(q) == 0 {\n        return true\n    }\n   \
    \ max := 0\n    for _, v := range q {\n        max += v\n    }\n    if max > w\
    \ {\n        return false\n    }\n    sum := 0\n    for _, v := range q {\n  \
    \      sum += v\n    }\n    if sum > w {\n        return true\n    }\n    return\
    \ will_it_fly(q[1:], w)\n}\n\nfunc TestWill_It_Fly(t *testing.T) {\n  candidate\
    \ := will_it_fly\n\ttype test struct {\n\t\tactual   interface{}\n\t\texpected\
    \ interface{}\n\t}\n   tests := []test{\n     { actual: candidate([]int{3, 2,\
    \ 3}, 9), expected: true },\n     { actual: candidate([]int{1, 2}, 5), expected:\
    \ false },\n     { actual: candidate([]int{3}, 5), expected: true },\n     { actual:\
    \ candidate([]int{3, 2, 3}, 1), expected: false },\n     { actual: candidate([]int{1,\
    \ 2, 3}, 6), expected: false },\n     { actual: candidate([]int{5}, 5), expected:\
    \ true },\n   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test\
    \ num % d\", i), func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual)\
    \ != fmt.Sprintf(\"%v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got\
    \ '%s'\", tc.expected, tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
  status: Exception
  stderr: ''
  stdout: "--- FAIL: TestWill_It_Fly (0.00s)\n    --- FAIL: TestWill_It_Fly/test_num__1\
    \ (0.00s)\n        tmpimd8e_5k_test.go:62: expected '%!s(bool=false)', got '%!s(bool=true)'\n\
    \    --- FAIL: TestWill_It_Fly/test_num__4 (0.00s)\n        tmpimd8e_5k_test.go:62:\
    \ expected '%!s(bool=false)', got '%!s(bool=true)'\nFAIL\nFAIL\tcommand-line-arguments\t\
    0.003s\nFAIL\n"
  timestamp: 1660075161
