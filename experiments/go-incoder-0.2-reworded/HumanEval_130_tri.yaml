name: HumanEval_130_tri
language: go_test.go
prompt: "package tri_test\n\nimport (\n    \"testing\"\n    \"fmt\"\n)\n\n// Everyone\
  \ knows Fibonacci sequence, it was studied deeply by mathematicians in \n// the\
  \ last couple centuries. However, what people don't know is Tribonacci sequence.\n\
  // Tribonacci sequence is defined by the recurrence:\n// tri(1) = 3\n// tri(n) =\
  \ 1 + n / 2, if n is even.\n// tri(n) =  tri(n - 1) + tri(n - 2) + tri(n + 1), if\
  \ n is odd.\n// For example:\n// tri(2) = 1 + (2 / 2) = 2\n// tri(4) = 3\n// tri(3)\
  \ = tri(2) + tri(1) + tri(4)\n// = 2 + 3 + 3 = 8 \n// You are given a non-negative\
  \ integer number n, you have to a return a list of the \n// first n + 1 numbers\
  \ of the Tribonacci sequence.\n// Examples:\n// >>> tri(3)\n// []int{1, 3, 2, 8}\n\
  func tri(n int) []int {\n"
tests: "func TestTri(t *testing.T) {\n  candidate := tri\n\ttype test struct {\n\t\
  \tactual   interface{}\n\t\texpected interface{}\n\t}\n   tests := []test{\n   \
  \  { actual: candidate(3), expected: []int{1, 3, 2, 8} },\n     { actual: candidate(4),\
  \ expected: []int{1, 3, 2, 8, 3} },\n     { actual: candidate(5), expected: []int{1,\
  \ 3, 2, 8, 3, 15} },\n     { actual: candidate(6), expected: []int{1, 3, 2, 8, 3,\
  \ 15, 4} },\n     { actual: candidate(7), expected: []int{1, 3, 2, 8, 3, 15, 4,\
  \ 24} },\n     { actual: candidate(8), expected: []int{1, 3, 2, 8, 3, 15, 4, 24,\
  \ 5} },\n     { actual: candidate(9), expected: []int{1, 3, 2, 8, 3, 15, 4, 24,\
  \ 5, 35} },\n     { actual: candidate(20), expected: []int{1, 3, 2, 8, 3, 15, 4,\
  \ 24, 5, 35, 6, 48, 7, 63, 8, 80, 9, 99, 10, 120, 11} },\n     { actual: candidate(0),\
  \ expected: []int{1} },\n     { actual: candidate(1), expected: []int{1, 3} },\n\
  \   }\n\n\tfor i, tc := range tests {\n\t\tt.Run(fmt.Sprintf(\"test num % d\", i),\
  \ func(t *testing.T) {\n\t\t\tif fmt.Sprintf(\"%v\", tc.actual) != fmt.Sprintf(\"\
  %v\", tc.expected) {\n\t\t\t\tt.Errorf(\"expected '%s', got '%s'\", tc.expected,\
  \ tc.actual)\n\t\t\t}\n\t\t})\n\t}\n}\n"
completions: ["    if n < 2 {\n        return []int{n}\n    }\n    result := make([]int,\
    \ n+1)\n    result [0] = 3\n    result [1] = 1 + n / 2\n    if n%2 == 0 {\n  \
    \      result [2] = tri(n - 1) + tri(n - 2) + tri(n + 1)\n    } else {\n     \
    \   result [2] = tri(n - 1) + tri(n - 2)\n    }\n    return result\n}\n", "  \
    \  if n < 0 {\n        return []int{}\n    }\n    result := make([]int, n+1)\n\
    \    result[0] = 3\n    i := 1\n    for i <= n {\n        result[i] = result[i-1]\
    \ + result[i-2] + result[i+2]\n        i += 3\n    }\n    return result\n}\n",
  "    if n < 2 {\n        return []int{n}\n    }\n    result := make([]int, n+1)\n\
    \    result[0] = 3\n    i := 1\n    for i < n {\n        result[i] = result[i-1]\
    \ + result[i-2] + result[i+1]\n        i += 2\n    }\n    return result\n}\n",
  "    result := make([]int, n+1)\n    \n    result [0] = 3\n    \n    if n%2 == 0\
    \ {\n        result [1] = 1 + n/2\n    } else {\n        result [1] = tri(n -\
    \ 1) + tri(n - 2) + tri(n + 1)\n    }\n    \n    return result\n}\n", "    result\
    \ := make([]int, n+1)\n    \n    result[0] = 3\n    \n    if n%2 == 0 {\n    \
    \    result[1] = 1 + n/2\n    } else {\n        result[1] = tri(n - 1) + tri(n\
    \ - 2) + tri(n + 1)\n    }\n    \n    return result\n}\n", "    if n < 0 {\n \
    \       return []int{}\n    }\n    if n == 0 {\n        return []int{3}\n    }\n\
    \    if n == 1 {\n        return []int{1, 3}\n    }\n    if n == 2 {\n       \
    \ return []int{1, 2, 3}\n    }\n    if n % 2 == 0 {\n        return append(tri(n\
    \ - 1), tri(n - 2), tri(n + 1))\n    }\n    return append(tri(n - 1), tri(n +\
    \ 1), tri(n - 2))\n}\n", "    if n < 0 {\n        return []int{}\n    }\n    if\
    \ n == 0 {\n        return []int{3}\n    }\n    if n == 1 {\n        return []int{1,\
    \ 3}\n    }\n    if n == 2 {\n        return []int{1, 2, 3}\n    }\n    if n ==\
    \ 3 {\n        return []int{1, 3, 3, 2}\n    }\n    if n % 2 == 0 {\n        return\
    \ append(tri(n - 1), tri(n - 2)...)\n    }\n    return append(tri(n - 1), tri(n\
    \ - 2), tri(n + 1))\n}\n", "    if n < 2 {\n        return []int{1, n}\n    }\n\
    \    result := make([]int, n+1)\n    result[0] = 3\n    i := 1\n    for i <= n\
    \ {\n        result[i] = result[i-1] + result[i-2] + result[i+1]\n        i +=\
    \ 2\n    }\n    return result\n}\n", "    result := make([]int, n+1)\n    \n \
    \   result[0] = 3\n    \n    if n%2 == 0 {\n        result[1] = 1 + n/2\n    }\
    \ else {\n        result[1] = tri(n - 1) + tri(n - 2) + tri(n + 1)\n    }\n  \
    \  \n    return result\n}\n", "    result := make([]int, n+1)\n    \n    result\
    \ [0] = 3\n    \n    if n%2 == 0 {\n        result [1] = 1 + n/2\n    } else {\n\
    \        result [1] = tri(n - 1) + tri(n - 2) + tri(n + 1)\n    }\n    \n    return\
    \ result\n}\n", "    result := make([]int, n+1)\n    \n    result [0] = 3\n  \
    \  \n    if n%2 == 0 {\n        result [1] = 1 + n / 2\n    } else {\n       \
    \ result [1] = tri(n - 1) + tri(n - 2) + tri(n + 1)\n    }\n    \n    return result\n\
    }\n", "    if n == 0 {\n        return []int{}\n    }\n    if n%2 == 0 {\n   \
    \     return []int{tri(n-1), tri(n-2)}\n    }\n    return []int{tri(n-1), tri(n-2),\
    \ tri(n+1), tri(n+2)}\n}\n", "    result := make([]int, n+1)\n    \n    result[0]\
    \ = 3\n    \n    for i := 1; i < n; i++ {\n        result[i] = result[i-1] + result[i-2]\
    \ + result[i+1]\n    }\n    \n    return result\n}\n", "    result := make([]int,\
    \ n+1)\n    result[0] = 3\n    if n%2 == 0 {\n        result[1] = 1 + n/2\n  \
    \  } else {\n        result[1] = tri(n - 1) + tri(n - 2) + tri(n + 1)\n    }\n\
    \    for i := 2; i <= n; i++ {\n        result[i] = result[i-1] + result[i-2]\n\
    \    }\n    return result\n}\n", "    result := make([]int, n+1)\n    result[0]\
    \ = 3\n    if n%2 == 0 {\n        result[1] = 1 + n/2\n    } else {\n        result[1]\
    \ = tri(n - 1) + tri(n - 2) + tri(n + 1)\n    }\n    return result\n}\n", "  \
    \  tri := []int{1, n}\n    if n%2 == 0 {\n        tri = append(tri, tri[n-1])\n\
    \        tri = append(tri, tri[n-2])\n        tri = append(tri, tri[n+1])\n  \
    \  } else {\n        tri = append(tri, tri[n-1])\n        tri = append(tri, tri[n-2])\n\
    \        tri = append(tri, tri[n+1])\n        tri = append(tri, tri[n+2])\n  \
    \  }\n    return tri\n}\n", "    if n < 2 {\n        return []int{1, n}\n    }\n\
    \    result := make([]int, n+1)\n    result[0] = result[1] = 3\n    for i := 2;\
    \ i < n; i++ {\n        result[i] = result[i-2] + result[i-3]\n    }\n    return\
    \ result\n}\n", "    result := make([]int, n+1)\n    \n    result[0] = 3\n   \
    \ \n    if n%2 == 0 {\n        result[1] = 1 + n/2\n    } else {\n        result[1]\
    \ = tri(n - 1) + tri(n - 2) + tri(n + 1)\n    }\n    \n    return result\n}\n",
  "    result := make([]int, n+1)\n    result[0] = 3\n    if n%2 == 0 {\n        result[1]\
    \ = 1 + n/2\n    } else {\n        result[1] = tri(n - 1) + tri(n - 2) + tri(n\
    \ + 1)\n    }\n    return result\n}\n", "    result := make([]int, n+1)\n    \n\
    \    result[0] = 3\n    \n    if n%2 == 0 {\n        result[1] = 1 + n/2\n   \
    \ } else {\n        result[1] = tri(n - 1) + tri(n - 2) + tri(n + 1)\n    }\n\
    \    \n    return result\n}\n"]
stop_tokens:
- "\nfunc"
- struct
- "\n// "
